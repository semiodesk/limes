/*

Copyright (c) 2008-2015 by the President and Fellows of Harvard College. All rights reserved.  Profiles Research Networking Software was developed under the supervision of Griffin M Weber, MD, PhD., and Harvard Catalyst: The Harvard Clinical and Translational Science Center, with support from the National Center for Research Resources and Harvard University.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    * Neither the name "Harvard" nor the names of its contributors nor the name "Harvard Catalyst" may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER (PRESIDENT AND FELLOWS OF HARVARD COLLEGE) AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


*/

IF (1 = FULLTEXTSERVICEPROPERTY('IsFullTextInstalled'))
begin
EXEC [dbo].[sp_fulltext_database] @action = 'enable'
end
GO
CREATE SCHEMA [Utility.NLP] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Utility.Math] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Utility.Application] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [User.Session] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [User.Account] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Search.Framework] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Search.Cache] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Search.] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [RDF.Stage] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [RDF.SemWeb] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [RDF.Security] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [RDF.Search] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [RDF.Cache] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [RDF.] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Profile.Module] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Profile.Import] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Profile.Framework] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Profile.Data] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Profile.Cache] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Ontology.Presentation] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Ontology.Import] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Ontology.] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Module.Profile] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Module.Edit] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Module.Beta] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Login.Framework] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [History.Framework] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [History] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Framework.] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Edit.Module] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Edit.Framework] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Direct.Framework] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [Direct.] AUTHORIZATION [dbo]
GO
CREATE SCHEMA [ORNG.]
GO
CREATE SCHEMA [ORCID.]
GO
CREATE FULLTEXT CATALOG [ft]WITH ACCENT_SENSITIVITY = ON
AS DEFAULT
AUTHORIZATION [dbo]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Import].[Person](
	[internalusername] [nvarchar](1000) NULL,
	[firstname] [nvarchar](1000) NULL,
	[middlename] [nvarchar](1000) NULL,
	[lastname] [nvarchar](1000) NULL,
	[displayname] [nvarchar](1000) NULL,
	[suffix] [nvarchar](1000) NULL,
	[addressline1] [nvarchar](1000) NULL,
	[addressline2] [nvarchar](1000) NULL,
	[addressline3] [nvarchar](1000) NULL,
	[addressline4] [nvarchar](1000) NULL,
	[addressstring] [nvarchar](1000) NULL,
	[City] [nvarchar](1000) NULL,
	[State] [nvarchar](1000) NULL,
	[Zip] [nvarchar](1000) NULL,
	[building] [nvarchar](1000) NULL,
	[room] [nvarchar](1000) NULL,
	[floor] [nvarchar](100) NULL,
	[latitude] [float] NULL,
	[longitude] [float] NULL,
	[phone] [nvarchar](1000) NULL,
	[fax] [nvarchar](1000) NULL,
	[emailaddr] [nvarchar](1000) NULL,
	[isactive] [bit] NULL,
	[isvisible] [bit] NULL
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Person](
	[PersonID] [int] IDENTITY(1,1) NOT NULL,
	[UserID] [int] NULL,
	[FirstName] [nvarchar](50) NULL,
	[LastName] [nvarchar](50) NULL,
	[MiddleName] [nvarchar](50) NULL,
	[DisplayName] [nvarchar](255) NULL,
	[Suffix] [nvarchar](50) NULL,
	[IsActive] [bit] NULL,
	[EmailAddr] [nvarchar](255) NULL,
	[Phone] [nvarchar](35) NULL,
	[Fax] [nvarchar](25) NULL,
	[AddressLine1] [nvarchar](255) NULL,
	[AddressLine2] [nvarchar](255) NULL,
	[AddressLine3] [nvarchar](255) NULL,
	[AddressLine4] [nvarchar](255) NULL,
	[City] [nvarchar](55) NULL,
	[State] [nvarchar](50) NULL,
	[Zip] [nvarchar](50) NULL,
	[Building] [nvarchar](255) NULL,
	[Floor] [int] NULL,
	[Room] [nvarchar](255) NULL,
	[AddressString] [nvarchar](1000) NULL,
	[Latitude] [decimal](18, 14) NULL,
	[Longitude] [decimal](18, 14) NULL,
	[GeoScore] [tinyint] NULL,
	[FacultyRankID] [int] NULL,
	[InternalUsername] [nvarchar](50) NULL,
	[Visible] [bit] NULL,
 CONSTRAINT [PK__person] PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY],
 CONSTRAINT [UC_Person_InternalUserName] UNIQUE NONCLUSTERED 
(
	[InternalUsername] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Cache].[Person](
	[PersonID] [int] NOT NULL,
	[UserID] [int] NULL,
	[InternalUsername] [nvarchar](100) NULL,
	[FirstName] [nvarchar](100) NULL,
	[LastName] [nvarchar](100) NULL,
	[DisplayName] [nvarchar](510) NULL,
	[AddressLine1] [nvarchar](255) NULL,
	[AddressLine2] [nvarchar](255) NULL,
	[AddressLine3] [nvarchar](255) NULL,
	[AddressLine4] [nvarchar](255) NULL,
	[AddressString] [nvarchar](2000) NULL,
	[Building] [nvarchar](510) NULL,
	[Room] [nvarchar](510) NULL,
	[Floor] [int] NULL,
	[Latitude] [decimal](18, 14) NULL,
	[Longitude] [decimal](18, 14) NULL,
	[Phone] [nvarchar](70) NULL,
	[Fax] [nvarchar](50) NULL,
	[EmailAddr] [nvarchar](510) NULL,
	[InstitutionName] [nvarchar](1000) NULL,
	[InstitutionAbbreviation] [nvarchar](100) NULL,
	[DepartmentName] [nvarchar](1000) NULL,
	[DivisionFullName] [nvarchar](1000) NULL,
	[FacultyRank] [varchar](100) NULL,
	[FacultyRankSort] [tinyint] NULL,
	[IsActive] [bit] NULL,
	[ShowAddress] [char](1) NULL,
	[ShowPhone] [char](1) NULL,
	[Showfax] [char](1) NULL,
	[ShowEmail] [char](1) NULL,
	[ShowPhoto] [char](1) NULL,
	[ShowAwards] [char](1) NULL,
	[ShowNarrative] [char](1) NULL,
	[ShowPublications] [char](1) NULL,
	[Visible] [bit] NULL,
	[NumPublications] [int] NULL,
	[PersonXML] [xml] NULL,
	[HasPublications] [bit] NULL,
	[HasSNA] [bit] NULL,
	[Reach1] [int] NULL,
	[Reach2] [int] NULL,
	[Closeness] [float] NULL,
	[Betweenness] [float] NULL,
 CONSTRAINT [PK_cache_person] PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE NONCLUSTERED INDEX [Person_Department] ON [Profile.Cache].[Person] 
(
	[DepartmentName] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Person.Affiliation](
	[PersonAffiliationID] [int] IDENTITY(1,1) NOT NULL,
	[PersonID] [int] NULL,
	[SortOrder] [int] NULL,
	[IsActive] [bit] NULL,
	[IsPrimary] [bit] NULL,
	[InstitutionID] [int] NULL,
	[DepartmentID] [int] NULL,
	[DivisionID] [int] NULL,
	[Title] [nvarchar](200) NULL,
	[EmailAddress] [nvarchar](200) NULL,
	[FacultyRankID] [int] NULL,
 CONSTRAINT [PK__person_affiliations] PRIMARY KEY CLUSTERED 
(
	[PersonAffiliationID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [UC_PrimaryAffiliation] UNIQUE NONCLUSTERED 
(
	[PersonID] ASC,
	[IsPrimary] ASC,
	[SortOrder] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_PersonAffiliationSortOrder] ON [Profile.Data].[Person.Affiliation] 
(
	[SortOrder] ASC
)
INCLUDE ( [PersonAffiliationID],
[PersonID],
[Title]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Cache].[Person.Affiliation](
	[PersonID] [int] NOT NULL,
	[SortOrder] [int] NOT NULL,
	[IsPrimary] [bit] NULL,
	[Title] [varchar](max) NULL,
	[InstititutionName] [varchar](200) NULL,
	[InstitutionAbbreviation] [varchar](100) NULL,
	[DepartmentName] [varchar](200) NULL,
	[DivisionName] [varchar](200) NULL,
	[FacultyRank] [varchar](200) NULL,
 CONSTRAINT [PK_cache_person_affiliations] PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC,
	[SortOrder] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Direct.].[LogOutgoing](
	[FSID] [uniqueidentifier] NULL,
	[SiteID] [int] NULL,
	[Details] [bit] NULL,
	[SentDate] [datetime] NULL,
	[ResponseTime] [float] NULL,
	[ResponseState] [int] NULL,
	[ResponseStatus] [int] NULL,
	[ResultText] [varchar](4000) NULL,
	[ResultCount] [varchar](10) NULL,
	[ResultDetailsURL] [varchar](1000) NULL,
	[QueryString] [varchar](1000) NULL
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO

CREATE NONCLUSTERED INDEX [NCI_FSID] ON [Direct.].[LogOutgoing]
(
	[FSID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Direct.].[LogIncoming](
	[Details] [bit] NULL,
	[ReceivedDate] [datetime] NULL,
	[RequestIP] [varchar](16) NULL,
	[QueryString] [varchar](1000) NULL
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [RDF.Stage].[Log.Triple](
	[LogID] [bigint] IDENTITY(0,1) NOT NULL,
	[CompleteDate] [datetime] NULL,
	[NewNodes] [bigint] NULL,
	[NewTriples] [bigint] NULL,
	[FoundRecords] [bigint] NULL,
	[ProcessedRecords] [bigint] NULL,
	[TimeElapsed] [float] NULL,
PRIMARY KEY CLUSTERED 
(
	[LogID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Framework.].[Log.Job](
	[LogID] [int] IDENTITY(0,1) NOT NULL,
	[JobID] [int] NULL,
	[JobGroup] [int] NULL,
	[Step] [int] NULL,
	[Script] [nvarchar](max) NULL,
	[JobStart] [datetime] NULL,
	[JobEnd] [datetime] NULL,
	[Status] [varchar](50) NULL,
	[ErrorCode] [int] NULL,
	[ErrorMsg] [varchar](max) NULL,
PRIMARY KEY CLUSTERED 
(
	[LogID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [RDF.Stage].[Log.DataMap](
	[LogID] [bigint] IDENTITY(0,1) NOT NULL,
	[DataMapID] [int] NULL,
	[StartDate] [datetime] NULL,
	[EndDate] [datetime] NULL,
	[RunTimeMS] [int] NULL,
	[DataMapType] [tinyint] NULL,
	[NewNodes] [bigint] NULL,
	[UpdatedNodes] [bigint] NULL,
	[ExistingNodes] [bigint] NULL,
	[DeletedNodes] [bigint] NULL,
	[TotalNodes] [bigint] NULL,
	[NewTriples] [bigint] NULL,
	[UpdatedTriples] [bigint] NULL,
	[ExistingTriples] [bigint] NULL,
	[DeletedTriples] [bigint] NULL,
	[TotalTriples] [bigint] NULL,
PRIMARY KEY CLUSTERED 
(
	[LogID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [missing_index_73290] ON [RDF.Stage].[Log.DataMap] 
(
	[DataMapID] ASC,
	[LogID] ASC
)
INCLUDE ( [RunTimeMS]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Ontology.].[Namespace](
	[URI] [varchar](500) NOT NULL,
	[Prefix] [varchar](50) NOT NULL,
 CONSTRAINT [PK__Namespaces__07C12930] PRIMARY KEY CLUSTERED 
(
	[URI] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Utility.Math].[N](
	[n] [int] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[n] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [RDF.Security].[Member](
	[UserID] [int] NOT NULL,
	[SecurityGroupID] [bigint] NOT NULL,
	[IsVisible] [bit] NULL,
PRIMARY KEY CLUSTERED 
(
	[UserID] ASC,
	[SecurityGroupID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_su] ON [RDF.Security].[Member] 
(
	[SecurityGroupID] ASC,
	[UserID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Utility.NLP].[ParsePorterStemming](
	[Step] [int] NOT NULL,
	[Ordering] [int] NOT NULL,
	[phrase1] [nvarchar](15) NOT NULL,
	[phrase2] [nvarchar](15) NULL
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Framework.].[Parameter](
	[ParameterID] [varchar](50) NOT NULL,
	[Value] [nvarchar](max) NULL,
 CONSTRAINT [PK__Parameters__498EEC8D] PRIMARY KEY CLUSTERED 
(
	[ParameterID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Ontology.Presentation].[Panel](
	[PresentationID] [int] NOT NULL,
	[Type] [varchar](100) NOT NULL,
	[TabSort] [int] NOT NULL,
	[TabType] [varchar](100) NULL,
	[Alias] [varchar](max) NULL,
	[Name] [varchar](max) NULL,
	[Icon] [varchar](max) NULL,
	[DisplayRule] [varchar](max) NULL,
	[ModuleXML] [xml] NULL
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Ontology.Import].[OWL](
	[Name] [nvarchar](100) NOT NULL,
	[Data] [xml] NULL,
	[Graph] [bigint] NULL,
 CONSTRAINT [PK__owl__656C112C] PRIMARY KEY CLUSTERED 
(
	[Name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Organization.Institution](
	[InstitutionID] [int] IDENTITY(1,1) NOT NULL,
	[InstitutionName] [nvarchar](500) NULL,
	[InstitutionAbbreviation] [nvarchar](50) NULL,
 CONSTRAINT [PK__institution] PRIMARY KEY CLUSTERED 
(
	[InstitutionID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [UC_Institution_InstitutionAbbreviation] UNIQUE NONCLUSTERED 
(
	[InstitutionAbbreviation] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [UC_Institution_InstitutionName] UNIQUE NONCLUSTERED 
(
	[InstitutionName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Search.Cache].[History.TopSearchPhrase](
	[TimePeriod] [char](1) NOT NULL,
	[Phrase] [varchar](100) NOT NULL,
	[NumberOfQueries] [int] NULL,
PRIMARY KEY CLUSTERED 
(
	[TimePeriod] ASC,
	[Phrase] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [User.Session].[History.ResolveURL](
	[HistoryID] [int] IDENTITY(0,1) NOT NULL,
	[RequestDate] [datetime] NULL,
	[ApplicationName] [varchar](1000) NULL,
	[param1] [varchar](1000) NULL,
	[param2] [varchar](1000) NULL,
	[param3] [varchar](1000) NULL,
	[param4] [varchar](1000) NULL,
	[param5] [varchar](1000) NULL,
	[param6] [varchar](1000) NULL,
	[param7] [varchar](1000) NULL,
	[param8] [varchar](1000) NULL,
	[param9] [varchar](1000) NULL,
	[SessionID] [uniqueidentifier] NULL,
	[RestURL] [varchar](max) NULL,
	[UserAgent] [varchar](255) NULL,
	[ContentType] [varchar](255) NULL,
	[CustomResolver] [varchar](1000) NULL,
	[Resolved] [bit] NULL,
	[ErrorDescription] [varchar](max) NULL,
	[ResponseURL] [varchar](1000) NULL,
	[ResponseContentType] [varchar](255) NULL,
	[ResponseStatusCode] [int] NULL,
	[ResponseRedirect] [bit] NULL,
	[ResponseIncludePostData] [bit] NULL,
PRIMARY KEY CLUSTERED 
(
	[HistoryID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE NONCLUSTERED INDEX [IDX_Session_Date] ON [User.Session].[History.ResolveURL] 
(
	[SessionID] ASC,
	[RequestDate] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Search.].[History.Query](
	[SearchHistoryQueryID] [int] IDENTITY(0,1) NOT NULL,
	[StartDate] [datetime] NULL,
	[EndDate] [datetime] NULL,
	[DurationMS] [int] NULL,
	[SessionID] [uniqueidentifier] NULL,
	[IsBot] [bit] NULL,
	[NumberOfConnections] [int] NULL,
	[SearchOptions] [xml] NULL,
PRIMARY KEY CLUSTERED 
(
	[SearchHistoryQueryID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Search.].[History.Phrase](
	[SearchHistoryPhraseID] [int] IDENTITY(0,1) NOT NULL,
	[SearchHistoryQueryID] [int] NULL,
	[PhraseID] [int] NULL,
	[ThesaurusMatch] [bit] NULL,
	[Phrase] [varchar](max) NULL,
	[EndDate] [datetime] NULL,
	[IsBot] [bit] NULL,
	[NumberOfConnections] [int] NULL,
PRIMARY KEY CLUSTERED 
(
	[SearchHistoryPhraseID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE NONCLUSTERED INDEX [IDX_QueryID] ON [Search.].[History.Phrase] 
(
	[SearchHistoryQueryID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [RDF.Security].[Group](
	[SecurityGroupID] [bigint] NOT NULL,
	[Label] [varchar](255) NOT NULL,
	[HasSpecialViewAccess] [bit] NULL,
	[HasSpecialEditAccess] [bit] NULL,
	[Description] [varchar](max) NULL,
PRIMARY KEY CLUSTERED 
(
	[SecurityGroupID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Framework.].[JobGroup](
	[JobGroup] [int] NOT NULL,
	[Name] [varchar](50) NULL,
	[Type] [varchar](50) NULL,
	[Description] [varchar](max) NULL,
PRIMARY KEY CLUSTERED 
(
	[JobGroup] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Framework.].[Job](
	[JobID] [int] NOT NULL,
	[JobGroup] [int] NULL,
	[Step] [int] NULL,
	[IsActive] [bit] NULL,
	[Script] [nvarchar](max) NULL,
	[Status] [varchar](50) NULL,
	[LastStart] [datetime] NULL,
	[LastEnd] [datetime] NULL,
	[ErrorCode] [int] NULL,
	[ErrorMsg] [varchar](max) NULL,
PRIMARY KEY CLUSTERED 
(
	[JobID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [RDF.Stage].[InternalNodeMap](
	[InternalNodeMapID] [bigint] IDENTITY(1,1) NOT NULL,
	[Class] [nvarchar](400) NOT NULL,
	[InternalType] [nvarchar](300) NOT NULL,
	[InternalID] [nvarchar](100) NOT NULL,
	[ViewSecurityGroup] [bigint] NULL,
	[EditSecurityGroup] [bigint] NULL,
	[InternalHash] [binary](20) NOT NULL,
	[NodeID] [bigint] NULL,
	[ValueHash] [binary](20) NULL,
	[Status] [tinyint] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[InternalNodeMapID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_ClassInternalTypeID] ON [RDF.Stage].[InternalNodeMap] 
(
	[Class] ASC,
	[InternalType] ASC,
	[InternalID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_InternalHash] ON [RDF.Stage].[InternalNodeMap] 
(
	[InternalHash] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_InternalNodeMapStatus] ON [RDF.Stage].[InternalNodeMap] 
(
	[Status] ASC
)
INCLUDE ( [InternalNodeMapID],
[InternalHash],
[NodeID],
[Class],
[InternalType],
[InternalID],
[ValueHash]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_StageInternalNodeMap] ON [RDF.Stage].[InternalNodeMap] 
(
	[NodeID] ASC
)
INCLUDE ( [Class],
[InternalType]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_StatusValueHash] ON [RDF.Stage].[InternalNodeMap] 
(
	[Status] ASC,
	[ValueHash] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Framework.].[InstallData](
	[InstallDataID] [int] IDENTITY(0,1) NOT NULL,
	[Data] [xml] NULL,
 CONSTRAINT [PK__InstallData__7CA47C3F] PRIMARY KEY CLUSTERED 
(
	[InstallDataID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Organization.Division](
	[DivisionID] [int] IDENTITY(1,1) NOT NULL,
	[DivisionName] [nvarchar](500) NULL,
 CONSTRAINT [PK__division] PRIMARY KEY CLUSTERED 
(
	[DivisionID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [UC_Division_DivisionName] UNIQUE NONCLUSTERED 
(
	[DivisionName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Organization.Department](
	[DepartmentID] [int] IDENTITY(1,1) NOT NULL,
	[DepartmentName] [nvarchar](500) NULL,
	[Visible] [bit] NULL,
 CONSTRAINT [PK__department] PRIMARY KEY CLUSTERED 
(
	[DepartmentID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [UC_Department_DepartmentName] UNIQUE NONCLUSTERED 
(
	[DepartmentName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [RDF.Security].[NodeProperty](
	[NodeID] [bigint] NOT NULL,
	[Property] [bigint] NOT NULL,
	[ViewSecurityGroup] [bigint] NULL,
PRIMARY KEY CLUSTERED 
(
	[NodeID] ASC,
	[Property] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [RDF.].[Node](
	[NodeID] [bigint] IDENTITY(1,1) NOT NULL,
	[ValueHash] [binary](20) NOT NULL,
	[Language] [nvarchar](255) NULL,
	[DataType] [nvarchar](255) NULL,
	[Value] [nvarchar](max) NOT NULL,
	[InternalNodeMapID] [int] NULL,
	[ObjectType] [bit] NULL,
	[ViewSecurityGroup] [bigint] NULL,
	[EditSecurityGroup] [bigint] NULL,
 CONSTRAINT [PK__Node__72C60C4A] PRIMARY KEY CLUSTERED 
(
	[NodeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_ValueHash] ON [RDF.].[Node] 
(
	[ValueHash] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [User.Account].[DesignatedProxy](
	[UserID] [int] NOT NULL,
	[ProxyForUserID] [int] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[UserID] ASC,
	[ProxyForUserID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_pu] ON [User.Account].[DesignatedProxy] 
(
	[ProxyForUserID] ASC,
	[UserID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [User.Account].[DefaultProxy](
	[DefaultProxyID] [int] IDENTITY(0,1) NOT NULL,
	[UserID] [int] NOT NULL,
	[ProxyForInstitution] [nvarchar](500) NULL,
	[ProxyForDepartment] [nvarchar](500) NULL,
	[ProxyForDivision] [nvarchar](500) NULL,
	[IsVisible] [bit] NULL,
PRIMARY KEY CLUSTERED 
(
	[DefaultProxyID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_u] ON [User.Account].[DefaultProxy] 
(
	[UserID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Ontology.].[DataMap](
	[DataMapID] [int] NOT NULL,
	[DataMapGroup] [int] NULL,
	[IsAutoFeed] [bit] NULL,
	[Graph] [bigint] NULL,
	[Class] [varchar](400) NULL,
	[NetworkProperty] [varchar](400) NULL,
	[Property] [varchar](1000) NULL,
	[MapTable] [varchar](max) NULL,
	[sInternalType] [varchar](1000) NULL,
	[sInternalID] [varchar](1000) NULL,
	[cClass] [varchar](400) NULL,
	[cInternalType] [varchar](1000) NULL,
	[cInternalID] [varchar](1000) NULL,
	[oClass] [varchar](400) NULL,
	[oInternalType] [varchar](1000) NULL,
	[oInternalID] [varchar](1000) NULL,
	[oValue] [varchar](1000) NULL,
	[oDataType] [varchar](1000) NULL,
	[oLanguage] [varchar](1000) NULL,
	[oStartDate] [varchar](1000) NULL,
	[oStartDatePrecision] [varchar](1000) NULL,
	[oEndDate] [varchar](1000) NULL,
	[oEndDatePrecision] [varchar](1000) NULL,
	[oObjectType] [bit] NULL,
	[Weight] [varchar](1000) NULL,
	[OrderBy] [varchar](1000) NULL,
	[ViewSecurityGroup] [varchar](1000) NULL,
	[EditSecurityGroup] [varchar](1000) NULL,
	[_ClassNode] [bigint] NULL,
	[_NetworkPropertyNode] [bigint] NULL,
	[_PropertyNode] [bigint] NULL,
 CONSTRAINT [PK__DataMap__966C304141713BA7] PRIMARY KEY CLUSTERED 
(
	[DataMapID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_cnps] ON [Ontology.].[DataMap] 
(
	[Class] ASC,
	[NetworkProperty] ASC,
	[Property] ASC,
	[sInternalType] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Ontology.Presentation].[General](
	[PresentationID] [int] NOT NULL,
	[Type] [char](1) NOT NULL,
	[Subject] [nvarchar](400) NULL,
	[Predicate] [nvarchar](400) NULL,
	[Object] [nvarchar](400) NULL,
	[PageColumns] [int] NULL,
	[WindowName] [varchar](max) NULL,
	[PageTitle] [varchar](max) NULL,
	[PageBackLinkName] [varchar](max) NULL,
	[PageBackLinkURL] [varchar](max) NULL,
	[PageSubTitle] [varchar](max) NULL,
	[PageDescription] [varchar](max) NULL,
	[PanelTabType] [varchar](max) NULL,
	[ExpandRDFList] [xml] NULL,
PRIMARY KEY CLUSTERED 
(
	[PresentationID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Concept.Mesh.XML](
	[DescriptorUI] [varchar](10) NOT NULL,
	[MeSH] [xml] NULL,
PRIMARY KEY CLUSTERED 
(
	[DescriptorUI] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Cache].[Concept.Mesh.Word2meshAll](
	[word] [varchar](255) NOT NULL,
	[mesh_header] [varchar](255) NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[word] ASC,
	[mesh_header] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Cache].[Concept.Mesh.Word2Mesh3All](
	[word] [varchar](255) NOT NULL,
	[mesh_term] [varchar](255) NOT NULL,
	[mesh_header] [varchar](255) NOT NULL,
	[num_words] [int] NULL,
PRIMARY KEY CLUSTERED 
(
	[word] ASC,
	[mesh_term] ASC,
	[mesh_header] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Cache].[Concept.Mesh.Word2mesh3](
	[word] [varchar](255) NOT NULL,
	[MeshTerm] [varchar](255) NOT NULL,
	[MeshHeader] [varchar](255) NOT NULL,
	[NumWords] [int] NULL,
 CONSTRAINT [PK_cache_word2mesh3] PRIMARY KEY CLUSTERED 
(
	[word] ASC,
	[MeshTerm] ASC,
	[MeshHeader] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Cache].[Concept.Mesh.Word2mesh2All](
	[word] [varchar](255) NOT NULL,
	[mesh_header] [varchar](255) NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[word] ASC,
	[mesh_header] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Cache].[Concept.Mesh.Word2mesh2](
	[word] [varchar](255) NOT NULL,
	[mesh_header] [varchar](255) NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[word] ASC,
	[mesh_header] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Cache].[Concept.Mesh.Word2mesh](
	[word] [varchar](255) NOT NULL,
	[MeshHeader] [nvarchar](255) NOT NULL,
 CONSTRAINT [PK_cache_word2mesh] PRIMARY KEY CLUSTERED 
(
	[word] ASC,
	[MeshHeader] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [User.Session].[Bot](
	[UserAgent] [varchar](500) NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[UserAgent] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Cache].[Concept.Mesh.Journal](
	[MeshHeader] [nvarchar](255) NOT NULL,
	[SortOrder] [int] NOT NULL,
	[Journal] [varchar](1000) NULL,
	[JournalTitle] [varchar](1000) NULL,
	[Weight] [float] NULL,
	[NumJournals] [int] NULL,
PRIMARY KEY CLUSTERED 
(
	[MeshHeader] ASC,
	[SortOrder] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Concept.Mesh.TreeTop](
	[TreeNumber] [varchar](255) NOT NULL,
	[DescriptorName] [varchar](255) NULL,
PRIMARY KEY CLUSTERED 
(
	[TreeNumber] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Cache].[Concept.Mesh.TreeTop](
	[FullTreeNumber] [varchar](255) NOT NULL,
	[ParentTreeNumber] [varchar](255) NULL,
	[TreeNumber] [varchar](255) NULL,
	[DescriptorName] [varchar](255) NULL,
	[DescriptorUI] [varchar](10) NULL,
PRIMARY KEY CLUSTERED 
(
	[FullTreeNumber] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE NONCLUSTERED INDEX [idx_d] ON [Profile.Cache].[Concept.Mesh.TreeTop] 
(
	[DescriptorUI] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_p] ON [Profile.Cache].[Concept.Mesh.TreeTop] 
(
	[ParentTreeNumber] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Concept.Mesh.Tree](
	[DescriptorUI] [varchar](10) NOT NULL,
	[TreeNumber] [varchar](255) NOT NULL,
 CONSTRAINT [pk_mesh_tree] PRIMARY KEY CLUSTERED 
(
	[DescriptorUI] ASC,
	[TreeNumber] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 95) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Cache].[Concept.Mesh.Tree](
	[MeshCode] [nvarchar](255) NOT NULL,
	[MeshHeader] [nvarchar](255) NULL,
	[NumPublications] [int] NULL,
	[NumFaculty] [int] NULL,
	[Weight] [float] NULL,
	[TotPublications] [int] NULL,
	[TotWeight] [float] NULL,
PRIMARY KEY CLUSTERED 
(
	[MeshCode] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Concept.Mesh.Term](
	[DescriptorUI] [varchar](10) NOT NULL,
	[ConceptUI] [varchar](10) NOT NULL,
	[TermUI] [varchar](10) NOT NULL,
	[TermName] [varchar](255) NOT NULL,
	[DescriptorName] [varchar](255) NULL,
	[PreferredConceptYN] [varchar](1) NULL,
	[RelationName] [varchar](3) NULL,
	[ConceptName] [varchar](255) NULL,
	[ConceptPreferredTermYN] [varchar](1) NULL,
	[IsPermutedTermYN] [varchar](1) NULL,
	[LexicalTag] [varchar](3) NULL,
 CONSTRAINT [pk_mesh_terms] PRIMARY KEY CLUSTERED 
(
	[DescriptorUI] ASC,
	[ConceptUI] ASC,
	[TermUI] ASC,
	[TermName] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 95) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Cache].[Concept.Mesh.SimilarConcept](
	[MeshHeader] [nvarchar](255) NOT NULL,
	[SortOrder] [int] NOT NULL,
	[SimilarConcept] [nvarchar](255) NULL,
	[Weight] [float] NULL,
PRIMARY KEY CLUSTERED 
(
	[MeshHeader] ASC,
	[SortOrder] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Concept.Mesh.SemanticType](
	[DescriptorUI] [varchar](10) NOT NULL,
	[SemanticTypeUI] [varchar](10) NOT NULL,
	[SemanticTypeName] [varchar](50) NULL,
 CONSTRAINT [pk_mesh_semantic_types] PRIMARY KEY CLUSTERED 
(
	[DescriptorUI] ASC,
	[SemanticTypeUI] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Concept.Mesh.SemanticType.XML](
	[DescriptorUI] [varchar](10) NOT NULL,
	[x] [xml] NULL,
PRIMARY KEY CLUSTERED 
(
	[DescriptorUI] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Concept.Mesh.SemanticGroupType](
	[SemanticGroupUI] [varchar](10) NOT NULL,
	[SemanticGroupName] [varchar](50) NULL,
	[SemanticTypeUI] [varchar](10) NOT NULL,
	[SemanticTypeName] [varchar](50) NULL,
PRIMARY KEY CLUSTERED 
(
	[SemanticTypeUI] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Concept.Mesh.SemanticGroup](
	[DescriptorUI] [varchar](10) NOT NULL,
	[SemanticGroupUI] [varchar](10) NOT NULL,
	[SemanticGroupName] [varchar](50) NULL,
 CONSTRAINT [pk_mesh_semantic_groups] PRIMARY KEY CLUSTERED 
(
	[DescriptorUI] ASC,
	[SemanticGroupUI] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Concept.Mesh.Qualifier](
	[DescriptorUI] [varchar](10) NOT NULL,
	[QualifierUI] [varchar](10) NOT NULL,
	[DescriptorName] [varchar](255) NULL,
	[QualifierName] [varchar](255) NULL,
	[Abbreviation] [varchar](2) NULL,
 CONSTRAINT [pk_mesh_qualifiers] PRIMARY KEY CLUSTERED 
(
	[DescriptorUI] ASC,
	[QualifierUI] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Cache].[Concept.Mesh.PersonPublication](
	[PersonID] [int] NOT NULL,
	[MeshHeader] [nvarchar](255) NOT NULL,
	[PMID] [int] NOT NULL,
	[NumPubsAll] [int] NOT NULL,
	[NumPubsThis] [int] NULL,
	[TopicWeight] [decimal](7, 5) NULL,
	[AuthorWeight] [decimal](7, 5) NULL,
	[YearWeight] [decimal](7, 5) NULL,
	[UniquenessWeight] [float] NULL,
	[MeshWeight] [float] NULL,
	[AuthorPosition] [char](1) NULL,
	[PubYear] [int] NULL,
	[NumPeopleAll] [int] NULL,
	[PubDate] [datetime] NULL,
 CONSTRAINT [PK_cache_pub_mesh] PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC,
	[MeshHeader] ASC,
	[PMID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 95) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE NONCLUSTERED INDEX [idx_pmid] ON [Profile.Cache].[Concept.Mesh.PersonPublication] 
(
	[PMID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_ump] ON [Profile.Cache].[Concept.Mesh.PersonPublication] 
(
	[PersonID] ASC,
	[MeshHeader] ASC,
	[PMID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Cache].[Concept.Mesh.Person](
	[PersonID] [int] NOT NULL,
	[MeshHeader] [nvarchar](255) NOT NULL,
	[NumPubsAll] [int] NULL,
	[NumPubsThis] [int] NULL,
	[Weight] [float] NULL,
	[FirstPublicationYear] [float] NULL,
	[LastPublicationYear] [float] NULL,
	[MaxAuthorWeight] [float] NULL,
	[WeightCategory] [tinyint] NULL,
	[FirstPubDate] [datetime] NULL,
	[LastPubDate] [datetime] NULL,
 CONSTRAINT [PK__UserMesh__5A846E65] PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC,
	[MeshHeader] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON, FILLFACTOR = 95) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Ontology.].[ClassTreeDepth](
	[Class] [varchar](400) NOT NULL,
	[_TreeDepth] [int] NULL,
	[_ClassNode] [bigint] NULL,
	[_ClassName] [varchar](400) NULL,
PRIMARY KEY CLUSTERED 
(
	[Class] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE NONCLUSTERED INDEX [idx_n] ON [Ontology.].[ClassTreeDepth] 
(
	[_ClassNode] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Ontology.].[ClassProperty](
	[ClassPropertyID] [int] NOT NULL,
	[Class] [varchar](400) NOT NULL,
	[NetworkProperty] [varchar](400) NULL,
	[Property] [varchar](400) NOT NULL,
	[IsDetail] [bit] NULL,
	[Limit] [int] NULL,
	[IncludeDescription] [bit] NULL,
	[IncludeNetwork] [bit] NULL,
	[SearchWeight] [float] NULL,
	[CustomDisplay] [bit] NULL,
	[CustomEdit] [bit] NULL,
	[ViewSecurityGroup] [bigint] NULL,
	[EditSecurityGroup] [bigint] NULL,
	[EditPermissionsSecurityGroup] [bigint] NULL,
	[EditExistingSecurityGroup] [bigint] NULL,
	[EditAddNewSecurityGroup] [bigint] NULL,
	[EditAddExistingSecurityGroup] [bigint] NULL,
	[EditDeleteSecurityGroup] [bigint] NULL,
	[MinCardinality] [int] NULL,
	[MaxCardinality] [int] NULL,
	[CustomDisplayModule] [xml] NULL,
	[CustomEditModule] [xml] NULL,
	[_ClassNode] [bigint] NULL,
	[_NetworkPropertyNode] [bigint] NULL,
	[_PropertyNode] [bigint] NULL,
	[_TagName] [nvarchar](1000) NULL,
	[_PropertyLabel] [nvarchar](400) NULL,
	[_ObjectType] [bit] NULL,
	[_NumberOfNodes] [bigint] NULL,
	[_NumberOfTriples] [bigint] NULL,
 CONSTRAINT [PK__ClassPro__D65A4C562D3171E7] PRIMARY KEY CLUSTERED 
(
	[ClassPropertyID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE NONCLUSTERED INDEX [idx__cndp] ON [Ontology.].[ClassProperty] 
(
	[_ClassNode] ASC,
	[_NetworkPropertyNode] ASC,
	[IsDetail] ASC,
	[_PropertyNode] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx__cnp] ON [Ontology.].[ClassProperty] 
(
	[_ClassNode] ASC,
	[_NetworkPropertyNode] ASC,
	[_PropertyNode] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_cndp] ON [Ontology.].[ClassProperty] 
(
	[Class] ASC,
	[NetworkProperty] ASC,
	[IsDetail] ASC,
	[Property] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Ontology.].[ClassPropertyCustom](
	[ClassPropertyCustomTypeID] [int] NOT NULL,
	[Class] [varchar](400) NOT NULL,
	[NetworkProperty] [varchar](400) NULL,
	[Property] [varchar](400) NOT NULL,
	[IncludeProperty] [bit] NULL,
	[Limit] [int] NULL,
	[IncludeNetwork] [bit] NULL,
	[IncludeDescription] [bit] NULL,
	[IsDetail] [bit] NULL,
	[_ClassPropertyID] [int] NOT NULL,
 CONSTRAINT [PK_ClassPropertyCustom] PRIMARY KEY CLUSTERED 
(
	[ClassPropertyCustomTypeID] ASC,
	[_ClassPropertyID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Ontology.].[ClassGroupClass](
	[ClassGroupURI] [varchar](400) NOT NULL,
	[ClassURI] [varchar](400) NOT NULL,
	[SortOrder] [int] NULL,
	[_ClassLabel] [nvarchar](400) NULL,
	[_ClassGroupNode] [bigint] NULL,
	[_ClassNode] [bigint] NULL,
	[_NumberOfNodes] [bigint] NULL,
 CONSTRAINT [PK__ClassGroupClass__31B75ECD] PRIMARY KEY CLUSTERED 
(
	[ClassGroupURI] ASC,
	[ClassURI] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE NONCLUSTERED INDEX [idx_ClassNode] ON [Ontology.].[ClassGroupClass] 
(
	[_ClassNode] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Ontology.].[ClassGroup](
	[ClassGroupURI] [varchar](400) NOT NULL,
	[SortOrder] [int] NULL,
	[_ClassGroupLabel] [nvarchar](400) NULL,
	[_ClassGroupNode] [bigint] NULL,
	[_NumberOfNodes] [bigint] NULL,
	[IsVisible] [bit] NULL,
 CONSTRAINT [PK__ClassGroup__2DE6CDE9] PRIMARY KEY CLUSTERED 
(
	[ClassGroupURI] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Concept.Mesh.File](
	[Name] [varchar](100) NOT NULL,
	[Data] [xml] NULL,
 CONSTRAINT [PK__Concept.Mesh.Fil__047AA831] PRIMARY KEY CLUSTERED 
(
	[Name] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Concept.Mesh.Descriptor](
	[DescriptorUI] [varchar](10) NOT NULL,
	[DescriptorName] [varchar](255) NULL,
PRIMARY KEY CLUSTERED 
(
	[DescriptorUI] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_DescriptorName] ON [Profile.Data].[Concept.Mesh.Descriptor] 
(
	[DescriptorName] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Cache].[Concept.Mesh.Count](
	[MeshHeader] [nvarchar](255) NOT NULL,
	[NumPublications] [int] NULL,
	[NumFaculty] [int] NULL,
	[Weight] [float] NULL,
	[RawWeight] [float] NULL,
 CONSTRAINT [PK__MeshCount__2B3F6F97] PRIMARY KEY CLUSTERED 
(
	[MeshHeader] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [RDF.].[Alias](
	[AliasType] [varchar](100) NOT NULL,
	[AliasID] [varchar](400) NOT NULL,
	[NodeID] [bigint] NOT NULL,
	[Preferred] [bit] NULL,
 CONSTRAINT [PK__Alias__456951BF] PRIMARY KEY CLUSTERED 
(
	[AliasType] ASC,
	[AliasID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_na] ON [RDF.].[Alias] 
(
	[NodeID] ASC,
	[Preferred] ASC,
	[AliasType] ASC,
	[AliasID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Import].[Beta.Narrative](
	[PersonID] [int] NOT NULL,
	[NarrativeMain] [text] NULL,
PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Import].[Beta.DisplayPreference](
	[PersonID] [int] NOT NULL,
	[ShowPhoto] [char](1) NULL,
	[ShowPublications] [char](1) NULL,
	[ShowAwards] [char](1) NULL,
	[ShowNarrative] [char](1) NULL,
	[ShowAddress] [char](1) NULL,
	[ShowEmail] [char](1) NULL,
	[ShowPhone] [char](1) NULL,
	[ShowFax] [char](1) NULL,
	[PhotoPreference] [int] NULL,
PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Import].[Beta.Award](
	[AwardID] [int] NOT NULL,
	[PersonID] [int] NULL,
	[Yr] [int] NULL,
	[Yr2] [int] NULL,
	[AwardNM] [varchar](100) NULL,
	[AwardingInst] [varchar](100) NULL,
PRIMARY KEY CLUSTERED 
(
	[AwardID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [User.Account].[Relationship](
	[RelationshipID] [int] IDENTITY(1,1) NOT NULL,
	[UserID] [int] NOT NULL,
	[PersonID] [int] NOT NULL,
	[RelationshipType] [varchar](50) NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[RelationshipID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.Type](
	[pubidtype_id] [varchar](20) NOT NULL,
	[name] [varchar](100) NULL,
	[sort_order] [int] NULL
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.Pubmed.Journal](
	[JournalID] [int] IDENTITY(1,1) NOT NULL,
	[MedlineTA] [varchar](1000) NULL,
	[JournalTitlesXML] [xml] NULL,
 CONSTRAINT [PK__Publication.Jour__7BFA6C9A] PRIMARY KEY CLUSTERED 
(
	[JournalID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.General](
	[PMID] [int] NOT NULL,
	[PMCID] [nvarchar](55) NULL,
	[doi] [varchar](100) NULL,
	[Owner] [varchar](50) NULL,
	[Status] [varchar](50) NULL,
	[PubModel] [varchar](50) NULL,
	[Volume] [varchar](255) NULL,
	[Issue] [varchar](255) NULL,
	[MedlineDate] [varchar](255) NULL,
	[JournalYear] [varchar](50) NULL,
	[JournalMonth] [varchar](50) NULL,
	[JournalDay] [varchar](50) NULL,
	[JournalTitle] [varchar](1000) NULL,
	[ISOAbbreviation] [varchar](100) NULL,
	[MedlineTA] [varchar](1000) NULL,
	[ArticleTitle] [nvarchar](4000) NULL,
	[MedlinePgn] [varchar](255) NULL,
	[AbstractText] [text] NULL,
	[ArticleDateType] [varchar](50) NULL,
	[ArticleYear] [varchar](10) NULL,
	[ArticleMonth] [varchar](10) NULL,
	[ArticleDay] [varchar](10) NULL,
	[Affiliation] [varchar](8000) NULL,
	[AuthorListCompleteYN] [varchar](1) NULL,
	[GrantListCompleteYN] [varchar](1) NULL,
	[PubDate] [datetime] NULL,
	[Authors] [nvarchar](4000) NULL,
PRIMARY KEY CLUSTERED 
(
	[PMID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.General.Stage](
	[PMID] [int] NOT NULL,
	[PMCID] [nvarchar](55) NULL,
	[doi] [varchar](100) NULL,
	[Owner] [varchar](50) NULL,
	[Status] [varchar](50) NULL,
	[PubModel] [varchar](50) NULL,
	[Volume] [varchar](255) NULL,
	[Issue] [varchar](255) NULL,
	[MedlineDate] [varchar](255) NULL,
	[JournalYear] [varchar](50) NULL,
	[JournalMonth] [varchar](50) NULL,
	[JournalDay] [varchar](50) NULL,
	[JournalTitle] [varchar](1000) NULL,
	[ISOAbbreviation] [varchar](100) NULL,
	[MedlineTA] [varchar](1000) NULL,
	[ArticleTitle] [nvarchar](4000) NULL,
	[MedlinePgn] [varchar](255) NULL,
	[AbstractText] [text] NULL,
	[ArticleDateType] [varchar](50) NULL,
	[ArticleYear] [varchar](10) NULL,
	[ArticleMonth] [varchar](10) NULL,
	[ArticleDay] [varchar](10) NULL,
	[Affiliation] [varchar](8000) NULL,
	[AuthorListCompleteYN] [varchar](1) NULL,
	[GrantListCompleteYN] [varchar](1) NULL,
	[PubDate] [datetime] NULL,
	[Authors] [nvarchar](4000) NULL,
PRIMARY KEY CLUSTERED 
(
	[PMID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.DisambiguationAudit](
	[BatchID] [uniqueidentifier] NULL,
	[BatchCount] [int] NULL,
	[PersonID] [int] NULL,
	[ServiceCallStart] [datetime] NULL,
	[ServiceCallEnd] [datetime] NULL,
	[ServiceCallPubsFound] [int] NULL,
	[ServiceCallNewPubs] [int] NULL,
	[ServiceCallExistingPubs] [int] NULL,
	[ServiceCallPubsAdded] [int] NULL,
	[ProcessEnd] [datetime] NULL,
	[Success] [bit] NULL,
	[ErrorText] [varchar](max) NULL
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.DisambiguationAffiliation](
	[affiliation] [varchar](1000) NULL
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.Disambiguation](
	[PersonID] [int] NOT NULL,
	[PMID] [int] NOT NULL,
	[K] [float] NULL,
	[P] [float] NULL,
 CONSTRAINT [PK_disambiguation_pubmed] PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC,
	[PMID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.AllXML](
	[PMID] [int] NOT NULL,
	[X] [xml] NULL,
	[ParseDT] [datetime] NULL,
PRIMARY KEY CLUSTERED 
(
	[PMID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Cache].[Publication.PubMed.AuthorPosition](
	[PersonID] [int] NOT NULL,
	[PMID] [int] NOT NULL,
	[AuthorPosition] [char](1) NULL,
	[AuthorWeight] [float] NULL,
	[PubDate] [datetime] NULL,
	[PubYear] [int] NULL,
	[YearWeight] [float] NULL,
	[authorRank] [int] NULL,
	[numberOfAuthors] [int] NULL,
	[authorNameAsListed] [varchar](255) NULL,
PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC,
	[PMID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.MyPub.Category](
	[HmsPubCategory] [varchar](50) NOT NULL,
	[CategoryName] [varchar](50) NULL,
PRIMARY KEY CLUSTERED 
(
	[HmsPubCategory] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.ISI.PubGeneral](
	[RecID] [int] NOT NULL,
	[InstId] [int] NULL,
	[Hot] [varchar](3) NULL,
	[SortKey] [bigint] NULL,
	[TimesCited] [int] NULL,
	[ItemIssue] [int] NULL,
	[CoverDate] [varchar](10) NULL,
	[RefKey] [int] NULL,
	[DBYear] [int] NULL,
	[Ut] [varchar](20) NULL,
	[ICKey] [varchar](50) NULL,
	[ICID] [varchar](20) NULL,
	[SourceTitle] [varchar](1000) NULL,
	[SourceAbbrev] [varchar](100) NULL,
	[ItemTitle] [varchar](4000) NULL,
	[BibId] [varchar](100) NULL,
	[BibPagesBegin] [varchar](20) NULL,
	[BibPagesEnd] [varchar](20) NULL,
	[BibPagesPages] [int] NULL,
	[BibPages] [varchar](255) NULL,
	[BibIssueYear] [int] NULL,
	[BibIssueVol] [varchar](10) NULL,
	[DocTypeCode] [varchar](3) NULL,
	[DocType] [varchar](100) NULL,
	[EditionsFull] [varchar](50) NULL,
	[LanguagesCount] [int] NULL,
	[AuthorsCount] [int] NULL,
	[EmailsCount] [int] NULL,
	[KeywordsCount] [int] NULL,
	[KeywordsPlusCount] [int] NULL,
	[RPAuthor] [varchar](100) NULL,
	[RPAddress] [varchar](1000) NULL,
	[RPOrganization] [varchar](1000) NULL,
	[RPCity] [varchar](255) NULL,
	[RPState] [varchar](50) NULL,
	[RPCountry] [varchar](50) NULL,
	[RPZipsCount] [int] NULL,
	[ResearchAddrsCount] [int] NULL,
	[AbstractAvail] [varchar](1) NULL,
	[AbstractCount] [int] NULL,
	[Abstract] [varchar](max) NULL,
	[RefsCount] [int] NULL,
	[PubDate] [datetime] NULL,
	[Authors] [varchar](4000) NULL,
	[DOI] [varchar](100) NULL,
 CONSTRAINT [PK__isi_pubs_general__6FF8854A] PRIMARY KEY CLUSTERED 
(
	[RecID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.ISI.MPID](
	[MPID] [varchar](50) NOT NULL,
	[PersonID] [int] NULL,
	[RecID] [int] NULL,
 CONSTRAINT [PK__isi2mpid__71E0CDBC] PRIMARY KEY CLUSTERED 
(
	[MPID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.Entity.InformationResource](
	[EntityID] [int] IDENTITY(1,1) NOT NULL,
	[PMID] [int] NULL,
	[MPID] [nvarchar](50) NULL,
	[PMCID] [nvarchar](55) NULL,
	[doi] [varchar](100) NULL,
	[EntityName] [nvarchar](4000) NULL,
	[EntityDate] [datetime] NULL,
	[Reference] [nvarchar](max) NULL,
	[Source] [varchar](25) NULL,
	[URL] [varchar](2000) NULL,
	[PubYear] [int] NULL,
	[YearWeight] [float] NULL,
	[SummaryXML] [xml] NULL,
	[IsActive] [bit] NULL,
	[Authors] [nvarchar](MAX),
 CONSTRAINT [PK__Publication.Enti__6892926B] PRIMARY KEY CLUSTERED 
(
	[EntityID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE NONCLUSTERED INDEX [idx_mpid] ON [Profile.Data].[Publication.Entity.InformationResource] 
(
	[MPID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_pmid] ON [Profile.Data].[Publication.Entity.InformationResource] 
(
	[PMID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_PublicationEntityInformationResourceIsActive] ON [Profile.Data].[Publication.Entity.InformationResource] 
(
	[IsActive] ASC
)
INCLUDE ( [EntityID],
[PubYear],
[PMID],
[EntityDate],
[Reference]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.Entity.Authorship](
	[EntityID] [int] IDENTITY(1,1) NOT NULL,
	[EntityName] [nvarchar](4000) NULL,
	[EntityDate] [datetime] NULL,
	[authorRank] [int] NULL,
	[numberOfAuthors] [int] NULL,
	[authorNameAsListed] [varchar](255) NULL,
	[authorWeight] [float] NULL,
	[authorPosition] [varchar](1) NULL,
	[PubYear] [int] NULL,
	[YearWeight] [float] NULL,
	[PersonID] [int] NULL,
	[InformationResourceID] [int] NULL,
	[SummaryXML] [xml] NULL,
	[IsActive] [bit] NULL,
	[AuthorsString] VARCHAR(MAX),
 CONSTRAINT [PK__Publication.Enti__6B6EFF16] PRIMARY KEY CLUSTERED 
(
	[EntityID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE NONCLUSTERED INDEX [idx_PIR] ON [Profile.Data].[Publication.Entity.Authorship] 
(
	[PersonID] ASC,
	[InformationResourceID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_PublicationEntityAuthorshipIsActive] ON [Profile.Data].[Publication.Entity.Authorship] 
(
	[IsActive] ASC
)
INCLUDE ( [EntityID],
[EntityName],
[EntityDate],
[authorPosition],
[authorRank],
[PersonID],
[numberOfAuthors],
[authorWeight],
[YearWeight],
[InformationResourceID]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.DSpace.PubGeneral](
	[DashId] [int] NOT NULL,
	[Label] [varchar](max) NULL,
	[IssueDate] [smallint] NULL,
	[BibliographicCitation] [varchar](max) NULL,
	[Abstract] [varchar](max) NULL,
 CONSTRAINT [PK_dash_pubs_general] PRIMARY KEY CLUSTERED 
(
	[DashId] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.DSpace.MPID](
	[MPID] [varchar](50) NOT NULL,
	[PersonID] [int] NULL,
	[DashID] [int] NULL,
 CONSTRAINT [PK__dash2mpid__6E103CD8] PRIMARY KEY CLUSTERED 
(
	[MPID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Search.Cache].[Public.NodeSummary](
	[NodeID] [bigint] NOT NULL,
	[ShortLabel] [varchar](500) NULL,
	[ClassName] [varchar](255) NULL,
	[SortOrder] [bigint] NULL,
PRIMARY KEY CLUSTERED 
(
	[NodeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Search.Cache].[Public.NodeRDF](
	[NodeID] [bigint] NOT NULL,
	[RDF] [nvarchar](max) NULL,
PRIMARY KEY CLUSTERED 
(
	[NodeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Search.Cache].[Public.NodePrefix](
	[Prefix] [varchar](800) NOT NULL,
	[NodeID] [bigint] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[Prefix] ASC,
	[NodeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_NodeID] ON [Search.Cache].[Public.NodePrefix] 
(
	[NodeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Search.Cache].[Public.NodeMap](
	[NodeID] [bigint] NOT NULL,
	[MatchedByNodeID] [bigint] NOT NULL,
	[Distance] [int] NULL,
	[Paths] [int] NULL,
	[Weight] [float] NULL,
PRIMARY KEY CLUSTERED 
(
	[MatchedByNodeID] ASC,
	[NodeID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_sm] ON [Search.Cache].[Public.NodeMap]
(
	[NodeID] ASC,
	[MatchedByNodeID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Search.Cache].[Public.NodeExpand](
	[NodeID] [bigint] NOT NULL,
	[ExpandNodeID] [bigint] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[NodeID] ASC,
	[ExpandNodeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Search.Cache].[Public.NodeClass](
	[NodeID] [bigint] NOT NULL,
	[Class] [bigint] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[NodeID] ASC,
	[Class] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Import].[PersonFilterFlag](
	[internalusername] [varchar](50) NULL,
	[personfilter] [varchar](50) NULL
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE NONCLUSTERED INDEX [missing_index_2042_2041] ON [Profile.Import].[PersonFilterFlag] 
(
	[personfilter] ASC
)
INCLUDE ( [internalusername]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Import].[PersonAffiliation](
	[internalusername] [nvarchar](1000) NULL,
	[title] [nvarchar](1000) NULL,
	[emailaddr] [nvarchar](1000) NULL,
	[primaryaffiliation] [bit] NULL,
	[affiliationorder] [tinyint] NULL,
	[institutionname] [nvarchar](1000) NULL,
	[institutionabbreviation] [nvarchar](1000) NULL,
	[departmentname] [nvarchar](1000) NULL,
	[departmentvisible] [bit] NULL,
	[divisionname] [nvarchar](1000) NULL,
	[facultyrank] [varchar](1000) NULL,
	[facultyrankorder] [tinyint] NULL
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE NONCLUSTERED INDEX [missing_index_152] ON [Profile.Import].[PersonAffiliation] 
(
	[facultyrankorder] ASC
)
INCLUDE ( [facultyrank]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Cache].[Process.Audit](
	[AuditID] [uniqueidentifier] NOT NULL,
	[ProcessName] [varchar](1000) NULL,
	[ProcessStartDate] [datetime] NULL,
	[ProcessEndDate] [datetime] NULL,
	[ProcessedRows] [int] NULL,
	[Error] [bit] NULL,
PRIMARY KEY CLUSTERED 
(
	[AuditID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Ontology.].[PropertyGroupProperty](
	[PropertyGroupURI] [varchar](400) NOT NULL,
	[PropertyURI] [nvarchar](400) NOT NULL,
	[SortOrder] [int] NULL,
	[CustomDisplayModule] [xml] NULL,
	[CustomEditModule] [xml] NULL,
	[_PropertyGroupNode] [bigint] NULL,
	[_PropertyNode] [bigint] NULL,
	[_TagName] [nvarchar](1000) NULL,
	[_PropertyLabel] [nvarchar](400) NULL,
	[_NumberOfNodes] [bigint] NULL,
 CONSTRAINT [PK__Property__1F57AE744D6D97C5] PRIMARY KEY CLUSTERED 
(
	[PropertyURI] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Ontology.].[PropertyGroup](
	[PropertyGroupURI] [varchar](400) NOT NULL,
	[SortOrder] [int] NULL,
	[_PropertyGroupLabel] [nvarchar](400) NULL,
	[_PropertyGroupNode] [bigint] NULL,
	[_NumberOfNodes] [bigint] NULL,
PRIMARY KEY CLUSTERED 
(
	[PropertyGroupURI] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Search.Cache].[Private.NodeSummary](
	[NodeID] [bigint] NOT NULL,
	[ShortLabel] [varchar](500) NULL,
	[ClassName] [varchar](255) NULL,
	[SortOrder] [bigint] NULL,
PRIMARY KEY CLUSTERED 
(
	[NodeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Search.Cache].[Private.NodeRDF](
	[NodeID] [bigint] NOT NULL,
	[RDF] [nvarchar](max) NULL,
PRIMARY KEY CLUSTERED 
(
	[NodeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Search.Cache].[Private.NodePrefix](
	[Prefix] [varchar](800) NOT NULL,
	[NodeID] [bigint] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[Prefix] ASC,
	[NodeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_NodeID] ON [Search.Cache].[Private.NodePrefix] 
(
	[NodeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Search.Cache].[Private.NodeMap](
	[NodeID] [bigint] NOT NULL,
	[MatchedByNodeID] [bigint] NOT NULL,
	[Distance] [int] NULL,
	[Paths] [int] NULL,
	[Weight] [float] NULL,
PRIMARY KEY CLUSTERED 
(
	[MatchedByNodeID] ASC,
	[NodeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_sm] ON [Search.Cache].[Private.NodeMap] 
(
	[NodeID] ASC,
	[MatchedByNodeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Search.Cache].[Private.NodeExpand](
	[NodeID] [bigint] NOT NULL,
	[ExpandNodeID] [bigint] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[NodeID] ASC,
	[ExpandNodeID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Search.Cache].[Private.NodeClass](
	[NodeID] [bigint] NOT NULL,
	[Class] [bigint] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[NodeID] ASC,
	[Class] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Person.Filter](
	[PersonFilterID] [int] IDENTITY(1,1) NOT NULL,
	[PersonFilter] [varchar](200) NULL,
	[PersonFilterCategory] [varchar](200) NULL,
	[PersonFilterSort] [int] NULL,
 CONSTRAINT [PK__PersonFilter__1CF15040] PRIMARY KEY CLUSTERED 
(
	[PersonFilterID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Person.FacultyRank](
	[FacultyRankID] [int] IDENTITY(1,1) NOT NULL,
	[FacultyRank] [varchar](100) NULL,
	[FacultyRankSort] [tinyint] NULL,
	[Visible] [bit] NULL,
 CONSTRAINT [PK_faculty_rank] PRIMARY KEY CLUSTERED 
(
	[FacultyRankID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [UC_FacultyRank_FacultyRank] UNIQUE NONCLUSTERED 
(
	[FacultyRank] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [UC_FacultyRank_FacultyRankSort] UNIQUE NONCLUSTERED 
(
	[FacultyRankSort] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Cache].[Person.SimilarPerson](
	[PersonID] [int] NOT NULL,
	[SimilarPersonID] [int] NOT NULL,
	[Weight] [float] NULL,
	[CoAuthor] [bit] NULL,
	[numberOfSubjectAreas] [int] NULL,
PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC,
	[SimilarPersonID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Cache].[Person.PhysicalNeighbor](
	[PersonID] [int] NOT NULL,
	[NeighborID] [int] NOT NULL,
	[Distance] [tinyint] NULL,
	[DisplayName] [nvarchar](255) NULL,
	[MyNeighbors] [nvarchar](100) NULL,
 CONSTRAINT [PK__cache_physical_n__39D17EC3] PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC,
	[NeighborID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Cache].[SNA.Coauthor.Reach](
	[PersonID] [int] NOT NULL,
	[Distance] [tinyint] NOT NULL,
	[NumPeople] [smallint] NULL,
 CONSTRAINT [PK_sna_reach] PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC,
	[Distance] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Cache].[SNA.Coauthor.DistanceLog](
	[x] [varchar](50) NULL,
	[d] [datetime] NULL
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Cache].[SNA.Coauthor.Distance](
	[PersonID1] [int] NOT NULL,
	[PersonID2] [int] NOT NULL,
	[Distance] [tinyint] NULL,
	[NumPaths] [smallint] NULL,
 CONSTRAINT [PK__sna_distance__6BDD104C] PRIMARY KEY CLUSTERED 
(
	[PersonID1] ASC,
	[PersonID2] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Cache].[SNA.Coauthor.Betweenness](
	[PersonID] [int] NOT NULL,
	[i] [smallint] NULL,
	[b] [float] NULL,
 CONSTRAINT [PK_sna_betweenness] PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Cache].[SNA.Coauthor](
	[PersonID1] [int] NOT NULL,
	[PersonID2] [int] NOT NULL,
	[i] [smallint] NULL,
	[j] [smallint] NULL,
	[w] [float] NULL,
	[FirstPubDate] [datetime] NULL,
	[LastPubDate] [datetime] NULL,
	[n] [int] NULL,
 CONSTRAINT [PK_sna_coauthors] PRIMARY KEY CLUSTERED 
(
	[PersonID1] ASC,
	[PersonID2] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Direct.].[Sites](
	[SiteID] [int] NOT NULL,
	[BootstrapURL] [varchar](255) NULL,
	[SiteName] [varchar](500) NULL,
	[QueryURL] [varchar](255) NULL,
	[SortOrder] [int] NULL,
	[IsActive] [bit] NULL
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [RDF.Stage].[Triple.Map](
	[StageTripleID] [bigint] NOT NULL,
	[TripleID] [bigint] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[StageTripleID] ASC,
	[TripleID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [RDF.Stage].[Triple](
	[StageTripleID] [bigint] IDENTITY(0,1) NOT NULL,
	[sCategory] [tinyint] NULL,
	[sURI] [nvarchar](400) NULL,
	[sValueHash] [binary](20) NULL,
	[sNodeType] [nvarchar](400) NULL,
	[sInternalType] [nvarchar](100) NULL,
	[sInternalID] [nvarchar](100) NULL,
	[sTripleID] [bigint] NULL,
	[sStageTripleID] [bigint] NULL,
	[sNodeID] [bigint] NULL,
	[sViewSecurityGroup] [bigint] NULL,
	[sEditSecurityGroup] [bigint] NULL,
	[pCategory] [tinyint] NULL,
	[pProperty] [nvarchar](400) NULL,
	[pValueHash] [binary](20) NULL,
	[pNodeID] [bigint] NULL,
	[pViewSecurityGroup] [bigint] NULL,
	[pEditSecurityGroup] [bigint] NULL,
	[oCategory] [tinyint] NULL,
	[oValue] [nvarchar](max) NULL,
	[oLanguage] [nvarchar](255) NULL,
	[oDataType] [nvarchar](255) NULL,
	[oObjectType] [bit] NULL,
	[oValueHash] [binary](20) NULL,
	[oNodeType] [nvarchar](400) NULL,
	[oInternalType] [nvarchar](100) NULL,
	[oInternalID] [nvarchar](100) NULL,
	[oTripleID] [bigint] NULL,
	[oStageTripleID] [bigint] NULL,
	[oStartTime] [nvarchar](100) NULL,
	[oEndTime] [nvarchar](100) NULL,
	[oTimePrecision] [nvarchar](100) NULL,
	[oNodeID] [bigint] NULL,
	[oViewSecurityGroup] [bigint] NULL,
	[oEditSecurityGroup] [bigint] NULL,
	[TripleHash] [binary](20) NULL,
	[TripleID] [bigint] NULL,
	[tViewSecurityGroup] [bigint] NULL,
	[Weight] [float] NULL,
	[SortOrder] [int] NULL,
	[Reitification] [bigint] NULL,
	[DataMapID] [int] NULL,
	[DataMapLink] [nvarchar](400) NULL,
	[Status] [int] NULL,
	[Graph] [bigint] NULL,
PRIMARY KEY CLUSTERED 
(
	[StageTripleID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [RDF.].[Triple](
	[TripleID] [bigint] IDENTITY(1,1) NOT NULL,
	[Subject] [bigint] NOT NULL,
	[Predicate] [bigint] NOT NULL,
	[Object] [bigint] NOT NULL,
	[TripleHash] [binary](20) NOT NULL,
	[Weight] [float] NOT NULL,
	[Reitification] [bigint] NULL,
	[ObjectType] [bit] NULL,
	[SortOrder] [int] NULL,
	[ViewSecurityGroup] [bigint] NULL,
	[Graph] [bigint] NULL,
 CONSTRAINT [PK_Triple] PRIMARY KEY NONCLUSTERED 
(
	[TripleID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE CLUSTERED INDEX [idx_SPO] ON [RDF.].[Triple] 
(
	[Subject] ASC,
	[Predicate] ASC,
	[Object] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_O] ON [RDF.].[Triple] 
(
	[Object] ASC
)
INCLUDE ( [ViewSecurityGroup],
[Subject],
[Predicate],
[Weight]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_POS] ON [RDF.].[Triple] 
(
	[Predicate] ASC,
	[Object] ASC,
	[Subject] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_Reitification] ON [RDF.].[Triple] 
(
	[Reitification] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_triple_nc_predicate] ON [RDF.].[Triple] 
(
	[Predicate] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_TripleHash] ON [RDF.].[Triple] 
(
	[TripleHash] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_TripleObjectType] ON [RDF.].[Triple] 
(
	[ObjectType] ASC
)
INCLUDE ( [TripleID],
[Subject],
[Predicate],
[Object],
[TripleHash],
[Weight],
[Reitification],
[SortOrder],
[ViewSecurityGroup],
[Graph]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_TriplePredicate] ON [RDF.].[Triple] 
(
	[Predicate] ASC
)
INCLUDE ( [TripleID],
[Subject],
[Object],
[TripleHash],
[Weight],
[Reitification],
[ObjectType],
[SortOrder],
[ViewSecurityGroup],
[Graph]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_TriplePredicateReitification] ON [RDF.].[Triple] 
(
	[Predicate] ASC,
	[Reitification] ASC
)
INCLUDE ( [Subject],
[Object]) WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Ontology.Import].[Triple](
	[OntologyTripleID] [int] IDENTITY(1,1) NOT NULL,
	[OWL] [nvarchar](100) NULL,
	[Graph] [bigint] NULL,
	[Subject] [nvarchar](max) NULL,
	[Predicate] [nvarchar](max) NULL,
	[Object] [nvarchar](max) NULL,
	[_SubjectNode] [bigint] NULL,
	[_PredicateNode] [bigint] NULL,
	[_ObjectNode] [bigint] NULL,
	[_TripleID] [bigint] NULL,
PRIMARY KEY CLUSTERED 
(
	[OntologyTripleID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Utility.NLP].[Thesaurus.Source](
	[Source] [int] NOT NULL,
	[SourceName] [varchar](100) NULL,
PRIMARY KEY CLUSTERED 
(
	[Source] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Utility.NLP].[Thesaurus](
	[Source] [int] NOT NULL,
	[ConceptID] [int] NOT NULL,
	[TermName] [nvarchar](400) NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[Source] ASC,
	[ConceptID] ASC,
	[TermName] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_term] ON [Utility.NLP].[Thesaurus] 
(
	[TermName] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Module].[Support.Map](
	[SupportMapID] [int] NOT NULL,
	[SupportID] [int] NULL,
	[Institution] [varchar](255) NULL,
	[Department] [varchar](255) NULL,
PRIMARY KEY CLUSTERED 
(
	[SupportMapID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Module].[Support.HTML](
	[SupportID] [int] NOT NULL,
	[HTML] [nvarchar](max) NULL,
PRIMARY KEY CLUSTERED 
(
	[SupportID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [User.Account].[User](
	[UserID] [int] IDENTITY(1,1) NOT NULL,
	[PersonID] [int] NULL,
	[IsActive] [bit] NULL,
	[CanBeProxy] [bit] NULL,
	[FirstName] [nvarchar](100) NULL,
	[LastName] [nvarchar](100) NULL,
	[DisplayName] [nvarchar](255) NULL,
	[Institution] [nvarchar](500) NULL,
	[Department] [nvarchar](500) NULL,
	[Division] [nvarchar](500) NULL,
	[EmailAddr] [nvarchar](255) NULL,
	[UserName] [nvarchar](50) NULL,
	[Password] [varchar](128) NULL,
	[CreateDate] [datetime] NULL,
	[ApplicationName] [varchar](255) NULL,
	[Comment] [varchar](255) NULL,
	[IsApproved] [bit] NULL,
	[IsOnline] [bit] NULL,
	[InternalUserName] [nvarchar](50) NULL,
	[NodeID] [bigint] NULL,
 CONSTRAINT [PK__user] PRIMARY KEY CLUSTERED 
(
	[UserID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY],
 CONSTRAINT [UC_User_InternalUserName] UNIQUE NONCLUSTERED 
(
	[InternalUserName] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Import].[User](
	[internalusername] [nvarchar](1000) NULL,
	[firstname] [nvarchar](1000) NULL,
	[lastname] [nvarchar](1000) NULL,
	[displayname] [nvarchar](1000) NULL,
	[institution] [nvarchar](1000) NULL,
	[department] [nvarchar](1000) NULL,
	[emailaddr] [nvarchar](1000) NULL,
	[canbeproxy] [bit] NULL
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Utility.NLP].[StopWord](
	[word] [varchar](50) NOT NULL,
	[stem] [varchar](50) NULL,
	[scope] [int] NULL,
PRIMARY KEY CLUSTERED 
(
	[word] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Framework.].[RestPath](
	[ApplicationName] [varchar](255) NOT NULL,
	[Resolver] [varchar](255) NULL,
 CONSTRAINT [PK__RestPath__239E4DCF] PRIMARY KEY CLUSTERED 
(
	[ApplicationName] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Ontology.Presentation].[XML](
	[PresentationID] [int] NOT NULL,
	[Type] [char](1) NOT NULL,
	[Subject] [nvarchar](400) NULL,
	[Predicate] [nvarchar](400) NULL,
	[Object] [nvarchar](400) NULL,
	[PresentationXML] [xml] NULL,
	[_SubjectNode] [bigint] NULL,
	[_PredicateNode] [bigint] NULL,
	[_ObjectNode] [bigint] NULL,
 CONSTRAINT [PK__Presenta__B3613E3C635F3AE9] PRIMARY KEY CLUSTERED 
(
	[PresentationID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_spo] ON [Ontology.Presentation].[XML] 
(
	[Type] ASC,
	[Subject] ASC,
	[Predicate] ASC,
	[Object] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [User.Session].[Session](
	[SessionID] [uniqueidentifier] NOT NULL,
	[SessionSequence] [int] IDENTITY(0,1) NOT NULL,
	[CreateDate] [datetime] NULL,
	[LastUsedDate] [datetime] NULL,
	[LoginDate] [datetime] NULL,
	[LogoutDate] [datetime] NULL,
	[RequestIP] [varchar](16) NULL,
	[UserID] [int] NULL,
	[PersonID] [int] NULL,
	[EntityID] [int] NULL,
	[UserRoleSetID] [uniqueidentifier] NULL,
	[NodeID] [bigint] NULL,
	[UserNode] [bigint] NULL,
	[ImpersonateUserNode] [bigint] NULL,
	[UserAgent] [varchar](500) NULL,
	[IsBot] [bit] NULL,
PRIMARY KEY CLUSTERED 
(
	[SessionID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE UNIQUE NONCLUSTERED INDEX [SessionSequence] ON [User.Session].[Session] 
(
	[SessionSequence] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
ALTER TABLE [User.Session].[Session]  WITH CHECK ADD  CONSTRAINT [FK_Session_Person] FOREIGN KEY([PersonID])
REFERENCES [Profile.Data].[Person] ([PersonID])
GO
ALTER TABLE [User.Session].[Session] CHECK CONSTRAINT [FK_Session_Person]
GO
ALTER TABLE [User.Session].[Session]  WITH CHECK ADD  CONSTRAINT [FK_Session_User] FOREIGN KEY([UserID])
REFERENCES [User.Account].[User] ([UserID])
GO
ALTER TABLE [User.Session].[Session] CHECK CONSTRAINT [FK_Session_User]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.Author](
	[PmPubsAuthorID] [int] IDENTITY(1,1) NOT NULL,
	[PMID] [int] NOT NULL,
	[ValidYN] [varchar](1) NULL,
	[LastName] [varchar](100) NULL,
	[FirstName] [varchar](100) NULL,
	[ForeName] [varchar](100) NULL,
	[Suffix] [varchar](20) NULL,
	[Initials] [varchar](20) NULL,
	[Affiliation] [varchar](8000) NULL,
	[CollectiveName] [nvarchar](1000) NULL,
    [ORCID] [varchar](50) NULL,
    [ValueHash] [varbinary](32) NULL,
 CONSTRAINT [PK__pm_pubs_authors__17F790F9] PRIMARY KEY CLUSTERED 
(
	[PmPubsAuthorID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Author]  WITH NOCHECK ADD  CONSTRAINT [FK_pm_pubs_authors_pm_pubs_general] FOREIGN KEY([PMID])
REFERENCES [Profile.Data].[Publication.PubMed.General] ([PMID])
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Author] CHECK CONSTRAINT [FK_pm_pubs_authors_pm_pubs_general]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.Author.Stage](
	[PmPubsAuthorID] [int] IDENTITY(1,1) NOT NULL,
	[PMID] [int] NOT NULL,
	[ValidYN] [varchar](1) NULL,
	[LastName] [varchar](100) NULL,
	[FirstName] [varchar](100) NULL,
	[ForeName] [varchar](100) NULL,
	[Suffix] [varchar](20) NULL,
	[Initials] [varchar](20) NULL,
	[Affiliation] [varchar](8000) NULL,
	[CollectiveName] [nvarchar](1000) NULL,
    [ORCID] [varchar](50) NULL,
	[ExistingPmPubsAuthorID] [int] NULL,
    [ValueHash] [varbinary](32) NULL,
 CONSTRAINT [PK__pm_pubs_authors_stage] PRIMARY KEY CLUSTERED 
(
	[PmPubsAuthorID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.PubType](
	[PMID] [int] NOT NULL,
	[PublicationType] [varchar](100) NOT NULL,
 CONSTRAINT [PK_pm_pubs_pubtypes] PRIMARY KEY CLUSTERED 
(
	[PMID] ASC,
	[PublicationType] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.PubType]  WITH NOCHECK ADD  CONSTRAINT [FK_pm_pubs_pubtypes_pm_pubs_general] FOREIGN KEY([PMID])
REFERENCES [Profile.Data].[Publication.PubMed.General] ([PMID])
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.PubType] CHECK CONSTRAINT [FK_pm_pubs_pubtypes_pm_pubs_general]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.Keyword](
	[PMID] [int] NOT NULL,
	[Keyword] [varchar](895) NOT NULL,
	[MajorTopicYN] [char](1) NULL,
 CONSTRAINT [PK_pm_pubs_keywords] PRIMARY KEY CLUSTERED 
(
	[PMID] ASC,
	[Keyword] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Keyword]  WITH NOCHECK ADD  CONSTRAINT [FK_pm_pubs_keywords_pm_pubs_general] FOREIGN KEY([PMID])
REFERENCES [Profile.Data].[Publication.PubMed.General] ([PMID])
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Keyword] CHECK CONSTRAINT [FK_pm_pubs_keywords_pm_pubs_general]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Person.Photo](
	[PhotoID] [int] IDENTITY(1,1) NOT NULL,
	[PersonID] [int] NOT NULL,
	[Photo] [varbinary](max) NULL,
	[PhotoLink] [nvarchar](max) NULL,
 CONSTRAINT [PK_photo] PRIMARY KEY CLUSTERED 
(
	[PhotoID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE NONCLUSTERED INDEX [idx_PersonID] ON [Profile.Data].[Person.Photo] 
(
	[PersonID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
ALTER TABLE [Profile.Data].[Person.Photo]  WITH CHECK ADD  CONSTRAINT [FK_photo_person] FOREIGN KEY([PersonID])
REFERENCES [Profile.Data].[Person] ([PersonID])
GO
ALTER TABLE [Profile.Data].[Person.Photo] CHECK CONSTRAINT [FK_photo_person]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Person.FilterRelationship](
	[PersonID] [int] NOT NULL,
	[PersonFilterid] [int] NOT NULL,
 CONSTRAINT [PK_person_filter_relationships_1] PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC,
	[PersonFilterid] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
ALTER TABLE [Profile.Data].[Person.FilterRelationship]  WITH NOCHECK ADD  CONSTRAINT [FK_person_type_relationships_person] FOREIGN KEY([PersonID])
REFERENCES [Profile.Data].[Person] ([PersonID])
GO
ALTER TABLE [Profile.Data].[Person.FilterRelationship] CHECK CONSTRAINT [FK_person_type_relationships_person]
GO
ALTER TABLE [Profile.Data].[Person.FilterRelationship]  WITH NOCHECK ADD  CONSTRAINT [FK_person_type_relationships_person_types] FOREIGN KEY([PersonFilterid])
REFERENCES [Profile.Data].[Person.Filter] ([PersonFilterID])
GO
ALTER TABLE [Profile.Data].[Person.FilterRelationship] CHECK CONSTRAINT [FK_person_type_relationships_person_types]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Publication.Person.Exclude](
	[PubID] [uniqueidentifier] NOT NULL,
	[PersonID] [int] NULL,
	[PMID] [int] NULL,
	[MPID] [nvarchar](50) NULL,
 CONSTRAINT [PK__publications_exc__3587F3E0] PRIMARY KEY CLUSTERED 
(
	[PubID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
ALTER TABLE [Profile.Data].[Publication.Person.Exclude]  WITH CHECK ADD  CONSTRAINT [FK_publications_exclude_person] FOREIGN KEY([PersonID])
REFERENCES [Profile.Data].[Person] ([PersonID])
GO
ALTER TABLE [Profile.Data].[Publication.Person.Exclude] CHECK CONSTRAINT [FK_publications_exclude_person]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Publication.Person.Add](
	[PubID] [uniqueidentifier] NOT NULL,
	[PersonID] [int] NOT NULL,
	[PMID] [int] NULL,
	[MPID] [nvarchar](50) NULL,
 CONSTRAINT [PK__publications_add__37703C52] PRIMARY KEY CLUSTERED 
(
	[PubID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
ALTER TABLE [Profile.Data].[Publication.Person.Add]  WITH CHECK ADD  CONSTRAINT [FK_publications_add_person] FOREIGN KEY([PersonID])
REFERENCES [Profile.Data].[Person] ([PersonID])
GO
ALTER TABLE [Profile.Data].[Publication.Person.Add] CHECK CONSTRAINT [FK_publications_add_person]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.Accession](
	[PMID] [int] NOT NULL,
	[DataBankName] [varchar](100) NOT NULL,
	[AccessionNumber] [varchar](50) NOT NULL,
 CONSTRAINT [PK_pm_pubs_accessions] PRIMARY KEY CLUSTERED 
(
	[PMID] ASC,
	[DataBankName] ASC,
	[AccessionNumber] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Accession]  WITH NOCHECK ADD  CONSTRAINT [FK_pm_pubs_accessions_pm_pubs_general] FOREIGN KEY([PMID])
REFERENCES [Profile.Data].[Publication.PubMed.General] ([PMID])
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Accession] CHECK CONSTRAINT [FK_pm_pubs_accessions_pm_pubs_general]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.MyPub.General](
	[MPID] [nvarchar](50) NOT NULL,
	[PersonID] [int] NULL,
	[PMID] [nvarchar](15) NULL,
	[HmsPubCategory] [nvarchar](60) NULL,
	[NlmPubCategory] [nvarchar](250) NULL,
	[PubTitle] [nvarchar](2000) NULL,
	[ArticleTitle] [nvarchar](2000) NULL,
	[ArticleType] [nvarchar](30) NULL,
	[ConfEditors] [nvarchar](2000) NULL,
	[ConfLoc] [nvarchar](2000) NULL,
	[EDITION] [nvarchar](30) NULL,
	[PlaceOfPub] [nvarchar](60) NULL,
	[VolNum] [nvarchar](30) NULL,
	[PartVolPub] [nvarchar](15) NULL,
	[IssuePub] [nvarchar](30) NULL,
	[PaginationPub] [nvarchar](30) NULL,
	[AdditionalInfo] [nvarchar](2000) NULL,
	[Publisher] [nvarchar](255) NULL,
	[SecondaryAuthors] [nvarchar](2000) NULL,
	[ConfNm] [nvarchar](2000) NULL,
	[ConfDTs] [nvarchar](60) NULL,
	[ReptNumber] [nvarchar](35) NULL,
	[ContractNum] [nvarchar](35) NULL,
	[DissUnivNm] [nvarchar](2000) NULL,
	[NewspaperCol] [nvarchar](15) NULL,
	[NewspaperSect] [nvarchar](15) NULL,
	[PublicationDT] [smalldatetime] NULL,
	[Abstract] [varchar](max) NULL,
	[Authors] [varchar](max) NULL,
	[URL] [varchar](1000) NULL,
	[CreatedDT] [datetime] NULL,
	[CreatedBy] [varchar](50) NULL,
	[UpdatedDT] [datetime] NULL,
	[UpdatedBy] [varchar](50) NULL,
 CONSTRAINT [PK__my_pubs_general__03BB8E22] PRIMARY KEY CLUSTERED 
(
	[MPID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [Profile.Data].[Publication.MyPub.General]  WITH NOCHECK ADD  CONSTRAINT [FK_my_pubs_general_person] FOREIGN KEY([PersonID])
REFERENCES [Profile.Data].[Person] ([PersonID])
GO
ALTER TABLE [Profile.Data].[Publication.MyPub.General] CHECK CONSTRAINT [FK_my_pubs_general_person]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.Databank](
	[PMID] [int] NOT NULL,
	[DataBankName] [varchar](100) NOT NULL,
 CONSTRAINT [PK_pm_pubs_databanks] PRIMARY KEY CLUSTERED 
(
	[PMID] ASC,
	[DataBankName] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Databank]  WITH NOCHECK ADD  CONSTRAINT [FK_pm_pubs_databanks_pm_pubs_general] FOREIGN KEY([PMID])
REFERENCES [Profile.Data].[Publication.PubMed.General] ([PMID])
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Databank] CHECK CONSTRAINT [FK_pm_pubs_databanks_pm_pubs_general]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.Chemical](
	[PMID] [int] NOT NULL,
	[NameOfSubstance] [varchar](255) NOT NULL
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Chemical]  WITH NOCHECK ADD  CONSTRAINT [FK_pm_pubs_chemicals_pm_pubs_general] FOREIGN KEY([PMID])
REFERENCES [Profile.Data].[Publication.PubMed.General] ([PMID])
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Chemical] CHECK CONSTRAINT [FK_pm_pubs_chemicals_pm_pubs_general]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.Mesh](
	[PMID] [int] NOT NULL,
	[DescriptorName] [varchar](255) NOT NULL,
	[QualifierName] [varchar](255) NOT NULL,
	[MajorTopicYN] [char](1) NULL,
 CONSTRAINT [PK_pm_pubs_mesh] PRIMARY KEY CLUSTERED 
(
	[PMID] ASC,
	[DescriptorName] ASC,
	[QualifierName] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
CREATE NONCLUSTERED INDEX [idx_dq] ON [Profile.Data].[Publication.PubMed.Mesh] 
(
	[DescriptorName] ASC,
	[QualifierName] ASC,
	[MajorTopicYN] ASC,
	[PMID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Mesh]  WITH NOCHECK ADD  CONSTRAINT [FK_pm_pubs_mesh_pm_pubs_general] FOREIGN KEY([PMID])
REFERENCES [Profile.Data].[Publication.PubMed.General] ([PMID])
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Mesh] CHECK CONSTRAINT [FK_pm_pubs_mesh_pm_pubs_general]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.Mesh.Stage](
	[PMID] [int] NOT NULL,
	[DescriptorName] [varchar](255) NOT NULL,
	[QualifierName] [varchar](255) NOT NULL,
	[MajorTopicYN] [char](1) NULL,
 CONSTRAINT [PK_pm_pubs_mesh_stage] PRIMARY KEY CLUSTERED 
(
	[PMID] ASC,
	[DescriptorName] ASC,
	[QualifierName] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.Investigator](
	[PmPubsInvestigatorId] [int] IDENTITY(0,1) NOT NULL,
	[PMID] [int] NOT NULL,
	[LastName] [varchar](100) NULL,
	[FirstName] [varchar](100) NULL,
	[ForeName] [varchar](100) NULL,
	[Suffix] [varchar](20) NULL,
	[Initials] [varchar](20) NULL,
	[Affiliation] [varchar](1000) NULL,
PRIMARY KEY CLUSTERED 
(
	[PmPubsInvestigatorId] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Investigator]  WITH NOCHECK ADD  CONSTRAINT [FK_pm_pubs_investigators_pm_pubs_general] FOREIGN KEY([PMID])
REFERENCES [Profile.Data].[Publication.PubMed.General] ([PMID])
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Investigator] CHECK CONSTRAINT [FK_pm_pubs_investigators_pm_pubs_general]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.Grant](
	[PMID] [int] NOT NULL,
	[GrantID] [varchar](100) NOT NULL,
	[Acronym] [varchar](50) NULL,
	[Agency] [varchar](1000) NULL,
 CONSTRAINT [PK_pm_pubs_grants] PRIMARY KEY CLUSTERED 
(
	[PMID] ASC,
	[GrantID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Grant]  WITH NOCHECK ADD  CONSTRAINT [FK_pm_pubs_grants_pm_pubs_general] FOREIGN KEY([PMID])
REFERENCES [Profile.Data].[Publication.PubMed.General] ([PMID])
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Grant] CHECK CONSTRAINT [FK_pm_pubs_grants_pm_pubs_general]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Publication.PubMed.Author2Person](
	[PersonID] [int] NOT NULL,
	[PmPubsAuthorID] [int] NOT NULL
) ON [PRIMARY]
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Author2Person]  WITH CHECK ADD  CONSTRAINT [FK_pm_authors2username_person] FOREIGN KEY([PersonID])
REFERENCES [Profile.Data].[Person] ([PersonID])
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Author2Person] CHECK CONSTRAINT [FK_pm_authors2username_person]
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Author2Person]  WITH NOCHECK ADD  CONSTRAINT [FK_pm_authors2username_pm_pubs_authors] FOREIGN KEY([PmPubsAuthorID])
REFERENCES [Profile.Data].[Publication.PubMed.Author] ([PmPubsAuthorID])
GO
ALTER TABLE [Profile.Data].[Publication.PubMed.Author2Person] CHECK CONSTRAINT [FK_pm_authors2username_pm_pubs_authors]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Publication.Person.Include](
	[PubID] [uniqueidentifier] NOT NULL,
	[PersonID] [int] NULL,
	[PMID] [int] NULL,
	[MPID] [nvarchar](50) NULL,
 CONSTRAINT [PK__publications_inc__339FAB6E] PRIMARY KEY CLUSTERED 
(
	[PubID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_mu] ON [Profile.Data].[Publication.Person.Include] 
(
	[MPID] ASC,
	[PersonID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_pu] ON [Profile.Data].[Publication.Person.Include] 
(
	[PMID] ASC,
	[PersonID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
CREATE NONCLUSTERED INDEX [idx_u] ON [Profile.Data].[Publication.Person.Include] 
(
	[PersonID] ASC
)WITH (PAD_INDEX  = OFF, STATISTICS_NORECOMPUTE  = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS  = ON, ALLOW_PAGE_LOCKS  = ON) ON [PRIMARY]
GO
ALTER TABLE [Profile.Data].[Publication.Person.Include]  WITH NOCHECK ADD  CONSTRAINT [FK_publications_include_my_pubs_general] FOREIGN KEY([MPID])
REFERENCES [Profile.Data].[Publication.MyPub.General] ([MPID])
GO
ALTER TABLE [Profile.Data].[Publication.Person.Include] CHECK CONSTRAINT [FK_publications_include_my_pubs_general]
GO
ALTER TABLE [Profile.Data].[Publication.Person.Include]  WITH NOCHECK ADD  CONSTRAINT [FK_publications_include_person] FOREIGN KEY([PersonID])
REFERENCES [Profile.Data].[Person] ([PersonID])
GO
ALTER TABLE [Profile.Data].[Publication.Person.Include] CHECK CONSTRAINT [FK_publications_include_person]
GO
ALTER TABLE [Profile.Data].[Publication.Person.Include]  WITH NOCHECK ADD  CONSTRAINT [FK_publications_include_pm_pubs_general] FOREIGN KEY([PMID])
REFERENCES [Profile.Data].[Publication.PubMed.General] ([PMID])
GO
ALTER TABLE [Profile.Data].[Publication.Person.Include] CHECK CONSTRAINT [FK_publications_include_pm_pubs_general]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [ORNG.].[Activity](
	[ActivityID] [int] IDENTITY(1,1) NOT NULL,
	[NodeID] [bigint] NULL,
	[AppID] [int] NULL,
	[CreatedDT] [datetime] NULL,
	[Activity] [xml] NULL,
 CONSTRAINT [PK__activity] PRIMARY KEY CLUSTERED 
(
	[ActivityID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
ALTER TABLE [ORNG.].[Activity] ADD  CONSTRAINT [DF_orng_activity_createdDT]  DEFAULT (getdate()) FOR [CreatedDT]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [ORNG.].[AppData](
	[NodeID] [bigint] NOT NULL,
	[AppID] [int] NOT NULL,
	[Keyname] [nvarchar](255) NOT NULL,
	[Value] [nvarchar](4000) NULL,
	[CreatedDT] [datetime] NULL,
	[UpdatedDT] [datetime] NULL
) ON [PRIMARY]

GO
SET ANSI_PADDING ON

GO
CREATE NONCLUSTERED INDEX [IDX_PersonApp] ON [ORNG.].[AppData]
(
	[NodeID] ASC,
	[AppID] ASC
)
INCLUDE ( 	[Keyname],
	[Value]) WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO
ALTER TABLE [ORNG.].[AppData] ADD  CONSTRAINT [DF_orng_appdata_createdDT]  DEFAULT (getdate()) FOR [CreatedDT]
GO
ALTER TABLE [ORNG.].[AppData] ADD  CONSTRAINT [DF_orng_appdata_updatedDT]  DEFAULT (getdate()) FOR [UpdatedDT]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [ORNG.].[Apps](
	[AppID] [int] NOT NULL,
	[Name] [nvarchar](255) NOT NULL,
	[Url] [nvarchar](255) NULL,
	[PersonFilterID] [int] NULL,
	[OAuthSecret] [nvarchar](255) NULL,
	[Enabled] [bit] NOT NULL,
 CONSTRAINT [PK__app] PRIMARY KEY CLUSTERED 
(
	[AppID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
ALTER TABLE [ORNG.].[Apps] ADD  CONSTRAINT [DF_orng_apps_enabled]  DEFAULT ((1)) FOR [Enabled]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [ORNG.].[AppViews](
	[AppID] [int] NOT NULL,
	[Page] [nvarchar](50) NULL,
	[View] [nvarchar](50) NULL,
	[ChromeID] [nvarchar](50) NULL,
	[Visibility] [nvarchar](50) NULL,
	[DisplayOrder] [int] NULL,
	[OptParams] [nvarchar](255) NULL
) ON [PRIMARY]

GO
ALTER TABLE [ORNG.].[AppViews]  WITH CHECK ADD  CONSTRAINT [FK_orng_app_views_apps] FOREIGN KEY([AppID])
REFERENCES [ORNG.].[Apps] ([AppID])
GO
ALTER TABLE [ORNG.].[AppViews] CHECK CONSTRAINT [FK_orng_app_views_apps]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [ORNG.].[Messages](
	[MsgID] [nvarchar](255) NOT NULL,
	[SenderNodeID] [bigint] NULL,
	[RecipientNodeID] [bigint] NULL,
	[Coll] [nvarchar](255) NULL,
	[Title] [nvarchar](255) NULL,
	[Body] [nvarchar](4000) NULL,
	[CreatedDT] [datetime] NULL
) ON [PRIMARY]

GO
ALTER TABLE [ORNG.].[Messages] ADD  CONSTRAINT [DF_orng_messages_createdDT]  DEFAULT (getdate()) FOR [CreatedDT]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[REF_AffiliationType](
	[AffiliationTypeID] [tinyint] NOT NULL,
	[AffiliationType] [varchar](50) NOT NULL,
 CONSTRAINT [PK_REF_AffiliationType] PRIMARY KEY CLUSTERED 
(
	[AffiliationTypeID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[REF_Decision](
	[DecisionID] [tinyint] IDENTITY(1,1) NOT NULL,
	[DecisionDescription] [varchar](150) NOT NULL,
	[DecisionDescriptionLong] [varchar](500) NOT NULL,
 CONSTRAINT [PK_REF_Decision] PRIMARY KEY CLUSTERED 
(
	[DecisionID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[REF_Permission](
	[PermissionID] [tinyint] IDENTITY(1,1) NOT NULL,
	[PermissionScope] [varchar](100) NOT NULL,
	[PermissionDescription] [varchar](500) NOT NULL,
	[MethodAndRequest] [varchar](100) NULL,
	[SuccessMessage] [varchar](1000) NULL,
	[FailedMessage] [varchar](1000) NULL,
 CONSTRAINT [PK_REF_Permission] PRIMARY KEY CLUSTERED 
(
	[PermissionID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[REF_PersonStatusType](
	[PersonStatusTypeID] [tinyint] IDENTITY(1,1) NOT NULL,
	[StatusDescription] [varchar](75) NOT NULL,
 CONSTRAINT [PK_REF_PersonStatusType] PRIMARY KEY CLUSTERED 
(
	[PersonStatusTypeID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[REF_RecordStatus](
	[RecordStatusID] [tinyint] NOT NULL,
	[StatusDescription] [varchar](150) NOT NULL,
 CONSTRAINT [PK_REF_RecordStatus] PRIMARY KEY CLUSTERED 
(
	[RecordStatusID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[REF_WorkExternalType](
	[WorkExternalTypeID] [tinyint] IDENTITY(1,1) NOT NULL,
	[WorkExternalType] [varchar](50) NOT NULL,
	[WorkExternalDescription] [varchar](100) NOT NULL,
 CONSTRAINT [PK_REF_WorkExternalType] PRIMARY KEY CLUSTERED 
(
	[WorkExternalTypeID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[RecordLevelAuditType](
	[RecordLevelAuditTypeID] [tinyint] IDENTITY(1,1) NOT NULL,
	[AuditType] [varchar](50) NOT NULL,
 CONSTRAINT [PK_RecordLevelAuditType] PRIMARY KEY CLUSTERED 
(
	[RecordLevelAuditTypeID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [ORCID.].[RecordLevelAuditTrail](
	[RecordLevelAuditTrailID] [bigint] IDENTITY(1,1) NOT NULL,
	[MetaTableID] [int] NOT NULL,
	[RowIdentifier] [bigint] NOT NULL,
	[RecordLevelAuditTypeID] [tinyint] NOT NULL,
	[CreatedDate] [smalldatetime] NOT NULL,
	[CreatedBy] [varchar](10) NOT NULL,
 CONSTRAINT [PK_RecordLevelAuditTrail] PRIMARY KEY CLUSTERED 
(
	[RecordLevelAuditTrailID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [ORCID.].[RecordLevelAuditTrail] ADD  CONSTRAINT [DF_RecordLevelAuditTrail_CreatedDate]  DEFAULT (getdate()) FOR [CreatedDate]
GO
ALTER TABLE [ORCID.].[RecordLevelAuditTrail]  WITH CHECK ADD  CONSTRAINT [FK_RecordLevelAuditTrail_RecordLevelAuditType] FOREIGN KEY([RecordLevelAuditTypeID])
REFERENCES [ORCID.].[RecordLevelAuditType] ([RecordLevelAuditTypeID])
ON UPDATE CASCADE
GO
ALTER TABLE [ORCID.].[RecordLevelAuditTrail] CHECK CONSTRAINT [FK_RecordLevelAuditTrail_RecordLevelAuditType]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[Person](
	[PersonID] [int] IDENTITY(1,1) NOT NULL,
	[InternalUsername] [nvarchar](100) NOT NULL,
	[PersonStatusTypeID] [tinyint] NOT NULL,
	[CreateUnlessOptOut] [bit] NOT NULL,
	[ORCID] [varchar](50) NULL,
	[ORCIDRecorded] [smalldatetime] NULL,
	[FirstName] [nvarchar](150) NULL,
	[LastName] [nvarchar](150) NULL,
	[PublishedName] [nvarchar](500) NULL,
	[EmailDecisionID] [tinyint] NULL,
	[EmailAddress] [varchar](300) NULL,
	[AlternateEmailDecisionID] [tinyint] NULL,
	[AgreementAcknowledged] [bit] NULL,
	[Biography] [varchar](5000) NULL,
	[BiographyDecisionID] [tinyint] NULL,
 CONSTRAINT [PK_Person] PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [ORCID.].[Person]  WITH CHECK ADD  CONSTRAINT [fk_Person_AlternateEmailDecisionID] FOREIGN KEY([AlternateEmailDecisionID])
REFERENCES [ORCID.].[REF_Decision] ([DecisionID])
GO
ALTER TABLE [ORCID.].[Person] CHECK CONSTRAINT [fk_Person_AlternateEmailDecisionID]
GO
ALTER TABLE [ORCID.].[Person]  WITH CHECK ADD  CONSTRAINT [fk_Person_BiographyDecisionID] FOREIGN KEY([BiographyDecisionID])
REFERENCES [ORCID.].[REF_Decision] ([DecisionID])
GO
ALTER TABLE [ORCID.].[Person] CHECK CONSTRAINT [fk_Person_BiographyDecisionID]
GO
ALTER TABLE [ORCID.].[Person]  WITH CHECK ADD  CONSTRAINT [fk_Person_EmailDecisionID] FOREIGN KEY([EmailDecisionID])
REFERENCES [ORCID.].[REF_Decision] ([DecisionID])
GO
ALTER TABLE [ORCID.].[Person] CHECK CONSTRAINT [fk_Person_EmailDecisionID]
GO
ALTER TABLE [ORCID.].[Person]  WITH CHECK ADD  CONSTRAINT [fk_Person_personstatustypeid] FOREIGN KEY([PersonStatusTypeID])
REFERENCES [ORCID.].[REF_PersonStatusType] ([PersonStatusTypeID])
GO
ALTER TABLE [ORCID.].[Person] CHECK CONSTRAINT [fk_Person_personstatustypeid]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[PersonMessage](
	[PersonMessageID] [int] IDENTITY(1,1) NOT NULL,
	[PersonID] [int] NOT NULL,
	[XML_Sent] [varchar](max) NULL,
	[XML_Response] [varchar](max) NULL,
	[ErrorMessage] [varchar](1000) NULL,
	[HttpResponseCode] [varchar](50) NULL,
	[MessagePostSuccess] [bit] NULL,
	[RecordStatusID] [tinyint] NULL,
	[PermissionID] [tinyint] NULL,
	[RequestURL] [varchar](1000) NULL,
	[HeaderPost] [varchar](1000) NULL,
	[UserMessage] [varchar](2000) NULL,
	[PostDate] [smalldatetime] NULL,
 CONSTRAINT [PK_PersonMessage] PRIMARY KEY CLUSTERED 
(
	[PersonMessageID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [ORCID.].[PersonMessage]  WITH CHECK ADD  CONSTRAINT [FK_PersonMessage_Person] FOREIGN KEY([PersonID])
REFERENCES [ORCID.].[Person] ([PersonID])
GO
ALTER TABLE [ORCID.].[PersonMessage] CHECK CONSTRAINT [FK_PersonMessage_Person]
GO
ALTER TABLE [ORCID.].[PersonMessage]  WITH CHECK ADD  CONSTRAINT [FK_PersonMessage_RecordStatusID] FOREIGN KEY([RecordStatusID])
REFERENCES [ORCID.].[REF_RecordStatus] ([RecordStatusID])
GO
ALTER TABLE [ORCID.].[PersonMessage] CHECK CONSTRAINT [FK_PersonMessage_RecordStatusID]
GO
ALTER TABLE [ORCID.].[PersonMessage]  WITH CHECK ADD  CONSTRAINT [FK_PersonMessage_REF_Permission] FOREIGN KEY([PermissionID])
REFERENCES [ORCID.].[REF_Permission] ([PermissionID])
GO
ALTER TABLE [ORCID.].[PersonMessage] CHECK CONSTRAINT [FK_PersonMessage_REF_Permission]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [ORCID.].[DefaultORCIDDecisionIDMapping](
	[SecurityGroupID] [bigint] NOT NULL,
	[DefaultORCIDDecisionID] [tinyint] NULL,
PRIMARY KEY CLUSTERED 
(
	[SecurityGroupID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [ORCID.].[ErrorLog](
	[ErrorLogID] [int] IDENTITY(1,1) NOT NULL,
	[InternalUsername] [nvarchar](11) NULL,
	[Exception] [text] NOT NULL,
	[OccurredOn] [smalldatetime] NOT NULL,
	[Processed] [bit] NOT NULL,
 CONSTRAINT [PK_ErrorLog] PRIMARY KEY CLUSTERED 
(
	[ErrorLogID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
ALTER TABLE [ORCID.].[ErrorLog] ADD  DEFAULT ((0)) FOR [Processed]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[FieldLevelAuditTrail](
	[FieldLevelAuditTrailID] [bigint] IDENTITY(1,1) NOT NULL,
	[RecordLevelAuditTrailID] [bigint] NOT NULL,
	[MetaFieldID] [int] NOT NULL,
	[ValueBefore] [varchar](50) NULL,
	[ValueAfter] [varchar](50) NULL,
 CONSTRAINT [PK_FieldLevelAuditTrail] PRIMARY KEY CLUSTERED 
(
	[FieldLevelAuditTrailID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [ORCID.].[FieldLevelAuditTrail]  WITH CHECK ADD  CONSTRAINT [FK_FieldLevelAuditTrail_RecordLevelAuditTrail] FOREIGN KEY([RecordLevelAuditTrailID])
REFERENCES [ORCID.].[RecordLevelAuditTrail] ([RecordLevelAuditTrailID])
ON UPDATE CASCADE
ON DELETE CASCADE
GO
ALTER TABLE [ORCID.].[FieldLevelAuditTrail] CHECK CONSTRAINT [FK_FieldLevelAuditTrail_RecordLevelAuditTrail]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [ORCID.].[Organization.Institution.Disambiguation](
	[InstitutionID] [int] NOT NULL,
	[DisambiguationID] [varchar](100) NULL,
	[DisambiguationSource] [varchar](100) NULL,
 CONSTRAINT [PK__institution] PRIMARY KEY CLUSTERED 
(
	[InstitutionID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[PersonAffiliation](
	[PersonAffiliationID] [int] IDENTITY(1,1) NOT NULL,
	[ProfilesID] [int] NOT NULL,
	[AffiliationTypeID] [tinyint] NOT NULL,
	[PersonID] [int] NOT NULL,
	[PersonMessageID] [int] NULL,
	[DecisionID] [tinyint] NOT NULL,
	[DepartmentName] [varchar](4000) NULL,
	[RoleTitle] [varchar](200) NULL,
	[StartDate] [smalldatetime] NULL,
	[EndDate] [smalldatetime] NULL,
	[OrganizationName] [varchar](4000) NOT NULL,
	[OrganizationCity] [varchar](4000) NULL,
	[OrganizationRegion] [varchar](2) NULL,
	[OrganizationCountry] [varchar](2) NULL,
	[DisambiguationID] [varchar](500) NULL,
	[DisambiguationSource] [varchar](500) NULL,
 CONSTRAINT [PK_PersonAffiliation] PRIMARY KEY CLUSTERED 
(
	[PersonAffiliationID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [ORCID.].[PersonAffiliation]  WITH CHECK ADD  CONSTRAINT [FK_PersonAffiliation_Person] FOREIGN KEY([PersonID])
REFERENCES [ORCID.].[Person] ([PersonID])
GO
ALTER TABLE [ORCID.].[PersonAffiliation] CHECK CONSTRAINT [FK_PersonAffiliation_Person]
GO
ALTER TABLE [ORCID.].[PersonAffiliation]  WITH CHECK ADD  CONSTRAINT [FK_PersonAffiliation_PersonMessage] FOREIGN KEY([PersonMessageID])
REFERENCES [ORCID.].[PersonMessage] ([PersonMessageID])
GO
ALTER TABLE [ORCID.].[PersonAffiliation] CHECK CONSTRAINT [FK_PersonAffiliation_PersonMessage]
GO
ALTER TABLE [ORCID.].[PersonAffiliation]  WITH CHECK ADD  CONSTRAINT [FK_PersonAffiliation_REF_Decision] FOREIGN KEY([DecisionID])
REFERENCES [ORCID.].[REF_Decision] ([DecisionID])
GO
ALTER TABLE [ORCID.].[PersonAffiliation] CHECK CONSTRAINT [FK_PersonAffiliation_REF_Decision]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[PersonAlternateEmail](
	[PersonAlternateEmailID] [int] IDENTITY(1,1) NOT NULL,
	[PersonID] [int] NOT NULL,
	[EmailAddress] [varchar](200) NOT NULL,
	[PersonMessageID] [int] NULL,
 CONSTRAINT [PK_PersonAlternateEmail] PRIMARY KEY CLUSTERED 
(
	[PersonAlternateEmailID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [ORCID.].[PersonAlternateEmail]  WITH CHECK ADD  CONSTRAINT [fk_PersonAlternateEmail_Personid] FOREIGN KEY([PersonID])
REFERENCES [ORCID.].[Person] ([PersonID])
GO
ALTER TABLE [ORCID.].[PersonAlternateEmail] CHECK CONSTRAINT [fk_PersonAlternateEmail_Personid]
GO
ALTER TABLE [ORCID.].[PersonAlternateEmail]  WITH CHECK ADD  CONSTRAINT [fk_PersonAlternateEmail_PersonMessageid] FOREIGN KEY([PersonMessageID])
REFERENCES [ORCID.].[PersonMessage] ([PersonMessageID])
GO
ALTER TABLE [ORCID.].[PersonAlternateEmail] CHECK CONSTRAINT [fk_PersonAlternateEmail_PersonMessageid]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [ORCID.].[PersonOthername](
	[PersonOthernameID] [int] IDENTITY(1,1) NOT NULL,
	[PersonID] [int] NOT NULL,
	[OtherName] [nvarchar](500) NULL,
	[PersonMessageID] [int] NULL,
 CONSTRAINT [PK_PersonOthername] PRIMARY KEY CLUSTERED 
(
	[PersonOthernameID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
ALTER TABLE [ORCID.].[PersonOthername]  WITH CHECK ADD  CONSTRAINT [fk_PersonOthername_Personid] FOREIGN KEY([PersonID])
REFERENCES [ORCID.].[Person] ([PersonID])
GO
ALTER TABLE [ORCID.].[PersonOthername] CHECK CONSTRAINT [fk_PersonOthername_Personid]
GO
ALTER TABLE [ORCID.].[PersonOthername]  WITH CHECK ADD  CONSTRAINT [fk_PersonOthername_PersonMessageid] FOREIGN KEY([PersonMessageID])
REFERENCES [ORCID.].[PersonMessage] ([PersonMessageID])
GO
ALTER TABLE [ORCID.].[PersonOthername] CHECK CONSTRAINT [fk_PersonOthername_PersonMessageid]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[PersonToken](
	[PersonTokenID] [int] IDENTITY(1,1) NOT NULL,
	[PersonID] [int] NOT NULL,
	[PermissionID] [tinyint] NOT NULL,
	[AccessToken] [varchar](50) NOT NULL,
	[TokenExpiration] [smalldatetime] NOT NULL,
	[RefreshToken] [varchar](50) NULL,
 CONSTRAINT [PK_PersonToken] PRIMARY KEY CLUSTERED 
(
	[PersonTokenID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [ORCID.].[PersonToken]  WITH CHECK ADD  CONSTRAINT [FK_PersonToken_Permissions] FOREIGN KEY([PermissionID])
REFERENCES [ORCID.].[REF_Permission] ([PermissionID])
GO
ALTER TABLE [ORCID.].[PersonToken] CHECK CONSTRAINT [FK_PersonToken_Permissions]
GO
ALTER TABLE [ORCID.].[PersonToken]  WITH CHECK ADD  CONSTRAINT [FK_PersonToken_Person] FOREIGN KEY([PersonID])
REFERENCES [ORCID.].[Person] ([PersonID])
GO
ALTER TABLE [ORCID.].[PersonToken] CHECK CONSTRAINT [FK_PersonToken_Person]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[PersonURL](
	[PersonURLID] [int] IDENTITY(1,1) NOT NULL,
	[PersonID] [int] NOT NULL,
	[PersonMessageID] [int] NULL,
	[URLName] [varchar](500) NULL,
	[URL] [varchar](2000) NOT NULL,
	[DecisionID] [tinyint] NOT NULL,
 CONSTRAINT [PK_PersonURL] PRIMARY KEY CLUSTERED 
(
	[PersonURLID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [ORCID.].[PersonURL]  WITH CHECK ADD  CONSTRAINT [FK_Person_PersonURL] FOREIGN KEY([PersonID])
REFERENCES [ORCID.].[Person] ([PersonID])
GO
ALTER TABLE [ORCID.].[PersonURL] CHECK CONSTRAINT [FK_Person_PersonURL]
GO
ALTER TABLE [ORCID.].[PersonURL]  WITH CHECK ADD  CONSTRAINT [FK_PersonMessage_PersonURL] FOREIGN KEY([PersonMessageID])
REFERENCES [ORCID.].[PersonMessage] ([PersonMessageID])
GO
ALTER TABLE [ORCID.].[PersonURL] CHECK CONSTRAINT [FK_PersonMessage_PersonURL]
GO
ALTER TABLE [ORCID.].[PersonURL]  WITH CHECK ADD  CONSTRAINT [FK_REFDecision_PersonURL] FOREIGN KEY([DecisionID])
REFERENCES [ORCID.].[REF_Decision] ([DecisionID])
GO
ALTER TABLE [ORCID.].[PersonURL] CHECK CONSTRAINT [FK_REFDecision_PersonURL]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[PersonWork](
	[PersonWorkID] [int] IDENTITY(1,1) NOT NULL,
	[PersonID] [int] NOT NULL,
	[PersonMessageID] [int] NULL,
	[DecisionID] [tinyint] NOT NULL,
	[WorkTitle] [varchar](max) NOT NULL,
	[ShortDescription] [varchar](max) NULL,
	[WorkCitation] [varchar](max) NULL,
	[WorkType] [varchar](500) NULL,
	[URL] [varchar](1000) NULL,
	[SubTitle] [varchar](max) NULL,
	[WorkCitationType] [varchar](500) NULL,
	[PubDate] [smalldatetime] NULL,
	[PublicationMediaType] [varchar](500) NULL,
	[PubID] [nvarchar](50) NOT NULL,
 CONSTRAINT [PK_PersonWork] PRIMARY KEY CLUSTERED 
(
	[PersonWorkID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [ORCID.].[PersonWork]  WITH CHECK ADD  CONSTRAINT [FK_PersonWork_Person] FOREIGN KEY([PersonID])
REFERENCES [ORCID.].[Person] ([PersonID])
GO
ALTER TABLE [ORCID.].[PersonWork] CHECK CONSTRAINT [FK_PersonWork_Person]
GO
ALTER TABLE [ORCID.].[PersonWork]  WITH CHECK ADD  CONSTRAINT [FK_PersonWork_PersonMessage] FOREIGN KEY([PersonMessageID])
REFERENCES [ORCID.].[PersonMessage] ([PersonMessageID])
GO
ALTER TABLE [ORCID.].[PersonWork] CHECK CONSTRAINT [FK_PersonWork_PersonMessage]
GO
ALTER TABLE [ORCID.].[PersonWork]  WITH CHECK ADD  CONSTRAINT [FK_PersonWork_REF_Decision] FOREIGN KEY([DecisionID])
REFERENCES [ORCID.].[REF_Decision] ([DecisionID])
GO
ALTER TABLE [ORCID.].[PersonWork] CHECK CONSTRAINT [FK_PersonWork_REF_Decision]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING OFF
GO
CREATE TABLE [ORCID.].[PersonWorkIdentifier](
	[PersonWorkIdentifierID] [int] IDENTITY(1,1) NOT NULL,
	[PersonWorkID] [int] NOT NULL,
	[WorkExternalTypeID] [tinyint] NOT NULL,
	[Identifier] [varchar](250) NOT NULL,
 CONSTRAINT [PK_PersonWorkIdentifier] PRIMARY KEY CLUSTERED 
(
	[PersonWorkIdentifierID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
ALTER TABLE [ORCID.].[PersonWorkIdentifier]  WITH CHECK ADD  CONSTRAINT [FK_PersonWorkIdentifier_PersonWork] FOREIGN KEY([PersonWorkID])
REFERENCES [ORCID.].[PersonWork] ([PersonWorkID])
GO
ALTER TABLE [ORCID.].[PersonWorkIdentifier] CHECK CONSTRAINT [FK_PersonWorkIdentifier_PersonWork]
GO
ALTER TABLE [ORCID.].[PersonWorkIdentifier]  WITH CHECK ADD  CONSTRAINT [FK_PersonWorkIdentifier_WorkExternalTypeID] FOREIGN KEY([WorkExternalTypeID])
REFERENCES [ORCID.].[REF_WorkExternalType] ([WorkExternalTypeID])
GO
ALTER TABLE [ORCID.].[PersonWorkIdentifier] CHECK CONSTRAINT [FK_PersonWorkIdentifier_WorkExternalTypeID]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [RDF.SemWeb].[Hash2Base64](
	[NodeID] [bigint] NOT NULL,
	[SemWebHash] [nchar](28) NULL
) ON [PRIMARY]

GO
SET ANSI_PADDING ON

GO
CREATE UNIQUE CLUSTERED INDEX [idx_SemWebHash] ON [RDF.SemWeb].[Hash2Base64]
(
	[SemWebHash] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_NodeID] ON [RDF.SemWeb].[Hash2Base64]
(
	[NodeID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE TABLE [Profile.Data].[EagleI.ImportXML](
	[ImportID] [int] IDENTITY(1,1) NOT NULL,
	[x] [xml] NULL,
PRIMARY KEY CLUSTERED 
(
	[ImportID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Data].[EagleI.HTML](
	[EagleIID] [int] IDENTITY(1,1) NOT NULL,
	[NodeID] [bigint] NOT NULL,
	[PersonID] [bigint] NOT NULL,
	[EagleIURI] [varchar](500) NULL,
	[HTML] [nvarchar](max) NULL,
PRIMARY KEY CLUSTERED 
(
	[EagleIID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO

SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Framework.].[Log.Activity](
	[activityLogId] [int] IDENTITY(1,1) NOT NULL,
	[userId] [int] NULL,
	[personId] [int] NULL,
	[methodName] [nvarchar](255) NULL,
	[property] [nvarchar](255) NULL,
	[privacyCode] [int] NULL,
	[param1] [nvarchar](255) NULL,
	[param2] [nvarchar](255) NULL,
	[createdDT] [datetime] NOT NULL,
 CONSTRAINT [PK__Log.Activity] PRIMARY KEY CLUSTERED 
(
	[activityLogId] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
ALTER TABLE [Framework.].[Log.Activity] ADD  CONSTRAINT [DF_Log.Activity_createdDT]  DEFAULT (getdate()) FOR [createdDT]
GO
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE TABLE [RDF.].[GetDataRDF.DebugLog.ExpandRDFListXML](
	[LogID] [int] NOT NULL,
	[ExpandRDFListXML] [xml] NULL,
PRIMARY KEY CLUSTERED 
(
	[LogID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE TABLE [RDF.].[GetDataRDF.DebugLog](
	[LogID] [int] IDENTITY(1,1) NOT NULL,
	[subject] [bigint] NULL,
	[predicate] [bigint] NULL,
	[object] [bigint] NULL,
	[offset] [bigint] NULL,
	[limit] [bigint] NULL,
	[showDetails] [bit] NULL,
	[expand] [bit] NULL,
	[SessionID] [uniqueidentifier] NULL,
	[StartDate] [datetime] NULL,
	[DurationMS] [int] NULL,
PRIMARY KEY CLUSTERED 
(
	[LogID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Data].[Funding.Agreement](
	[FundingAgreementID] [varchar](50) NOT NULL,
	[FundingID] [varchar](50) NULL,
	[AgreementLabel] [varchar](2000) NULL,
	[GrantAwardedBy] [varchar](1000) NULL,
	[StartDate] [date] NULL,
	[EndDate] [date] NULL,
	[PrincipalInvestigatorName] [varchar](100) NULL,
	[Abstract] [varchar](max) NULL,
	[Source] [varchar](20) NULL,
	[FundingID2] [varchar](50) NULL,
PRIMARY KEY CLUSTERED 
(
	[FundingAgreementID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Data].[Funding.Role](
	[FundingRoleID] [varchar](50) NOT NULL,
	[PersonID] [int] NULL,
	[FundingAgreementID] [varchar](50) NULL,
	[RoleLabel] [varchar](100) NULL,
	[RoleDescription] [varchar](max) NULL,
PRIMARY KEY CLUSTERED 
(
	[FundingRoleID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Data].[Funding.Add](
	[FundingRoleID] [varchar](50) NOT NULL,
	[PersonID] [int] NOT NULL,
	[FundingAgreementID] [varchar](50) NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[FundingRoleID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Data].[Funding.Delete](
	[FundingRoleID] [varchar](50) NOT NULL,
	[PersonID] [int] NULL,
	[FundingAgreementID] [varchar](50) NULL,
	[Source] varchar(20) not null,
	[FundingID] [varchar](50) NULL,
	[FundingID2] [varchar](50) NULL,
PRIMARY KEY CLUSTERED 
(
	[FundingRoleID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] 
GO
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Data].[Funding.DisambiguationOrganizationMapping](
	[InstitutionID] [int] NULL,
	[Organization] [varchar](1000) NOT NULL
) ON [PRIMARY]

GO

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Data].[Funding.DisambiguationResults](
	[PersonID] [int] NOT NULL,
	[FundingID] [varchar](50) NOT NULL,
	[FundingID2] [varchar](50) NULL,
	[Source] [varchar](50) NOT NULL,
	[GrantAwardedBy] [varchar](50) NULL,
	[StartDate] [date] NULL,
	[EndDate] [date] NULL,
	[PrincipalInvestigatorName] [varchar](100) NULL,
	[AgreementLabel] [varchar](500) NULL,
	[Abstract] [varchar](max) NULL,
	[RoleLabel] [varchar](50) NULL,
PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC,
	[FundingID] ASC,
	[Source] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Data].[Funding.DisambiguationAudit](
	[LogID] [bigint] IDENTITY(0,1) NOT NULL,
	[ServiceCallStart] [datetime] NULL,
	[ServiceCallEnd] [datetime] NULL,
	[ProcessEnd] [datetime] NULL,
	[Success] [bit] NULL,
	[ErrorText] [varchar](max) NULL
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Group.Admin](
	[UserID] [int] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[UserID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Group.General](
	[GroupID] [int] IDENTITY(1,1) NOT NULL,
	[GroupName] [varchar](400) NULL,
	[ViewSecurityGroup] [bigint] NULL,
	[CreateDate] [datetime] NULL,
	[EndDate] [datetime] NULL,
PRIMARY KEY CLUSTERED 
(
	[GroupID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Group.Manager](
	[GroupID] [int] NOT NULL,
	[UserID] [int] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[GroupID] ASC,
	[UserID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Group.Member](
	[MemberRoleID] [varchar](50) NOT NULL,
	[GroupID] [int] NOT NULL,
	[UserID] [int] NOT NULL,
	[IsActive] [bit] NULL,
	[IsApproved] [bit] NULL,
	[IsVisible] [bit] NULL,
	[Title] [nvarchar](255) NULL,
	[IsFeatured] [bit] NULL,
	[SortOrder] [int] NULL,
PRIMARY KEY CLUSTERED 
(
	[MemberRoleID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Group.Photo](
	[PhotoID] [int] IDENTITY(1,1) NOT NULL,
	[GroupID] [int] NOT NULL,
	[Photo] [varbinary](max) NULL,
	[PhotoLink] [nvarchar](max) NULL,
PRIMARY KEY CLUSTERED 
(
	[PhotoID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Publication.Group.Include](
	[PubID] [uniqueidentifier] NOT NULL,
	[GroupID] [int] NULL,
	[PMID] [int] NULL,
	[MPID] [nvarchar](50) NULL,
PRIMARY KEY CLUSTERED 
(
	[PubID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.Group.MyPub.General](
	[MPID] [nvarchar](50) NOT NULL,
	[GroupID] [int] NULL,
	[PMID] [nvarchar](15) NULL,
	[HmsPubCategory] [nvarchar](60) NULL,
	[NlmPubCategory] [nvarchar](250) NULL,
	[PubTitle] [nvarchar](2000) NULL,
	[ArticleTitle] [nvarchar](2000) NULL,
	[ArticleType] [nvarchar](30) NULL,
	[ConfEditors] [nvarchar](2000) NULL,
	[ConfLoc] [nvarchar](2000) NULL,
	[EDITION] [nvarchar](30) NULL,
	[PlaceOfPub] [nvarchar](60) NULL,
	[VolNum] [nvarchar](30) NULL,
	[PartVolPub] [nvarchar](15) NULL,
	[IssuePub] [nvarchar](30) NULL,
	[PaginationPub] [nvarchar](30) NULL,
	[AdditionalInfo] [nvarchar](2000) NULL,
	[Publisher] [nvarchar](255) NULL,
	[SecondaryAuthors] [nvarchar](2000) NULL,
	[ConfNm] [nvarchar](2000) NULL,
	[ConfDTs] [nvarchar](60) NULL,
	[ReptNumber] [nvarchar](35) NULL,
	[ContractNum] [nvarchar](35) NULL,
	[DissUnivNm] [nvarchar](2000) NULL,
	[NewspaperCol] [nvarchar](15) NULL,
	[NewspaperSect] [nvarchar](15) NULL,
	[PublicationDT] [smalldatetime] NULL,
	[Abstract] [varchar](max) NULL,
	[Authors] [varchar](max) NULL,
	[URL] [varchar](1000) NULL,
	[CreatedDT] [datetime] NULL,
	[CreatedBy] [varchar](50) NULL,
	[UpdatedDT] [datetime] NULL,
	[UpdatedBy] [varchar](50) NULL,
	[CopiedMPID] [nvarchar](50) NULL,
PRIMARY KEY CLUSTERED 
(
	[MPID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_PADDING OFF
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Publication.Group.Option](
	[GroupID] [int] NOT NULL,
	[IncludeMemberPublications] [bit] NULL,
PRIMARY KEY CLUSTERED 
(
	[GroupID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Group.Websites](
	[UrlID] [varchar](50) NOT NULL,
	[GroupID] [int] NOT NULL,
	[URL] [varchar](max) NOT NULL,
	[WebPageTitle] [varchar](max) NOT NULL,
	[SortOrder] [int] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[UrlID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Group.MediaLinks](
	[UrlID] [varchar](50) NOT NULL,
	[GroupID] [int] NOT NULL,
	[URL] [varchar](max) NOT NULL,
	[WebPageTitle] [varchar](max) NOT NULL,
	[PublicationDate] [varchar](100) NULL,
	[SortOrder] [int] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[UrlID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Person.Websites](
	[UrlID] [varchar](50) NOT NULL,
	[PersonID] [int] NOT NULL,
	[URL] [varchar](max) NOT NULL,
	[WebPageTitle] [varchar](max) NOT NULL,
	[SortOrder] [int] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[UrlID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Data].[Person.MediaLinks](
	[UrlID] [varchar](50) NOT NULL,
	[PersonID] [int] NOT NULL,
	[URL] [varchar](max) NOT NULL,
	[WebPageTitle] [varchar](max) NOT NULL,
	[PublicationDate] [varchar](100) NULL,
	[SortOrder] [int] NOT NULL,
PRIMARY KEY CLUSTERED 
(
	[UrlID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.Pubmed.Bibliometrics] (
    [PMID]                     INT           NOT NULL,
    [PMCCitations]             INT           NOT NULL,
    [MedlineTA]                VARCHAR (255) NULL,
    [Fields]                   VARCHAR (MAX) NULL,
    [TranslationHumans]        INT           NULL,
    [TranslationAnimals]       INT           NULL,
    [TranslationCells]         INT           NULL,
    [TranslationPublicHealth]  INT           NULL,
    [TranslationClinicalTrial] INT           NULL,
    PRIMARY KEY CLUSTERED ([PMID] ASC)
);
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Data].[Publication.Pubmed.JournalHeading] (
    [MedlineTA]           VARCHAR (255) NOT NULL,
    [BroadJournalHeading] VARCHAR (100) NOT NULL,
    [Weight]              FLOAT (53)    NOT NULL,
    [DisplayName]         VARCHAR (100) NULL,
    [Abbreviation]        VARCHAR (50)  NULL,
    [Color]               VARCHAR (6)   NULL,
    [Angle]               FLOAT (53)    NULL,
    [Arc]                 FLOAT (53)    NULL,
    PRIMARY KEY CLUSTERED ([MedlineTA] ASC, [BroadJournalHeading] ASC)
);
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Import].[PRNSWebservice.Log] (
    [LogID]            INT           IDENTITY (1, 1) NOT NULL,
    [Job]              VARCHAR (100) NOT NULL,
    [BatchID]          VARCHAR (100) NOT NULL,
    [RowID]            INT           NOT NULL,
    [HttpMethod]       VARCHAR (10)  NULL,
    [URL]              VARCHAR (500) NULL,
    [PostData]         VARCHAR (MAX) NULL,
    [ServiceCallStart] DATETIME      NULL,
    [ServiceCallEnd]   DATETIME      NULL,
    [ProcessEnd]       DATETIME      NULL,
    [Success]          BIT           NULL,
    [HttpResponseCode] INT           NULL,
    [HttpResponse]     VARCHAR (MAX) NULL,
    [ResultCount]      INT           NULL,
    [ErrorText]        VARCHAR (MAX) NULL,
    PRIMARY KEY CLUSTERED ([LogID] ASC)
);
GO

CREATE NONCLUSTERED INDEX [idx_PRNSWebserviceLogBatchRow]
    ON [Profile.Import].[PRNSWebservice.Log]([BatchID] ASC, [RowID] ASC)
    INCLUDE([LogID]);
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Module].[GenericRDF.Data](
	[Name] [varchar](55) NOT NULL,
	[NodeID] [bigint] NOT NULL,
	[Data] [varchar](max) NULL,
	[SearchableData] [varchar](max) NULL,
PRIMARY KEY CLUSTERED 
(
	[Name] ASC,
	[NodeID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE TABLE [Profile.Module].[GenericRDF.Plugins](
	[Name] [varchar](55) NOT NULL,
	[EnabledForPerson] [bit] NOT NULL,
	[EnabledForGroup] [bit] NOT NULL,
	[Label] [varchar](55) NOT NULL,
	[PropertyGroupURI] [varchar](400) NULL,
	[CustomDisplayModule] [varchar](max) NULL,
	[CustomEditModule] [varchar](max) NULL,
	[CustomDisplayModuleXML] [xml] NULL,
	[CustomEditModuleXML] [xml] NULL,
PRIMARY KEY CLUSTERED 
(
	[Name] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Cache].[List.Export.Publications] (
    [PersonID] INT           NOT NULL,
    [Data]     VARCHAR (MAX) NULL,
    PRIMARY KEY CLUSTERED ([PersonID] ASC)
)

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Data].[List.Admin] (
    [AdminID]             INT            IDENTITY (0, 1) NOT NULL,
    [UserID]              INT            NOT NULL,
    [AdminForInstitution] NVARCHAR (500) NULL,
    [AdminForDepartment]  NVARCHAR (500) NULL,
    [AdminForDivision]    NVARCHAR (500) NULL,
    PRIMARY KEY CLUSTERED ([AdminID] ASC)
)

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Data].[List.General](
	[UserID] [int] PRIMARY KEY,
	[CreateDate] [datetime] NULL,
	[Size] [int] NULL,
)
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Data].[List.Member] (
	[UserID] [int] NOT NULL,
	[PersonID] [int] NOT NULL,
    PRIMARY KEY CLUSTERED ([UserID] ASC, [PersonID] ASC)
)

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Data].[Publication.PubMed.DisambiguationExclude](
	[PMID] [int] NOT NULL PRIMARY KEY
)
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Data].[Publication.Pubmed.DisambiguationSettings](
	[PersonID] [int] NOT NULL,
	[Enabled] [bit] NULL,
PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO

CREATE TABLE [Profile.Data].[Funding.DisambiguationSettings](
	[PersonID] [int] NOT NULL,
	[Enabled] [bit] NULL,
PRIMARY KEY CLUSTERED 
(
	[PersonID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Import].[PRNSWebservice.Options](
	[job] [varchar](100) NOT NULL,
	[url] [varchar](500) NULL,
	[options] [varchar](100) NULL,
	[apiKey] [varchar](100) NULL,
	[logLevel] [int] NULL,
	[batchSize] [int] NULL,
	[GetPostDataProc] [varchar](1000) NULL,
	[ImportDataProc] [varchar](1000) NULL,
PRIMARY KEY CLUSTERED 
(
	[job] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_PADDING ON
GO
CREATE TABLE [Profile.Import].[PRNSWebservice.Log.Summary](
	[LogID] INT IDENTITY (1, 1) NOT NULL,
	[Job]              VARCHAR (100) NOT NULL,
    [BatchID]          VARCHAR (100) NOT NULL,
	[RecordsCount] INT NULL,
	[RowsCount] INT NULL,
	[JobStart] DATETIME NULL,
	[JobEnd] DATETIME NULL,
	[ErrorCount] int
	)

CREATE NONCLUSTERED INDEX [idx_PRNSWebserviceLogSummaryBatch]
    ON [Profile.Import].[PRNSWebservice.Log.Summary]([BatchID] ASC)
    INCLUDE([LogID]);
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [RDF.].[fnTripleHash] (
	@Subject	bigint,
	@Predicate	bigint,
	@Object		bigint
) 
RETURNS binary(20)
AS
BEGIN
	DECLARE @result binary(20)
	SELECT @result = convert(binary(20),HashBytes('sha1',
						convert(nvarchar(max),
							+N'"'
							+N'<#'+convert(nvarchar(max),@Subject)+N'> '
							+N'<#'+convert(nvarchar(max),@Predicate)+N'> '
							+N'<#'+convert(nvarchar(max),@Object)+N'> .'
							+N'"'
							+N'^^http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement'
						)
					))
	RETURN @result
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE function [Utility.Application].[fnText2Bool] (@bool VARCHAR(5))
RETURNS varchar(5) 
begin
	return CASE WHEN @bool = 'true' THEN 1 ELSE 0 END
	
end
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create FUNCTION  [Utility.NLP].[fnPorterEndsDoubleConsonant]
	(
		@Word nvarchar(4000)
	)
RETURNS bit
AS
BEGIN

--checking whether word ends with a double consonant (e.g. -TT, -SS).

--declaring local variables
DECLARE @holds_ends NVARCHAR(2), @ret bit, @hold_third_last NCHAR(1)

SET @ret = 0
--first check whether the size of the word is >= 2
If Len(@Word) >= 2
    BEGIN
	-- extract 2 characters from right of str
	SELECT @holds_ends = Right(@Word, 2)
	-- checking if both the characters are same and not double vowel
    	IF SUBSTRING(@holds_ends,1,1) = SUBSTRING(@holds_ends,2,1) AND
	   CHARINDEX(@holds_ends, N'aaeeiioouu') = 0
	    BEGIN
            	--if the second last character is y, and there are atleast three letters in str
            	If @holds_ends = N'yy' AND Len(@Word) > 2 
		    BEGIN
			-- extracting the third last character
			SELECT @hold_third_last = LEFT(Right(@Word, 3),1)
                	IF CHARINDEX(@hold_third_last, N'aaeeiioouu') > 0
			    SET @ret = 1
		    END            
            	ELSE
		    SET @ret = 1
	    END            
    END            
            
RETURN @Ret
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create function [Utility.Application].[fnBool2Text] (@bool BIT)
RETURNS varchar(5) 
begin
	return CASE WHEN @bool = 1 THEN 'true' ELSE 'false' END
	
end
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [Utility.Application].[fnBinaryToBase64] (@Binary VARBINARY(MAX))
RETURNS VARCHAR(MAX)
AS
BEGIN
	RETURN CAST(N'' AS XML).value('xs:base64Binary(xs:hexBinary(sql:variable("@Binary")))', 'VARCHAR(MAX)')
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [Utility.Application].[fnBase64ToBinary] (@Base64 VARCHAR(MAX))
RETURNS VARBINARY(MAX)
AS
BEGIN
	RETURN CAST(N'' AS XML).value('xs:base64Binary(sql:variable("@Base64"))', 'VARBINARY(MAX)')
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE function [Utility.Application].[fnExecDynamicXQuery] (
	@XML xml, -- XML value
	@Method varchar(10), -- Method to be executed. Must be one of: query, value, exist, nodes.
	@XQuery varchar(max), -- XQuery string to be executed against the XML value.
	@SQLType varchar(128) = NULL -- Used only for the value method.
)
RETURNS XML
begin
	declare	@Stmt nvarchar(max),
			@ParamDefinition nvarchar(max),
			@Output xml
	select @Stmt = 
N'declare @XML xml, @Output xml
set @XML = @XMLValue
set @Output = @XML.' + @Method + '(''' + @XQuery + '''' + CASE @Method WHEN 'value' THEN ', ''' + @SQLType + '''' ELSE '' END + ')',
			@ParamDefinition = N'@XMLValue xml, @Output xml OUTPUT'

	exec @Stmt--sp_executesql @Stmt, @ParamDefinition, @XMLValue = @XML, @Output = @Output

	return @Output
	
end
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [Utility.Application].[fnEncryptRC4]( @strInput VARCHAR(max), @strPassword VARCHAR(100) ) 
RETURNS VARCHAR(MAX)
AS
BEGIN
    --Returns a string encrypted with key k 
    --     ( RC4 encryption )
    --Original code: Eric Hodges http://www.planet-source-code.com/vb/scripts/ShowCode.asp?txtCodeId=29691&lngWId=1
    --Originally translated to TSQL by Joseph Gama
    DECLARE @i int, @j int, @n int, @t int, @s VARCHAR(256), @k VARCHAR(256),
     @tmp1 CHAR(1), @tmp2 CHAR(1), @result VARCHAR(max)
    SET @i=0 SET @s='' SET @k='' SET @result=''
    SET @strPassword = 'PRNS'+@strPassword
    WHILE @i<=255--127--255
    	BEGIN
    	SET @s=@s+CHAR(@i)
    	SET @k=@k+CHAR(ASCII(SUBSTRING(@strPassword, 1+@i % LEN(@strPassword),1)))
    	SET @i=@i+1
    	END
    SET @i=0 SET @j=0
    WHILE @i<=255--127--255
    	BEGIN
    	SET @j=(@j+ ASCII(SUBSTRING(@s,@i+1,1))+ASCII(SUBSTRING(@k,@i+1,1)))% 256 --256
    	SET @tmp1=SUBSTRING(@s,@i+1,1)
    	SET @tmp2=SUBSTRING(@s,@j+1,1)
    	SET @s=STUFF(@s,@i+1,1,@tmp2)
    	SET @s=STUFF(@s,@j+1,1,@tmp1)
    	SET @i=@i+1
    	END
    SET @i=0 SET @j=0
    SET @n=1
    WHILE @n<=LEN(@strInput)
    	BEGIN
    	SET @i=(@i+1) % 256--128--256
    	SET @j=(@j+ASCII(SUBSTRING(@s,@i+1,1))) % 256--128--256
    	SET @tmp1=SUBSTRING(@s,@i+1,1)
    	SET @tmp2=SUBSTRING(@s,@j+1,1)
    	SET @s=STUFF(@s,@i+1,1,@tmp2)
    	SET @s=STUFF(@s,@j+1,1,@tmp1)
    	SET @t=((ASCII(SUBSTRING(@s,@i+1,1))+ASCII(SUBSTRING(@s,@j+1,1))) % 256)--128)	--256)
    	IF ASCII(SUBSTRING(@s,@t+1,1))=ASCII(SUBSTRING(@strInput,@n,1))
    		SET @result=@result+SUBSTRING(@strInput,@n,1)
    	ELSE	
    		SET @result=@result+CHAR(ASCII(SUBSTRING(@s,@t+1,1)) ^ ASCII(SUBSTRING(@strInput,@n,1)))
    	SET @n=@n+1
    	END
    RETURN @result
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create FUNCTION  [Utility.NLP].[fnPorterCVCpattern]
	(
		@Word nvarchar(4000)
	)
RETURNS nvarchar(4000)
AS
BEGIN

--local variables
    DECLARE @Ret nvarchar(4000), @i int

--checking each character to see if it is a consonent or a vowel. also inputs the information in const_vowel
SELECT @i = 1, @Ret = N''
WHILE @i <= LEN(@Word)
    BEGIN
	IF CHARINDEX(SUBSTRING(@Word,@i,1), N'aeiou') > 0
	    BEGIN
		SELECT @Ret = @Ret + N'v'
	    END
	-- if y is not the first character, only then check the previous character
	ELSE IF SUBSTRING(@Word,@i,1) = N'y' AND @i > 1
	    BEGIN
            	--check to see if previous character is a consonent
		IF CHARINDEX(SUBSTRING(@Word,@i-1,1), N'aeiou') = 0
		     SELECT @Ret = @Ret + N'v'
		ELSE
		     SELECT @Ret = @Ret + N'c'
	    END
        Else
	    BEGIN
	     SELECT @Ret = @Ret + N'c'
	    END
	SELECT @i = @i + 1
    END
    RETURN @Ret
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create function [Profile.Data].[fnPublication.Pubmed.GetPubDate]
(
	@MedlineDate varchar(255),
	@JournalYear varchar(50),
	@JournalMonth varchar(50),	
	@JournalDay varchar(50),	
	@ArticleYear varchar(10),
	@ArticleMonth varchar(10),	
	@ArticleDay varchar(10)
)
RETURNS datetime
AS
BEGIN
	-- Declare the return variable here
	DECLARE @PubDate datetime


	declare @MedlineMonth varchar(10)
	declare @MedlineYear varchar(10)

	set @MedlineYear = left(@MedlineDate,4)

	set @JournalMonth = (select case left(@JournalMonth,3)
								when 'Jan' then '1'
								when 'Feb' then '2'
								when 'Mar' then '3'
								when 'Apr' then '4'
								when 'May' then '5'
								when 'Jun' then '6'
								when 'Jul' then '7'
								when 'Aug' then '8'
								when 'Sep' then '9'
								when 'Oct' then '10'
								when 'Nov' then '11'
								when 'Dec' then '12'
								when 'Win' then '1'
								when 'Spr' then '4'
								when 'Sum' then '7'
								when 'Fal' then '10'
								when '1' then '1'
								when '2' then '2'
								when '3' then '3'
								when '4' then '4'
								when '5' then '5'
								when '6' then '6'
								when '7' then '7'
								when '8' then '8'
								when '9' then '9'
								when '01' then '1'
								when '02' then '2'
								when '03' then '3'
								when '04' then '4'
								when '05' then '5'
								when '06' then '6'
								when '07' then '7'
								when '08' then '8'
								when '09' then '9'
								when '10' then '10'
								when '11' then '11'
								when '12' then '12'
								else null end)
	set @MedlineMonth = (select case substring(replace(@MedlineDate,' ',''),5,3)
								when 'Jan' then '1'
								when 'Feb' then '2'
								when 'Mar' then '3'
								when 'Apr' then '4'
								when 'May' then '5'
								when 'Jun' then '6'
								when 'Jul' then '7'
								when 'Aug' then '8'
								when 'Sep' then '9'
								when 'Oct' then '10'
								when 'Nov' then '11'
								when 'Dec' then '12'
								when 'Win' then '1'
								when 'Spr' then '4'
								when 'Sum' then '7'
								when 'Fal' then '10'
								else null end)
	set @ArticleMonth = (select case @ArticleMonth
								when 'Jan' then '1'
								when 'Feb' then '2'
								when 'Mar' then '3'
								when 'Apr' then '4'
								when 'May' then '5'
								when 'Jun' then '6'
								when 'Jul' then '7'
								when 'Aug' then '8'
								when 'Sep' then '9'
								when 'Oct' then '10'
								when 'Nov' then '11'
								when 'Dec' then '12'
								when 'Win' then '1'
								when 'Spr' then '4'
								when 'Sum' then '7'
								when 'Fal' then '10'
								when '1' then '1'
								when '2' then '2'
								when '3' then '3'
								when '4' then '4'
								when '5' then '5'
								when '6' then '6'
								when '7' then '7'
								when '8' then '8'
								when '9' then '9'
								when '01' then '1'
								when '02' then '2'
								when '03' then '3'
								when '04' then '4'
								when '05' then '5'
								when '06' then '6'
								when '07' then '7'
								when '08' then '8'
								when '09' then '9'
								when '10' then '10'
								when '11' then '11'
								when '12' then '12'
								else null end)
	declare @jd datetime
	declare @ad datetime


	set @jd = (select case when @JournalYear is not null and (@MedlineYear is null or @JournalMonth is not null) then
							cast(coalesce(@JournalMonth,'1') + '/' + coalesce(@JournalDay,'1') + '/' + @JournalYear as datetime)
						when @MedlineYear is not null then
							cast(coalesce(@MedlineMonth,'1') + '/1/' + @MedlineYear as datetime)
						else
							null
						end)

	set @ad = (select case when @ArticleYear is not null then
							cast(coalesce(@ArticleMonth,'1') + '/' + coalesce(nullif(@ArticleDay,''),'1') + '/' + @ArticleYear as datetime)
						else
							null
						end)

	declare @jdx int
	declare @adx int

	set @jdx = (select case when @jd is null then 0
							when @JournalDay is not null then 3
							when @JournalMonth is not null then 2
							else 1
							end)
	set @adx = (select case when @ad is null then 0
							when @ArticleDay is not null then 3
							when @ArticleMonth is not null then 2
							else 1
							end)

	set @PubDate = (select case when @jdx + @adx = 0 then cast('1/1/1900' as datetime)
								when @jdx > @adx then @jd
								when @adx > @jdx then @ad
								when @ad < @jd then @ad
								else @jd
								end)

	-- Return the result of the function
	RETURN @PubDate

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create function [Profile.Cache].[fnPublication.Pubmed.General2Reference]	(
	@pmid int,
	@ArticleDay varchar(10),
	@ArticleMonth varchar(10),
	@ArticleYear varchar(10),
	@ArticleTitle nvarchar(4000),
	@Authors nvarchar(4000),
	@AuthorListCompleteYN varchar(1),
	@Issue varchar(255),
	@JournalDay varchar(50),
	@JournalMonth varchar(50),
	@JournalYear varchar(50),
	@MedlineDate varchar(255),
	@MedlinePgn varchar(255),
	@MedlineTA varchar(1000),
	@Volume varchar(255),
	@encode_html bit=0
)

RETURNS NVARCHAR(MAX) 
AS 
BEGIN

	DECLARE @Reference NVARCHAR(MAX)

	SET @Reference = /*(case when right(@Authors,5) = 'et al' then @Authors+'. '
								when @AuthorListCompleteYN = 'N' then @Authors+', et al. '
								when @Authors <> '' then @Authors+'. '
								else '' end)
					+*/ CASE WHEN @encode_html=1 THEN '<a href="'+'http'+'://www.ncbi.nlm.nih.gov/pubmed/'+cast(@pmid as varchar(50))+'" target="_blank">'+coalesce(@ArticleTitle,'')+'</a>' + ' '
								 ELSE coalesce(@ArticleTitle,'') + ' '
						END
					+ coalesce(@MedlineTA,'') + '. '
					+ (case when @JournalYear is not null then rtrim(@JournalYear + ' ' + coalesce(@JournalMonth,'') + ' ' + coalesce(@JournalDay,''))
							when @MedlineDate is not null then @MedlineDate
							when @ArticleYear is not null then rtrim(@ArticleYear + ' ' + coalesce(@ArticleMonth,'') + ' ' + coalesce(@ArticleDay,''))
						else '' end)
					+ (case when coalesce(@JournalYear,@MedlineDate,@ArticleYear) is not null
								and (coalesce(@Volume,'')+coalesce(@Issue,'')+coalesce(@MedlinePgn,'') <> '')
							then '; ' else '' end)
					+ coalesce(@Volume,'')
					+ (case when coalesce(@Issue,'') <> '' then '('+@Issue+')' else '' end)
					+ (case when (coalesce(@MedlinePgn,'') <> '') and (coalesce(@Volume,'')+coalesce(@Issue,'') <> '') then ':' else '' end)
					+ coalesce(@MedlinePgn,'')
					+ '.'

	RETURN @Reference

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create FUNCTION [Utility.NLP].[fnNormalize]
	(
		@InWord nvarchar(4000)
	)
RETURNS nvarchar(4000)
AS
BEGIN
    DECLARE @Temp nvarchar(4000)
	DECLARE @Norm nvarchar(4000)
	DECLARE @i int
	DECLARE @c varchar(1)
	DECLARE @lastc varchar(1)

    SELECT @Temp = LOWER(ISNULL(RTRIM(LTRIM(@InWord)),N''))

	SET @Norm = ''
	SET @i = 1
	SET @lastc = ''

	WHILE @i <= LEN(@Temp)
	BEGIN
		SET @c = (select substring(@Temp,@i,1))
		IF not ((ascii(@c) between 48 and 57) or (ascii(@c) between 97 and 122))
			SET @c = ' '
		IF (@c <> '') or (@lastc <> ' ')
			SET @Norm = @Norm + @c
		SET @lastc = @c
		SET @i = @i + 1
	END

    RETURN RTRIM(LTRIM(@Norm))
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date, ,>
-- Description:	<Description, ,>
-- =============================================
create FUNCTION [Utility.NLP].[fnNamePart1]
(
	@s nvarchar(500)
)
RETURNS nvarchar(500)
AS
BEGIN

	set @s = (
		select
			replace(replace((case when charindex(' ',x) = 0 then x else left(x,charindex(' ',x)-1) end),'^$',' '),'^#','-')
		from (
			select
				substring(
					replace(replace(replace(
					replace(replace(replace(replace(replace(replace(replace(replace(
					replace(replace(replace(replace(replace(replace(replace(replace(
					replace(replace(replace(replace(
					' '+ltrim(rtrim(replace(
					@s
					,'.',' ')))
					,' de la ',' de^$la^$'),' de-la ',' de^#la^$'),' de la-',' de^$la^#'),' de-la-',' de^#la^#')
					,' da ',' da^$'),' de ',' de^$'),' del ',' del^$'),' do ',' do^$'),' dos ',' dos^$'),' du ',' du^$'),' el ',' el^$'),' le ',' le^$')
					,' da-',' da^#'),' de-',' de^#'),' del-',' del^#'),' do-',' do^#'),' dos-',' dos^#'),' du-',' du^#'),' el-',' el^#'),' le-',' le^#')
					,' -',' ^#'),'-',' '),'  ',' ')
				,2,999) x
		) t
	)

	RETURN @s

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [RDF.SemWeb].[fnHash2Base64]
(
	@hash char(20)
)
RETURNS nchar(28)
WITH SCHEMABINDING
AS
BEGIN

	declare @SemWebHash as nchar(28)

	-- base64 encode hashed string
	declare @alphabet64 varchar(100)
	declare @s64 varchar(1000)
	declare @pad1 bit
	declare @pad2 bit
	declare @pos int
	declare @d3 int
	declare @b1 int
	declare @b2 int
	declare @b3 int
	declare @b4 int
	set @alphabet64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	set @s64 = ''
	set @pad1 = 0
	set @pad2 = 0
	set @pos = 1
	while @pos <= 20 --len(@hash)
	begin
		set @d3 = ascii(substring(@hash,@pos,1))*256*256
		if @pos+1 <= 20 --len(@hash)
		  set @d3 = @d3 + ascii(substring(@hash,@pos+1,1))*256
		else
		  set @pad1 = 1
		if @pos+2 <= 20 --len(@hash)
		  set @d3 = @d3 + ascii(substring(@hash,@pos+2,1))
		else
		  set @pad2 = 1
		set @b1 = floor(@d3/(64*64*64))
		set @b2 = floor(@d3/(64*64)) - @b1*64
		set @b3 = floor(@d3/64) - @b1*64*64 - @b2*64
		set @b4 = @d3 - @b1*64*64*64 - @b2*64*64 - @b3*64
		set @s64 = @s64 + substring(@alphabet64,@b1+1,1)
		set @s64 = @s64 + substring(@alphabet64,@b2+1,1)
		if @pad1=1
		  set @s64 = @s64 + '='
		else
		  set @s64 = @s64 + substring(@alphabet64,@b3+1,1)
		if @pad2=1
		  set @s64 = @s64 + '='
		else
		  set @s64 = @s64 + substring(@alphabet64,@b4+1,1)
		set @pos = @pos + 3
	end

	select @SemWebHash = cast(@s64 as nchar(28))

	-- return result
	RETURN @SemWebHash

	-- select [RDF.SemWeb].[fnHash2Base64] ( [RDF.].[fnValueHash](null,null,'Griffin') )

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [RDF.].[fnValueHash] (
	@Language	nvarchar(255),
	@DataType	nvarchar(255),
	@Value		nvarchar(max)
) 
RETURNS binary(20)
AS
BEGIN
	DECLARE @result binary(20)
	SELECT @result = CONVERT(binary(20),
						HASHBYTES('sha1',
							CONVERT(nvarchar(4000),
									N'"'+replace(isnull(@Value,N''),N'"',N'\"')+N'"'
									+IsNull(N'@'+replace(@Language,N'@',N''),N'')
									+IsNull(N'^^'+replace(@DataType,N'^',N''),N'')
							)
						)
					)
	RETURN @result
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [RDF.].[fnURI2NodeID] (
	@URI	nvarchar(4000)
) 
RETURNS bigint
AS
BEGIN
	DECLARE @result bigint
	IF @URI IS NULL
		SELECT @result = NULL
	ELSE
		SELECT @result = NodeID
			FROM [RDF.].Node
			WHERE ValueHash = [RDF.].fnValueHash(null,null,@URI)
	RETURN @result
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [Ontology.Import].[fnGetPropertyTree]
(
	-- Add the parameters for the function here
	@property nvarchar(1000) = NULL,
	@depth int = 0
)
RETURNS xml
AS
BEGIN
	-- Declare the return variable here
	DECLARE @x xml

	-- select [Ontology.Import].[fnGetPropertyTree](null,0)

	if @property is null
		select @x = (
				select Subject as "property/@name", @depth as "property/@depth", Object as "property/@type",
					[Ontology.Import].[fnGetPropertyTree](Subject,@depth+1) as "property"
				from (
					select Subject, Object
						from [Ontology.Import].[Triple] a
						where Object in ('http://www.w3.org/2002/07/owl#DatatypeProperty','http://www.w3.org/2002/07/owl#ObjectProperty')
							and not exists (
								select * 
								from [Ontology.Import].[Triple] b 
								where b.Predicate = 'http://www.w3.org/2000/01/rdf-schema#subPropertyOf'
									and b.Subject = a.Subject
							)
					union all
					select Object, 'http://www.w3.org/2002/07/owl#DatatypeProperty'
						from [Ontology.Import].[Triple] a
						where a.Predicate = 'http://www.w3.org/2000/01/rdf-schema#subPropertyOf'
							and not exists (
								select * from [Ontology.Import].[Triple] b
								where b.Object in ('http://www.w3.org/2002/07/owl#DatatypeProperty','http://www.w3.org/2002/07/owl#ObjectProperty')
									and a.Object = b.Subject
							)
				) t
				order by Subject
				for xml path(''), type
		)
	else
		select @x = (
				select Subject as "property/@name", @depth as "property/@depth", Object as "property/@type",
					[Ontology.Import].[fnGetPropertyTree](Subject,@depth+1) as "property"
				from [Ontology.Import].[Triple] a
				where Object in ('http://www.w3.org/2002/07/owl#DatatypeProperty','http://www.w3.org/2002/07/owl#ObjectProperty')
					and exists (
						select * 
						from [Ontology.Import].[Triple] b 
						where b.Predicate = 'http://www.w3.org/2000/01/rdf-schema#subPropertyOf'
							and b.Object = @property
							and b.Subject = a.Subject
					)
				order by Subject
				for xml path(''), type
		)

	-- Return the result of the function
	RETURN @x

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [Ontology.Import].[fnGetClassTree]
(
	-- Add the parameters for the function here
	@class nvarchar(1000) = NULL,
	@depth int = 0
)
RETURNS xml
AS
BEGIN
	-- Declare the return variable here
	DECLARE @x xml

	-- select [Ontology.Import].fnGetClassTree(null,0)

	if @class is null
		select @x = (
				select Subject as "class/@name", @depth as "class/@depth", @class as "class/@parent",
					[Ontology.Import].fnGetClassTree(Subject,@depth+1) as "class"
				from (
					select Subject
						from [Ontology.Import].[Triple] a
						where Object = 'http://www.w3.org/2002/07/owl#Class'
							and not exists (
								select * 
								from [Ontology.Import].[Triple] b 
								where b.Predicate = 'http://www.w3.org/2000/01/rdf-schema#subClassOf'
									and b.Object not like 'http://profiles.catalyst.harvard.edu/ontology/nodeID#%'
									and b.Subject = a.Subject
							)
					union all
					select Object
						from [Ontology.Import].[Triple] a
						where a.Predicate = 'http://www.w3.org/2000/01/rdf-schema#subClassOf'
							and not exists (
								select * from [Ontology.Import].[Triple] b
								where b.Object = 'http://www.w3.org/2002/07/owl#Class'
									and a.Object = b.Subject
							)
							and a.Object not like 'http://profiles.catalyst.harvard.edu/ontology/nodeID#%'
				) t
				order by Subject
				for xml path(''), type
		)
	else
		select @x = (
				select Subject as "class/@name", @depth as "class/@depth", @class as "class/@parent",
					[Ontology.Import].fnGetClassTree(Subject,@depth+1) as "class"
				from [Ontology.Import].[Triple] a
				where Object = 'http://www.w3.org/2002/07/owl#Class'
					and exists (
						select * 
						from [Ontology.Import].[Triple] b 
						where b.Predicate = 'http://www.w3.org/2000/01/rdf-schema#subClassOf'
							and b.Object = @class
							and b.Subject = a.Subject
					)
				order by Subject
				for xml path(''), type
		)

	-- Return the result of the function
	RETURN @x

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create FUNCTION  [Utility.NLP].[fnPorterCountm]
	(
		@Word nvarchar(4000)
	)
RETURNS tinyint
AS
BEGIN

--A \consonant\ in a word is a letter other than A, E, I, O or U, and other
--than Y preceded by a consonant. (The fact that the term `consonant' is
--defined to some extent in terms of itself does not make it ambiguous.) So in
--TOY the consonants are T and Y, and in SYZYGY they are S, Z and G. If a
--letter is not a consonant it is a \vowel\.

--declaring local variables
DECLARE @pattern nvarchar(4000), @ret tinyint, @i int, @flag bit

--initializing
SELECT @ret = 0, @flag = 0,  @i = 1

If Len(@Word) > 0
    BEGIN
	--find out the CVC pattern
	SELECT @pattern =  [Utility.NLP].fnPorterCVCpattern(@Word)
	--counting the number of m's...
	WHILE @i <= LEN(@pattern)
	    BEGIN
        	IF SUBSTRING(@pattern,@i,1) = N'v' OR @flag = 1
		    BEGIN
			SELECT @flag = 1
		        IF SUBSTRING(@pattern,@i,1) = N'c'
			    SELECT @ret = @ret + 1, @flag = 0
		    END
		SELECT @i = @i + 1
	    END
    END

    RETURN @Ret
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create FUNCTION  [Utility.NLP].[fnPorterContainsVowel]
	(
		@Word nvarchar(4000)
	)
RETURNS bit
AS
BEGIN

--checking word to see if vowels are present
DECLARE @pattern nvarchar(4000), @ret bit

SET @ret = 0

IF LEN(@Word) > 0
    BEGIN
    	--find out the CVC pattern
    	SELECT @pattern =  [Utility.NLP].fnPorterCVCpattern(@Word)
	--check to see if the return pattern contains a vowel
    	IF CHARINDEX( N'v',@pattern) > 0
	  SELECT @ret = 1
    END
RETURN @Ret
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [Utility.Application].[fnEncryptBase64RC4]( @strInput VARCHAR(max), @strPassword VARCHAR(100) ) 
RETURNS VARCHAR(MAX)
AS
BEGIN
	RETURN [Utility.Application].fnBinaryToBase64(
				CONVERT(VARBINARY(max),
							[Utility.Application].[fnEncryptRC4](@strInput,@strPassword)
						)
			)
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [Utility.Application].[fnDecryptBase64RC4]( @strInput VARCHAR(max), @strPassword VARCHAR(100) ) 
RETURNS VARCHAR(MAX)
AS
BEGIN
	RETURN [Utility.Application].[fnEncryptRC4](
				[Utility.Application].fnBase64ToBinary(@strInput),
				@strPassword
			)
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create FUNCTION  [Utility.NLP].[fnPorterEndsCVC]
	(
		@Word nvarchar(4000)
	)
RETURNS bit
AS
BEGIN
--*o  - the stem ends cvc, where the second c is not W, X or Y (e.g. -WIL, -HOP).

--declaring local variables
DECLARE @pattern NVARCHAR(3), @ret bit


SELECT @ret = 0

--'check to see if atleast 3 characters are present
If LEN(@Word) >= 3
    BEGIN
	-- find out the CVC pattern
	-- we need to check only the last three characters
	SELECT @pattern = RIGHT( [Utility.NLP].fnPorterCVCpattern(@Word),3)
	-- check to see if the letters in str match the sequence cvc
	IF @pattern = N'cvc' AND CHARINDEX(RIGHT(@Word,1), N'wxy') = 0
		SELECT @ret = 1
    END
RETURN @Ret
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create FUNCTION  [Utility.NLP].[fnPorterEndsDoubleCVC]
	(
		@Word nvarchar(4000)
	)
RETURNS bit
AS
BEGIN

--*o  - the stem ends cvc, where the second c is not W, X or Y (e.g. -WIL, -HOP).

--declaring local variables
DECLARE @pattern NVARCHAR(3), @ret bit

SET @ret = 0

--check to see if atleast 3 characters are present
IF Len(@Word) >= 3 
    BEGIN    
  	-- find out the CVC pattern
    	-- we need to check only the last three characters
	SELECT @pattern = RIGHT( [Utility.NLP].fnPorterCVCpattern(@Word),3)
	-- check to see if the letters in str match the sequence cvc
    	IF @pattern = N'cvc' AND 
	   CHARINDEX(RIGHT(@Word,1), N'wxy') = 0
		SELECT @ret = 1
    END
RETURN @Ret
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create FUNCTION [Utility.NLP].[fnPorterStep5]
	(
		@InWord nvarchar(4000)
	)
RETURNS nvarchar(4000)
AS
BEGIN
--STEP 5a
--
--    (m>1) E     ->                  probate        ->  probat
--                                    rate           ->  rate
--    (m=1 and not *o) E ->           cease          ->  ceas
--
--STEP 5b
--
--    (m>1 and *d and *L) -> single letter
--                                    controll       ->  control
--                                    roll           ->  roll

--declaring local variables
    DECLARE @Ret nvarchar(4000), @Temp nvarchar(4000), @m tinyint
    SET @Ret = @InWord

--Step5a
    IF RIGHT(@Ret , 1) = N'e'	            --word ends with e
	BEGIN
	    SELECT @temp = LEFT(@Ret, LEN(@Ret) - 1)
	    SELECT @m = [Utility.NLP].fnPorterCountm(@temp)
	    IF @m > 1						--m>1
		SELECT @Ret = LEFT(@Ret, LEN(@Ret) - 1)
	    ELSE IF @m = 1					--m=1
		BEGIN
		    IF [Utility.NLP].fnPorterEndsCVC(@temp) = 0		--not *o
			SELECT @Ret = LEFT(@Ret, LEN(@Ret) - 1)
		END
	END
----------------------------------------------------------------------------------------------------------
--
--Step5b
IF [Utility.NLP].fnPorterCountm(@Ret) > 1
    BEGIN
	IF [Utility.NLP].fnPorterEndsDoubleConsonant(@Ret) = 1 AND RIGHT(@Ret, 1) = N'l'
	    SELECT @Ret = LEFT(@Ret, LEN(@Ret) - 1)
    END
--retuning the word
RETURN @Ret
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [Utility.NLP].[fnPorterStep4]
	(
		@InWord nvarchar(4000)
	)
RETURNS nvarchar(4000)
AS
BEGIN
--STEP 4
--
--    (m>1) AL    ->                  revival        ->  reviv
--    (m>1) ANCE  ->                  allowance      ->  allow
--    (m>1) ENCE  ->                  inference      ->  infer
--    (m>1) ER    ->                  airliner       ->  airlin
--    (m>1) IC    ->                  gyroscopic     ->  gyroscop
--    (m>1) ABLE  ->                  adjustable     ->  adjust
--    (m>1) IBLE  ->                  defensible     ->  defens
--    (m>1) ANT   ->                  irritant       ->  irrit
--    (m>1) EMENT ->                  replacement    ->  replac
--    (m>1) MENT  ->                  adjustment     ->  adjust
--    (m>1) ENT   ->                  dependent      ->  depend
--    (m>1 and (*S or *T)) ION ->     adoption       ->  adopt
--    (m>1) OU    ->                  homologou      ->  homolog
--    (m>1) ISM   ->                  communism      ->  commun
--    (m>1) ATE   ->                  activate       ->  activ
--    (m>1) ITI   ->                  angulariti     ->  angular
--    (m>1) OUS   ->                  homologous     ->  homolog
--    (m>1) IVE   ->                  effective      ->  effect
--    (m>1) IZE   ->                  bowdlerize     ->  bowdler
--
--The suffixes are now removed. All that remains is a little tidying up.

    DECLARE @Ret nvarchar(4000), @Temp nvarchar(4000)
    DECLARE @Phrase1 NVARCHAR(15)
    DECLARE @CursorName CURSOR

--checking word
    SELECT @Ret = @InWord
    SET @CursorName = CURSOR FOR 
	SELECT phrase1 FROM [Utility.NLP].ParsePorterStemming WHERE Step = 4 AND RIGHT(@Ret ,LEN(Phrase1)) = Phrase1
		ORDER BY Ordering
    OPEN @CursorName

    -- Do Step 4
    FETCH NEXT FROM @CursorName INTO @Phrase1
    WHILE @@FETCH_STATUS = 0 
	BEGIN
	    --IF RIGHT(@Ret ,LEN(@Phrase1)) = @Phrase1
		BEGIN
		    SELECT @temp = LEFT(@Ret, LEN(@Ret) - LEN(@Phrase1))
            	    IF [Utility.NLP].fnPorterCountm(@temp) > 1
			BEGIN
			    IF RIGHT(@Ret ,LEN(N'ion')) = N'ion'
				BEGIN
				    IF RIGHT(@temp ,1) = N's' OR RIGHT(@temp ,1) = N't'
					SELECT @Ret = LEFT(@Ret, LEN(@Ret) - LEN(@Phrase1))
				END
			    ELSE
				SELECT @Ret = LEFT(@Ret, LEN(@Ret) - LEN(@Phrase1))
			END
            	    BREAK
		END
	    FETCH NEXT FROM @CursorName INTO @Phrase1
        END

    -- Free Resources
    CLOSE @CursorName
    DEALLOCATE @CursorName

    --retuning the word
    RETURN @Ret
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION  [Utility.NLP].[fnPorterStep3]
	(
		@InWord nvarchar(4000)
	)
RETURNS nvarchar(4000)
AS
BEGIN

/*STEP 3
    (m>0) ICATE ->  IC              triplicate     ->  triplic
    (m>0) ATIVE ->                  formative      ->  form
    (m>0) ALIZE ->  AL              formalize      ->  formal
    (m>0) ICITI ->  IC              electriciti    ->  electric
    (m>0) ICAL  ->  IC              electrical     ->  electric
    (m>0) FUL   ->                  hopeful        ->  hope
    (m>0) NESS  ->                  goodness       ->  good
*/

--declaring local variables
    DECLARE @Ret nvarchar(4000), @Temp nvarchar(4000)
    DECLARE @Phrase1 NVARCHAR(15), @Phrase2 NVARCHAR(15)
    DECLARE @CursorName CURSOR, @i int

--checking word
    SET @Ret = @InWord
    SET @CursorName = CURSOR FOR 
	SELECT phrase1, phrase2 FROM  [Utility.NLP].ParsePorterStemming WHERE Step = 3 AND RIGHT(@Ret ,LEN(Phrase1)) = Phrase1
		ORDER BY Ordering
    OPEN @CursorName

    -- Do Step 2
    FETCH NEXT FROM @CursorName INTO @Phrase1, @Phrase2
    WHILE @@FETCH_STATUS = 0 
	BEGIN
	    --IF RIGHT(@Ret ,LEN(@Phrase1)) = @Phrase1
		BEGIN
		    SELECT @temp = LEFT(@Ret, LEN(@Ret) - LEN(@Phrase1))
            	    IF  [Utility.NLP].fnPorterCountm(@temp) > 0
			SELECT @Ret = LEFT(@Ret, LEN(@Ret) - LEN(@Phrase1)) + @Phrase2
            	    BREAK
		END
	    FETCH NEXT FROM @CursorName INTO @Phrase1, @Phrase2
        END


    -- Free Resources
    CLOSE @CursorName
    DEALLOCATE @CursorName

    --retuning the word
    RETURN @Ret
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION  [Utility.NLP].[fnPorterStep2]
	(
		@InWord nvarchar(4000)
	)
RETURNS nvarchar(4000)
AS
BEGIN

/*STEP 2

    (m>0) ATIONAL ->  ATE           relational     ->  relate
    (m>0) TIONAL  ->  TION          conditional    ->  condition
                                    rational       ->  rational
    (m>0) ENCI    ->  ENCE          valenci        ->  valence
    (m>0) ANCI    ->  ANCE          hesitanci      ->  hesitance
    (m>0) IZER    ->  IZE           digitizer      ->  digitize
Also,
    (m>0) BLI    ->   BLE           conformabli    ->  conformable

    (m>0) ALLI    ->  AL            radicalli      ->  radical
    (m>0) ENTLI   ->  ENT           differentli    ->  different
    (m>0) ELI     ->  E             vileli        - >  vile
    (m>0) OUSLI   ->  OUS           analogousli    ->  analogous
    (m>0) IZATION ->  IZE           vietnamization ->  vietnamize
    (m>0) ATION   ->  ATE           predication    ->  predicate
    (m>0) ATOR    ->  ATE           operator       ->  operate
    (m>0) ALISM   ->  AL            feudalism      ->  feudal
    (m>0) IVENESS ->  IVE           decisiveness   ->  decisive
    (m>0) FULNESS ->  FUL           hopefulness    ->  hopeful
    (m>0) OUSNESS ->  OUS           callousness    ->  callous
    (m>0) ALITI   ->  AL            formaliti      ->  formal
    (m>0) IVITI   ->  IVE           sensitiviti    ->  sensitive
    (m>0) BILITI  ->  BLE           sensibiliti    ->  sensible
Also,
    (m>0) LOGI    ->  LOG           apologi        -> apolog

The test for the string S1 can be made fast by doing a program switch on
the penultimate letter of the word being tested. This gives a fairly even
breakdown of the possible values of the string S1. It will be seen in fact
that the S1-strings in step 2 are presented here in the alphabetical order
of their penultimate letter. Similar techniques may be applied in the other
steps.
*/

--declaring local variables
    DECLARE @Ret nvarchar(4000), @Temp nvarchar(4000)
    DECLARE @Phrase1 NVARCHAR(15), @Phrase2 NVARCHAR(15)
    DECLARE @CursorName CURSOR --, @i int

--checking word
    SET @Ret = @InWord
    SET @CursorName = CURSOR FOR 
	SELECT phrase1, phrase2 FROM  [Utility.NLP].ParsePorterStemming WHERE Step = 2 AND RIGHT(@Ret ,LEN(Phrase1)) = Phrase1
		ORDER BY Ordering
    OPEN @CursorName

    -- Do Step 2
    FETCH NEXT FROM @CursorName INTO @Phrase1, @Phrase2
    WHILE @@FETCH_STATUS = 0 
	BEGIN
	    --IF RIGHT(@Ret ,LEN(@Phrase1)) = @Phrase1
		BEGIN
		    SELECT @temp = LEFT(@Ret, LEN(@Ret) - LEN(@Phrase1))
            	    IF  [Utility.NLP].fnPorterCountm(@temp) > 0
			SELECT @Ret = LEFT(@Ret, LEN(@Ret) - LEN(@Phrase1)) + @Phrase2
            	    BREAK
		END
	    FETCH NEXT FROM @CursorName INTO @Phrase1, @Phrase2
        END
    -- Free Resources
    CLOSE @CursorName
    DEALLOCATE @CursorName


--retuning the word
    RETURN @Ret
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION  [Utility.NLP].[fnPorterStep1]
	(
		@InWord nvarchar(4000)
	)
RETURNS nvarchar(4000)
AS
BEGIN

    DECLARE @Ret nvarchar(4000)
    DECLARE @Phrase1 NVARCHAR(15), @Phrase2 NVARCHAR(15)
    DECLARE @CursorName CURSOR

    -- DO some initial cleanup
    SELECT @Ret = @InWord

/*STEP 1A

    SSES -> SS                         caresses  ->  caress
    IES  -> I                          ponies    ->  poni
                                       ties      ->  ti
    SS   -> SS                         caress    ->  caress
    S    ->                            cats      ->  cat
*/
    -- Create Cursor for Porter Step 1
    SET @CursorName = CURSOR FOR 
	SELECT phrase1, phrase2 FROM  [Utility.NLP].ParsePorterStemming WHERE Step = 1 AND RIGHT(@Ret ,LEN(Phrase1)) = Phrase1
		ORDER BY Ordering
    OPEN @CursorName

    -- Do Step 1
    FETCH NEXT FROM @CursorName INTO @Phrase1, @Phrase2
    WHILE @@FETCH_STATUS = 0 
	BEGIN
	    --IF RIGHT(@Ret ,LEN(@Phrase1)) = @Phrase1
		BEGIN
		    SELECT @Ret = LEFT(@Ret, LEN(@Ret) - LEN(@Phrase1)) + @Phrase2
		    BREAK
		END
	    FETCH NEXT FROM @CursorName INTO @Phrase1, @Phrase2
        END
    -- Free Resources
    CLOSE @CursorName
    DEALLOCATE @CursorName

--STEP 1B
--
--   If
--       (m>0) EED -> EE                     feed      ->  feed
--                                           agreed    ->  agree
--   Else
--       (*v*) ED  ->                        plastered ->  plaster
--                                           bled      ->  bled
--       (*v*) ING ->                        motoring  ->  motor
--                                           sing      ->  sing
--
--If the second or third of the rules in Step 1b is successful, the following
--is done:
--
--    AT -> ATE                       conflat(ed)  ->  conflate
--    BL -> BLE                       troubl(ed)   ->  trouble
--    IZ -> IZE                       siz(ed)      ->  size
--    (*d and not (*L or *S or *Z))
--       -> single letter
--                                    hopp(ing)    ->  hop
--                                    tann(ed)     ->  tan
--                                    fall(ing)    ->  fall
--                                    hiss(ing)    ->  hiss
--                                    fizz(ed)     ->  fizz
--    (m=1 and *o) -> E               fail(ing)    ->  fail
--                                    fil(ing)     ->  file
--
--The rule to map to a single letter causes the removal of one of the double
--letter pair. The -E is put back on -AT, -BL and -IZ, so that the suffixes
---ATE, -BLE and -IZE can be recognised later. This E may be removed in step
--4.

--declaring local variables
DECLARE @m tinyint, @Temp nvarchar(4000),@second_third_success bit

--initializing 
SELECT @second_third_success = 0

--(m>0) EED -> EE..else..(*v*) ED  ->(*v*) ING  ->
    IF RIGHT(@Ret ,LEN(N'eed')) = N'eed'
	BEGIN
	    --counting the number of m--s
	    SELECT @temp = LEFT(@Ret, LEN(@Ret) - LEN(N'eed'))
	    SELECT @m =  [Utility.NLP].fnPorterCountm(@temp)

    	    If @m > 0
                SELECT @Ret = LEFT(@Ret, LEN(@Ret) - LEN(N'eed')) + N'ee' 
	END
    ELSE IF RIGHT(@Ret ,LEN(N'ed')) = N'ed'
	BEGIN
	    --trim and check for vowel
	    SELECT @temp = LEFT(@Ret, LEN(@Ret) - LEN(N'ed'))
	    If  [Utility.NLP].fnPorterContainsVowel(@temp) = 1
		SELECT @ret = LEFT(@Ret, LEN(@Ret) - LEN(N'ed')), @second_third_success = 1
	END
    ELSE IF RIGHT(@Ret ,LEN(N'ing')) = N'ing'
	BEGIN
	    --trim and check for vowel
	    SELECT @temp = LEFT(@Ret, LEN(@Ret) - LEN(N'ing'))
	    If  [Utility.NLP].fnPorterContainsVowel(@temp) = 1
		SELECT @ret = LEFT(@Ret, LEN(@Ret) - LEN(N'ing')), @second_third_success = 1
	END

--If the second or third of the rules in Step 1b is SUCCESSFUL, the following
--is done:
--
--    AT -> ATE                       conflat(ed)  ->  conflate
--    BL -> BLE                       troubl(ed)   ->  trouble
--    IZ -> IZE                       siz(ed)      ->  size
--    (*d and not (*L or *S or *Z))
--       -> single letter
--                                    hopp(ing)    ->  hop
--                                    tann(ed)     ->  tan
--                                    fall(ing)    ->  fall
--                                    hiss(ing)    ->  hiss
--                                    fizz(ed)     ->  fizz
--    (m=1 and *o) -> E               fail(ing)    ->  fail
--                                    fil(ing)     ->  file


IF @second_third_success = 1              --If the second or third of the rules in Step 1b is SUCCESSFUL
    BEGIN        
    	IF RIGHT(@Ret ,LEN(N'at')) = N'at'	--AT -> ATE
	    SELECT @ret = LEFT(@Ret, LEN(@Ret) - LEN(N'at')) + N'ate'
    	ELSE IF RIGHT(@Ret ,LEN(N'bl')) = N'bl'	--BL -> BLE
	    SELECT @ret = LEFT(@Ret, LEN(@Ret) - LEN(N'bl')) + N'ble'
    	ELSE IF RIGHT(@Ret ,LEN(N'iz')) = N'iz'	--IZ -> IZE
	    SELECT @ret = LEFT(@Ret, LEN(@Ret) - LEN(N'iz')) + N'ize'
    	ELSE IF  [Utility.NLP].fnPorterEndsDoubleConsonant(@Ret) = 1  /*(*d and not (*L or *S or *Z))-> single letter*/
	    BEGIN
		IF CHARINDEX(RIGHT(@Ret,1), N'lsz') = 0
		    SELECT @ret = LEFT(@Ret, LEN(@Ret) - 1)
            END
	ELSE IF  [Utility.NLP].fnPorterCountm(@Ret) = 1        /*(m=1 and *o) -> E */
	    BEGIN
	       	IF  [Utility.NLP].fnPorterEndsDoubleCVC(@Ret) = 1
                   SELECT @ret = @Ret + N'e'
            END
    END
    
----------------------------------------------------------------------------------------------------------
--
--STEP 1C
--
--    (*v*) Y -> I                    happy        ->  happi
--                                    sky          ->  sky
IF RIGHT(@Ret ,LEN(N'y')) = N'y'
    BEGIN        
        --trim and check for vowel
        SELECT @temp = LEFT(@Ret, LEN(@Ret)-1)
        IF  [Utility.NLP].fnPorterContainsVowel(@temp) = 1
	    SELECT @ret = LEFT(@Ret, LEN(@Ret) - 1) + N'i'
    END

    RETURN @Ret
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE  function [Profile.Data].[fnPublication.Person.GetPublications](@UserID INT)
RETURNS  @p  TABLE(
										RowNum VARCHAR(10),
										Reference NVARCHAR(MAX),
										FromPubMed BIT,
										PubId NVARCHAR(50),
										pmid INT,
										mpid VARCHAR(50),
										category NVARCHAR(60),
										url			VARCHAR(1000),
									  pubdate DATETIME
									)
AS
BEGIN
DECLARE  @encode_html INT,
@pubmed_url VARCHAR(200)
declare @dash_url varchar(max)
select @dash_url = ISNULL('http://dash.harvard.edu/handle/1/',''),
			@pubmed_url='http://www.ncbi.nlm.nih.gov/pubmed/'
SELECT @encode_html = 0;
 
WITH cte
		 AS (SELECT CONVERT(VARCHAR,ROW_NUMBER() OVER(ORDER BY publication_dt desc, publications)) + '. ' AS rownum,
								publications,
								frompubmed,
								pubid,
								pmid,
								mpid,
								category,
								url,publication_dt
					 FROM (SELECT  DISTINCT 
												 p.pmid,
												 NULL                                              AS mpid,
													[Profile.Cache].[fnPublication.Pubmed.General2Reference]	(p.pmid ,ArticleDay,ArticleMonth,ArticleYear,ArticleTitle,Authors,AuthorListCompleteYN,Issue,JournalDay,JournalMonth,JournalYear,MedlineDate,MedlinePgn,MedlineTA,Volume,0) AS publications,
												 1                                                 AS frompubmed,
												 [Profile.Data].[fnPublication.Pubmed.GetPubDate]( MedlineDate,JournalYear,JournalMonth,JournalDay,ArticleYear,ArticleMonth,ArticleDay)                                           AS publication_dt,
												 pubid,
												 NULL                                              category,
												 @pubmed_url + CAST(ISNULL(p.pmid,'') AS VARCHAR(20))	     url,
												 'PubMed'										   sourcename
									 FROM [Profile.Data].[Publication.Person.Include] i    
									 JOIN [Profile.Data].[Publication.PubMed.General] p ON i.pmid = p.pmid
									WHERE  i.personid = @UserID
									  AND p.pmid IS NOT NULL
								 UNION ALL
								 SELECT  DISTINCT 
												 m.pmid,
												 m.mpid,
												 --dbo.fn_GetPublicationReference(m.mpid,'mpid',1)	AS Publications			,
 	
				 (SELECT authors + 
																(CASE 
																	WHEN url <> ''
																			 AND article <> ''
																			 AND pub <> '' THEN url + article + '</a>. ' + pub + '. '
																	WHEN url <> ''
																			 AND article <> '' THEN url + article + '</a>. '
																	WHEN url <> ''
																			 AND pub <> '' THEN url + pub + '</a>. '
																	WHEN article <> ''
																			 AND pub <> '' THEN article + '. ' + pub + '. '
																	WHEN article <> '' THEN article + '. '
																	WHEN pub <> '' THEN pub + '. '
																	ELSE ''
																END) + 
																y + 
															 (CASE 
																	 WHEN y <> ''
																				AND vip <> '' THEN '; '
																	 ELSE ''
																END) + 
																vip + 
																(CASE 
																	WHEN y <> ''
																				OR vip <> '' THEN '.'
																	ELSE ''
																END)
													FROM (SELECT url,
																			 (CASE 
																					WHEN authors = '' THEN ''
																					WHEN RIGHT(authors,1) = '.' THEN LEFT(authors,LEN(authors) - 1)
																					ELSE authors
																				END) authors,
																			 (CASE 
																					WHEN article = '' THEN ''
																					WHEN RIGHT(article,1) = '.' THEN LEFT(article,LEN(article) - 1)
																					ELSE article
																				END) article,
																			 (CASE 
																					WHEN pub = '' THEN ''
																					WHEN RIGHT(pub,1) = '.' THEN LEFT(pub,LEN(pub) - 1)
																					ELSE pub
																				END) pub,
																			 y,
																			 vip,
																			 frompubmed,
																			 publicationdt
														       		  FROM (SELECT ( 		case													WHEN RTRIM(LTRIM(COALESCE(authors,''))) = '' THEN ''
																									WHEN RIGHT(COALESCE(authors,''),1) = '.' THEN COALESCE(authors,'') + ' '
																									ELSE COALESCE(authors,'') + '. '
																								END) authors,
																							 (CASE 
																									WHEN COALESCE(url,'') <> ''
																											 AND LEFT(COALESCE(url,''),4) = 'http' THEN '<a href="' + url + '" target="_blank">'
																									WHEN COALESCE(url,'') <> '' THEN '<a href="http://' + url + '" target="_blank">'
																									ELSE ''
																								END) url,
																							 LTRIM(RTRIM(COALESCE(articletitle,'')))     article,
																							 LTRIM(RTRIM(COALESCE(pubtitle,'')))         pub,
																							 (CASE 
																									WHEN publicationdt > '1/1/1901' THEN CONVERT(VARCHAR(50),YEAR(publicationdt))
																									ELSE ''
																								END) y,
																							 COALESCE(volnum,'') + 
																							(CASE 
																									WHEN COALESCE(issuepub,'') <> '' THEN '(' + issuepub + ')'
																									ELSE ''
																								END) +	
																							(CASE 
																								WHEN (COALESCE(paginationpub,'') <> '') AND (COALESCE(volnum,'') + COALESCE(issuepub,'') <> '') THEN ':'
																								ELSE ''
																						  END) + 
																							COALESCE(paginationpub,'') vip,
																							0                                           AS frompubmed,
																							publicationdt
																			FROM		[Profile.Data].[Publication.MyPub.General] m2
																	   WHERE		m2.mpid = m.mpid) t) 
																 t) AS publications,
																 0,
																 publicationdt,
																 pubid,
																 hmspubcategory,
																 url,
																'Custom'										   sourcename
									FROM [Profile.Data].[Publication.MyPub.General] m
								    JOIN [Profile.Data].[Publication.Person.Include] i 	ON i.mpid = m.mpid
			 
 WHERE m.personid = @UserID	
								     AND i.mpid IS NOT NULL
								     AND i.mpid NOT LIKE 'DASH%'
								     AND i.mpid NOT LIKE 'ISI%'
								     AND i.pmid IS NULL 
									UNION ALL 
									SELECT		null as pmid, 
										p.mpid,
										g.BibliographicCitation publications, 
										0 as FromPubMed, 
										m.publicationdt,
										pubid,
										m.hmspubcategory,
										@dash_url+cast(g.dashid as varchar(10)) url,
										'DASH' sourcename
									FROM	[Profile.Data].[Publication.MyPub.General] m, [Profile.Data].[Publication.Person.Include] p, [Profile.Data].[Publication.DSpace.MPID] d, [Profile.Data].[Publication.DSpace.PubGeneral] g
									WHERE	p.personid = @UserID
										and m.mpid = p.mpid
										and p.mpid is not null and p.pmid is null
										and p.mpid like 'DASH%' 
										and p.mpid = d.mpid and d.dashid = g.dashid
									UNION ALL
									SELECT 
										null as pmid, 
										p.mpid,
										(g.authors + '. ' 
										+ g.itemtitle + (case when right(g.itemtitle,1) not in ('.','?','!') then '. ' else ' ' end) 
										+ coalesce(g.sourceabbrev, g.sourcetitle) 
										+ '. ' + g.bibid + '.')
										publications,
										0 as FromPubMed, 
										m.publicationdt,
										pubid,
										m.hmspubcategory,
										'http://dx.doi.org/' + doi url,
										'DOI' sourcename
									FROM [Profile.Data].[Publication.MyPub.General] m,[Profile.Data].[Publication.Person.Include] p, [Profile.Data].[Publication.ISI.MPID] d, [Profile.Data].[Publication.ISI.PubGeneral] g
									where p.personid = @UserID
										and m.mpid = p.mpid
										and p.mpid is not null and p.pmid is null
										and p.mpid like 'ISI%' 
										and p.mpid = d.mpid and d.recid = g.recid
		 			     
								    ) t)
INSERT INTO @p
SELECT * 
	FROM cte
 ORDER BY CONVERT(INT,REPLACE(rownum,'.',''))
 
RETURN
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [Utility.NLP].[fnPorterAlgorithm]
	(
		@InWord nvarchar(4000)
	)
RETURNS nvarchar(4000)
AS
BEGIN
    DECLARE @Ret nvarchar(4000), @Temp nvarchar(4000)

    -- DO some initial cleanup
    SELECT @Ret = LOWER(ISNULL(RTRIM(LTRIM(@InWord)),N''))

    -- only strings greater than 2 are stemmed
    IF LEN(@Ret) > 2
	BEGIN
	    SELECT @Ret = [Utility.NLP].fnPorterStep1(@Ret)
	    SELECT @Ret = [Utility.NLP].fnPorterStep2(@Ret)
	    SELECT @Ret = [Utility.NLP].fnPorterStep3(@Ret)
	    SELECT @Ret = [Utility.NLP].fnPorterStep4(@Ret)
	    SELECT @Ret = [Utility.NLP].fnPorterStep5(@Ret)
	END

--End of Porter's algorithm.........returning the word
    RETURN @Ret
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create FUNCTION [Utility.NLP].[fnNormalizeSplitStem]
	(
		@InWord nvarchar(4000)
	)
RETURNS 
	@words table (
		word varchar(255),word2 varchar(255)
	)
AS
BEGIN

	insert into @words (word,word2)
		select distinct [Utility.NLP].fnPorterAlgorithm(nref.value('.','varchar(max)')) word,nref.value('.','varchar(max)')  word2 
		from (
			select cast(replace(
				'<x><w>'+replace([Utility.NLP].fnNormalize(@InWord),' ','</w><w>')+'</w></x>',
				'<w></w>','') as xml) x
		) t
		cross apply x.nodes('//w') as R(nref)

    RETURN
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create function [Utility.NLP].[fnQuoteNormalizeSplitStem]
	(
		@InWord nvarchar(4000)
	)
RETURNS 
	@words table (
	phrase int,
		plen int,
		wpos int,
		word varchar(255),
		phrasestr varchar(2000)
	)
 AS
 BEGIN

    DECLARE @Temp nvarchar(4000)
	DECLARE @str nvarchar(4000)
	DECLARE @i int
	DECLARE @c varchar(1)
	DECLARE @q int
	DECLARE @phrases table (
		phrase int identity(0,1),
		phrasestr varchar(4000),
		quoted int
	)
	DECLARE @w table (
		phrase int,
		wpos int identity(0,1),
		word varchar(255),
		quoted int,
		phrasestr varchar(2000)
	)

    SELECT @Temp = ISNULL(RTRIM(LTRIM(@InWord)),N'')

	SET @str = ''
	SET @i = 1
	SET @q = 0

	WHILE @i <= LEN(@Temp)
	BEGIN
		SET @c = (select substring(@Temp,@i,1))
		IF (@c = '"')
		BEGIN
			INSERT INTO @phrases (phrasestr, quoted) VALUES (@str, @q)
			SET @q = 1 - @q
			SET @str = ''
		END
		ELSE
		BEGIN
			SET @str = @str + @c
		END
		SET @i = @i + 1
	END
	INSERT INTO @phrases (phrasestr, quoted) VALUES (@str, @q)

	DELETE FROM @phrases WHERE phrasestr = ''

 
 
	insert into @w (phrase, word, quoted,phrasestr)
		select phrase, word, quoted,CASE WHEN quoted=1 THEN ltrim(rtrim(phrasestr))ELSE word2 END
		from @phrases cross apply [Utility.NLP].fnNormalizeSplitStem(phrasestr)
		where word not in ('and');
 
	;with w as (
		select phrase, (row_number() over (partition by phrase order by wpos)) - 1 wpos, word, phrasestr
		from (
			select word, wpos, (dense_rank() over (order by k)) - 1 phrase,phrasestr
			from (
				select phrase + (case when quoted = 1 then 0 else wpos/10000.0 end) k, * from @w
			) t
		) t
	)
	insert into @words (phrase, plen, wpos, word,phrasestr)
		select w.phrase, v.plen, w.wpos, w.word ,phrasestr
		from w, (select phrase, count(*) plen from w group by phrase) v
		where w.phrase = v.phrase

    RETURN
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [RDF.].[fnNodeID2TypeID] (
	@NodeID	bigint
) 
RETURNS nvarchar(200)
AS
BEGIN
	DECLARE @result nvarchar(200)

	declare @typeID bigint
	select @typeID = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')

	select @result = coalesce(@result + ',', '') + cast(Object as nvarchar(10))  from [RDF.].Triple where subject=@NodeID and predicate=@typeID order by Object
	RETURN @result
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [Profile.Data].[fnPublication.Pubmed.ShortenAuthorLengthString](@strInput VARCHAR(max)) 
RETURNS VARCHAR(MAX)
AS
BEGIN
		select @strInput = substring(@strInput,3,len(@strInput))
		return case	when len(@strInput) < 3990 then @strInput
					when charindex(',',reverse(left(@strInput,3990)))>0 then
						left(@strInput,3990-charindex(',',reverse(left(@strInput,3990))))+', et al'
					else left(@strInput,3990)
					end
END
GO

SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE FUNCTION [Profile.Data].[fnPublication.MyPub.HighlightAuthors]	(
	@Authors varchar(max),
	@FirstName varchar(50),
	@Middlename varchar(50),
	@LastName varchar(50)
)
RETURNS NVARCHAR(MAX) 
AS 
BEGIN

	DECLARE @highlightedAuthors NVARCHAR(MAX)

	if @Authors like '%' + @LastName  + ' '+ SUBSTRING(@FirstName, 1, 1) + isnull(SUBSTRING(@Middlename, 1, 1), '') + '%'
		SET @highlightedAuthors = replace(@Authors, @LastName  + ' '+ SUBSTRING(@FirstName, 1, 1) + isnull(SUBSTRING(@Middlename, 1, 1), ''), '<b>' + @LastName + ' ' + SUBSTRING(@FirstName, 1, 1) + case when @Middlename = '' then '' else isnull(SUBSTRING(@Middlename, 1, 1), '') end + '</b>')

	else if @Authors like '%' + @LastName  + ' '+ SUBSTRING(@FirstName, 1, 1) + ',%' 
		SET @highlightedAuthors = replace(@Authors, @LastName  + ' '+ SUBSTRING(@FirstName, 1, 1) + ',', '<b>' + @LastName + ' ' + SUBSTRING(@FirstName, 1, 1) + '</b>,')

	else if @Authors like '%' + @LastName  + ' '+ SUBSTRING(@FirstName, 1, 1)
		SET @highlightedAuthors = SUBSTRING(@Authors, 1, len(@authors) - len (@Lastname) - 2) + '<b>' + @LastName  + ' '+ SUBSTRING(@FirstName, 1, 1) + '</b>'

	RETURN @highlightedAuthors

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Framework.].[vwBufferObjects] AS
	SELECT OBJECT_SCHEMA_NAME(t.object_id) SchemaName, OBJECT_NAME(t.object_id) ObjectName, i.name IndexName, 
			i.type_desc IndexType, t.BufferPageCount/128.0 BufferMB, t.BufferPageCount, t.object_id, t.index_id
		FROM (
				SELECT p.object_id, p.index_id, count(*) BufferPageCount
				FROM sys.dm_os_buffer_descriptors b
					INNER JOIN sys.allocation_units a
						ON b.allocation_unit_id = a.allocation_unit_id
					INNER JOIN sys.partitions p
						ON a.container_id = p.hobt_id
				WHERE b.database_id = db_id()
				GROUP BY p.object_id, p.index_id
			) t
			LEFT OUTER JOIN sys.indexes i
				ON i.object_id = t.object_id AND i.index_id = t.index_id
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Framework.].[vwBufferDatabases] AS
	SELECT (CASE WHEN database_id = 32767 THEN 'ResourceDb' ELSE DB_NAME(database_id) END) DatabaseName, 
			BufferPageCount/128.0 BufferMB, BufferPageCount, database_id
		FROM (
			SELECT database_id, count(*) BufferPageCount
			FROM sys.dm_os_buffer_descriptors
			GROUP BY database_id
		) t
	--DBCC FREEPROCCACHE
	--DBCC DROPCLEANBUFFERS
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Framework.].[vwDatabaseObjects] AS
	SELECT o.type, o.type_desc, '['+s.name+'].['+o.name+']' full_name, s.name schema_name, o.name, 
			o.object_id, o.principal_id, o.schema_id, o.parent_object_id, 
			o.create_date, o.modify_date, o.is_ms_shipped, o.is_published, o.is_schema_published
		FROM sys.objects o, sys.schemas s
		WHERE o.schema_id = s.schema_id
	UNION ALL
	SELECT '@', 'SCHEMA', '['+name+']', name, name,
			NULL, principal_id, schema_id, null, 
			null, null, null, null, null
		FROM sys.schemas
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [RDF.SemWeb].[vwPublic_Entities] AS
	SELECT NodeID id, value
	FROM [RDF.].Node
	WHERE ObjectType = 0 AND ViewSecurityGroup = -1
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Profile.Data].[vwPublication.Entity.Authorship]
AS
SELECT EntityID, EntityName, EntityDate, authorRank, numberOfAuthors, authorNameAsListed, authorWeight, authorPosition, PubYear, YearWeight, PersonID, InformationResourceID, SummaryXML, IsActive
	FROM [Profile.Data].[Publication.Entity.Authorship]
	WHERE IsActive = 1
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [RDF.SemWeb].[vwPublic_Statements] AS
	SELECT t.subject, t.predicate, t.objecttype, t.object, 1 meta
	FROM [RDF.].Triple t, [RDF.].Node s, [RDF.].Node p, [RDF.].Node o
	WHERE t.ViewSecurityGroup = -1
		AND t.Subject=s.NodeID AND t.Predicate=p.NodeID AND t.Object=o.NodeID
		AND s.ViewSecurityGroup = -1 AND p.ViewSecurityGroup = -1 AND o.ViewSecurityGroup = -1
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Framework.].[vwDatabaseCode] AS
	SELECT o.type, o.type_desc, o.full_name, 
		o.object_id, o.create_date, o.modify_date,
		c.number, c.colid, c.text,
		o.schema_name, o.name,
		o.principal_id, o.schema_id, o.parent_object_id,
		o.is_ms_shipped, o.is_published, o.is_schema_published
	FROM [Framework.].vwDatabaseObjects o, syscomments c
	WHERE c.id = o.object_id
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE    view [Profile.Cache].[vwConcept.Mesh.Person]
with schemabinding
as
SELECT meshheader,
			 personid,
			 MAX(ISNULL(numpubsall,0))numpubsall,
			 MAX(ISNULL(NumPubsThis,0))NumPubsThis,
			 SUM(ISNULL(TopicWeight,0))TopicWeight,
			 SUM(ISNULL(AuthorWeight,0))AuthorWeight,
			 SUM(ISNULL(YearWeight,0))YearWeight,
			 MAX(ISNULL(UniquenessWeight,0))UniquenessWeight,
			 MAX(ISNULL(MeshWeight,0))MeshWeight,
			 COUNT_BIG(*)countbig
from [Profile.Cache].[Concept.Mesh.PersonPublication]
group by meshheader,
			 personid
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [RDF.SemWeb].[vwPrivate_Entities] AS
	SELECT NodeID id, Value value
	FROM [RDF.].Node
	WHERE ObjectType = 0
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create view [Profile.Data].[vwPerson.SecurityGroup]
as
select p.PersonID, p.IsActive, p.Visible, u.UserID, m.NodeID,
	(case	when p.IsActive = 1 and p.Visible = 1 then -1
			when p.IsActive = 1 then IsNull(m.NodeID,-40)
			else -50 end) ViewSecurityGroup,
	(case	when p.IsActive = 1 then IsNull(m.NodeID,-40)
			else -50 end) EditSecurityGroup
from [Profile.Data].Person p 
	left outer join [User.Account].[User] u
		on p.PersonID = u.PersonID
	left outer join [RDF.Stage].InternalNodeMap m
		on m.Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#User' and m.InternalType = 'User' and m.InternalID = cast(u.UserID as varchar(50))
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [RDF.SemWeb].[vwHash2Base64]
	AS
	SELECT NodeID, SemWebHash
		FROM [RDF.SemWeb].[Hash2Base64]

	/*

	-- This version of the view allows truncation / modification to [RDF.].Node	
	AS
	SELECT NodeID, [RDF.SemWeb].[fnHash2Base64](ValueHash) SemWebHash
		FROM [RDF.].Node

	-- This version of the view allows indexes
	WITH SCHEMABINDING
	AS
	SELECT NodeID, [RDF.SemWeb].[fnHash2Base64](ValueHash) SemWebHash
		FROM [RDF.].Node
	
	--Run after creating this view
	CREATE UNIQUE CLUSTERED INDEX [idx_SemWebHash] ON [RDF.SemWeb].[vwHash2Base64]([SemWebHash] ASC)
	CREATE UNIQUE NONCLUSTERED INDEX [idx_NodeID] ON [RDF.SemWeb].[vwHash2Base64]([NodeID] ASC)

	*/

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [RDF.SemWeb].[vwPrivate_Statements] AS
	SELECT t.subject, t.predicate, t.objecttype, t.object, 1 meta
	FROM [RDF.].Triple t
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Profile.Data].[vwPublication.Entity.InformationResource]
AS
SELECT EntityID, PMID, MPID, EntityName, EntityDate, Reference, Source, URL, PubYear, YearWeight, SummaryXML, IsActive
	FROM [Profile.Data].[Publication.Entity.InformationResource]
	WHERE IsActive = 1
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE view [RDF.].[vwTripleValue] as
	select t.TripleID, t.ViewSecurityGroup, t.Subject, t.Predicate, t.Object, t.TripleHash, 
		t.SortOrder, t.Weight, t.Reitification, 
		s.value SubjectValue, p.value PredicateValue, 
		o.value ObjectValue, o.Language, o.DataType, 
		s.ViewSecurityGroup sViewSecurityGroup, p.ViewSecurityGroup pViewSecurityGroup, o.ViewSecurityGroup oViewSecurityGroup
	from [RDF.].Triple t, [RDF.].Node s, [RDF.].Node p, [RDF.].Node o
	where t.subject=s.nodeid and t.predicate=p.nodeid and t.object=o.nodeid
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [RDF.].[vwBigDataTriple] AS
SELECT    
'<' + s.VALUE + '> ' + 
'<' + p.value + '> ' + 
CASE WHEN o.objecttype = 1 THEN  REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(o.VALUE,'\','\\'),'"','\"'),CHAR(10),'\n'),CHAR(13),'\r'),CHAR(9),'\t')    
	 else '<'  + o.value + '>' end
+ ' .' + CHAR(13) + CHAR(10) triple
FROM [RDF.].Triple t, [RDF.].Node s, [RDF.].Node p, [RDF.].Node o
WHERE t.subject=s.nodeid AND t.predicate=p.nodeid AND t.object=o.nodeid
AND s.ViewSecurityGroup  =-1 AND  p.ViewSecurityGroup =-1  and o.ViewSecurityGroup =-1 AND t.ViewSecurityGroup =-1
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE view [Profile.Data].[vwPerson.Affiliation] as
	select PersonAffiliationID,
		a.PersonID,
		a.SortOrder,
		a.IsActive,
		a.IsPrimary,
		a.InstitutionID,
		a.DepartmentID,
		a.DivisionID,
		coalesce(a.Title,'') Title,
		coalesce(a.EmailAddress,'') EmailAddress,
		coalesce(i.InstitutionName,'') InstitutionName,
		coalesce(i.InstitutionAbbreviation,'') InstitutionAbbreviation, 
		coalesce(d.DepartmentName,'') DepartmentName, 
		coalesce(v.DivisionName,'') DivisionName 
	from [Profile.Data].[Person.Affiliation] a 
		left outer join [Profile.Data].[Organization.Institution] i on a.institutionid = i.institutionid 
		left outer join [Profile.Data].[Organization.Department] d on a.departmentid = d.departmentid 
		left outer join [Profile.Data].[Organization.Division] v on a.divisionid = v.divisionid
	where a.IsActive = 1
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE view [Profile.Data].[vwPerson]
as
		SELECT p.personid,
					 p.userid,
					 p.internalusername,
					 p.firstname,
					 p.lastname,
					 p.displayname, 
					 CASE WHEN ISNULL(dp.ShowAddress,'Y')='Y' THEN p.addressline1 END addressline1,
					 CASE WHEN ISNULL(dp.ShowAddress,'Y')='Y' THEN p.addressline2 END addressline2,
					 CASE WHEN ISNULL(dp.ShowAddress,'Y')='Y' THEN p.addressline3 END addressline3,
					 CASE WHEN ISNULL(dp.ShowAddress,'Y')='Y' THEN p.addressline4 END addressline4,
					 CASE WHEN ISNULL(dp.ShowAddress,'Y')='Y' THEN p.addressstring END addressstring, 
					 CASE WHEN ISNULL(dp.ShowAddress,'Y')='Y' THEN  p.building END building,
					 CASE WHEN ISNULL(dp.ShowAddress,'Y')='Y' THEN  p.room END room,
					 CASE WHEN ISNULL(dp.ShowAddress,'Y')='Y' THEN  p.floor END floor, 
					 CASE WHEN ISNULL(dp.ShowAddress,'Y')='Y' THEN  p.latitude END latitude, 
					 CASE WHEN ISNULL(dp.ShowAddress,'Y')='Y' THEN  p.longitude END longitude,
					 CASE WHEN ISNULL(dp.ShowAddress,'Y')='Y' THEN p.phone END phone,
					 CASE WHEN ISNULL(dp.ShowAddress,'Y')='Y' THEN p.fax END fax,  
					 CASE WHEN ISNULL(dp.ShowEmail,'Y') = 'Y' THEN p.emailaddr END emailaddr,
					 i2.institutionname,
					 i2.institutionabbreviation, 
					 de.departmentname,
					 dv.divisionname,  
					 A.facultyrank, 
					 A.facultyranksort, 
					 p.isactive,
					 ISNULL(dp.ShowAddress,'Y')ShowAddress,
					 ISNULL(dp.ShowPhone,'Y')ShowPhone,
					 ISNULL(dp.Showfax,'Y')Showfax,
					 ISNULL(dp.ShowEmail,'Y')ShowEmail,
					 ISNULL(dp.ShowPhoto,'N')ShowPhoto,
					 ISNULL(dp.ShowAwards,'N')ShowAwards,
					 ISNULL(dp.ShowNarrative,'N')ShowNarrative,
					 ISNULL(dp.ShowPublications,'Y')ShowPublications, 
					 ISNULL(p.visible,1)visible,
					 0 numpublications
			FROM [Profile.Data].Person p
 LEFT JOIN [Profile.Cache].Person ps				 ON ps.personid = p.personid
 LEFT JOIN [Profile.Data].[Person.Affiliation] pa				 ON pa.personid = p.personid
																				AND pa.isprimary=1 
 LEFT JOIN [Profile.Data].[Organization.Institution] i2				 ON pa.institutionid = i2.institutionid 
 LEFT JOIN [Profile.Data].[Organization.Department] de				 ON de.departmentid = pa.departmentid
 LEFT JOIN [Profile.Data].[Organization.Division] dv				 ON dv.divisionid = pa.divisionid
 LEFT JOIN [Profile.Import].[Beta.DisplayPreference] dp on dp.PersonID=p.PersonID 
 OUTER APPLY(SELECT TOP 1 facultyrank ,facultyranksort from [Profile.Data].[Person.Affiliation] pa JOIN [Profile.Data].[Person.FacultyRank] fr on fr.facultyrankid = pa.facultyrankid  where personid = p.personid order by facultyranksort asc)a
 WHERE p.isactive = 1
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Ontology.Import].[vwOwlTriple] AS
	WITH xmlnamespaces (
		'http://aims.fao.org/aos/geopolitical.owl#' AS geo,
		'http://www.w3.org/2004/02/skos/core#' AS skco,
		'http://purl.org/NET/c4dm/event.owl#' AS event,
		'http://vivoweb.org/ontology/provenance-support#' AS pvs,
		'http://purl.org/dc/elements/1.1/' AS dcelem,
		'http://www.w3.org/2006/12/owl2-xml#' AS owl2,
		'http://vivoweb.org/ontology/scientific-research-resource#' AS scirr,
		'http://vivoweb.org/ontology/core#' AS vivo,
		'http://purl.org/vocab/vann/' AS vann,
		'http://vitro.mannlib.cornell.edu/ns/vitro/0.7#' AS vitro,
		'http://www.w3.org/2008/05/skos#' AS skos,
		'http://www.w3.org/1999/02/22-rdf-syntax-ns#' AS rdf,
		'http://jena.hpl.hp.com/ARQ/function#' AS afn,
		'http://purl.org/ontology/bibo/' AS bibo,
		'http://xmlns.com/foaf/0.1/' AS foaf,
		'http://www.w3.org/2003/06/sw-vocab-status/ns#' AS swvs,
		'http://www.w3.org/2002/07/owl#' AS owl,
		'http://purl.org/dc/terms/' AS dcterms,
		'http://www.w3.org/2001/XMLSchema#' AS xsd,
		'http://www.w3.org/2000/01/rdf-schema#' AS rdfs
	), d as (
		SELECT x.name OWL, x.Graph, d.query('.') d, isnull(d.value('@rdf:about','nvarchar(max)'),'http://profiles.catalyst.harvard.edu/ontology/nodeID#'+d.value('@rdf:nodeID','nvarchar(max)')) a
		FROM [Ontology.Import].[OWL] x CROSS APPLY data.nodes('//rdf:Description') AS R(d)
	)
	SELECT d.OWL,
		d.Graph,
		d.a Subject,
		d.d.value('namespace-uri((/rdf:Description/*[sql:column("n.n")])[1])','nvarchar(max)') 
				+ d.d.value('local-name((/rdf:Description/*[sql:column("n.n")])[1])','nvarchar(max)') Predicate,
		coalesce(d.d.value('(/rdf:Description/*[sql:column("n.n")]/@rdf:resource)[1]','nvarchar(max)'), 
				'http://profiles.catalyst.harvard.edu/ontology/nodeID#'
					+d.d.value('(/rdf:Description/*[sql:column("n.n")]/@rdf:nodeID)[1]','nvarchar(max)'), 
				d.d.value('(/rdf:Description/*[sql:column("n.n")])[1]','nvarchar(max)')) Object,
		d.d.value('count(rdf:Description/*)','nvarchar(max)') n, 
		n.n i
	FROM d, [Utility.Math].N n
	WHERE n.n between 1 and cast(d.d.value('count(rdf:Description/*)','nvarchar(max)') as int)
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create VIEW [Profile.Data].[vwPublication.Pubmed.Mesh.Descriptor]
AS
select pmid, descriptorname as MeshHeader, max(MajorTopicYN) MajorTopicYN
from [Profile.Data].[Publication.PubMed.Mesh]
group by pmid, descriptorname
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Profile.Data].[vwPublication.Entity.General] AS
		SELECT e.EntityID, g.MedlineTA, g.JournalTitle Journal, g.Authors
			FROM [Profile.Data].[vwPublication.Entity.InformationResource] e, [Profile.Data].[Publication.PubMed.General] g
			WHERE e.pmid = g.pmid AND e.pmid IS NOT NULL AND e.IsActive = 1
		UNION ALL
		SELECT e.EntityID, null MedlineTA, g.PubTitle Journal, g.Authors
			FROM [Profile.Data].[vwPublication.Entity.InformationResource] e, [Profile.Data].[Publication.MyPub.General] g
			WHERE e.mpid = g.mpid AND e.pmid IS NULL AND e.MPID IS NOT NULL AND e.IsActive = 1
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Profile.Data].[vwPublication.Entity.Concept.MinorTopicList] AS
	SELECT EntityID, SubjectAreaList
	FROM (
		SELECT e.EntityID, substring((
			SELECT '; '+t.DescriptorName
			FROM (
				SELECT m.DescriptorName
				FROM [Profile.Data].[Publication.PubMed.Mesh] m
				WHERE e.pmid = m.pmid
				GROUP BY m.DescriptorName
				HAVING MAX(MajorTopicYN)='N'
			) t
			ORDER BY t.DescriptorName
			FOR XML PATH(''), TYPE
			).value('(./text())[1]','nvarchar(max)'),3,99999) SubjectAreaList
		FROM [Profile.Data].[vwPublication.Entity.InformationResource] e
		WHERE e.IsActive = 1
	) t
	WHERE SubjectAreaList IS NOT NULL
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Profile.Data].[vwPublication.Entity.Concept.MajorTopicList] AS
	SELECT EntityID, SubjectAreaList
	FROM (
		SELECT e.EntityID, substring((
			SELECT '; '+t.DescriptorName
			FROM (
				SELECT m.DescriptorName
				FROM [Profile.Data].[Publication.PubMed.Mesh] m
				WHERE e.pmid = m.pmid
				GROUP BY m.DescriptorName
				HAVING MAX(MajorTopicYN)='Y'
			) t
			ORDER BY t.DescriptorName
			FOR XML PATH(''), TYPE
			).value('(./text())[1]','nvarchar(max)'),3,99999) SubjectAreaList
		FROM [Profile.Data].[vwPublication.Entity.InformationResource] e
		WHERE e.IsActive = 1
	) t
	WHERE SubjectAreaList IS NOT NULL
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Profile.Data].[vwPublication.Entity.Concept] AS
	SELECT t.EntityID, d.DescriptorUI, t.DescriptorName, hasSubjectAreaWeight, subjectAreaForWeight
	FROM (
		SELECT e.EntityID, m.DescriptorName,
			max(case when MajorTopicYN='N' then 0.25 else 1.0 end) hasSubjectAreaWeight,
			max(case when MajorTopicYN='N' then 0.25*e.YearWeight else e.YearWeight end) subjectAreaForWeight
		FROM [Profile.Data].[vwPublication.Entity.InformationResource] e, [Profile.Data].[Publication.PubMed.Mesh] m
		WHERE e.pmid = m.pmid AND e.pmid IS NOT NULL AND e.IsActive = 1
		GROUP BY e.EntityID, m.DescriptorName
	) t, [Profile.Data].[Concept.Mesh.Descriptor] d
	WHERE t.DescriptorName = d.DescriptorName
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE view [RDF.].[vwPropertyTall] as
	with a as (
		select s.Value Property, s.NodeID, s.NodeID PropertyNode
		from [RDF.].Triple t, [RDF.].Node s
		where t.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
			and (t.object = [RDF.].fnURI2NodeID('http://www.w3.org/2002/07/owl#DatatypeProperty')
					or t.object = [RDF.].fnURI2NodeID('http://www.w3.org/2002/07/owl#ObjectProperty')
				)
			and t.subject = s.NodeID
	), b as (
		select t.subject, v.object
		from [RDF.].Triple t, [RDF.].Triple v
		where t.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
			and t.object = [RDF.].fnURI2NodeID('http://www.w3.org/2002/07/owl#Restriction')
			and t.subject = v.subject
			and v.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2002/07/owl#onProperty')
	), c as (
		select *
			from a
		union
		select a.property, b.subject, b.object
			from a, b
			where a.NodeID = b.object
	), d as (
		select 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' Predicate
		union all select 'http://www.w3.org/2002/07/owl#minCardinality'
		union all select 'http://www.w3.org/2002/07/owl#maxCardinality'
		union all select 'http://www.w3.org/2000/01/rdf-schema#label'
		union all select 'http://www.w3.org/2000/01/rdf-schema#range'
		union all select 'http://www.w3.org/2002/07/owl#allValuesFrom'
		union all select 'http://www.w3.org/2002/07/owl#someValuesFrom'
		union all select 'http://www.w3.org/2000/01/rdf-schema#domain'
	), e as (
		select Predicate, [RDF.].fnURI2NodeID(Predicate) ActualPredicateNode
		from d
	), f as (
		select (case when Predicate in ('http://www.w3.org/2002/07/owl#allValuesFrom','http://www.w3.org/2002/07/owl#someValuesFrom')
					then 'http://www.w3.org/2000/01/rdf-schema#range' else Predicate end) Predicate,
				ActualPredicateNode,
				(case when Predicate in ('http://www.w3.org/2002/07/owl#allValuesFrom','http://www.w3.org/2002/07/owl#someValuesFrom')
					then [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#range') else ActualPredicateNode end) PredicateNode
		from e
	)
	select distinct c.Property, f.Predicate, n.Value, c.PropertyNode, f.PredicateNode, n.NodeID ValueNode
		from c, f, [RDF.].Triple t, [RDF.].Node n
		where t.subject = c.NodeID and t.predicate = f.ActualPredicateNode and t.object = n.NodeID
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE view [Ontology.].[vwPropertyTall] as
	with a as (
		select distinct Subject Property, cast(Subject as varbinary(max)) xProperty
			from [Ontology.Import].[Triple] b
			where Graph is not null
				and Predicate = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
				and Object in ('http://www.w3.org/2002/07/owl#DatatypeProperty','http://www.w3.org/2002/07/owl#ObjectProperty')
	), b as (
		select t.Subject Property, t.Predicate, t.Object Value, 
			t._SubjectNode PropertyNode, t._PredicateNode PredicateNode, t._ObjectNode ValueNode,
			a.xProperty
		from a, [Ontology.Import].[Triple] t
		where t.Graph is not null
			and a.xProperty = cast(t.Subject as varbinary(max))
	), c as (
		select m.Object Property, p.Predicate, p.Object Value,
				m._ObjectNode PropertyNode, p._PredicateNode PredicateNode, p._ObjectNode ValueNode,
				cast(m.Object as varbinary(max)) xProperty
			from [Ontology.Import].[Triple] t, [Ontology.Import].[Triple] m, [Ontology.Import].[Triple] p, a
			where t.Graph is not null
				and t.Predicate = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
				and t.Object = 'http://www.w3.org/2002/07/owl#Restriction'
				and m.Graph is not null
				and m.OWL = t.OWL
				and cast(m.Subject as varbinary(max)) = cast(t.Subject as varbinary(max))
				and m.Predicate = 'http://www.w3.org/2002/07/owl#onProperty'
				and p.Graph is not null
				and p.OWL = t.OWL
				and cast(p.Subject as varbinary(max)) = cast(t.Subject as varbinary(max))
				and not (p.Predicate = t.Predicate and p.Object = t.Object)
				and not (p.Predicate = m.Predicate and p.Object = m.Object)
				and cast(m.Object as varbinary(max)) = a.xProperty
	), d as (
		select * from b
		union all
		select * from c
	), e as (
		select distinct Property, 
			(case when Predicate in ('http://www.w3.org/2002/07/owl#someValuesFrom','http://www.w3.org/2002/07/owl#allValuesFrom') 
				then 'http://www.w3.org/2000/01/rdf-schema#range' 
				else Predicate end) Predicate,
			Value,
			PropertyNode,
			(case when Predicate in ('http://www.w3.org/2002/07/owl#someValuesFrom','http://www.w3.org/2002/07/owl#allValuesFrom') 
				then [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#range')
				else PredicateNode end) PredicateNode,
			ValueNode,
			xProperty
		from d
	)
	select Property, Predicate, Value, PropertyNode, PredicateNode, ValueNode
		from e
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [RDF.SemWeb].[vwPrivate_Literals] AS
	SELECT 0 id, 'ver:1'+char(10)+'guid:c8bcf60e1d354ebf9d8cecd5c02a2182'+char(10) value, null language, null datatype, null hash
	UNION ALL
	SELECT n.NodeID id, n.value, n.language, n.datatype, b.SemWebHash hash
		FROM [RDF.].Node n, [RDF.SemWeb].[vwHash2Base64] b --WITH (NOEXPAND)
		WHERE n.NodeID = b.NodeID AND n.ObjectType = 1
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Profile.Data].[vwPerson.Photo]
AS
SELECT p.*, m.NodeID PersonNodeID, v.NodeID UserNodeID, o.Value+'Modules/CustomViewPersonGeneralInfo/PhotoHandler.ashx?NodeID='+CAST(m.NodeID as varchar(50)) URI
FROM [Profile.Data].[Person.Photo] p
	INNER JOIN [RDF.Stage].[InternalNodeMap] m
		ON m.Class = 'http://xmlns.com/foaf/0.1/Person'
			AND m.InternalType = 'Person'
			AND m.InternalID = CAST(p.PersonID as varchar(50))
	INNER JOIN [User.Account].[User] u
		ON p.PersonID = u.PersonID
	INNER JOIN [RDF.Stage].[InternalNodeMap] v
		ON v.Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#User'
			AND v.InternalType = 'User'
			AND v.InternalID = CAST(u.UserID as varchar(50))
	INNER JOIN [Framework.].[Parameter] o
		ON o.ParameterID = 'baseURI';
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [RDF.].[vwClass] AS
	select Class, Label, ClassNode, LabelNode
		from (
			select s.Value Class, l.Value Label, s.NodeID ClassNode, l.NodeID LabelNode,
				row_number() over (partition by s.Value order by s.NodeID, l.NodeID) k
			from [RDF.].Triple t
				inner join [RDF.].Node s
					on t.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
						and t.object = [RDF.].fnURI2NodeID('http://www.w3.org/2002/07/owl#Class')
						and t.subject = s.NodeID
				left outer join [RDF.].Triple v
					on v.subject = t.subject
						and v.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')
				left outer join [RDF.].Node l
					on v.object = l.NodeID
		) t
		where k = 1
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- View
CREATE VIEW [RDF.SemWeb].[vwPublic_Literals] AS
	SELECT 0 id, 'ver:1'+char(10)+'guid:c8bcf60e1d354ebf9d8cecd5c02a2182'+char(10) value, null language, null datatype, null hash
	UNION ALL
	SELECT n.NodeID id, n.value, n.language, n.datatype, b.SemWebHash hash
		FROM [RDF.].Node n, [RDF.SemWeb].[vwHash2Base64] b --WITH (NOEXPAND)
		WHERE n.NodeID = b.NodeID AND n.ObjectType = 1 AND n.ViewSecurityGroup = -1
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create view [RDF.].[vwPropertyWide] as
	with x as (
		select * from [RDF.].vwPropertyTall
	)
	select b.Value Domain, a.Property, a.Value Type, c.Value Range, d.Value MinCardinality, e.Value MaxCardinality, f.Value Label
	from x a
		left outer join x b
			on a.Property = b.Property and b.Predicate = 'http://www.w3.org/2000/01/rdf-schema#domain'
		left outer join x c
			on a.Property = c.Property and c.Predicate = 'http://www.w3.org/2000/01/rdf-schema#range'
		left outer join x d
			on a.Property = d.Property and d.Predicate = 'http://www.w3.org/2002/07/owl#minCardinality'
		left outer join x e
			on a.Property = e.Property and e.Predicate = 'http://www.w3.org/2002/07/owl#maxCardinality'
		left outer join x f
			on a.Property = f.Property and f.Predicate = 'http://www.w3.org/2000/01/rdf-schema#label'
	where a.Predicate = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
		and a.Value in ('http://www.w3.org/2002/07/owl#DatatypeProperty','http://www.w3.org/2002/07/owl#ObjectProperty')
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create view [Ontology.].[vwPropertyWide] as
	with x as (
		select * from [Ontology.].vwPropertyTall
	)
	select b.Value Domain, a.Property, a.Value Type, c.Value Range, d.Value MinCardinality, e.Value MaxCardinality, f.Value Label
	from x a
		left outer join x b
			on a.Property = b.Property and b.Predicate = 'http://www.w3.org/2000/01/rdf-schema#domain'
		left outer join x c
			on a.Property = c.Property and c.Predicate = 'http://www.w3.org/2000/01/rdf-schema#range'
		left outer join x d
			on a.Property = d.Property and d.Predicate = 'http://www.w3.org/2002/07/owl#minCardinality'
		left outer join x e
			on a.Property = e.Property and e.Predicate = 'http://www.w3.org/2002/07/owl#maxCardinality'
		left outer join x f
			on a.Property = f.Property and f.Predicate = 'http://www.w3.org/2000/01/rdf-schema#label'
	where a.Predicate = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
		and a.Value in ('http://www.w3.org/2002/07/owl#DatatypeProperty','http://www.w3.org/2002/07/owl#ObjectProperty')
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create view [Ontology.].[vwMissingPropertyGroupProperty] as
	with a as (
		select max(SortOrder) StartID
		from [ontology.].PropertyGroupProperty
		where PropertyGroupURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#PropertyGroupOverview'
	), b as (
		select distinct Property
		from [RDF.].vwPropertyTall
		where Property not in (select PropertyURI from [ontology.].PropertyGroupProperty)
	)
	select 'http://profiles.catalyst.harvard.edu/ontology/prns#PropertyGroupOverview' PropertyGroupURI,
			Property PropertyURI,
			row_number() over (order by Property) + StartID SortOrder
		from a, b
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE view [Ontology.].[vwMissingClassProperty] as
	with a as (
		select max(ClassPropertyID) StartID
		from [Ontology.].ClassProperty
	), b as (
		select Class, min(HasType) HasType, min(HasLabel) HasLabel
		from (
			select Class, 0 HasType, 0 HasLabel
				from [RDF.].[vwClass]
				where Class not in (select class from [Ontology.].ClassProperty)
			union all
			select Class, 0 HasType, 1 HasLabel
				from [Ontology.].ClassProperty
				where Class not in (
					select Class 
					from [Ontology.].ClassProperty
					where Property = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' and NetworkProperty is null
				)
			union all
			select Class, 1 HasType, 0 HasLabel
				from [Ontology.].ClassProperty
				where Class not in (
					select Class 
					from [Ontology.].ClassProperty
					where Property = 'http://www.w3.org/2000/01/rdf-schema#label' and NetworkProperty is null
				)
			) t
		group by Class
	), c as (
		select Class, null NetworkProperty, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' Property, 0 IsDetail, null Limit, 1 IncludeDescription, 0 IncludeNetwork,
				0 SearchWeight,
				1 CustomDisplay, 0 CustomEdit, -1 ViewSecurityGroup, 
				-40 EditSecurityGroup,
				-40 EditPermissionsSecurityGroup, -40 EditExistingSecurityGroup, -40 EditAddNewSecurityGroup, -40 EditAddExistingSecurityGroup, -40 EditDeleteSecurityGroup,
				1 MinCardinality, null MaxCardinality, cast(null as xml) CustomEditModule
			from b
			where HasType = 0
		union all
		select Class, null NetworkProperty, 'http://www.w3.org/2000/01/rdf-schema#label' Property, 0 IsDetail, null Limit, 0 IncludeDescription, 0 IncludeNetwork,
				1 SearchWeight,
				1 CustomDisplay, 0 CustomEdit, -1 ViewSecurityGroup, 
				-40 EditSecurityGroup,
				-40 EditPermissionsSecurityGroup, -40 EditExistingSecurityGroup, -40 EditAddNewSecurityGroup, -40 EditAddExistingSecurityGroup, -40 EditDeleteSecurityGroup,
				1 MinCardinality, null MaxCardinality, cast(null as xml) CustomEditModule
			from b
			where HasLabel = 0
		union all
		select p.Value Domain, null NetworkProperty, p.Property, 1 IsDetail, null Limit, 
				(case when t.Value = 'http://www.w3.org/2002/07/owl#ObjectProperty' then 1 else 0 end) IncludeDescription, 
				0 IncludeNetwork,
				(case when t.Value = 'http://www.w3.org/2002/07/owl#ObjectProperty' then 0 else 0.5 end) SearchWeight,
				0 CustomDisplay, 0 CustomEdit, -1 ViewSecurityGroup, 
				-40 EditSecurityGroup,
				-40 EditPermissionsSecurityGroup, -40 EditExistingSecurityGroup, -40 EditAddNewSecurityGroup, -40 EditAddExistingSecurityGroup, -40 EditDeleteSecurityGroup,
				0 MinCardinality, null MaxCardinality, cast(null as xml) CustomEditModule
			from [RDF.].vwPropertyTall p, [RDF.].vwPropertyTall t
			where p.Predicate = 'http://www.w3.org/2000/01/rdf-schema#domain'
				and p.Property = t.Property
				and t.Predicate = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
				and t.Value in ('http://www.w3.org/2002/07/owl#DatatypeProperty','http://www.w3.org/2002/07/owl#ObjectProperty')
				and not exists (
					select *
					from [Ontology.].ClassProperty c
					where c.Class = p.Value and c.Property = p.Property and c.NetworkProperty is null
				)
	)
	select row_number() over (order by c.Class, c.Property) + a.StartID ClassPropertyID, c.*
		from c, a
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE VIEW [ORNG.].[vwAppPersonData] as
	SELECT m.InternalID + '-' + CAST(a.AppID as varchar) + '-' + d.Keyname PrimaryId, 
	 m.InternalID + '-' + CAST(a.AppID as varchar)PersonIdAppId,
	 m.InternalID PersonId, a.AppID,
	 a.Name AppName, d.Keyname, d.Value FROM [ORNG.].[Apps] a 
	 join [ORNG.].AppData d on a.AppID = d.AppID 
	 join [RDF.Stage].InternalNodeMap m on d.NodeID = m.NodeID

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create view [ORNG.].[vwPerson]
as
SELECT n.nodeId
      ,par.[Value] + '/display/' +  cast (n.nodeId as nvarchar(50))  as profileURL, p.IsActive
  FROM [Framework.].Parameter par JOIN
  [Profile.Data].[Person] p ON  par.[ParameterID] = 'basePath'
	LEFT JOIN [RDF.Stage].internalnodemap n on n.internalid = p.personId
	and n.[class] = 'http://xmlns.com/foaf/0.1/Person' 




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [RDF.].[vwLiteral]
	WITH SCHEMABINDING
	AS
	SELECT NodeID, Value
		FROM [RDF.].[Node]
		WHERE ObjectType = 1 
			AND (DataType IS NULL OR DataType <> 'http://www.w3.org/2001/XMLSchema#float')

GO
SET ARITHABORT ON
SET CONCAT_NULL_YIELDS_NULL ON
SET QUOTED_IDENTIFIER ON
SET ANSI_NULLS ON
SET ANSI_PADDING ON
SET ANSI_WARNINGS ON
SET NUMERIC_ROUNDABORT OFF

GO
CREATE UNIQUE CLUSTERED INDEX [idx_NodeID] ON [RDF.].[vwLiteral]
(
	[NodeID] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
GO
CREATE FULLTEXT INDEX ON [RDF.].[vwLiteral](
[Value] LANGUAGE [English])
KEY INDEX [idx_NodeID]ON [ft]
WITH CHANGE_TRACKING AUTO


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE VIEW [Profile.Data].[vwGroup.GeneralWithDeleted] AS 
	SELECT GroupID, GroupName, g.ViewSecurityGroup, ISNULL(m.NodeID,-40) EditSecurityGroup, CreateDate, EndDate,
		(case when g.ViewSecurityGroup = 0 then 'Deleted' when g.ViewSecurityGroup > 0 then 'Private' else isnull(s.Label,'Unknown') end) ViewSecurityGroupName, 
		m.NodeID GroupNodeID
	FROM [Profile.Data].[Group.General] g
		LEFT OUTER JOIN [RDF.Security].[Group] s
			ON g.ViewSecurityGroup = s.SecurityGroupID
		LEFT OUTER JOIN [RDF.Stage].InternalNodeMap m
			ON m.Class = 'http://xmlns.com/foaf/0.1/Group' AND m.InternalType = 'Group' AND InternalID = g.GroupID
		LEFT OUTER JOIN [RDF.].[Node] n
			ON m.NodeID = n.NodeID

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Profile.Data].[vwGroup.General] AS 
	SELECT GroupID, GroupName, ViewSecurityGroup, EditSecurityGroup, CreateDate, ViewSecurityGroupName, GroupNodeID
	FROM [Profile.Data].[vwGroup.GeneralWithDeleted]
	WHERE ViewSecurityGroup <> 0

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE VIEW [Profile.Data].[vwGroup.Manager] AS 
	SELECT m.GroupID, m.UserID, g.ViewSecurityGroup, -40 EditSecurityGroup
	FROM [Profile.Data].[Group.Manager] m
		INNER JOIN [Profile.Data].[Group.General] g
			ON g.GroupID = m.GroupID
	WHERE g.ViewSecurityGroup <> 0
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Profile.Data].[vwGroup.Member] AS 
	SELECT m.MemberRoleID, m.GroupID, m.UserID, u.PersonID, m.IsActive, m.IsApproved, m.IsVisible, m.Title, m.IsFeatured, m.SortOrder, g.ViewSecurityGroup, -40 EditSecurityGroup
	FROM [Profile.Data].[Group.Member] m
		INNER JOIN [Profile.Data].[Group.General] g
			ON g.GroupID = m.GroupID
		INNER JOIN [User.Account].[User] u
			ON m.UserID = u.UserID
	WHERE (m.IsActive=1) AND (m.IsApproved=1) AND (m.IsVisible=1) AND (u.PersonID IS NOT NULL) and (g.ViewSecurityGroup <> 0)
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE VIEW [Profile.Data].[vwGroup.Photo]
AS
SELECT p.*, m.NodeID GroupNodeID, o.Value+'Modules/CustomViewPersonGeneralInfo/PhotoHandler.ashx?NodeID='+CAST(m.NodeID as varchar(50)) URI
FROM [Profile.Data].[Group.Photo] p
	INNER JOIN [RDF.Stage].[InternalNodeMap] m
		ON m.Class = 'http://xmlns.com/foaf/0.1/Group'
			AND m.InternalType = 'Group'
			AND m.InternalID = CAST(p.GroupID as varchar(50))
	INNER JOIN [Framework.].[Parameter] o
		ON o.ParameterID = 'baseURI';

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Profile.Data].[vwGroup.Publication.Entity.AssociatedInformationResource]
AS
	SELECT GroupID, EntityID, EntityDate FROM [Profile.Data].[Publication.Entity.InformationResource] ir
		JOIN [Profile.Data].[Publication.Group.Include] i
		ON ((ir.PMID = i.PMID AND ir.MPID IS NULL) OR (ir.MPID = i.MPID AND ir.PMID IS NULL))
	UNION
	SELECT g.GroupID, InformationResourceID, EntityDate FROM [Profile.Data].[Publication.Group.Option] o
		JOIN [Profile.Data].[Group.Member] g
		ON o.GroupID = g.GroupID and o.IncludeMemberPublications = 1 and g.IsActive = 1
		JOIN [User.Account].[User] u
		ON g.UserID = u.UserID
		JOIN [Profile.Data].[vwPublication.Entity.Authorship] a
		ON u.PersonID = a.PersonID
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Framework.].[GetBasePath]
AS
BEGIN
	select [value] from [Framework.].[parameter] with(nolock) where parameterid = 'basepath'
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Framework.].[GetBaseURI]
AS
BEGIN
	select [value] from [Framework.].[parameter] with(nolock) where parameterid = 'baseuri'

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE VIEW [Profile.Data].[vwURL] AS 
	SELECT [UrlID], [URL], [WebPageTitle], null as [PublicationDate] FROM [Profile.Data].[Group.Websites]
	UNION SELECT [UrlID], [URL], [WebPageTitle], [PublicationDate] FROM [Profile.Data].[Group.MediaLinks]
	UNION SELECT [UrlID], [URL], [WebPageTitle], null as [PublicationDate] FROM [Profile.Data].[Person.Websites]
	UNION SELECT [UrlID], [URL], [WebPageTitle], [PublicationDate] FROM [Profile.Data].[Person.MediaLinks]
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE view [Profile.Data].[vwPublication.PubMed.AllXML.PubMedBookArticle]
as
		select pmid, 
			'PubMedBookDocument' HmsPubCategory,
			nref.value('Book[1]/BookTitle[1]','varchar(2000)') PubTitle, 
			nref.value('ArticleTitle[1]','varchar(2000)') ArticleTitle,
			nref.value('Book[1]/Publisher[1]/PublisherLocation[1]','varchar(60)') PlaceOfPub, 
			nref.value('Book[1]/Publisher[1]/PublisherName[1]','varchar(255)') Publisher, 
			cast(isnull(nref.value('Book[1]/PubDate[1]/Year[1]','varchar(4)'), '1900') + '-' + isnull(nref.value('Book[1]/PubDate[1]/Month[1]','varchar(2)'), '01') + '-' + isnull(nref.value('Book[1]/PubDate[1]/Day[1]','varchar(2)'), '01') as DATETIME) PublicationDT
		from [Profile.Data].[Publication.PubMed.AllXML] cross apply x.nodes('//PubmedBookArticle/BookDocument') as R(nref)
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Framework.].[LoadXMLFile](@FilePath varchar(max), @TableDestination VARCHAR(MAX), @DestinationColumn VARCHAR(MAX), @NameValue VARCHAR(MAX)=NULL )
AS
BEGIN
	 
	SET NOCOUNT ON;

	/*

	This stored procedure imports the contents of an xml file into the 
	specified table and column from a supplied filepath. 

	Input parameters:
		@FilePath				Path where xml data file exists, relative to the sql server.		  
		@TableDestination		Table where data is to be stored
		@DestinationColumn		Column where data is to be stored
		@NameValue				Name of the file (optional)

	Test Call:
		[Framework.].[uspLoadXMLFile] 'c:\InstallData.xml', '[Framework.].[InstallData]', 'Data', 'VIVO_1.4'
		
	*/

	DECLARE @sql NVARCHAR(MAX)
	 
	SELECT @SQL = 'INSERT INTO ' + @TableDestination + '(' + @DestinationColumn + CASE WHEN @NameValue IS NOT NULL THEN ',Name' ELSE '' END +  ') 
									 SELECT  xXML' + CASE WHEN @NameValue IS NOT NULL THEN ',''' + @NameValue + '''' ELSE '' END + ' FROM   ( SELECT CONVERT(xml, BulkColumn, 2) FROM OPENROWSET(BULK ''' + @FilePath + ''', SINGLE_BLOB) AS T ) AS x ( xXML )'  
	 
	EXEC SP_EXECUTESQL @SQL 

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Framework.].[LICENCE]
AS
BEGIN
PRINT 
'
Copyright (c) 2008-2014 by the President and Fellows of Harvard College. All rights reserved.  Profiles Research Networking Software was developed under the supervision of Griffin M Weber, MD, PhD., and Harvard Catalyst: The Harvard Clinical and Translational Science Center, with support from the National Center for Research Resources and Harvard University.
 
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
	* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
	* Neither the name "Harvard" nor the names of its contributors nor the name "Harvard Catalyst" may be used to endorse or promote products derived from this software without specific prior written permission.
 
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER (PRESIDENT AND FELLOWS OF HARVARD COLLEGE) AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
'
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [User.Account].[Proxy.Search]
	@LastName nvarchar(100) = NULL,
	@FirstName nvarchar(100) = NULL,
	@Institution nvarchar(500) = NULL,
	@Department nvarchar(500) = NULL,
	@Division nvarchar(500) = NULL,
	@offset INT = 0,
	@limit INT = 20
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET nocount  ON;

	SELECT @offset = IsNull(@offset,0), @limit = IsNull(@limit,1000)
	SELECT @limit = 1000 WHERE @limit > 1000
	
	SELECT	@LastName = (CASE WHEN @LastName = '' THEN NULL ELSE @LastName END),
			@FirstName = (CASE WHEN @FirstName = '' THEN NULL ELSE @FirstName END),
			@Institution = (CASE WHEN @Institution = '' THEN NULL ELSE @Institution END),
			@Department = (CASE WHEN @Department = '' THEN NULL ELSE @Department END),
			@Division = (CASE WHEN @Division = '' THEN NULL ELSE @Division END)

	DECLARE @sql NVARCHAR(MAX)
	
	SELECT @sql = '
		SELECT UserID, DisplayName, Institution, Department, EmailAddr
			FROM (
				SELECT UserID, DisplayName, Institution, Department, EmailAddr, 
					row_number() over (order by LastName, FirstName, UserID) k
				FROM [User.Account].[User]
				WHERE IsActive = 1
					AND CanBeProxy = 1
					' + IsNull('AND FirstName LIKE '''+replace(@FirstName,'''','''''')+'%''','') + '
					' + IsNull('AND LastName LIKE '''+replace(@LastName,'''','''''')+'%''','') + '
					' + IsNull('AND Institution = '''+replace(@Institution,'''','''''')+'''','') + '
					' + IsNull('AND Department = '''+replace(@Department,'''','''''')+'''','') + '
					' + IsNull('AND Division = '''+replace(@Division,'''','''''')+'''','') + '
			) t
			WHERE (k >= ' + cast(@offset+1 as varchar(50)) + ') AND (k < ' + cast(@offset+@limit+1 as varchar(50)) + ')
			ORDER BY k
		'

	EXEC sp_executesql @sql

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Edit.Framework].[ResolveURL]
	@ApplicationName varchar(1000) = '',
	@param1 varchar(1000) = '',
	@param2 varchar(1000) = '',
	@param3 varchar(1000) = '',
	@param4 varchar(1000) = '',
	@param5 varchar(1000) = '',
	@param6 varchar(1000) = '',
	@param7 varchar(1000) = '',
	@param8 varchar(1000) = '',
	@param9 varchar(1000) = '',
	@SessionID uniqueidentifier = null,
	@ContentType varchar(255) = null,
	@Resolved bit OUTPUT,
	@ErrorDescription varchar(max) OUTPUT,
	@ResponseURL varchar(1000) OUTPUT,
	@ResponseContentType varchar(255) OUTPUT,
	@ResponseStatusCode int OUTPUT,
	@ResponseRedirect bit OUTPUT,
	@ResponseIncludePostData bit OUTPUT

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	-- By default we were not able to resolve the URL
	SELECT @Resolved = 0

	-- Load param values into a table
	DECLARE @params TABLE (id int, val varchar(1000))
	INSERT INTO @params (id, val) VALUES (1, @param1)
	INSERT INTO @params (id, val) VALUES (2, @param2)
	INSERT INTO @params (id, val) VALUES (3, @param3)
	INSERT INTO @params (id, val) VALUES (4, @param4)
	INSERT INTO @params (id, val) VALUES (5, @param5)
	INSERT INTO @params (id, val) VALUES (6, @param6)
	INSERT INTO @params (id, val) VALUES (7, @param7)
	INSERT INTO @params (id, val) VALUES (8, @param8)
	INSERT INTO @params (id, val) VALUES (9, @param9)

	DECLARE @MaxParam int
	SELECT @MaxParam = 0
	SELECT @MaxParam = MAX(id) FROM @params WHERE val > ''

	DECLARE @TabParam int
	SELECT @TabParam = 3

	DECLARE @REDIRECTPAGE VARCHAR(255)
	
	SELECT @REDIRECTPAGE = '~/edit/default.aspx'


--this is for the display of the people search results if a queryID exists.
		if(@Param1	<>	'' and IsNumeric(@Param1)=1)
		BEGIN

			SELECT @Resolved = 1,
				@ErrorDescription = '',
				@ResponseURL = @REDIRECTPAGE  + '?subject=' + @Param1							
				
					
		END		


set	@ResponseContentType =''
set	@ResponseStatusCode  =''
set	@ResponseRedirect =0
set	@ResponseIncludePostData =0








END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*
declare @resolved bit
declare @t uniqueidentifier
set @t = '719491AF-F4B2-48C0-B264-465D46730AB1';
	declare @ErrorDescription varchar(max) 
	declare @ResponseURL varchar(1000) 
	declare @ResponseContentType varchar(255) 
	declare @ResponseStatusCode int 
	declare @ResponseRedirect bit 
	declare @ResponseIncludePostData bit 



exec [Direct.Framework].[ResolveDirectURL] 'direct','directservice.aspx', 'asdf','','','','','','','',@t,'', @resolved output, 
	 @ErrorDescription output,
	 @ResponseURL output,
	 @ResponseContentType output,
	 @ResponseStatusCode output,
	 @ResponseRedirect output,
	 @ResponseIncludePostData output



select @ResponseURL

*/
CREATE PROCEDURE [Direct.Framework].[ResolveURL]
	@ApplicationName varchar(1000) = '',
	@param1 varchar(1000) = '',
	@param2 varchar(1000) = '',
	@param3 varchar(1000) = '',
	@param4 varchar(1000) = '',
	@param5 varchar(1000) = '',
	@param6 varchar(1000) = '',
	@param7 varchar(1000) = '',
	@param8 varchar(1000) = '',
	@param9 varchar(1000) = '',
	@SessionID uniqueidentifier = null,
	@ContentType varchar(255) = null,
	@Resolved bit OUTPUT,
	@ErrorDescription varchar(max) OUTPUT,
	@ResponseURL varchar(1000) OUTPUT,
	@ResponseContentType varchar(255) OUTPUT,
	@ResponseStatusCode int OUTPUT,
	@ResponseRedirect bit OUTPUT,
	@ResponseIncludePostData bit OUTPUT

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	-- By default we were not able to resolve the URL
	SELECT @Resolved = 0

	-- Load param values into a table
	DECLARE @params TABLE (id int, val varchar(1000))
	INSERT INTO @params (id, val) VALUES (1, @param1)
	INSERT INTO @params (id, val) VALUES (2, @param2)
	INSERT INTO @params (id, val) VALUES (3, @param3)
	INSERT INTO @params (id, val) VALUES (4, @param4)
	INSERT INTO @params (id, val) VALUES (5, @param5)
	INSERT INTO @params (id, val) VALUES (6, @param6)
	INSERT INTO @params (id, val) VALUES (7, @param7)
	INSERT INTO @params (id, val) VALUES (8, @param8)
	INSERT INTO @params (id, val) VALUES (9, @param9)

	DECLARE @MaxParam int
	SELECT @MaxParam = 0
	SELECT @MaxParam = MAX(id) FROM @params WHERE val > ''

	DECLARE @TabParam int
	SELECT @TabParam = 3

	DECLARE @REDIRECTPAGE VARCHAR(255)
	
	SELECT @REDIRECTPAGE = '~/direct/default.aspx'

	-- Return results
	IF (@ErrorDescription IS NULL)
	BEGIN

		if(@ApplicationName = 'direct' and @param1 <> '' and @param2 = '')
		BEGIN
			SELECT @Resolved = 1,
				@ErrorDescription = '',
				@ResponseURL = @REDIRECTPAGE + '?queryid=' + @param1
					
		END


		if(@ApplicationName = 'direct' and @param1 <> '' and @param2 <> '')
		BEGIN
			SELECT @Resolved = 1,
				@ErrorDescription = '',
				@ResponseURL = @REDIRECTPAGE + '?queryid=' + @param1 + '&stop=true'
					
		END
	
		set	@ResponseContentType =''
		set	@ResponseStatusCode  =''
		set	@ResponseRedirect =0
		set	@ResponseIncludePostData =0
				
	END

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [History.Framework].[ResolveURL]
@ApplicationName VARCHAR (1000)='', @param1 VARCHAR (1000)='', @param2 VARCHAR (1000)='', @param3 VARCHAR (1000)='', @param4 VARCHAR (1000)='', @param5 VARCHAR (1000)='', @param6 VARCHAR (1000)='', @param7 VARCHAR (1000)='', @param8 VARCHAR (1000)='', @param9 VARCHAR (1000)='', @SessionID UNIQUEIDENTIFIER=null, @ContentType VARCHAR (255)=null, @Resolved BIT OUTPUT, @ErrorDescription VARCHAR (MAX) OUTPUT, @ResponseURL VARCHAR (1000) OUTPUT, @ResponseContentType VARCHAR (255) OUTPUT, @ResponseStatusCode INT OUTPUT, @ResponseRedirect BIT OUTPUT, @ResponseIncludePostData BIT OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	-- By default we were not able to resolve the URL
	SELECT @Resolved = 0

	-- Load param values into a table
	DECLARE @params TABLE (id int, val varchar(1000))
	INSERT INTO @params (id, val) VALUES (1, @param1)
	INSERT INTO @params (id, val) VALUES (2, @param2)
	INSERT INTO @params (id, val) VALUES (3, @param3)
	INSERT INTO @params (id, val) VALUES (4, @param4)
	INSERT INTO @params (id, val) VALUES (5, @param5)
	INSERT INTO @params (id, val) VALUES (6, @param6)
	INSERT INTO @params (id, val) VALUES (7, @param7)
	INSERT INTO @params (id, val) VALUES (8, @param8)
	INSERT INTO @params (id, val) VALUES (9, @param9)

	DECLARE @MaxParam int
	SELECT @MaxParam = 0
	SELECT @MaxParam = MAX(id) FROM @params WHERE val > ''

	DECLARE @TabParam int
	SELECT @TabParam = 3

	DECLARE @REDIRECTPAGE VARCHAR(255)
	
	SELECT @REDIRECTPAGE = '~/history/default.aspx'

	-- Return results
	IF (@ErrorDescription IS NULL)
	BEGIN
	
		if(@Param1='list')
		BEGIN
			SELECT @Resolved = 1,
				@ErrorDescription = '',
				@ResponseURL = @REDIRECTPAGE + '?tab=list'
		END						

		if(@Param1='type')
		BEGIN
			SELECT @Resolved = 1,
				@ErrorDescription = '',
				@ResponseURL = @REDIRECTPAGE  + '?tab=type'									
		END		
	

set	@ResponseContentType =''
set	@ResponseStatusCode  =''
set	@ResponseRedirect =0
set	@ResponseIncludePostData =0



				
	END





END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Search.Framework].[ResolveURL]
@ApplicationName VARCHAR (1000)='', @param1 VARCHAR (1000)='', @param2 VARCHAR (1000)='', @param3 VARCHAR (1000)='', @param4 VARCHAR (1000)='', @param5 VARCHAR (1000)='', @param6 VARCHAR (1000)='', @param7 VARCHAR (1000)='', @param8 VARCHAR (1000)='', @param9 VARCHAR (1000)='', @SessionID UNIQUEIDENTIFIER=null, @ContentType VARCHAR (255)=null, @Resolved BIT OUTPUT, @ErrorDescription VARCHAR (MAX) OUTPUT, @ResponseURL VARCHAR (1000) OUTPUT, @ResponseContentType VARCHAR (255) OUTPUT, @ResponseStatusCode INT OUTPUT, @ResponseRedirect BIT OUTPUT, @ResponseIncludePostData BIT OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	
	-- By default we were not able to resolve the URL
	SELECT @Resolved = 0

	-- Load param values into a table
	DECLARE @params TABLE (id int, val varchar(1000))
	INSERT INTO @params (id, val) VALUES (1, @param1)
	INSERT INTO @params (id, val) VALUES (2, @param2)
	INSERT INTO @params (id, val) VALUES (3, @param3)
	INSERT INTO @params (id, val) VALUES (4, @param4)
	INSERT INTO @params (id, val) VALUES (5, @param5)
	INSERT INTO @params (id, val) VALUES (6, @param6)
	INSERT INTO @params (id, val) VALUES (7, @param7)
	INSERT INTO @params (id, val) VALUES (8, @param8)
	INSERT INTO @params (id, val) VALUES (9, @param9)

	DECLARE @MaxParam int
	SELECT @MaxParam = 0
	SELECT @MaxParam = MAX(id) FROM @params WHERE val > ''

	DECLARE @TabParam int
	SELECT @TabParam = 3

	DECLARE @REDIRECTPAGE VARCHAR(255)
	
	SELECT @REDIRECTPAGE = '~/search/default.aspx'

	-- Return results
	IF (@ErrorDescription IS NULL)
	BEGIN


		if(@Param1='all' and @Param2='')
		BEGIN
			SELECT @Resolved = 1,
				@ErrorDescription = '',
				@ResponseURL = @REDIRECTPAGE + '?tab=all'
		END		


		if(@Param1='all' and @Param2='results')
		BEGIN          
		
			SELECT @Resolved = 1,
				@ErrorDescription = '',
				@ResponseURL = @REDIRECTPAGE + '?tab=all&action=results'
							
		END


		if(@Param1='people' and @Param2='')
		BEGIN
			SELECT @Resolved = 1,
				@ErrorDescription = '',
				@ResponseURL = @REDIRECTPAGE  + '?tab=people'				
					
		END		
		if(@Param1='people' and @Param2='results')
		BEGIN
			SELECT @Resolved = 1,
				@ErrorDescription = '',
				@ResponseURL = @REDIRECTPAGE  + '?tab=people&action=results'				
					
		END		


set	@ResponseContentType =''
set	@ResponseStatusCode  =''
set	@ResponseRedirect =0
set	@ResponseIncludePostData =0



				
	END





END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Person.DoesPersonExist](	@PersonID INT,@exists BIT OUTPUT)
AS
BEGIN
	SET NOCOUNT ON;

  SELECT @exists=0
  SELECT TOP 1 @exists=0, @exists = CASE WHEN PersonID	  IS NULL THEN 0 ELSE 1 END  
		FROM [Profile.Data].vw_person 
	 WHERE PersonID	  = @PersonID
		 AND IsActive=1
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[SNA.Coauthor.UpdateBetweenness]  
AS

BEGIN

	SET NOCOUNT ON;

	DECLARE @date DATETIME,@auditid UNIQUEIDENTIFIER, @rows int
	 
	CREATE TABLE #neighbors (i INT NOT NULL, j INT NOT NULL)
	INSERT INTO #neighbors (i,j)
		SELECT DISTINCT PersonID1, PersonID2
			FROM [Profile.Cache].[SNA.Coauthor] 
			WHERE PersonID1 <> PersonID2

	ALTER TABLE #neighbors ADD PRIMARY KEY (i,j)

	CREATE TABLE #c(v INT PRIMARY KEY, c FLOAT)
	CREATE TABLE #p(w INT, v INT)
	CREATE CLUSTERED INDEX idx_w ON #p(w)
	CREATE TABLE #e(t INT PRIMARY KEY, e FLOAT)
	CREATE TABLE #d(j int primary key, distance INT, numpaths FLOAT)
	CREATE UNIQUE NONCLUSTERED INDEX idx_d ON #d(distance,j)

	DECLARE @s INT, @d INT, @AuthCount INT, @MaxS INT

	INSERT INTO #c SELECT DISTINCT i, 0 FROM #neighbors
	INSERT INTO #e SELECT DISTINCT i, 0 FROM #neighbors
	INSERT INTO #d SELECT DISTINCT i, 0, 0 FROM #neighbors
 
	SELECT @AuthCount = COUNT(DISTINCT i ) FROM [Profile.Cache].[SNA.Coauthor]

	SELECT @MaxS = (SELECT MAX(PersonID1) FROM [Profile.Cache].[SNA.Coauthor.Distance])

	SET @s = 1
	WHILE @s <= @MaxS
	BEGIN
		IF EXISTS (SELECT top 1 * FROM [Profile.Cache].[SNA.Coauthor] WHERE PersonID1 = @s)
		BEGIN

			DROP INDEX #d.idx_d
			UPDATE	d 
				SET	d.distance = s.distance, 
							d.numpaths = s.numpaths
				FROM	#d d
					JOIN  [Profile.Cache].[SNA.Coauthor.Distance] s ON s.PersonID1 = @s AND s.PersonID2 = d.j

			CREATE UNIQUE NONCLUSTERED INDEX idx_d ON #d(distance,j)

			TRUNCATE TABLE #p
			DROP INDEX #p.idx_w

			INSERT INTO #p(w,v)
				SELECT w.j, v.j
					FROM #d v
					JOIN #neighbors n ON v.j = n.i
					JOIN #d w on n.j = w.j
								 AND w.distance = v.distance + 1
				WHERE v.distance <= 99   
				 
			CREATE CLUSTERED INDEX idx_w ON #p(w)

			UPDATE #e 
				 SET e = 0

			SELECT @d = (SELECT MAX(distance) FROM #d WHERE distance < 99)
			WHILE @d > -1
			BEGIN
				UPDATE e 
					SET e.e = e.e + t.e
					FROM #e e, (
						SELECT	ev.t, SUM((bv.numpaths/bw.numpaths)*(1+ew.e)) e
							FROM	#p p
								JOIN  #e ev ON p.v = ev.t 
								JOIN  #e ew ON p.w = ew.t 
								JOIN  #d d ON d.distance = @d AND d.j = p.w
								JOIN  #d bv ON p.v = bv.j
								JOIN  #d bw ON  p.w = bw.j 										 
							GROUP BY ev.t
						) t
					WHERE e.t = t.t

				 SELECT @d = @d - 1
			END

			UPDATE c 
				SET c.c = c.c + e.e 
				FROM #c c
					JOIN #e e ON c.v = e.t
				WHERE c.v <> @s

		END

		SET @s = @s + 1
	END
	 
	BEGIN TRY
		BEGIN TRAN
			TRUNCATE TABLE [Profile.Cache].[SNA.Coauthor.Betweenness]
			INSERT INTO [Profile.Cache].[SNA.Coauthor.Betweenness] (personid,b)
				SELECT v, c FROM #c							 
		COMMIT 
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK

		 
		 
		-- Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()

		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH

	 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Import].[ValidateProfilesImportTables]	 
AS
BEGIN
	SET NOCOUNT ON;	

	BEGIN TRY

		DECLARE @errorstring VARCHAR(2000), @ErrMsg VARCHAR(2000),@errSeverity VARCHAR(20)

		CREATE TABLE #Msg (MsgStr NVARCHAR(2000))
		DECLARE @sql NVARCHAR(max)


		--*************************************************************************************************************
		--*************************************************************************************************************
		--*** Validate column lengths and use of null values.
		--*************************************************************************************************************
		--*************************************************************************************************************

		-- Create a list of all the loading table columns and their valid lengths and types
		DECLARE @columns TABLE (
			tableName VARCHAR(50),
			columnName VARCHAR(50),
			dataType VARCHAR(50),
			maxLength INT,
			columnType VARCHAR(50)
		)
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','internalusername','string',50,'Required')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','firstname','string',50,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','middlename','string',50,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','lastname','string',50,'Required')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','displayname','string',255,'Required')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','suffix','string',50,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','addressline1','string',255,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','addressline2','string',255,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','addressline3','string',255,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','addressline4','string',255,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','addressstring','string',1000,'Required')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','city','string',100,'Not Used')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','state','string',2,'Not Used')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','zip','string',10,'Not Used')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','building','string',255,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','room','string',255,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','floor','int',null,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','latitude','decimal',null,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','longitude','decimal',null,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','phone','string',35,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','fax','string',25,'Optional') 
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','emailaddr','string',255,'Optional') 
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','isactive','bit',null,'Required')
		INSERT INTO @columns VALUES ('[Profile.Import].[Person] ','isvisible','bit',null,'Required')
		INSERT INTO @columns VALUES ('[Profile.Import].[PersonAffiliation]  ','internalusername','string',50,'Required') 
		INSERT INTO @columns VALUES ('[Profile.Import].[PersonAffiliation]  ','title','string',200,'Optional') 
		INSERT INTO @columns VALUES ('[Profile.Import].[PersonAffiliation]  ','emailaddr','string',200,'Dont Use')
		INSERT INTO @columns VALUES ('[Profile.Import].[PersonAffiliation]  ','primaryaffiliation','bit',null,'Required')
		INSERT INTO @columns VALUES ('[Profile.Import].[PersonAffiliation]  ','affiliationorder','int',null,'Required')
		INSERT INTO @columns VALUES ('[Profile.Import].[PersonAffiliation]  ','institutionname','string',500,'Optional') 
		INSERT INTO @columns VALUES ('[Profile.Import].[PersonAffiliation]  ','institutionabbreviation','string',50,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[PersonAffiliation]  ','departmentname','string',500,'Optional')  
		INSERT INTO @columns VALUES ('[Profile.Import].[PersonAffiliation]  ','departmentvisible','bit',null,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[PersonAffiliation]  ','divisionname','string',500,'Optional')  
		INSERT INTO @columns VALUES ('[Profile.Import].[PersonAffiliation]  ','facultyrank','string',100,'Optional') 
		INSERT INTO @columns VALUES ('[Profile.Import].[PersonAffiliation]  ','facultyrankorder','tinyint',null,'Optional')  
		INSERT INTO @columns VALUES ('[Profile.Import].[PersonFilterFlag]  ','internalusername','string',50,'Required') 
		INSERT INTO @columns VALUES ('[Profile.Import].[PersonFilterFlag]  ','personfilter','string',50,'Required')
		INSERT INTO @columns VALUES ('[Profile.Import].[User]','internalusername','string',50,'Required') 
		INSERT INTO @columns VALUES ('[Profile.Import].[User]','firstname','string',100,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[User]','lastname','string',100,'Required')
		INSERT INTO @columns VALUES ('[Profile.Import].[User]','displayname','string',255,'Required') 
		INSERT INTO @columns VALUES ('[Profile.Import].[User]','institution','string',500,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[User]','department','string',500,'Optional')
		INSERT INTO @columns VALUES ('[Profile.Import].[User]','canbeproxy','bit',null,'Required')

		-- Check for values that are too long
		SELECT @sql = ''
		SELECT @sql = @sql + '
				INSERT INTO #Msg 
					SELECT ''ERROR: '+tableName+'.'+columnName+' has values longer than '+cast(maxLength as nvarchar(50))+' characters.''
					FROM '+tableName+'
					HAVING MAX(LEN(ISNULL('+columnName+',''''))) > '+cast(maxLength as nvarchar(50))+';'
			FROM @columns
			WHERE dataType = 'string'
		EXEC sp_executesql @sql 			 

		-- Check for values that should be numeric but are not
		SELECT @sql = ''
		SELECT @sql = @sql + '
				INSERT INTO #Msg 
					SELECT ''ERROR: '+tableName+'.'+columnName+' has values that are not numeric.''
					FROM '+tableName+' where '+tableName+'.'+columnName+' <>''''
					HAVING MIN(ISNUMERIC(ISNULL('+columnName+',0))) = 0;'
			FROM @columns
			WHERE columnName IN ('floor','assistantuserid')
		EXEC sp_executesql @sql 			 
  
		-- Check that Required columns do not have any NULLs
		SELECT @sql = ''
		SELECT @sql = @sql + '
				INSERT INTO #Msg 
					SELECT ''ERROR: '+tableName+'.'+columnName+' must contain only NOT NULL values. It currently has at least one NULL value.''
					FROM '+tableName+'
					HAVING MAX(CASE WHEN '+columnName+' IS NULL THEN 1 ELSE 0 END)=1;'
			FROM @columns
			WHERE columnType = 'Required'
		EXEC sp_executesql @sql 			 

		-- Check that Dont Use columns only have NULLs
		SELECT @sql = ''
		SELECT @sql = @sql + '
				INSERT INTO #Msg 
					SELECT ''ERROR: '+tableName+'.'+columnName+' must contain only NULL values. It currently has at least one NOT NULL value.''
					FROM '+tableName+' where '+tableName+'.'+columnName+' <>''''
					HAVING MIN(CASE WHEN '+columnName+' IS NULL THEN 1 ELSE 0 END)=0;'
			FROM @columns
			WHERE columnType = 'Dont Use'
		EXEC sp_executesql @sql 			 

		-- Check that columns do not mix NULLs and NOT NULLs
		SELECT @sql = ''
		SELECT @sql = @sql + '
				INSERT INTO #Msg 
					SELECT ''ERROR: '+tableName+'.'+columnName+' contains both null and not null values.''
					FROM '+tableName+'
					HAVING MAX(CASE WHEN '+columnName+' IS NULL THEN 1 ELSE 0 END) <> MIN(CASE WHEN '+columnName+' IS NULL THEN 1 ELSE 0 END);'
			FROM @columns
			WHERE columnType = 'Optional'
		EXEC sp_executesql @sql 			 


		--*************************************************************************************************************
		--*************************************************************************************************************
		--*** Validate data logic (duplicate values, cross-column consistency, invalid mapping, etc).
		--*************************************************************************************************************
		--*************************************************************************************************************

		-- Check for internalusername duplicates

		INSERT INTO #Msg
			SELECT 'ERROR: An internalusername is used more than once in [Profile.Import].[Person] .'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[Person]  GROUP BY internalusername HAVING COUNT(*)>1)

		INSERT INTO #Msg
			SELECT 'ERROR: An internalusername is used more than once in [Profile.Import].[User].'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[User] GROUP BY internalusername HAVING COUNT(*)>1)
				
		INSERT INTO #Msg
			SELECT 'ERROR: An internalusername is used in both [Profile.Import].[Person] and [Profile.Import].[User].'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[Person] p JOIN [Profile.Import].[User] u ON p.internalusername = u.internalusername)

		-- Check that primaryaffiliation and affiliationsort are being used correctly

		INSERT INTO #Msg
			SELECT 'ERROR: A person in [Profile.Import].[PersonAffiliation] does not have a record with primaryaffiliation=1.'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[PersonAffiliation] GROUP BY internalusername HAVING SUM(primaryaffiliation*1)=0)

		INSERT INTO #Msg
			SELECT 'ERROR: A person in [Profile.Import].[PersonAffiliation] has more than one record with primaryaffiliation=1.'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[PersonAffiliation] GROUP BY internalusername HAVING SUM(primaryaffiliation*1)>1)

		INSERT INTO #Msg
			SELECT 'ERROR: A person in [Profile.Import].[PersonAffiliation] has more than one affiliationorder values that are the same.'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[PersonAffiliation] GROUP BY internalusername HAVING COUNT(DISTINCT affiliationorder)<>COUNT(affiliationorder))

		-- Check that institutions are being defined correctly

	
		INSERT INTO #Msg
			SELECT 'ERROR: An institutionname in [Profile.Import].[PersonAffiliation] is NULL when either institutionfullname or institutionabbreviation is defined.'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[PersonAffiliation] WHERE COALESCE(institutionname,institutionabbreviation) IS NOT NULL AND institutionname IS NULL)

		INSERT INTO #Msg
			SELECT 'ERROR: An institutionabbreviation in [Profile.Import].[PersonAffiliation] is NULL when either institutionfullname or institutionname is defined.'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[PersonAffiliation] WHERE institutionname IS NOT NULL AND institutionabbreviation IS NULL)

		INSERT INTO #Msg
			SELECT 'ERROR: An institutionname in [Profile.Import].[PersonAffiliation] is being mapped to more than one institutionabbreviation.'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[PersonAffiliation] WHERE institutionname IS NOT NULL GROUP BY institutionname HAVING COUNT(DISTINCT institutionabbreviation)>1)

		INSERT INTO #Msg
			SELECT 'ERROR: An institutionabbreviation in [Profile.Import].[PersonAffiliation] is being mapped to more than one institutionname.'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[PersonAffiliation] WHERE institutionabbreviation IS NOT NULL GROUP BY institutionabbreviation HAVING COUNT(DISTINCT institutionname)>1)

		-- Check that departments are being defined correctly
				
		INSERT INTO #Msg
			SELECT 'ERROR: A departmentvisible in [Profile.Import].[PersonAffiliation] is NULL when a departmentname is defined.'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[PersonAffiliation] WHERE departmentname IS NOT NULL AND departmentvisible IS NULL)

		-- Check that divisions are being defined correctly

		-- Check that faculty ranks are being defined correctly
		INSERT INTO #Msg
			SELECT 'ERROR: A facultyrank in [Profile.Import].[PersonAffiliation] has a NULL facultyrankorder.'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[PersonAffiliation] WHERE facultyrank IS NOT NULL AND facultyrankorder IS NULL)

		INSERT INTO #Msg
			SELECT 'ERROR: A facultyrank in [Profile.Import].[PersonAffiliation] is being mapped to more than one facultyrankorder.'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[PersonAffiliation] WHERE facultyrank IS NOT NULL GROUP BY facultyrank HAVING COUNT(DISTINCT facultyrankorder)>1)

		INSERT INTO #Msg
			SELECT 'ERROR: A facultyrankorder in [Profile.Import].[PersonAffiliation] is being mapped to more than one facultyrank.'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[PersonAffiliation] WHERE facultyrankorder IS NOT NULL GROUP BY facultyrankorder HAVING COUNT(DISTINCT facultyrank)>1)



		--*************************************************************************************************************
		--*************************************************************************************************************
		--*** Identify items that are not errors, but might produce unexpected behavior.
		--*************************************************************************************************************
		--*************************************************************************************************************

		INSERT INTO #Msg
			SELECT 'WARNING: All records in [Profile.Import].[Person]  have isactive=0 (or IS NULL). As a result, no people will appear on the website.'
				WHERE NOT EXISTS (SELECT 1 FROM [Profile.Import].[Person]  WHERE isactive=1)

		INSERT INTO #Msg
			SELECT 'WARNING: All records in [Profile.Import].[Person]  have isvisible=0 (or IS NULL). As a result, all profile pages will show an ''Under Construction'' message.'
				WHERE NOT EXISTS (SELECT 1 FROM [Profile.Import].[Person]  WHERE isvisible=1)

		INSERT INTO #Msg
			SELECT 'WARNING: All records in [Profile.Import].[User] have canbeproxy=0 (or IS NULL). As a result, people will not be able to select any of these users to be their proxies.'
				WHERE NOT EXISTS (SELECT 1 FROM [Profile.Import].[User] WHERE canbeproxy=1)

		INSERT INTO #Msg
			SELECT 'WARNING: All [Profile.Import].[Person] .addresslineN values are NULL. As a result, no addresses will be displayed on the website.'
				FROM [Profile.Import].[Person] 
				HAVING MIN(CASE WHEN COALESCE(addressline1,addressline2,addressline3,addressline4) IS NULL THEN 1 ELSE 0 END) = 1

		INSERT INTO #Msg
			SELECT 'WARNING: All [Profile.Import].[Person] .addressstring values are NULL. As a result, geocoding will not work, and people will not be displayed on maps.'
				FROM [Profile.Import].[Person] 
				HAVING MIN(CASE WHEN addressstring IS NULL AND (latitude IS NULL or longitude IS NULL) THEN 1 ELSE 0 END) = 1

		INSERT INTO #Msg
			SELECT 'WARNING: All departments in [Profile.Import].[PersonAffiliation] have departmentvisible=0 (or IS NULL). As a result, no departments will be listed in the website search form.'
				FROM [Profile.Import].[PersonAffiliation]
				HAVING MAX(IsNull(departmentvisible*1,-1))=0

		INSERT INTO #Msg
			SELECT 'WARNING: A departmentname in [Profile.Import].[PersonAffiliation] has records with departmentvisible=0 (or IS NULL) and departmentvisible=1. The department will be visible on the website.'
				WHERE EXISTS (SELECT 1 FROM [Profile.Import].[PersonAffiliation] WHERE departmentname IS NOT NULL GROUP BY departmentname HAVING MAX(departmentvisible*1)<>MIN(departmentvisible*1))


		--*************************************************************************************************************
		--*************************************************************************************************************
		--*** Display the list of errors and warnings that were found.
		--*************************************************************************************************************
		--*************************************************************************************************************

		INSERT INTO #Msg
			SELECT 'No problems were found.'
				WHERE NOT EXISTS (SELECT 1 FROM #Msg)

		SELECT * FROM #Msg 


	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK

		-- Raise an error with the details of the exception
		SELECT @ErrMsg = '[Profile.Import].[ValidateProfilesImportTables] Failed with : ' + ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()

		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH	
				
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Framework.].[RunJobGroup]
	@JobGroup INT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Exit if there is an error
	IF EXISTS (SELECT * FROM [Framework.].[Job] WHERE IsActive = 1 AND Status = 'ERROR')
	BEGIN
		RETURN
	END
	
	CREATE TABLE #Job (
		Step INT IDENTITY(0,1) PRIMARY KEY,
		JobID INT,
		Script NVARCHAR(MAX)
	)
	
	-- Get the list of job steps
	INSERT INTO #Job (JobID, Script)
		SELECT JobID, Script
			FROM [Framework.].[Job]
			WHERE JobGroup = @JobGroup AND IsActive = 1
			ORDER BY Step, JobID

	DECLARE @Step INT
	DECLARE @SQL NVARCHAR(MAX)
	DECLARE @LogID INT
	DECLARE @JobStart DATETIME
	DECLARE @JobEnd DATETIME
	DECLARE @JobID INT
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
	DECLARE @date DATETIME,@auditid UNIQUEIDENTIFIER, @rows INT
	SELECT @date=GETDATE() 
	
	-- Loop through all steps
	WHILE EXISTS (SELECT * FROM #Job)
	BEGIN
		-- Get the next step
		SELECT @Step = (SELECT MIN(Step) FROM #Job)
		
		-- Get the SQL
		SELECT @SQL = Script, @JobID = JobID
			FROM #Job
			WHERE Step = @Step

		-- Wait until other jobs are complete
		WHILE EXISTS (SELECT *
						FROM [Framework.].[Job] o, #Job j
						WHERE o.JobID = j.JobID AND o.Status = 'PROCESSING')
		BEGIN
			WAITFOR DELAY '00:00:30'
		END

		-- Update the status
		SELECT @JobStart = GetDate()
		UPDATE o
			SET o.Status = 'PROCESSING', o.LastStart = @JobStart, o.LastEnd = NULL, o.ErrorCode = NULL, o.ErrorMsg = NULL
			FROM [Framework.].[Job] o, #Job j
			WHERE o.JobID = j.JobID AND j.Step = @Step
		INSERT INTO [Framework.].[Log.Job] (JobID, JobGroup, Step, Script, JobStart, Status)
			SELECT @JobID, @JobGroup, @Step, @SQL, @JobStart, 'PROCESSING'
		SELECT @LogID = @@IDENTITY
			
		
		-- Log Step Execution
		--SELECT @date=GETDATE()
		--EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@SQL,@ProcessStartDate=@date,@insert_new_record=1
		
		BEGIN TRY 
			-- Run the step
			EXEC sp_executesql @SQL
		END TRY 
		BEGIN CATCH
			--Check success
			IF @@TRANCOUNT > 0
				ROLLBACK
				
			--SELECT @date=GETDATE()
			--EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@SQL,@ProcessEndDate=@date,@error = 1,@insert_new_record=0
			-- Log error 
			-- Update the status
			SELECT @JobEnd = GetDate()
			SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
			UPDATE o
				SET o.Status = 'JOB FAILED', o.LastEnd = GetDate(), o.ErrorCode = @ErrSeverity, o.ErrorMsg = @ErrMsg
				FROM [Framework.].[Job] o, #Job j
				WHERE o.JobID = j.JobID AND j.Step = @Step
			UPDATE [Framework.].[Log.Job]
				SET JobEnd = @JobEnd, Status = 'JOB FAILED', ErrorCode = @ErrSeverity, ErrorMsg = @ErrMsg
				WHERE LogID = @LogID
			--Raise an error with the details of the exception

			RAISERROR(@ErrMsg, @ErrSeverity, 1)
			RETURN
		END CATCH
		
		-- Log Step Execution
		--SELECT @date=GETDATE()
		--EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@SQL,@ProcessStartDate=@date,@insert_new_record=0
		
		
		-- Update the status
		SELECT @JobEnd = GetDate()
		UPDATE o
			SET o.Status = 'COMPLETED', o.LastEnd = GetDate(), o.ErrorCode = NULL, o.ErrorMsg = NULL
			FROM [Framework.].[Job] o, #Job j
			WHERE o.JobID = j.JobID AND j.Step = @Step
		UPDATE [Framework.].[Log.Job]
			SET JobEnd = @JobEnd, Status = 'COMPLETED'
			WHERE LogID = @LogID

		-- Remove the first step from the list
		DELETE j
			FROM #Job j
			WHERE Step = @Step
	END

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Framework].[ResolveURL]
	@ApplicationName varchar(1000) = '',
	@param1 varchar(1000) = '',
	@param2 varchar(1000) = '',
	@param3 varchar(1000) = '',
	@param4 varchar(1000) = '',
	@param5 varchar(1000) = '',
	@param6 varchar(1000) = '',
	@param7 varchar(1000) = '',
	@param8 varchar(1000) = '',
	@param9 varchar(1000) = '',
	@SessionID uniqueidentifier = null,
	@ContentType varchar(255) = null,
	@Resolved bit = NULL OUTPUT,
	@ErrorDescription varchar(max) = NULL OUTPUT,
	@ResponseURL varchar(1000) = NULL OUTPUT,
	@ResponseContentType varchar(255) = NULL OUTPUT,
	@ResponseStatusCode int = NULL OUTPUT,
	@ResponseRedirect bit = NULL OUTPUT,
	@ResponseIncludePostData bit = NULL OUTPUT,
	@subject BIGINT = NULL OUTPUT,
	@predicate BIGINT = NULL OUTPUT,
	@object BIGINT = NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- URL Pattern String:
	-- domainname	/{profile | display}	/{sNodeID | sAliasType/sAliasID}	/{pNodeID | pAliasType/pAliasID | sTab}	/{oNodeID | oAliasType/oAliasID | pTab}	/oTab	/sNodeID_pNodeID_oNodeID.rdf

	DECLARE @SessionHistory XML

	-- By default we were not able to resolve the URL
	SELECT @Resolved = 0

	-- Load param values into a table
	DECLARE @params TABLE (id int, val varchar(1000))
	INSERT INTO @params (id, val) VALUES (1, @param1)
	INSERT INTO @params (id, val) VALUES (2, @param2)
	INSERT INTO @params (id, val) VALUES (3, @param3)
	INSERT INTO @params (id, val) VALUES (4, @param4)
	INSERT INTO @params (id, val) VALUES (5, @param5)
	INSERT INTO @params (id, val) VALUES (6, @param6)
	INSERT INTO @params (id, val) VALUES (7, @param7)
	INSERT INTO @params (id, val) VALUES (8, @param8)
	INSERT INTO @params (id, val) VALUES (9, @param9)

	DECLARE @MaxParam int
	SELECT @MaxParam = 0
	SELECT @MaxParam = MAX(id) FROM @params WHERE val > ''

	DECLARE @Tab VARCHAR(1000)
	DECLARE @File VARCHAR(1000)
	DECLARE @ViewAs VARCHAR(50)
	
	SELECT @subject=NULL, @predicate=NULL, @object=NULL, @Tab=NULL, @File=NULL
	
	SELECT @File = val, @MaxParam = @MaxParam-1
		FROM @params
		WHERE id = @MaxParam and val like '%.%'

	DECLARE @pointer INT
	SELECT @pointer=1
	
	DECLARE @aliases INT
	SELECT @aliases = 0
	
	-- subject
	IF (@MaxParam >= @pointer)
	BEGIN
		SELECT @subject = CAST(val AS BIGINT), @pointer = @pointer + 1
			FROM @params 
			WHERE id=@pointer AND val NOT LIKE '%[^0-9]%'
		IF @subject IS NULL AND @MaxParam > @pointer
			SELECT @subject = NodeID, @pointer = @pointer + 2, @aliases = @aliases + 1
				FROM [RDF.].Alias 
				WHERE AliasType = (SELECT val FROM @params WHERE id = @pointer)
					AND AliasID = (SELECT val FROM @params WHERE id = @pointer+1)
		IF @subject IS NULL
			SELECT @ErrorDescription = 'The subject cannot be found.'
	END

	-- predicate
	IF (@MaxParam >= @pointer) AND (@subject IS NOT NULL)
	BEGIN
		SELECT @predicate = CAST(val AS BIGINT), @pointer = @pointer + 1
			FROM @params 
			WHERE id=@pointer AND val NOT LIKE '%[^0-9]%'
		IF @predicate IS NULL AND @MaxParam > @pointer
			SELECT @predicate = NodeID, @pointer = @pointer + 2, @aliases = @aliases + 1
				FROM [RDF.].Alias 
				WHERE AliasType = (SELECT val FROM @params WHERE id = @pointer)
					AND AliasID = (SELECT val FROM @params WHERE id = @pointer+1)
		IF @predicate IS NULL AND @MaxParam = @pointer
			SELECT @Tab=(SELECT val FROM @params WHERE id = @pointer)
		IF @predicate IS NULL AND @Tab IS NULL
			SELECT @ErrorDescription = 'The predicate cannot be found.'
	END
	
	-- object
	IF (@MaxParam >= @pointer) AND (@predicate IS NOT NULL)
	BEGIN
		SELECT @object = CAST(val AS BIGINT), @pointer = @pointer + 1
			FROM @params 
			WHERE id=@pointer AND val NOT LIKE '%[^0-9]%'
		IF @object IS NULL AND @MaxParam > @pointer
			SELECT @object = NodeID, @pointer = @pointer + 2, @aliases = @aliases + 1
				FROM [RDF.].Alias 
				WHERE AliasType = (SELECT val FROM @params WHERE id = @pointer)
					AND AliasID = (SELECT val FROM @params WHERE id = @pointer+1)
		IF @object IS NULL AND @MaxParam = @pointer
			SELECT @Tab=(SELECT val FROM @params WHERE id = @pointer)
		IF @object IS NULL AND @Tab IS NULL
			SELECT @ErrorDescription = 'The object cannot be found.'
	END
	
	-- tab
	IF (@MaxParam = @pointer) AND (@object IS NOT NULL) AND (@Tab IS NULL)
		SELECT @Tab=(SELECT val FROM @params WHERE id = @pointer)
	
	-- Return results
	IF (@ErrorDescription IS NULL)
	BEGIN

		declare @basePath nvarchar(400)
		select @basePath = value from [Framework.].Parameter where ParameterID = 'basePath'

		-- Default
		SELECT	@Resolved = 1,
				@ErrorDescription = '',
				@ResponseContentType = @ContentType,
				@ResponseStatusCode = 200,
				@ResponseRedirect = 0,
				@ResponseIncludePostData = 0,
				@ResponseURL = '~/profile/Profile.aspx?'
					+ 'subject=' + IsNull(cast(@subject as varchar(50)),'')
					+ '&predicate=' + IsNull(cast(@predicate as varchar(50)),'')
					+ '&object=' + IsNull(cast(@object as varchar(50)),'')
					+ '&tab=' + IsNull(@tab,'')
					+ '&file=' + IsNull(@file,'')

		DECLARE @FileRDF varchar(1000)
		SELECT @FileRDF =	IsNull(cast(@subject as varchar(50)),'')
							+IsNull('_'+cast(@predicate as varchar(50)),'')
							+IsNull('_'+cast(@object as varchar(50)),'')+'.rdf'

		DECLARE @FilePresentationXML varchar(1000)
		SELECT @FilePresentationXML = 'presentation_'
							+IsNull(cast(@subject as varchar(50)),'')
							+IsNull('_'+cast(@predicate as varchar(50)),'')
							+IsNull('_'+cast(@object as varchar(50)),'')+'.xml'

		IF (@ApplicationName = 'profile') AND (@File = @FileRDF)
				-- Display as RDF
				SELECT	@ResponseContentType = 'application/rdf+xml',
						@ResponseURL = @ResponseURL + '&viewas=RDF'
		ELSE IF (@ApplicationName = 'profile') AND (@File = @FilePresentationXML)
				-- Display PresentationXML
				SELECT	@ResponseContentType = 'application/rdf+xml',
						@ResponseURL = @ResponseURL + '&viewas=PresentationXML'
		ELSE IF (@ApplicationName = 'profile') AND (@ContentType = 'application/rdf+xml')
				-- Redirect 303 to the RDF URL
				SELECT	@ResponseContentType = 'application/rdf+xml',
						@ResponseStatusCode = 303,
						@ResponseRedirect = 1,
						@ResponseIncludePostData = 1,
						@ResponseURL = @basePath + '/profile'
							+ IsNull('/'+cast(@subject as varchar(50)),'')
							+ IsNull('/'+cast(@predicate as varchar(50)),'')
							+ IsNull('/'+cast(@object as varchar(50)),'')
							+ '/' + @FileRDF
		ELSE IF (@ApplicationName = 'profile')
				-- Redirect 303 to the HTML URL
				SELECT	@ResponseContentType = @ContentType,
						@ResponseStatusCode = 303,
						@ResponseRedirect = 1,
						@ResponseIncludePostData = 1,
						@ResponseURL = @basePath + '/display'
							+ (CASE WHEN @Subject IS NULL THEN ''
									ELSE IsNull((SELECT TOP 1 '/'+Subject
											FROM (
												SELECT 1 k, AliasType+'/'+AliasID Subject
													FROM [RDF.].Alias
													WHERE NodeID = @Subject AND Preferred = 1
												UNION ALL
												SELECT 2, CAST(@Subject AS VARCHAR(50))
											) t
											ORDER BY k, Subject),'')
									END)
							+ (CASE WHEN @Predicate IS NULL THEN ''
									ELSE IsNull((SELECT TOP 1 '/'+Subject
											FROM (
												SELECT 1 k, AliasType+'/'+AliasID Subject
													FROM [RDF.].Alias
													WHERE NodeID = @Predicate AND Preferred = 1
												UNION ALL
												SELECT 2, CAST(@Predicate AS VARCHAR(50))
											) t
											ORDER BY k, Subject),'')
									END)
							+ (CASE WHEN @Object IS NULL THEN ''
									ELSE IsNull((SELECT TOP 1 '/'+Subject
											FROM (
												SELECT 1 k, AliasType+'/'+AliasID Subject
													FROM [RDF.].Alias
													WHERE NodeID = @Object AND Preferred = 1
												UNION ALL
												SELECT 2, CAST(@Object AS VARCHAR(50))
											) t
											ORDER BY k, Subject),'')
									END)
							+ (CASE WHEN @MaxParam >= 1 AND @Pointer <= 1 THEN '/'+@param1 ELSE '' END)
							+ (CASE WHEN @MaxParam >= 2 AND @Pointer <= 2 THEN '/'+@param2 ELSE '' END)
							+ (CASE WHEN @MaxParam >= 3 AND @Pointer <= 3 THEN '/'+@param3 ELSE '' END)
							+ (CASE WHEN @MaxParam >= 4 AND @Pointer <= 4 THEN '/'+@param4 ELSE '' END)
							+ (CASE WHEN @MaxParam >= 5 AND @Pointer <= 5 THEN '/'+@param5 ELSE '' END)
							+ (CASE WHEN @MaxParam >= 6 AND @Pointer <= 6 THEN '/'+@param6 ELSE '' END)
							+ (CASE WHEN @MaxParam >= 7 AND @Pointer <= 7 THEN '/'+@param7 ELSE '' END)
							+ (CASE WHEN @MaxParam >= 8 AND @Pointer <= 8 THEN '/'+@param8 ELSE '' END)
							+ (CASE WHEN @MaxParam >= 9 AND @Pointer <= 9 THEN '/'+@param9 ELSE '' END)
		ELSE IF (@ApplicationName = 'presentation')
				-- Display as HTML
				SELECT	@ResponseURL = @ResponseURL + '&viewas=PresentationXML'
		ELSE
				-- Display as HTML
				SELECT	@ResponseURL = replace(@ResponseURL,'~/Profile/Profile.aspx','~/Profile/Display.aspx') + '&viewas=HTML'


		IF @ResponseRedirect = 0
			SELECT @ResponseURL = @ResponseURL + '&ContentType='+IsNull(@ResponseContentType,'') + '&StatusCode='+IsNull(cast(@ResponseStatusCode as varchar(50)),'')

	END

	/*
		Valid Rest Paths (T=text, N=numeric):

		T
		T/N
			T/N/N
				T/N/N/N
					T/N/N/N/T
				T/N/N/T
				T/N/N/T/T
					T/N/N/T/T/T
			T/N/T
			T/N/T/T
				T/N/T/T/N
					T/N/T/T/N/T
				T/N/T/T/T
				T/N/T/T/T/T
					T/N/T/T/T/T/T
		T/T/T
			T/T/T/N
				T/T/T/N/N
					T/T/T/N/N/T
				T/T/T/N/T
				T/T/T/N/T/T
					T/T/T/N/T/T/T
			T/T/T/T
			T/T/T/T/T
				T/T/T/T/T/N
					T/T/T/T/T/N/T
				T/T/T/T/T/T
				T/T/T/T/T/T/T
					T/T/T/T/T/T/T/T
	*/

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[SNA.Coauthor.UpdateSummary]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
	DECLARE @date DATETIME,@auditid UNIQUEIDENTIFIER, @rows int
	 
	select p.personid, --(case when numpublications > 0 then 1 else 0 end) 
	0 HasPublications,
			(case when isnull(s.clustersize,0)>1000 then 1 else 0 end) HasSNA,
			isnull(d.NumPeople,0) Reach1,
			isnull(r.NumPeople,0) Reach2,
			isnull(c.Closeness,0) Closeness,
			isnull(b.b,0) Betweenness
		into #cache_sna
		from [Profile.Cache].Person p
			left outer join (select * from [Profile.Cache].[SNA.Coauthor.Reach] where distance = 1) d on p.personid = d.personid
			left outer join (select * from [Profile.Cache].[SNA.Coauthor.Reach] where distance = 2) r on p.personid = r.personid
			left outer join (select personid, sum(cast(NumPeople as float)*Distance)/sum(cast(NumPeople as float)) closeness from [Profile.Cache].[SNA.Coauthor.Reach] where distance < 99 group by personid) c on p.personid = c.personid
			left outer join (select personid, sum(cast(NumPeople as int)) clustersize from [Profile.Cache].[SNA.Coauthor.Reach] where distance < 99 group by personid) s on p.personid = s.personid
			left outer join (select * from [Profile.Cache].[SNA.Coauthor.Betweenness]) b on p.personid = b.personid
	alter table #cache_sna add primary key (personid)

	BEGIN TRY
		BEGIN TRAN
			update p
				set p.HasPublications = s.HasPublications,
					p.HasSNA = s.HasSNA,
					p.Reach1 = s.Reach1,
					p.Reach2 = s.Reach2,
					p.Closeness = s.Closeness,
					p.Betweenness = s.Betweenness
				from [Profile.Cache].Person p inner join #cache_sna s on p.personid = s.personid
			SELECT @rows = @@ROWCOUNT
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
	 
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH

	 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Utility.NLP].[UpdateThesaurus]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- MeSH
	delete from [Utility.NLP].[Thesaurus] where Source = 1
	insert into [Utility.NLP].[Thesaurus] (Source, ConceptID, TermName)
		select 1, dense_rank() over (order by ConceptUI) ConceptID, TermName
		from (
			select ConceptUI, replace(TermName,',','') TermName
				from [Profile.Data].[Concept.Mesh.Term]
			union
			select ConceptUI, replace(DescriptorName,',','') DescriptorName
				from [Profile.Data].[Concept.Mesh.Term]
				where PreferredConceptYN = 'N' and ConceptPreferredTermYN = 'Y'
		) t

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[Support.GetHTML]
	@NodeID BIGINT,
	@EditMode BIT = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @str VARCHAR(MAX)

	DECLARE @PersonID INT
 	SELECT @PersonID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
			AND m.Class = 'http://xmlns.com/foaf/0.1/Person' AND m.InternalType = 'Person'

	IF @PersonID IS NOT NULL
	BEGIN

		if @editMode = 0
			set @str = 'Local representatives can answer questions about the Profiles website or help with editing a profile or issues with profile data. For assistance with this profile:'
		else
			set @str = 'Local representatives can help you modify your basic information above, including title and contact information, or answer general questions about Profiles. For assistance with this profile:'

		select @str = @str + (
				select ' '+s.html
					from [Profile.Module].[Support.HTML] s, (
						select m.SupportID, min(SortOrder) x 
							from [Profile.Cache].[Person.Affiliation] a, [Profile.Module].[Support.Map] m
							where a.instititutionname = m.institution and (a.departmentname = m.department or m.department = '')
								and a.PersonID = @PersonID
							group by m.SupportID
					) t
					where s.SupportID = t.SupportID
					order by t.x
					for xml path(''), type
			).value('(./text())[1]','nvarchar(max)')

	END

	SELECT @str HTML WHERE @str IS NOT NULL

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Framework.].[ResolveURL]
	@ApplicationName varchar(1000) = '',
    @param1 varchar(1000) = '',
	@param2 varchar(1000) = '',
	@param3 varchar(1000) = '',
	@param4 varchar(1000) = '',
	@param5 varchar(1000) = '',
	@param6 varchar(1000) = '',
	@param7 varchar(1000) = '',
	@param8 varchar(1000) = '',
	@param9 varchar(1000) = '',
	@SessionID uniqueidentifier = NULL,	 
	@RestURL varchar(MAX) = NULL,
	@UserAgent varchar(255) = NULL,
	@ContentType varchar(255) = NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Log request
	DECLARE @HistoryID INT
	INSERT INTO [User.Session].[History.ResolveURL]	(RequestDate, ApplicationName, param1, param2, param3, param4, param5, param6, param7, param8, param9, SessionID, RestURL, UserAgent, ContentType)
		SELECT GetDate(), @ApplicationName, @param1, @param2, @param3, @param4, @param5, @param6, @param7, @param8, @param9, @SessionID, @RestURL, @UserAgent, @ContentType
	SELECT @HistoryID = @@IDENTITY		 

	-- For dynamic sql
	DECLARE @sql nvarchar(max)

	-- Define variables needed to construct the output XML
	DECLARE @Resolved bit
	DECLARE @ErrorDescription varchar(max)
	DECLARE @ResponseURL varchar(1000)
	DECLARE @ResponseContentType varchar(255)
	DECLARE @ResponseStatusCode int
	DECLARE @ResponseRedirect bit
	DECLARE @ResponseIncludePostData bit

	-- Determine if this application has a custom resolver
	DECLARE @CustomResolver varchar(1000)
	SELECT @CustomResolver = Resolver
		FROM [Framework.].RestPath
		WHERE ApplicationName = @ApplicationName

	-- Resolve the URL
	SELECT @Resolved = 0
	IF @CustomResolver IS NOT NULL
	BEGIN
		-- Use a custom resolver
		SELECT @sql = 'EXEC ' + @CustomResolver 
			+ ' @ApplicationName = ''' + replace(@ApplicationName,'''','''''') + ''', '
			+ ' @param1 = ''' + replace(@param1,'''','''''') + ''', '
			+ ' @param2 = ''' + replace(@param2,'''','''''') + ''', '
			+ ' @param3 = ''' + replace(@param3,'''','''''') + ''', '
			+ ' @param4 = ''' + replace(@param4,'''','''''') + ''', '
			+ ' @param5 = ''' + replace(@param5,'''','''''') + ''', '
			+ ' @param6 = ''' + replace(@param6,'''','''''') + ''', '
			+ ' @param7 = ''' + replace(@param7,'''','''''') + ''', '
			+ ' @param8 = ''' + replace(@param8,'''','''''') + ''', '
			+ ' @param9 = ''' + replace(@param9,'''','''''') + ''', '
			+ ' @SessionID = ' + IsNull('''' + replace(@SessionID,'''','''''') + '''','NULL') + ', '
			+ ' @ContentType = ' + IsNull('''' + replace(@ContentType,'''','''''') + '''','NULL') + ', '
			+ ' @Resolved = @Resolved_OUT OUTPUT, '
			+ ' @ErrorDescription = @ErrorDescription_OUT OUTPUT, '
			+ ' @ResponseURL = @ResponseURL_OUT OUTPUT, '
			+ ' @ResponseContentType = @ResponseContentType_OUT OUTPUT, '
			+ ' @ResponseStatusCode = @ResponseStatusCode_OUT OUTPUT, '
			+ ' @ResponseRedirect = @ResponseRedirect_OUT OUTPUT, '
			+ ' @ResponseIncludePostData = @ResponseIncludePostData_OUT OUTPUT '
		EXEC sp_executesql @sql, 
			N'
				@Resolved_OUT bit OUTPUT,
				@ErrorDescription_OUT varchar(max) OUTPUT,
				@ResponseURL_OUT varchar(1000) OUTPUT,
				@ResponseContentType_OUT varchar(255) OUTPUT,
				@ResponseStatusCode_OUT int OUTPUT,
				@ResponseRedirect_OUT bit OUTPUT,
				@ResponseIncludePostData_OUT bit OUTPUT',
			@Resolved_OUT = @Resolved OUTPUT,
			@ErrorDescription_OUT = @ErrorDescription OUTPUT,
			@ResponseURL_OUT = @ResponseURL OUTPUT,
			@ResponseContentType_OUT = @ResponseContentType OUTPUT,
			@ResponseStatusCode_OUT = @ResponseStatusCode OUTPUT,
			@ResponseRedirect_OUT = @ResponseRedirect OUTPUT,
			@ResponseIncludePostData_OUT = @ResponseIncludePostData OUTPUT
	END
	ELSE
	BEGIN
		-- Use the default resolver
		SELECT	@Resolved = 1,
				@ErrorDescription = '', 
				@ResponseURL = BaseURL,
				@ResponseContentType = @ContentType,
				@ResponseStatusCode = 200,
				@ResponseRedirect = 0,
				@ResponseIncludePostData = 0
		    FROM [Framework.Alias].ApplicationBaseURL
			WHERE ApplicationName = @ApplicationName
		SELECT @ResponseURL = @ResponseURL + (CASE WHEN CHARINDEX('?',@ResponseURL) > 0 THEN '' ELSE '?' END)
			+ '&param1=' + @param1
			+ '&param2=' + @param2
			+ '&param3=' + @param3
			+ '&param4=' + @param4
			+ '&param5=' + @param5
			+ '&param6=' + @param6
			+ '&param7=' + @param7
			+ '&param8=' + @param8
			+ '&param9=' + @param9
	END
	-- Add standard parameters
	IF (@Resolved = 1) AND (@ResponseRedirect = 0)
	BEGIN
		SELECT @ResponseURL = @ResponseURL + (CASE WHEN CHARINDEX('?',@ResponseURL) > 0 THEN '' ELSE '?' END)
		SELECT @ResponseURL = @ResponseURL + '&SessionID=' + IsNull(CAST(@SessionID AS varchar(50)),'')
	END
	SELECT @ErrorDescription = IsNull(@ErrorDescription,'URL could not be resolved.')

	-- Log results
	UPDATE [User.Session].[History.ResolveURL]
		SET CustomResolver = @CustomResolver,
			Resolved = @Resolved,
			ErrorDescription = @ErrorDescription,
			ResponseURL = @ResponseURL,
			ResponseContentType = @ResponseContentType,
			ResponseStatusCode = @ResponseStatusCode,
			ResponseRedirect = @ResponseRedirect,
			ResponseIncludePostData = @ResponseIncludePostData
		WHERE HistoryID = @HistoryID

	-- Return results 
	SELECT	@Resolved Resolved, 
			@ErrorDescription ErrorDescription, 
			@ResponseURL ResponseURL,
			@ResponseContentType ResponseContentType,
			@ResponseStatusCode ResponseStatusCode,
			@ResponseRedirect ResponseRedirect,
			@ResponseIncludePostData ResponseIncludePostData,
			@SessionID RedirectHeaderSessionID


	/*
		Examples:

		EXEC [Framework.].[ResolveURL] @ApplicationName='profile', @param1='12345', @ContentType='application/rdf+xml'
		EXEC [Framework.].[ResolveURL] @ApplicationName='profile', @param1='12345', @param2='12345.rdf'
		EXEC [Framework.].[ResolveURL] @ApplicationName='profile', @param1='12345'
		EXEC [Framework.].[ResolveURL] @ApplicationName='display', @param1='12345', @SessionID = '16A199ED-07C5-436F-AB7D-0214792630A6'
		EXEC [Framework.].[ResolveURL] @ApplicationName='profile', @param1='12345', @param2='12345.rdf', @SessionID = '16A199ED-07C5-436F-AB7D-0214792630A6'

	*/

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Person.GetUnGeocodedAddresses]	 
AS
BEGIN
	SET NOCOUNT ON;	

SELECT DISTINCT addressstring
  FROM [Profile.Data].Person
 WHERE (ISNULL(latitude ,0)=0
 		OR geoscore = 0)
and addressstring<>''
and IsActive = 1


END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [RDF.Stage].[ProcessTriples]
	@ProcessAll bit = 1,
	@ShowCounts bit = 0,
	@ProcessLimit bigint = 1000000,
	@IsRunningInLoop bit = 0
AS

BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	/* 
 
	This stored procedure converts triples defined in [RDF.Stage].Triple into 
	records in [RDF.].Node and [RDF.].Triple and updates IsPublic and other attributes
	on existing records.
 
	The subject, predicate, and object of a triple can be defined in different ways:
		Subject
			Cat 0: sNodeID (from [RDF.].Node)
			Cat 1: sURI
			Cat 2: sNodeType (primary VIVO type, http://xmlns.com/foaf/0.1/Person), sInternalType (Profiles10 type, such as "Person"), sInternalID (personID=32213)
			Cat 3: sTripleID (from [RDF.].Triple -- a reitification)
			Cat 4: sStageTripleID (from [RDF.Stage.].Triple -- a reitification of a triple not yet loaded)
		Predicate
			Cat 0: pNodeID (from [RDF.].Node)
			Cat 1: pProperty (a VIVO property, such as http://www.w3.org/1999/02/22-rdf-syntax-ns#type or http://xmlns.com/foaf/0.1/firstName)
		Object
			Cat 0: oNodeID (from [RDF.].Node)
			Cat 1: oValue, oLanguage, oDataType, oObjectType (standard RDF literal [oObjectType=1], or just oValue if URI [oObjectType=0])
			Cat 2: oNodeType (primary VIVO type, http://xmlns.com/foaf/0.1/Person), oInternalType (Profiles10 type, such as "Person"), oInternalID (personID=32213)
			Cat 3: oTripleID (from [RDF.].Triple -- a reitification)
			Cat 4: oStageTripleID (from [RDF.Stage.].Triple -- a reitification of a triple not yet loaded)
			Cat 5: oStartTime, oEndTime, oTimePrecision (VIVO's DateTimeInterval, DateTimeValue, and DateTimeValuePrecision classes)
			Cat 6: oStartTime, oTimePrecision (VIVO's DateTimeValue, and DateTimeValuePrecision classes)
 
	The following are also related to a triple:
		sIsPublic = 1 (security of subject)
		pIsPublic = 1 (security of predicate)
		oIsPublic = 1 (security of object)
		tIsPublic = 1 (security of triple)
		Weight = 1 (float, strength of connection)
		SortOrder = 1 (should be a row_number() over (partition by subject, predicate order by ...))
 
	These field s are to help with processing:
		StageTripleID
		sValueHash
		pValueHash
		oValueHash
		TripleID
		TripleHash
		Reitification
		Status
 
	1. Determine the input categories for subject, predicate, and object in [RDF.Stage].Triple
	2. Create a distinct list of node definitions from [RDF.Stage].Triple
	3. Map each node definition to an existing NodeID or create a new node and get its NodeID
	4. Lookup the NodeID for each node definition in [RDF.Stage].Triple
	5. Update or insert triples
	6. Update node attributes
	7. Save a list of which stage triples were processed
 
	*/
 

	-- Turn off real-time indexing
	IF @IsRunningInLoop = 0
		ALTER FULLTEXT INDEX ON [RDF.].vwLiteral SET CHANGE_TRACKING OFF 


	--*******************************************************************************************
	--*******************************************************************************************
	-- Iterate through multiple calls to this procedure until all triples are processed
	--*******************************************************************************************
	--*******************************************************************************************


	if @ProcessAll = 1
	begin

		truncate table [RDF.Stage].[Triple.Map]
		
		declare @IterationResults table (NewNodes bigint, NewTriples bigint, FoundRecords bigint, ProcessedRecords bigint)
		declare @IterationCount int
		declare @IterationStart datetime
		declare @IterationMax int
		select @IterationCount = 0, @IterationMax = 1000
		while @IterationCount < @IterationMax
		begin
			select @IterationStart = getdate()
			insert into @IterationResults
				exec [RDF.Stage].[ProcessTriples] @ProcessAll = 0, @ShowCounts = 1, @ProcessLimit = @ProcessLimit, @IsRunningInLoop = 1
			if @ShowCounts = 1
				select * from @IterationResults
			if ((select count(*) from @IterationResults) = 0) or ((select ProcessedRecords from @IterationResults) = 0)
				select @IterationCount = @IterationMax
			insert into [rdf.stage].[Log.Triple] (CompleteDate, NewNodes, NewTriples, FoundRecords, ProcessedRecords, TimeElapsed)
				select getdate(), *, datediff(ms,@IterationStart,getdate())/1000.00000 from @IterationResults
			delete from @IterationResults
			set @IterationCount = @IterationCount + 1
		end

		-- Turn on real-time indexing
		ALTER FULLTEXT INDEX ON [RDF.].vwLiteral SET CHANGE_TRACKING AUTO;
		-- Kick off population FT Catalog and index
		ALTER FULLTEXT INDEX ON [RDF.].vwLiteral START FULL POPULATION 

		return

	end


	--*******************************************************************************************
	--*******************************************************************************************
	-- Start a single iteration
	--*******************************************************************************************
	--*******************************************************************************************

	declare @NewNodes bigint
	declare @NewTriples bigint
	declare @FoundRecords bigint
	declare @ProcessedRecords bigint
	select @NewNodes = 0, @NewTriples = 0, @FoundRecords = 0, @ProcessedRecords = 0
 
	create table #Debug (i int identity(0,1) primary key, x varchar(100), d datetime)

	--*******************************************************************************************
	--*******************************************************************************************
	-- 1. Determine the input categories for subject, predicate, and object in [RDF.Stage].Triple
	--*******************************************************************************************
	--*******************************************************************************************

	insert into #Debug (x,d) select '1',GetDate()

	select top (@ProcessLimit)
			t.StageTripleID,
				(case	when sNodeID is not null then 0
						when sURI is not null then 1
						when sNodeType is not null and sInternalType is not null and sInternalID is not null then 2
						when sTripleID is not null then 3
						when sStageTripleID is not null then 4
						else null end) sCategory,
				(case	when pNodeID is not null then 0
						when pProperty is not null then 1
						else null end) pCategory,
				(case	when oNodeID is not null then 0
						when oValue is not null and oObjectType is not null then 1
						when oNodeType is not null and oInternalType is not null and oInternalID is not null then 2
						when oTripleID is not null then 3
						when oStageTripleID is not null then 4
						when oStartTime is not null and oEndTime is not null and oTimePrecision is not null then 5
						when oStartTime is not null and oTimePrecision is not null then 6
						else null end) oCategory,
				(case	when sNodeID is not null then null
						when sURI is not null then CONVERT(binary(20),HASHBYTES('sha1',CONVERT(nvarchar(4000),N'"'+replace(isnull(sURI,N''),N'"',N'\"')+N'"'))) 
						when sNodeType is not null and sInternalType is not null and sInternalID is not null then CONVERT(binary(20),HASHBYTES('sha1',CONVERT(nvarchar(4000),N'"'+replace(isnull(sNodeType+'^^'+sInternalType+'^^'+sInternalID,N''),N'"',N'\"')+N'"'))) 
						when sTripleID is not null then CONVERT(binary(20),HASHBYTES('sha1',CONVERT(nvarchar(4000),N'"'+replace(isnull('#TRIPLE'+cast(sTripleID as varchar(50)),N''),N'"',N'\"')+N'"')))
						when sStageTripleID is not null then CONVERT(binary(20),HASHBYTES('sha1',CONVERT(nvarchar(4000),N'"'+replace(isnull('#STAGETRIPLE'+cast(sStageTripleID as varchar(50)),N''),N'"',N'\"')+N'"')))
						else null end) sValueHash,
				(case	when pNodeID is not null then null
						when pProperty is not null then CONVERT(binary(20),HASHBYTES('sha1',CONVERT(nvarchar(4000),N'"'+replace(isnull(pProperty,N''),N'"',N'\"')+N'"')))
						else null end) pValueHash,
				(case	when oNodeID is not null then null
						when oValue is not null and oObjectType is not null then CONVERT(binary(20),HASHBYTES('sha1',CONVERT(nvarchar(4000),N'"'+replace(isnull(oValue,N''),N'"',N'\"')+'"'+IsNull(N'"@'+replace(oLanguage,N'@',N''),N'')+IsNull(N'"^^'+replace(oDataType,N'^',N''),N''))))
						when oNodeType is not null and oInternalType is not null and oInternalID is not null then CONVERT(binary(20),HASHBYTES('sha1',CONVERT(nvarchar(4000),N'"'+replace(isnull(oNodeType+'^^'+oInternalType+'^^'+oInternalID,N''),N'"',N'\"')+N'"'))) 
						when oTripleID is not null then CONVERT(binary(20),HASHBYTES('sha1',CONVERT(nvarchar(4000),N'"'+replace(isnull('#TRIPLE'+cast(oTripleID as varchar(50)),N''),N'"',N'\"')+N'"')))
						when oStageTripleID is not null then CONVERT(binary(20),HASHBYTES('sha1',CONVERT(nvarchar(4000),N'"'+replace(isnull('#STAGETRIPLE'+cast(oStageTripleID as varchar(50)),N''),N'"',N'\"')+N'"')))
						else null end) oValueHash,
			sNodeID, sViewSecurityGroup, sEditSecurityGroup,
			pNodeID, pViewSecurityGroup, pEditSecurityGroup,
			oNodeID, oViewSecurityGroup, oEditSecurityGroup,
			oObjectType, TripleHash, 
			TripleID, tViewSecurityGroup,
			Weight, SortOrder, Reitification, Graph, 0 Status
		into #TripleHash
		from [RDF.Stage].Triple t
		where status is null
		order by StageTripleID

	select @FoundRecords = @@ROWCOUNT
 
 
	--***************************************************************** **************************
	--*******************************************************************************************
	-- 2. Create a distinct list of node definitions from [RDF.Stage].Triple
	--*******************************************************************************************
	--*******************************************************************************************
 
	insert into #Debug (x,d) select '2',GetDate()

	create table #nodes (
		Category tinyint,
		NodeType nvarchar(400),
		InternalType nvarchar(100),
		InternalID nvarchar(100),
		InternalHash binary(20),
		Value nvarchar(max),
		Language nvarchar(255),
		DataType nvarchar(255),
		ObjectType bit,
		ValueHash binary(20),
		StartTime datetime,
		EndTime datetime,
		TimePrecision nvarchar(255),
		TripleID bigint,
		StageTripleID bigint,
		NodeID bigint,
		Status tinyint
	)

	select ValueHash, Category, StageTripleID, maxObjectType ObjectType, n
		into #ntemp
		from (
			select *, row_number() over (partition by ValueHash order by StageTripleID, n) k,
				max(ObjectType) over (partition by ValueHash) maxObjectType
			from (
				select (case when n in (0,1,2) then 1 when n in (3,4) then 2 when n in (5,6) then 3 when n in (7,8) then 4 else null end) Category,
					(case when n in (0,3,5,7) then sValueHash when n=1 then pValueHash when n in (2,4,6,8) then oValueHash else null end) ValueHash, 
					StageTripleID, 
					(case when n=2 then cast(oObjectType as tinyint) else 0 end) ObjectType,
					n
				from #TripleHash t, [Utility.Math].N n
				where n <= 8
					and (	(n=0 and sCategory=1) or 
							(n=1 and pCategory=1) or 
							(n=2 and oCategory=1) or
							(n=3 and sCategory=2) or
							(n=4 and oCategory=2) or
							(n=5 and sCategory=3) or
							(n=6 and oCategory=3) or
							(n=7 and sCategory=4) or
							(n=8 and oCategory=4)
						)
			) t
		) t
		where k = 1

	insert into #Debug (x,d) select '2.2',GetDate()

	-- Use the pointers to create a distinct list of nodes.
	insert into #nodes (Category, NodeType, InternalType, InternalID, InternalHash, Value, Language, DataType, ObjectType, ValueHash, TripleID, StageTripleID, Status)
		select n.Category, 
			(case when n=3 then sNodeType when n=4 then oNodeType else null end),
			(case when n=3 then sInternalType when n=4 then oInternalType else null end),
			(case when n=3 then sInternalID when n=4 then oInternalID else null end),
			n.ValueHash,
			(case when n=0 then sURI when n=1 then pProperty when n=2 then oValue else null end),
			(case when n=2 then oLanguage else null end),
			(case when n=2 then oDataType else null end),
			n.ObjectType, 
			(case when n.Category=1 then n.ValueHash else null end),
			(case when n=5 then sTripleID when n=6 then oTripleID else null end),
			(case when n=7 then sStageTripleID when n=8 then oStageTripleID else null end)m,
			0
		from [RDF.Stage].Triple t, #ntemp n
		where t.StageTripleID = n.StageTripleID
	--create nonclustered index idx_ValueHash on #nodes(Category,ValueHash) include (NodeID)
	--create nonclustered index idx_InternalHash on #nodes(Category,InternalHash) include (NodeID)

	insert into #Debug (x,d) select '2.3',GetDate()

	create nonclustered index idx_ValueHash on #nodes(Category,ValueHash)
	create nonclustered index idx_InternalHash on #nodes(Category,InternalHash)
	create nonclustered index idx_node on #nodes(Category,NodeID)
 
 
	--*******************************************************************************************
	--*******************************************************************************************
	-- 3. Map each node definition to an existing NodeID or create a new node and get its NodeID
	--*******************************************************************************************
	--*******************************************************************************************

	insert into #Debug (x,d) select '3',GetDate()

	-- Lookup the base URI
	declare @baseURI nvarchar(400)
	select @baseURI = value from [Framework.].Parameter where ParameterID = 'baseURI'
 
	--------------------------------------------------
	-- Category 1 (URI, Property, or Value)
	--------------------------------------------------

	insert into #Debug (x,d) select '3.1',GetDate()

	-- Find existing NodeIDs
	update n
		set n.NodeID = m.NodeID
		from #nodes n, [RDF.].Node m
		where n.Category = 1
			and n.ValueHash = m.ValueHash
 
	-- Create new nodes
	insert into [RDF.].Node (ViewSecurityGroup, EditSecurityGroup, ValueHash, Language, DataType, Value, ObjectType)
		select 0, 0, ValueHash, Language, DataType, Value, ObjectType
		from #nodes
		where Category = 1 and NodeID is null
	select @NewNodes = @NewNodes + @@ROWCOUNT
	update n
		set n.NodeID = m.NodeID
		from #nodes n, [RDF.].Node m
		where n.Category = 1 and n.NodeID is null
			and n.ValueHash = m.ValueHash
 
	--------------------------------------------------
	-- Category 2 (InternalID)
	--------------------------------------------------

	insert into #Debug (x,d) select '3.2',GetDate()
 
	-- Find existing NodeIDs
	update n
		set n.NodeID = m.NodeID
		from #nodes n, [RDF.Stage].InternalNodeMap m
		where n.Category = 2
			and n.InternalHash = m.InternalHash

	insert into #Debug (x,d) select '3.2.2',GetDate()
 
	-- Create new nodes for new internal IDs
	insert into [RDF.Stage].InternalNodeMap (Class, InternalType, InternalID, Status, InternalHash)
		select NodeType, InternalType, InternalID, 0, InternalHash
		from #nodes
		where Category = 2 and NodeID is null

	insert into #Debug (x,d) select '3.2.3',GetDate()

	update [RDF.Stage].InternalNodeMap
		set ValueHash = CONVERT(binary(20),HASHBYTES('sha1',CONVERT(nvarchar(4000),N'"#INM'+cast(InternalNodeMapID as nvarchar(50))+N'"'))), 
			status = 1
		where status = 0

	insert into #Debug (x,d) select '3.2.4',GetDate()

	insert into [RDF.].Node (ViewSecurityGroup, EditSecurityGroup, ValueHash, Value, InternalNodeMapID, ObjectType)
		select 0, 0, ValueHash,
			'#INM'+cast(InternalNodeMapID as nvarchar(50)),
			InternalNodeMapID, 0
		from [RDF.Stage].InternalNodeMap
		where status = 1
	select @NewNodes = @NewNodes + @@ROWCOUNT

	insert into #Debug (x,d) select '3.2.5',GetDate()

	update i
		set i.NodeID = n.NodeID, i.Status = 2,
			i.ValueHash = CONVERT(binary(20),HASHBYTES('sha1',CONVERT(nvarchar(4000),N'"'+@baseURI+cast(n.NodeID as nvarchar(50))+N'"'))) 
		from [RDF.Stage].InternalNodeMap i, [RDF.].Node n
		where i.Status = 1 and i.ValueHash = n.ValueHash

	insert into #Debug (x,d) select '3.2.6',GetDate()

	update n
		set n.Value = @baseURI+cast(n.NodeID as nvarchar(50)),
			n.ValueHash = i.ValueHash
		from [RDF.Stage].InternalNodeMap i, [RDF.].Node n
		where i.Status = 2 and i.NodeID = n.NodeID

	insert into #Debug (x,d) select '3.2.7',GetDate()

	update [RDF.Stage].InternalNodeMap
		set Status = 3
		where Status = 2

	insert into #Debug (x,d) select '3.2.8',GetDate()

	update n
		set n.NodeID = m.NodeID
		from #nodes n, [RDF.Stage].InternalNodeMap m
		where n.Category = 2 and n.NodeID is null
			and n.InternalHash = m.InternalHash

	--------------------------------------------------
	-- Category 4 (StageTripleID - Map to TripleID)
	--------------------------------------------------

	insert into #Debug (x,d) select '3.4',GetDate()
 
	update n
		set	n.TripleID = IsNull(m.TripleID,n.TripleID), 
			--n.InternalHash = (case when m.TripleID IS NULL then n.InternalHash else CONVERT(binary(20),HASHBYTES('sha1',CONVERT(nvarchar(4000),N'"#TRIPLE'+cast(m.TripleID as varchar(50))+N'"'))) end),
			n.Category = (case when m.TripleID IS NULL then 99 else 4 end)
		from #nodes n LEFT OUTER JOIN [RDF.Stage].[Triple.Map] m ON n.StageTripleID = m.StageTripleID
		where n.Category = 4

	--------------------------------------------------
	-- Category 3 (TripleID - Reitification)
	--------------------------------------------------

	insert into #Debug (x,d) select '3.3',GetDate()
 
	-- Find existing NodeIDs
	update n
		set n.NodeID = t.Reitification, n.Status = 2
		from #nodes n, [RDF.].Triple t
		where n.Category IN (3,4) and n.TripleID = t.TripleID and t.Reitification is not null

	insert into #Debug (x,d) select '3.3.2',GetDate()
 
	-- Create new nodes for new triples
	insert into [RDF.].Node (ViewSecurityGroup, EditSecurityGroup, ValueHash, Value, ObjectType)
		select 0, 0, InternalHash,
			'#TRIPLE'+cast(TripleID as nvarchar(50)),
			0
		from #nodes
		where Category IN (3,4) and Status = 0
	select @NewNodes = @NewNodes + @@ROWCOUNT

	insert into #Debug (x,d) select '3.3.3',GetDate()

	update i
		set i.NodeID = n.NodeID,
			i.ValueHash = CONVERT(binary(20),HASHBYTES('sha1',CONVERT(nvarchar(4000),N'"'+@baseURI+cast(n.NodeID as nvarchar(50))+N'"'))),
			i.Status = 1
		from #nodes i, [RDF.].Node n
		where i.Category IN (3,4) and i.Status = 0 and i.InternalHash = n.ValueHash

	insert into #Debug (x,d) select '3.3.4',GetDate()

	update n
		set n.Value = @baseURI+cast(n.NodeID as nvarchar(50)),
			n.ValueHash = i.ValueHash
		from #nodes i, [RDF.].Node n
		where i.Category IN (3,4) and i.Status = 1 and i.NodeID = n.NodeID

	insert into #Debug (x,d) select '3.3.5',GetDate()

	update t
		set t.Reitification = i.NodeID
		from #nodes i, [RDF.].Triple t
		where i.Category IN (3,4) and i.Status = 1 and i.TripleID = t.TripleID

	insert into #Debug (x,d) select '3.3.6',GetDate()

	update #nodes
		set Status = 2
		where Category IN (3,4) and Status = 1
 
 
	--*******************************************************************************************
	--*******************************************************************************************
	-- 4. Lookup the NodeID for each node definition
	--*******************************************************************************************
	--*******************************************************************************************

	insert into #Debug (x,d) select '4',GetDate()

	select t.StageTripleID,
			t.sCategory, t.sNodeID, t.sViewSecurityGroup, t.sEditSecurityGroup,
			t.pCategory, t.pNodeID, t.pViewSecurityGroup, t.pEditSecurityGroup,
			t.oCategory, t.oNodeID, t.oViewSecurityGroup, t.oEditSecurityGroup, t.oObjectType,
			convert(binary(20),NULL) TripleHash,
			t.TripleID, t.tViewSecurityGroup, t.Weight, t.SortOrder, t.Reitification,
			t.sValueHash, t.pValueHash, t.oValueHash, t.Graph,
			1 Status
		into #TripleCompact
		from #TripleHash t
	update t
		set t.sNodeID = IsNull(t.sNodeID,s.NodeID),
			t.pNodeID = IsNull(t.pNodeID,p.NodeID),
			t.oNodeID = IsNull(t.oNodeID,o.NodeID)
		from #TripleCompact t
			left outer join #nodes s on t.sNodeID is null and t.sCategory = s.Category and t.sValueHash = s.InternalHash
			left outer join #nodes p on t.pNodeID is null and t.pCategory = p.Category and t.pValueHash = p.InternalHash
			left outer join #nodes o on t.oNodeID is null and t.oCategory = o.Category and t.oValueHash = o.InternalHash
	delete
		from #TripleCompact
		where sNodeID IS NULL OR pNodeID IS NULL OR oNodeID IS NULL
	update #TripleCompact
		set TripleHash = 			
			convert(binary(20),HashBytes('sha1',
				convert(nvarchar(max),
					+N'"'
					+N'<#'+convert(nvarchar(max),sNodeID)+N'> '
					+N'<#'+convert(nvarchar(max),pNodeID)+N'> '
					+N'<#'+convert(nvarchar(max),oNodeID)+N'> .'
					+N'"'
					+N'^^http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement'
				)
			))
	create nonclustered index idx_status on #TripleCompact (status)

 
	--*******************************************************************************************
	--*******************************************************************************************
	-- 5. Update or insert triples
	--*******************************************************************************************
	--*******************************************************************************************

	insert into #Debug (x,d) select '5',GetDate()

	-------------------------------------
	-- Existing triples
	-------------------------------------

	insert into #Debug (x,d) select '5.1',GetDate()

	-- Find existing TripleIDs
	update t
		set t.TripleID = v.TripleID, t.status = 2
		from #TripleCompact t, [RDF.].Triple v
		where t.TripleHash = v.TripleHash and t.status = 1
	-- Update attributes of existing TripleIDs
	update v
		set v.ViewSecurityGroup = t.ViewSecurityGroup, v.Weight = t.Weight, v.SortOrder = t.SortOrder
		from [RDF.].Triple v, (
			select TripleID, min(tViewSecurityGroup) ViewSecurityGroup, max(Weight) Weight, min(SortOrder) SortOrder
			from #TripleCompact
			where status = 2
			group by TripleID
		) t
		where v.TripleID = t.TripleID
			and (v.ViewSecurityGroup <> t.ViewSecurityGroup OR v.Weight <> t.Weight OR v.SortOrder <> t.SortOrder)

	-------------------------------------
	-- New triples without dependencies
	-------------------------------------

	insert into #Debug (x,d) select '5.2',GetDate()

	-- Create new triples
	insert into [RDF.].Triple (ViewSecurityGroup, Subject, Predicate, Object, TripleHash, Weight, ObjectType, SortOrder, Graph)
		select min(tViewSecurityGroup), sNodeID, pNodeID, oNodeID, TripleHash, max(Weight), max(cast(oObjectType as tinyint)), min(SortOrder), min(Graph)
			from #TripleCompact
			where status = 1
			group by sNodeID, pNodeID, oNodeID, TripleHash
	select @NewTriples = @NewTriples + @@ROWCOUNT

	insert into #Debug (x,d) select '5.2.1',GetDate()

	update t
		set t.TripleID = v.TripleID, t.status = 2
		from #TripleCompact t, [RDF.].Triple v
		where t.status = 1 and t.TripleHash = v.TripleHash


	--*******************************************************************************************
	--*******************************************************************************************
	-- 6. Update node attributes
	--*******************************************************************************************
	--*******************************************************************************************

	insert into #Debug (x,d) select '6',GetDate()
 
	create table #nAttributes (
		NodeID bigint primary key,
		ViewSecurityGroup bigint,
		EditSecurityGroup bigint,
		ObjectType bit
	)
	insert into #nAttributes (NodeID, ViewSecurityGroup, EditSecurityGroup, ObjectType)
		select NodeID, min(ViewSecurityGroup), min(EditSecurityGroup), max(ObjectType)
		from (
			select	(case when n=0 then sNodeID when n=1 then pNodeID else oNodeID end) NodeID, 
					(case when n=0 then sViewSecurityGroup when n=1 then pViewSecurityGroup else oViewSecurityGroup end) ViewSecurityGroup, 
					(case when n=0 then sEditSecurityGroup when n=1 then pEditSecurityGroup else oEditSecurityGroup end) EditSecurityGroup, 
					(case when n=2 then cast(oObjectType as tinyint) else 0 end) ObjectType
			from #TripleCompact t, [Utility.Math].N n
			where n <= 2
				and ((n=0 and sNodeID is not null) or (n=1 and pNodeID is not null) or (n=2 and oNodeID is not null))
		) t
		group by NodeID
	update n
		set n.ViewSecurityGroup = a.ViewSecurityGroup, n.EditSecurityGroup = a.EditSecurityGroup, n.ObjectType = a.ObjectType
		from [RDF.].Node n, #nAttributes a
		where n.NodeID = a.NodeID
			and (n.ViewSecurityGroup <> a.ViewSecurityGroup OR n.EditSecurityGroup <> a.EditSecurityGroup OR n.ObjectType <> a.ObjectType)
	update t
		set t.ObjectType = a.ObjectType
		from [RDF.].Triple t, #nAttributes a
		where t.Object = a.NodeID 
			and (t.ObjectType <> a.ObjectType)


	--*******************************************************************************************
	--*******************************************************************************************
	-- 7. Save a list of which stage triples were processed
	--*******************************************************************************************
	--*******************************************************************************************

	insert into #Debug (x,d) select '7.1',GetDate()

	insert into [RDF.Stage].[Triple.Map] (StageTripleID, TripleID)
		select StageTripleID, TripleID
			from #TripleCompact
			where status = 2

	insert into #Debug (x,d) select '7.2',GetDate()

	update t
		set t.Status = (case when c.status = 2 then 2 else null end)
		from [rdf.stage].triple t
			INNER JOIN #TripleHash p ON t.StageTripleID = p.StageTripleID
			LEFT OUTER JOIN #TripleCompact c ON t.StageTripleID = c.StageTripleID


	--*******************************************************************************************
	--*******************************************************************************************
	-- Wrap up
	--*******************************************************************************************
	--*******************************************************************************************

	insert into #Debug (x,d) select 'X',GetDate()

	/*
		select q.*, datediff(ms,q.d,r.d)
		from #Debug q, #Debug r
		where q.i = r.i-1
	*/

	if @ShowCounts = 1
	begin
		select @ProcessedRecords = (select count(*) from #TripleCompact where status = 2)
		select @NewNodes NewNodes, @NewTriples NewTriples, @FoundRecords FoundRecords, @ProcessedRecords RecordsProcessed
	end

	IF @IsRunningInLoop = 0
	BEGIN
		-- Turn on real-time indexing
		ALTER FULLTEXT INDEX ON [RDF.].vwLiteral SET CHANGE_TRACKING AUTO;
	 
		-- Kick off population FT Catalog and index
		ALTER FULLTEXT INDEX ON [RDF.].vwLiteral START FULL POPULATION 
	END
	 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [RDF.Stage].[ProcessDataMap]
	@DataMapID INT = NULL,
	@DataMapGroupMin INT = NULL,
	@DataMapGroupMax INT = NULL,
	@AutoFeedOnly BIT = 1,
	@InternalIdIn NVARCHAR(MAX) = NULL,
	@ShowCounts BIT = 0,
	@SaveLog BIT = 1,
	@TurnOffIndexing BIT = 1
AS
 
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	--*******************************************************************************************
	--*******************************************************************************************
	-- Create a queue of DataMap items to process
	--*******************************************************************************************
	--*******************************************************************************************

	CREATE TABLE #Queue(DataMapID  INT )
	IF @DataMapID IS NULL
	BEGIN
		INSERT INTO #Queue
		SELECT DataMapID			
			FROM [Ontology.].DataMap
			WHERE DataMapGroup >= IsNull(@DataMapGroupMin,DataMapGroup)
				AND DataMapGroup <= IsNull(@DataMapGroupMax,DataMapGroup)
				AND (@AutoFeedOnly = 0 OR IsAutoFeed = 1)
			ORDER BY DataMapID
	END 
	ELSE 
	BEGIN
		INSERT INTO #Queue
		SELECT @DataMapID  
	END

	--*******************************************************************************************
	--*******************************************************************************************
	-- Loop through each DataMap item in the queue
	--*******************************************************************************************
	--*******************************************************************************************

	-- Turn off real-time indexing
	IF @TurnOffIndexing = 1
		ALTER FULLTEXT INDEX ON [RDF.].vwLiteral SET CHANGE_TRACKING OFF 

	-- Do the loop	
	WHILE (SELECT COUNT(*) FROM #Queue) > 0
	BEGIN
		
		SELECT @DataMapID = (SELECT TOP 1 DataMapID FROM #Queue)
		
		DECLARE @StartDate DATETIME
		SELECT @StartDate = GetDate()

		DECLARE @NewNodes BIGINT
		DECLARE @UpdatedNodes BIGINT
		DECLARE @ExistingNodes BIGINT
		DECLARE @DeletedNodes BIGINT
		DECLARE @TotalNodes BIGINT
		DECLARE @NewTriples BIGINT
		DECLARE @UpdatedTriples BIGINT
		DECLARE @ExistingTriples BIGINT
		DECLARE @DeletedTriples BIGINT
		DECLARE @TotalTriples BIGINT

		SELECT	@NewNodes=0, @UpdatedNodes=0, @ExistingNodes=0, @DeletedNodes=0, @TotalNodes=0,
				@NewTriples=0, @UpdatedTriples=0, @ExistingTriples=0, @DeletedTriples=0, @TotalTriples=0

		DECLARE @s nvarchar(max)

		DECLARE @baseURI NVARCHAR(400)
		SELECT @baseURI = value FROM [Framework.].Parameter WHERE ParameterID = 'baseURI'

		-- Determine the DataMapType and validate the record
		DECLARE @DataMapType INT
		SELECT @DataMapType = (CASE	WHEN (MapTable IS NULL) OR (Class IS NULL) OR (sInternalType IS NULL) OR (sInternalID IS NULL) THEN NULL
									WHEN Property IS NULL THEN 1
									WHEN (NetworkProperty IS NULL) 
											AND (oClass IS NOT NULL) AND (oInternalID IS NOT NULL) AND (oInternalID IS NOT NULL) THEN 2
									WHEN (NetworkProperty IS NULL) 
											AND (oValue IS NOT NULL) THEN 3
									WHEN (NetworkProperty IS NOT NULL) 
											AND (cInternalID IS NOT NULL) AND (cInternalID IS NOT NULL) AND (cInternalID IS NOT NULL) 
											AND (oClass IS NOT NULL) AND (oInternalID IS NOT NULL) AND (oInternalID IS NOT NULL) THEN 4
									WHEN (NetworkProperty IS NOT NULL) 
											AND (cInternalID IS NOT NULL) AND (cInternalID IS NOT NULL) AND (cInternalID IS NOT NULL) 
											AND (oValue IS NOT NULL) THEN 5
									ELSE NULL END)
			FROM [Ontology.].DataMap
			WHERE DataMapID = @DataMapID


		--*******************************************************************************************
		--*******************************************************************************************
		-- DataMapType = 1 (Nodes)
		--*******************************************************************************************
		--*******************************************************************************************

		IF @DataMapType = 1
		BEGIN

			SELECT @s = ''
					+'SELECT Class, InternalType, InternalID, '
					+'		coalesce(max(case when ViewSecurityGroup < 0 then ViewSecurityGroup else null end),max(ViewSecurityGroup),-1) ViewSecurityGroup, '
					+'		coalesce(max(case when EditSecurityGroup < 0 then EditSecurityGroup else null end),max(EditSecurityGroup),-40) EditSecurityGroup, '
					+'		NULL InternalHash '
					--+'		HASHBYTES(''sha1'',N''"''+CAST(replace(Class+N''^^''+InternalType+N''^^''+InternalID,N''"'',N''\"'') AS NVARCHAR(MAX))+N''"'') InternalHash '
					+'	FROM ('
					+'		SELECT '
					+'			'''+replace(Class,'''','')+''' Class,'
					+'			'''+replace(sInternalType,'''','')+''' InternalType,'
					+'			CAST('+sInternalID+' AS NVARCHAR(300)) InternalID,'
					+'			'+IsNull(ViewSecurityGroup,'NULL')+' ViewSecurityGroup,'
					+'			'+IsNull(EditSecurityGroup,'NULL')+' EditSecurityGroup'
					+'		FROM '+MapTable
					+(CASE WHEN @InternalIdIn IS NOT NULL THEN 'WHERE '+sInternalID+' IN ('+@InternalIdIn+')' ELSE '' END)
					+'	) t'
					+'	WHERE Class IS NOT NULL AND InternalType IS NOT NULL AND InternalID IS NOT NULL '
					+'	GROUP BY Class, InternalType, InternalID '
				FROM [Ontology.].DataMap
				WHERE DataMapID = @DataMapID

			-- Get the nodes
			CREATE TABLE #Node (
				Class nvarchar(400),
				InternalType nvarchar(300),
				InternalID nvarchar(100),
				ViewSecurityGroup bigint,
				EditSecurityGroup bigint,
				InternalHash binary(20)
			)
			INSERT INTO #Node (Class, InternalType, InternalID, ViewSecurityGroup, EditSecurityGroup, InternalHash)
				EXEC sp_executesql @s
			SELECT @TotalNodes = @@ROWCOUNT

			CREATE NONCLUSTERED INDEX idx_ClassTypeID on #Node(Class,InternalType,InternalID)

			-- Update security groups of deleted nodes
			IF @InternalIdIn IS NULL
			BEGIN
				UPDATE n
					SET	n.ViewSecurityGroup = 0,
						n.EditSecurityGroup = -50
					FROM [RDF.Stage].InternalNodeMap m 
						INNER JOIN [Ontology.].DataMap o ON m.Class = o.Class AND m.InternalType = o.sInternalType and o.DataMapID = @DataMapID
						INNER JOIN [RDF.].Node n ON m.NodeID = n.NodeID
						LEFT OUTER JOIN #Node x ON m.Class = x.Class AND m.InternalType = x.InternalType and m.InternalID = x.InternalID
					WHERE x.Class IS NULL
			END
			SELECT @DeletedNodes = @@ROWCOUNT

			-- Update security groups of existing nodes if needed
			UPDATE n
				SET	n.ViewSecurityGroup = IsNull(x.ViewSecurityGroup,n.ViewSecurityGroup),
					n.EditSecurityGroup = IsNull(x.EditSecurityGroup,n.EditSecurityGroup)
				FROM [RDF.Stage].InternalNodeMap m 
					INNER JOIN #Node x ON m.Class = x.Class AND m.InternalType = x.InternalType and m.InternalID = x.InternalID
					INNER JOIN [RDF.].Node n ON m.NodeID = n.NodeID
						AND (n.ViewSecurityGroup <> IsNull(x.ViewSecurityGroup,n.ViewSecurityGroup)
								OR n.EditSecurityGroup <> IsNull(x.EditSecurityGroup,n.EditSecurityGroup))
			SELECT @UpdatedNodes = @@ROWCOUNT

			-- Create new nodes
			INSERT INTO [RDF.Stage].InternalNodeMap (Class, InternalType, InternalID, ViewSecurityGroup, EditSecurityGroup, Status, InternalHash)
				SELECT Class, InternalType, InternalID, IsNull(ViewSecurityGroup,-1), IsNull(EditSecurityGroup,-40), 0 Status,
						HASHBYTES('sha1',N'"'+CAST(replace(Class+N'^^'+InternalType+N'^^'+InternalID,N'"',N'\"') AS NVARCHAR(4000))+N'"') InternalHash
					FROM #Node x
					WHERE NOT EXISTS (
						SELECT *
						FROM [RDF.Stage].InternalNodeMap m
						WHERE m.Class = x.Class AND m.InternalType = x.InternalType and m.InternalID = x.InternalID
					)
			INSERT INTO [RDF.].Node (ValueHash, Language, DataType, Value, InternalNodeMapID, ObjectType, ViewSecurityGroup, EditSecurityGroup)
				SELECT InternalHash, NULL, NULL, Class+N'^^'+InternalType+N'^^'+InternalID, InternalNodeMapID, 0, ViewSecurityGroup, EditSecurityGroup
					FROM [RDF.Stage].InternalNodeMap
					WHERE Status = 0
			UPDATE m
				SET	m.NodeID = n.NodeID, 
					m.ValueHash = HASHBYTES('sha1',N'"'+@baseURI+CAST(n.NodeID AS NVARCHAR(50))+N'"')
				FROM [RDF.Stage].InternalNodeMap m, [RDF.].Node n
				WHERE m.Status = 0 AND m.InternalHash = n.ValueHash
			UPDATE n
				SET n.ValueHash = m.ValueHash, n.Value = @baseURI+CAST(n.NodeID AS NVARCHAR(50))
				FROM [RDF.Stage].InternalNodeMap m, [RDF.].Node n
				WHERE m.Status = 0 AND m.NodeID = n.NodeID
			UPDATE [RDF.Stage].InternalNodeMap
				SET ViewSecurityGroup = NULL, EditSecurityGroup = NULL, Status = 3
				WHERE Status = 0
			SELECT @NewNodes = @@ROWCOUNT
			
			SELECT @ExistingNodes = @TotalNodes - @NewNodes

			DROP TABLE #Node

		END

		--*******************************************************************************************
		--*******************************************************************************************
		-- DataMapType IN (2,3,4,5) (Triples)
		--*******************************************************************************************
		--*******************************************************************************************

		IF @DataMapType IN (2,3,4,5)
		BEGIN
			CREATE TABLE #Triple (
				Subject bigint,
				Predicate bigint,
				Object bigint,
				TripleID bigint,
				Language nvarchar(255),
				DataType nvarchar(255),
				Value nvarchar(max),
				ValueHash binary(20),
				Weight float,
				SortOrder int,
				ObjectType bit,
				ViewSecurityGroup bigint,
				EditSecurityGroup bigint,
				ReitificationTripleID bigint,
				Reitification bigint,
				TripleHash binary(20),
				Graph bigint,
				Status tinyint
			)
			CREATE NONCLUSTERED INDEX idx_status on #Triple(Status)

			/*
			Statuses:
			0 - Update triple
			1 - Delete triple
			2 - New triple from entity
			3 - New triple from value
			4 - New triple from reitification and entity
			5 - New triple from reitification and value
			*/		

			DECLARE @ObjectType BIT
			DECLARE @PropertyNode BIGINT
			SELECT @ObjectType = oObjectType, @PropertyNode = _PropertyNode
				FROM [Ontology.].DataMap
				WHERE DataMapID = @DataMapID
		
			SELECT @s = '
						SELECT 
							'''+replace(Class,'''','')+''' sClass,
							'''+replace(sInternalType,'''','')+''' sInternalType,
							CAST('+sInternalID+' AS NVARCHAR(300)) sInternalID,
							'+IsNull(cast(_NetworkPropertyNode as nvarchar(50)),'NULL')+' NetworkPredicate,
							'+cast(_PropertyNode as nvarchar(50))+' predicate,
							'+IsNull(''''+replace(cClass,'''','')+'''','NULL')+' cClass,
							'+IsNull(''''+replace(cInternalType,'''','')+'''','NULL')+' cInternalType,
							CAST('+IsNull(cInternalID,'NULL')+' AS NVARCHAR(300)) cInternalID,
							'+IsNull(''''+replace(oClass,'''','')+'''','NULL')+' oClass,
							'+IsNull(''''+replace(oInternalType,'''','')+'''','NULL')+' oInternalType,
							CAST('+IsNull(oInternalID,'NULL')+' AS NVARCHAR(300)) oInternalID,
							CAST('+IsNull(''''+replace(oLanguage,'''','')+'''','NULL')+' AS NVARCHAR(255)) Language,
							CAST('+IsNull(''''+replace(oDataType,'''','')+'''','NULL')+' AS NVARCHAR(255)) DataType,
							CAST('+IsNull(oValue,'NULL')+' AS NVARCHAR(MAX)) Value,
							'+IsNull(ViewSecurityGroup,'NULL')+' ViewSecurityGroup,
							'+IsNull(EditSecurityGroup,'NULL')+' EditSecurityGroup,
							IsNull('+IsNull(Weight,1)+',1) Weight,
							'+IsNull(cast(Graph as varchar(50)),'NULL')+' Graph,
							'+(CASE WHEN @DataMapType IN (3,5) THEN 'HASHBYTES(''sha1'',CONVERT(nvarchar(4000),N''"''+replace(isnull(CAST('+IsNull(oValue,'NULL')+' AS NVARCHAR(MAX)),N''''),N''"'',N''\"'')+''"''+IsNull(N''"@''+replace(CAST('+IsNull(''''+replace(oLanguage,'''','')+'''','NULL')+' AS NVARCHAR(255)),N''@'',N''''),N'''')+IsNull(N''"^^''+replace(CAST('+IsNull(''''+replace(oDataType,'''','')+'''','NULL')+' AS NVARCHAR(255)),N''^'',N''''),N''''))) ValueHash, ' ELSE '' END)+'
							ROW_NUMBER() OVER (PARTITION BY '+sInternalID+'
								ORDER BY '+IsNull(OrderBy+',','')+coalesce(oInternalID+',','IsNull('+oValue+',NULL),','')+sInternalID+IsNull(','+cInternalID,'')+') SortOrder
						FROM '+MapTable
						+(CASE	WHEN @InternalIdIn IS NOT NULL AND @DataMapType IN (3,5) 
									THEN ' WHERE ('+sInternalID+' IN ('+@InternalIdIn+')) AND (IsNull(CAST('+IsNull(oValue,'NULL')+' AS NVARCHAR(MAX)),'''') <> '''') ' 
								WHEN @InternalIdIn IS NOT NULL
									THEN ' WHERE '+sInternalID+' IN ('+@InternalIdIn+')'
								WHEN @DataMapType IN (3,5)
									THEN ' WHERE IsNull(CAST('+IsNull(oValue,'NULL')+' AS NVARCHAR(MAX)),'''') <> '''' '
								ELSE '' 
							END)
				FROM [Ontology.].DataMap
				WHERE DataMapID = @DataMapID


			IF @DataMapType = 200
				SELECT @s = '
					CREATE TABLE #Temp (
											sClass NVARCHAR(400),
											sInternalType NVARCHAR(300),
											sInternalID NVARCHAR(100),
											NetworkPredicate BIGINT,
											predicate BIGINT,
											cClass NVARCHAR(400),
											cInternalType NVARCHAR(300),
											cInternalID NVARCHAR(100),
											oClass NVARCHAR(400),
											oInternalType NVARCHAR(300),
											oInternalID NVARCHAR(100),
											Language NVARCHAR(255),
											DataType NVARCHAR(255),
											Value NVARCHAR(MAX),
											ViewSecurityGroup BIGINT,
											EditSecurityGroup BIGINT,
											Weight FLOAT,
											Graph BIGINT, 
											SortOrder INT
										)
					INSERT INTO #Temp
						' + @s + ' ;
					'+(CASE WHEN @InternalIdIn IS NOT NULL THEN '
					CREATE TABLE #Temp2 (NodeID BIGINT Primary Key)
					INSERT INTO #Temp2
						SELECT NodeID
							FROM [RDF.Stage].InternalNodeMap s
							WHERE s.Class='''+Class+''' AND s.InternalType='''+sInternalType+''' AND s.NodeID IS NOT NULL
								AND s.InternalID IN ('+@InternalIdIn+')
					' ELSE '' END)+'
					;WITH a AS (
						SELECT s.NodeID Subject, x.Predicate, o.NodeID Object, x.Weight, x.SortOrder, 
								IsNull(p.ViewSecurityGroup,x.ViewSecurityGroup) ViewSecurityGroup, x.Graph
						FROM #Temp x
							INNER JOIN [RDF.Stage].InternalNodeMap s
								ON s.Class=x.sClass AND s.InternalType=x.sInternalType AND s.InternalID=x.sInternalID AND s.NodeID IS NOT NULL
							INNER JOIN [RDF.Stage].InternalNodeMap o
								ON o.Class=x.oClass AND o.InternalType=x.oInternalType AND o.InternalID=x.oInternalID AND o.NodeID IS NOT NULL
							LEFT OUTER JOIN [RDF.Security].NodeProperty p
								ON p.NodeID = s.NodeID AND p.Property = '+CAST(@PropertyNode as varchar(50))+'
					), b AS (
						SELECT t.*
						FROM '+(CASE WHEN @InternalIdIn IS NOT NULL THEN '#Temp2' ELSE '[RDF.Stage].InternalNodeMap' END)+' s
							INNER JOIN [RDF.Stage].InternalNodeMap o
								ON o.Class='''+oClass+''' AND o.InternalType='''+oInternalType+''' AND o.NodeID IS NOT NULL
							INNER JOIN [RDF.].Triple t
								ON t.Subject = s.NodeID AND t.Predicate = '+cast(_PropertyNode as varchar(50))+' AND t.Object = o.NodeID
						'+(CASE WHEN @InternalIdIn IS NOT NULL THEN '' ELSE 'WHERE s.Class='''+Class+''' AND s.InternalType='''+sInternalType+''' AND s.NodeID IS NOT NULL' END)+'
					)
					SELECT a.Subject, a.Predicate, a.Object, b.TripleID, 
							null Language, null DataType, null Value, null ValueHash,
							a.Weight, a.SortOrder, 0 ObjectType, a.ViewSecurityGroup, null EditSecurityGroup,
							null ReitificationTripleID, b.Reitification, b.TripleHash, a.Graph,
							(CASE	WHEN b.TripleID IS NULL THEN 2 
									WHEN a.Subject IS NULL THEN 1 
									ELSE 0 END) Status
						FROM a FULL OUTER JOIN b
								ON a.Subject = b.Subject AND a.Object = b.Object
						WHERE	a.Subject IS NULL
								OR b.TripleID IS NULL
								OR a.Weight <> b.Weight
								OR a.SortOrder <> b.SortOrder
								OR a.ViewSecurityGroup <> b.ViewSecurityGroup
					UNION ALL
					SELECT COUNT(*),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,100 FROM #Temp
					'+(CASE WHEN @InternalIdIn IS NOT NULL THEN 'OPTION (FORCE ORDER)' ELSE '' END)	 
				FROM [Ontology.].DataMap
				WHERE DataMapID = @DataMapID



	 
			IF @DataMapType = 2
				SELECT @s = '
					CREATE TABLE #Temp (
											sClass NVARCHAR(400),
											sInternalType NVARCHAR(300),
											sInternalID NVARCHAR(100),
											NetworkPredicate BIGINT,
											predicate BIGINT,
											cClass NVARCHAR(400),
											cInternalType NVARCHAR(300),
											cInternalID NVARCHAR(100),
											oClass NVARCHAR(400),
											oInternalType NVARCHAR(300),
											oInternalID NVARCHAR(100),
											Language NVARCHAR(255),
											DataType NVARCHAR(255),
											Value NVARCHAR(MAX),
											ViewSecurityGroup BIGINT,
											EditSecurityGroup BIGINT,
											Weight FLOAT,
											Graph BIGINT, 
											SortOrder INT
										)
					INSERT INTO #Temp
						' + @s + ' ;
					;WITH a AS (
						SELECT s.NodeID Subject, x.Predicate, o.NodeID Object, x.Weight, x.SortOrder, 
								IsNull(p.ViewSecurityGroup,x.ViewSecurityGroup) ViewSecurityGroup, x.Graph
						FROM #Temp x
							INNER JOIN [RDF.Stage].InternalNodeMap s
								ON s.Class=x.sClass AND s.InternalType=x.sInternalType AND s.InternalID=x.sInternalID AND s.NodeID IS NOT NULL
							INNER JOIN [RDF.Stage].InternalNodeMap o
								ON o.Class=x.oClass AND o.InternalType=x.oInternalType AND o.InternalID=x.oInternalID AND o.NodeID IS NOT NULL
							LEFT OUTER JOIN [RDF.Security].NodeProperty p
								ON p.NodeID = s.NodeID AND p.Property = '+CAST(@PropertyNode as varchar(50))+'
					), b AS (
						SELECT t.*
						FROM [RDF.Stage].InternalNodeMap s
							INNER JOIN [RDF.Stage].InternalNodeMap o
								ON o.Class='''+oClass+''' AND o.InternalType='''+oInternalType+''' AND o.NodeID IS NOT NULL
							INNER JOIN [RDF.].Triple t
								ON t.Subject = s.NodeID AND t.Predicate = '+cast(_PropertyNode as varchar(50))+' AND t.Object = o.NodeID
						WHERE s.Class='''+Class+''' AND s.InternalType='''+sInternalType+''' AND s.NodeID IS NOT NULL
							'+(CASE WHEN @InternalIdIn IS NOT NULL THEN 'AND s.InternalID IN ('+@InternalIdIn+')' ELSE '' END)+'
					)
					SELECT a.Subject, a.Predicate, a.Object, b.TripleID, 
							null Language, null DataType, null Value, null ValueHash,
							a.Weight, a.SortOrder, 0 ObjectType, a.ViewSecurityGroup, null EditSecurityGroup,
							null ReitificationTripleID, b.Reitification, b.TripleHash, a.Graph,
							(CASE	WHEN b.TripleID IS NULL THEN 2 
									WHEN a.Subject IS NULL THEN 1 
									ELSE 0 END) Status
						FROM a FULL OUTER JOIN b
								ON a.Subject = b.Subject AND a.Object = b.Object
						WHERE	a.Subject IS NULL
								OR b.TripleID IS NULL
								OR a.Weight <> b.Weight
								OR a.SortOrder <> b.SortOrder
								OR a.ViewSecurityGroup <> b.ViewSecurityGroup
					UNION ALL
					SELECT COUNT(*),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,100 FROM #Temp
					'	 
				FROM [Ontology.].DataMap
				WHERE DataMapID = @DataMapID

/*
						SELECT t.*
						FROM [Ontology.].DataMap m
							INNER JOIN [RDF.Stage].InternalNodeMap s
								ON s.Class=m.Class AND s.InternalType=m.sInternalType AND s.NodeID IS NOT NULL
									'+(CASE WHEN @InternalIdIn IS NOT NULL THEN 'AND s.InternalID IN ('+@InternalIdIn+')' ELSE '' END)+'
							INNER JOIN [RDF.Stage].InternalNodeMap o
								ON o.Class=m.oClass AND o.InternalType=m.oInternalType AND o.NodeID IS NOT NULL
							INNER JOIN [RDF.].Triple t
								ON t.Subject = s.NodeID AND t.Predicate = m._PropertyNode AND t.Object = o.NodeID
						WHERE m.DataMapID = '+CAST(@DataMapID as varchar(50))+'
*/
	  
			IF @DataMapType = 3
				SELECT @s = '
					CREATE TABLE #Temp (
											sClass NVARCHAR(400),
											sInternalType NVARCHAR(300),
											sInternalID NVARCHAR(100),
											NetworkPredicate BIGINT,
											predicate BIGINT,
											cClass NVARCHAR(400),
											cInternalType NVARCHAR(300),
											cInternalID NVARCHAR(100),
											oClass NVARCHAR(400),
											oInternalType NVARCHAR(300),
											oInternalID NVARCHAR(100),
											Language NVARCHAR(255),
											DataType NVARCHAR(255),
											Value NVARCHAR(MAX),
											ViewSecurityGroup BIGINT,
											EditSecurityGroup BIGINT,
											Weight FLOAT,
											Graph BIGINT, 
											ValueHash BINARY(20), 
											SortOrder INT
										)
					INSERT INTO #Temp 
						' + @s + ';
					;WITH a AS (
						SELECT s.NodeID Subject, x.Predicate, o.NodeID Object, x.Weight, x.SortOrder, 
								IsNull(p.ViewSecurityGroup,x.ViewSecurityGroup) ViewSecurityGroup, x.Graph,
								x.Value, x.Language, x.DataType, x.ValueHash, x.EditSecurityGroup
						FROM #Temp x
							INNER JOIN [RDF.Stage].InternalNodeMap s
								ON s.Class=x.sClass AND s.InternalType=x.sInternalType AND s.InternalID=x.sInternalID AND s.NodeID IS NOT NULL
							LEFT OUTER JOIN [RDF.].Node o
								ON o.ValueHash=x.ValueHash
							LEFT OUTER JOIN [RDF.Security].NodeProperty p
								ON p.NodeID = s.NodeID AND p.Property = '+CAST(@PropertyNode as varchar(50))+'
					), b AS (
						SELECT t.*
						FROM [Ontology.].DataMap m
							INNER JOIN [RDF.Stage].InternalNodeMap s
								ON s.Class='''+Class+''' AND s.InternalType='''+sInternalType+''' AND s.NodeID IS NOT NULL
									'+(CASE WHEN @InternalIdIn IS NOT NULL THEN 'AND s.InternalID IN ('+@InternalIdIn+')' ELSE '' END)+'
							INNER JOIN [RDF.].Triple t
								ON t.Subject = s.NodeID AND t.Predicate = m._PropertyNode AND t.ObjectType = '+CAST(@ObjectType as varchar(50))+'
						WHERE m.DataMapID = '+CAST(@DataMapID as varchar(50))+'
					)
					SELECT a.Subject, a.Predicate, a.Object, b.TripleID, 
							a.Language, a.DataType, a.Value, a.ValueHash,
							a.Weight, a.SortOrder, '+CAST(@ObjectType as varchar(50))+' ObjectType, a.ViewSecurityGroup, a.EditSecurityGroup,
							null ReitificationTripleID, b.Reitification, b.TripleHash, a.Graph,
							(CASE	WHEN b.TripleID IS NULL AND a.Object IS NULL THEN 3 
									WHEN b.TripleID IS NULL THEN 2 
									WHEN a.Subject IS NULL THEN 1
									ELSE 0 END) Status
						FROM a FULL OUTER JOIN b
								ON a.Subject = b.Subject AND a.Object = b.Object AND a.Object IS NOT NULL
						WHERE	a.Subject IS NULL
								OR b.TripleID IS NULL
								OR a.Weight <> b.Weight
								OR a.SortOrder <> b.SortOrder
								OR a.ViewSecurityGroup <> b.ViewSecurityGroup
					UNION ALL
					SELECT COUNT(*),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,100 FROM #Temp
					'
				FROM [Ontology.].DataMap
				WHERE DataMapID = @DataMapID

/*
						SELECT t.*
						FROM [Ontology.].DataMap m
							INNER JOIN [RDF.Stage].InternalNodeMap s
								ON s.Class=m.Class AND s.InternalType=m.sInternalType AND s.NodeID IS NOT NULL
									'+(CASE WHEN @InternalIdIn IS NOT NULL THEN 'AND s.InternalID IN ('+@InternalIdIn+')' ELSE '' END)+'
							INNER JOIN [RDF.].Triple t
								ON t.Subject = s.NodeID AND t.Predicate = m._PropertyNode AND t.ObjectType = '+CAST(@ObjectType as varchar(50))+'
						WHERE m.DataMapID = '+CAST(@DataMapID as varchar(50))+'

						SELECT t.*
						FROM [RDF.Stage].InternalNodeMap s
							INNER JOIN [RDF.].Triple t
								ON t.Subject = s.NodeID AND t.Predicate = '+cast(_PropertyNode as varchar(50))+' AND t.ObjectType = '+CAST(@ObjectType as varchar(50))+'
						WHERE s.Class='''+Class+''' AND s.InternalType='''+sInternalType+''' AND s.NodeID IS NOT NULL
							'+(CASE WHEN @InternalIdIn IS NOT NULL THEN 'AND s.InternalID IN ('+@InternalIdIn+')' ELSE '' END)+'

*/
				 
			IF @DataMapType = 4
				SELECT @s = '
					WITH x AS (
						'+@s+'
					), a AS (
						SELECT t.Reitification Subject, x.Predicate, o.NodeID Object, x.Weight, x.SortOrder, 
								x.ViewSecurityGroup, x.Graph,
								x.NetworkPredicate, t.TripleID, v.TripleID ExistingTripleID
						FROM x
							INNER JOIN [RDF.Stage].InternalNodeMap s
								ON s.Class=x.sClass AND s.InternalType=x.sInternalType AND s.InternalID=x.sInternalID AND s.NodeID IS NOT NULL
							INNER JOIN [RDF.Stage].InternalNodeMap c
								ON c.Class=x.cClass AND c.InternalType=x.cInternalType AND c.InternalID=x.cInternalID AND c.NodeID IS NOT NULL
							INNER JOIN [RDF.].Triple t
								ON t.Subject = s.NodeID AND t.Predicate = x.NetworkPredicate AND t.Object = c.NodeID
							INNER JOIN [RDF.Stage].InternalNodeMap o
								ON o.Class=x.oClass AND o.InternalType=x.oInternalType AND o.InternalID=x.oInternalID AND o.NodeID IS NOT NULL
							LEFT OUTER JOIN [RDF.].Triple v
								ON v.Subject = t.Reitification AND v.Predicate = x.Predicate AND v.Object = o.NodeID
									AND t.Reitification IS NOT NULL AND o.NodeID IS NOT NULL
					), b AS (
						SELECT v.*
						FROM [Ontology.].DataMap m
							INNER JOIN [RDF.Stage].InternalNodeMap s
								ON s.Class=m.Class AND s.InternalType=m.sInternalType AND s.NodeID IS NOT NULL
									'+(CASE WHEN @InternalIdIn IS NOT NULL THEN 'AND s.InternalID IN ('+@InternalIdIn+')' ELSE '' END)+'
							INNER JOIN [RDF.Stage].InternalNodeMap c
								ON c.Class=m.cClass AND c.InternalType=m.cInternalType AND c.NodeID IS NOT NULL
							INNER JOIN [RDF.].Triple t
								ON t.Subject = s.NodeID AND t.Predicate = m._NetworkPropertyNode AND t.Object = c.NodeID AND t.Reitification IS NOT NULL
							INNER JOIN [RDF.Stage].InternalNodeMap o
								ON o.Class=m.oClass AND o.InternalType=m.oInternalType AND o.NodeID IS NOT NULL
							INNER JOIN [RDF.].Triple v
								ON v.Subject = t.Reitification AND v.Predicate = m._PropertyNode AND v.Object = o.NodeID
						WHERE m.DataMapID = '+CAST(@DataMapID as varchar(50))+'
					)
					SELECT a.Subject, a.Predicate, a.Object, b.TripleID, 
							null Language, null DataType, null Value, null ValueHash,
							a.Weight, a.SortOrder, 0 ObjectType, a.ViewSecurityGroup, null EditSecurityGroup,
							a.TripleID ReitificationTripleID, b.Reitification, b.TripleHash, a.Graph,
							(CASE	WHEN (b.TripleID IS NULL) AND (a.TripleID IS NOT NULL) AND (a.Object IS NOT NULL) AND (a.ExistingTripleID IS NULL) AND (a.Subject IS NULL) THEN 4
									WHEN (b.TripleID IS NULL) AND (a.TripleID IS NOT NULL) AND (a.Object IS NOT NULL) AND (a.ExistingTripleID IS NULL) AND (a.Subject IS NOT NULL) THEN 2
									WHEN (b.TripleID IS NOT NULL) AND ((a.TripleID IS NULL) OR (a.Object IS NULL)) THEN 1
									WHEN (b.TripleID IS NOT NULL) AND (a.TripleID IS NOT NULL) AND (a.Object IS NOT NULL) AND (a.ExistingTripleID IS NOT NULL) THEN 0
									ELSE -1 END) Status
						FROM a FULL OUTER JOIN b
								ON a.Subject = b.Subject AND a.Object = b.Object
						WHERE	b.TripleID IS NULL
								OR a.TripleID IS NULL
								OR a.Object IS NULL
								OR a.Subject IS NULL
								OR a.ExistingTripleID IS NULL
								OR a.Weight <> b.Weight
								OR a.SortOrder <> b.SortOrder
								OR a.ViewSecurityGroup <> b.ViewSecurityGroup
					UNION ALL
					SELECT COUNT(*),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,100 FROM x
					'

			IF @DataMapType = 5
				SELECT @s = ' CREATE TABLE #Temp (
											sClass NVARCHAR(400),
											sInternalType NVARCHAR(300),
											sInternalID NVARCHAR(100),
											NetworkPredicate BIGINT,
											predicate BIGINT,
											cClass NVARCHAR(400),
											cInternalType NVARCHAR(300),
											cInternalID NVARCHAR(100),
											oClass NVARCHAR(400),
											oInternalType NVARCHAR(300),
											oInternalID NVARCHAR(100),
											Language NVARCHAR(255),
											DataType NVARCHAR(255),
											Value NVARCHAR(MAX),
											ViewSecurityGroup BIGINT,
											EditSecurityGroup BIGINT,
											Weight FLOAT,
											Graph BIGINT, 
											ValueHash BINARY(20), 
											SortOrder INT
										)
					INSERT INTO #Temp 
						' + @s + ';
					 
						SELECT t.Reitification Subject, x.Predicate, o.NodeID Object, x.Weight, x.SortOrder, 
								x.ViewSecurityGroup, x.Graph,
								x.NetworkPredicate, t.TripleID, v.TripleID ExistingTripleID,
								x.Value, x.Language, x.DataType, x.ValueHash, x.EditSecurityGroup
						into #a
						FROM #Temp x
							INNER JOIN [RDF.Stage].InternalNodeMap s
								ON s.Class=x.sClass AND s.InternalType=x.sInternalType AND s.InternalID=x.sInternalID AND s.NodeID IS NOT NULL
							INNER JOIN [RDF.Stage].InternalNodeMap c
								ON c.Class=x.cClass AND c.InternalType=x.cInternalType AND c.InternalID=x.cInternalID AND c.NodeID IS NOT NULL
							INNER hash JOIN [RDF.].Triple t
								ON t.Subject = s.NodeID AND t.Predicate = x.NetworkPredicate AND t.Object = c.NodeID
							LEFT OUTER JOIN [RDF.].Node o
								ON o.ValueHash=x.ValueHash
							LEFT OUTER JOIN [RDF.].Triple v
								ON v.Subject = t.Reitification AND v.Predicate = x.Predicate AND v.Object = o.NodeID
									AND t.Reitification IS NOT NULL AND o.NodeID IS NOT NULL
					 
						SELECT v.* INTO #b
						FROM [Ontology.].DataMap m
							INNER JOIN [RDF.Stage].InternalNodeMap s
								ON s.Class=m.Class AND s.InternalType=m.sInternalType AND s.NodeID IS NOT NULL
									'+(CASE WHEN @InternalIdIn IS NOT NULL THEN 'AND s.InternalID IN ('+@InternalIdIn+')' ELSE '' END)+'
							INNER JOIN [RDF.Stage].InternalNodeMap c
								ON c.Class=m.cClass AND c.InternalType=m.cInternalType AND c.NodeID IS NOT NULL
							INNER JOIN [RDF.].Triple t
								ON t.Subject = s.NodeID AND t.Predicate = m._NetworkPropertyNode AND t.Object = c.NodeID AND t.Reitification IS NOT NULL
							INNER JOIN [RDF.].Triple v
								ON v.Subject = t.Reitification AND v.Predicate = m._PropertyNode AND v.ObjectType = '+CAST(@ObjectType as varchar(50))+'
						WHERE m.DataMapID = '+CAST(@DataMapID as varchar(50))+'
					 
					SELECT a.Subject, a.Predicate, a.Object, b.TripleID, 
							a.Language, a.DataType, a.Value, a.ValueHash,
							a.Weight, a.SortOrder, '+CAST(@ObjectType as varchar(50))+' ObjectType, a.ViewSecurityGroup, a.EditSecurityGroup,
							a.TripleID ReitificationTripleID, b.Reitification, b.TripleHash, a.Graph,
							(CASE	WHEN (b.TripleID IS NULL) AND (a.TripleID IS NOT NULL) AND (a.Object IS NULL) AND (a.ExistingTripleID IS NULL) AND (a.Subject IS NULL) THEN 5
									WHEN (b.TripleID IS NULL) AND (a.TripleID IS NOT NULL) AND (a.Object IS NOT NULL) AND (a.ExistingTripleID IS NULL) AND (a.Subject IS NULL) THEN 4
									WHEN (b.TripleID IS NULL) AND (a.TripleID IS NOT NULL) AND (a.Object IS NULL) AND (a.ExistingTripleID IS NULL) AND (a.Subject IS NOT NULL) THEN 3
									WHEN (b.TripleID IS NULL) AND (a.TripleID IS NOT NULL) AND (a.Object IS NOT NULL) AND (a.ExistingTripleID IS NULL) AND (a.Subject IS NOT NULL) THEN 2
									WHEN (b.TripleID IS NOT NULL) AND (a.TripleID IS NULL) THEN 1
									WHEN (b.TripleID IS NOT NULL) AND (a.TripleID IS NOT NULL) AND (a.Object IS NOT NULL) AND (a.ExistingTripleID IS NOT NULL) THEN 0
									ELSE -1 END) Status
						FROM #a a FULL OUTER JOIN #b b
								ON a.Subject = b.Subject AND a.Object = b.Object AND a.Object IS NOT NULL
						WHERE	b.TripleID IS NULL
								OR a.TripleID IS NULL
								OR a.Object IS NULL
								OR a.Subject IS NULL
								OR a.ExistingTripleID IS NULL
								OR a.Weight <> b.Weight
								OR a.SortOrder <> b.SortOrder
								OR a.ViewSecurityGroup <> b.ViewSecurityGroup
					UNION ALL
					SELECT COUNT(*),NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,100 FROM #temp x
					'
--print @s return
			--declare @d datetime
			--select @d = getdate()					
			--select @datamapid, replace(@s,char(10),'NEWLINE')
			--return
			--select @DataMapType, @s
			
			INSERT INTO #Triple
				EXEC sp_executesql @s
			--select @datamapid, datediff(ms,@d,getdate()), (select count(*) from #Triple), replace(@s,char(10),'NEWLINE')
			--select * from #Triple
			--retrun
				
			SELECT @TotalTriples = IsNull((SELECT MAX(Subject) FROM #Triple WHERE Status = 100),0)
			
			---------------------------------------------------------------------
			-- Status 0 - Update triple
			---------------------------------------------------------------------
			
			UPDATE t
				SET	t.Weight = IsNull(x.Weight,t.Weight),
					t.SortOrder = IsNull(x.SortOrder,t.SortOrder),
					t.ObjectType = IsNull(x.ObjectType,t.ObjectType)
				FROM [RDF.].Triple t, #Triple x
				WHERE x.Status = 0
					AND t.TripleID = x.TripleID
			SELECT @UpdatedTriples = @@ROWCOUNT

			---------------------------------------------------------------------
			-- Status 1 - Delete triple
			---------------------------------------------------------------------

			CREATE TABLE #DeleteTriples (TripleID BIGINT PRIMARY KEY)
			CREATE TABLE #DeleteNodes (NodeID BIGINT PRIMARY KEY)
			CREATE TABLE #NewDeleteTriples (TripleID BIGINT PRIMARY KEY, Reitification BIGINT)
			CREATE TABLE #NewDeleteNodes (NodeID BIGINT PRIMARY KEY)
			DECLARE @NewDeletedTriples BIGINT
			-- Get triples that should be deleted
			INSERT INTO #NewDeleteTriples (TripleID, Reitification)
				SELECT TripleID, Reitification
					FROM #Triple
					WHERE Status = 1
			SELECT @NewDeletedTriples = @@ROWCOUNT
			WHILE @NewDeletedTriples > 0
			BEGIN
				-- Get reitification nodes
				INSERT INTO #DeleteNodes(NodeID)
					SELECT NodeID FROM #NewDeleteNodes
				TRUNCATE TABLE #NewDeleteNodes
				INSERT INTO #NewDeleteNodes (NodeID)
					SELECT DISTINCT Reitification 
						FROM #NewDeleteTriples 
						WHERE Reitification IS NOT NULL AND Reitification NOT IN (SELECT NodeID FROM #DeleteNodes)
				-- Get triples using reitification nodes
				INSERT INTO #DeleteTriples (TripleID)
					SELECT TripleID FROM #NewDeleteTriples
				TRUNCATE TABLE #NewDeleteTriples
				INSERT INTO #NewDeleteTriples (TripleID, Reitification)
					SELECT t.TripleID, t.Reitification
						FROM [RDF.].Triple t
						join  #NewDeleteNodes n on t.subject = n.NodeID 
											    or t.predicate = n.NodeID 
											    or t.object = n.NodeID
							where t.TripleID NOT IN (SELECT TripleID FROM #DeleteTriples)
					--SELECT t.TripleID, t.Reitification
					--	FROM [RDF.].Triple t, #NewDeleteNodes n
					--	WHERE t.subject = n.NodeID 
					--	   or t.predicate = n.NodeID 
					--	   or t.object = n.NodeID
					--		AND t.TripleID NOT IN (SELECT TripleID FROM #DeleteTriples)
				SELECT @NewDeletedTriples = @@ROWCOUNT
			END
			-- Delete triples and reitification nodes and triples
			DELETE 
				FROM [RDF.].Triple
				WHERE TripleID IN (SELECT TripleID FROM #DeleteTriples)
			SELECT @DeletedTriples = @@ROWCOUNT
			DELETE 
				FROM [RDF.].Node
				WHERE NodeID IN (SELECT NodeID FROM #DeleteNodes)
			SELECT @DeletedNodes = @@ROWCOUNT


			---------------------------------------------------------------------
			-- Status 4 & 5 - Create new reitifications
			---------------------------------------------------------------------

			UPDATE #Triple
				SET TripleHash = HASHBYTES('sha1',N'"#TRIPLE'+cast(ReitificationTripleID as nvarchar(50))+N'"')
				WHERE Status IN (4,5)
			INSERT INTO [RDF.].Node (ValueHash, Language, DataType, Value, ObjectType, ViewSecurityGroup, EditSecurityGroup)
				SELECT DISTINCT TripleHash, NULL, NULL, '#TRIPLE'+CAST(ReitificationTripleID AS VARCHAR(50)), 0, -1, -50
					FROM #Triple
					WHERE Status IN (4,5)
			SELECT @NewNodes = @NewNodes + @@ROWCOUNT
			UPDATE t
				SET	t.Subject = n.NodeID,
					t.TripleHash = (CASE WHEN t.Object IS NULL THEN t.TripleHash ELSE HASHBYTES('sha1',N'"<#'+convert(nvarchar(4000),n.NodeID)+N'> <#'+convert(nvarchar(4000),t.Predicate)+N'> <#'+convert(nvarchar(max),t.Object)+N'> ."^^http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement') END)
				FROM #Triple t, [RDF.].Node n
				WHERE t.Status IN (4,5) AND t.TripleHash = n.ValueHash
			UPDATE v
				SET v.Reitification = t.Subject
				FROM #Triple t, [RDF.].Triple v
				WHERE t.Status IN (4,5) AND t.ReitificationTripleID = v.TripleID
			UPDATE n
				SET n.Value = @baseURI+cast(n.NodeID as nvarchar(50)),
					n.ValueHash = HASHBYTES('sha1',N'"' + @baseURI + cast(n.NodeID as nvarchar(50)) + N'"')
				FROM #Triple t, [RDF.].Node n
				WHERE t.Status IN (4,5) AND t.Subject = n.NodeID
				
			---------------------------------------------------------------------
			-- Status 3 & 5 - Create new literals
			---------------------------------------------------------------------

			-- Create the new literals
			INSERT INTO [RDF.].Node (ValueHash, Language, DataType, Value, ObjectType, ViewSecurityGroup, EditSecurityGroup)
				SELECT ValueHash, MAX(Language), MAX(DataType), MAX(Value), MAX(ObjectType*1),
						IsNull(Min(ViewSecurityGroup),-1), IsNull(Min(EditSecurityGroup),-40)
					FROM #Triple
					WHERE Status IN (3,5)
					GROUP BY ValueHash
			SELECT @NewNodes = @NewNodes + @@ROWCOUNT
			-- Update #Triple with the NodeID of the new literals
			UPDATE t
				SET t.Object = n.NodeID
				FROM #Triple t, [RDF.].Node n
				WHERE t.Status IN (3,5)
					AND t.ValueHash = n.ValueHash
					
			---------------------------------------------------------------------
			-- Status 2, 3, 4, and 5 - Create new triple
			---------------------------------------------------------------------

			-- Create the new triples
			INSERT INTO [RDF.].Triple (Subject, Predicate, Object, TripleHash, Weight, ObjectType, SortOrder, ViewSecurityGroup, Graph)
				SELECT Subject, Predicate, Object, TripleHash, Max(Weight), Max(cast(ObjectType as Tinyint)), Min(SortOrder), Max(ViewSecurityGroup), Min(Graph)
					FROM (
						SELECT Subject, Predicate, Object,
							HASHBYTES('sha1',N'"<#'+convert(nvarchar(4000),Subject)+N'> <#'+convert(nvarchar(4000),Predicate)+N'> <#'+convert(nvarchar(4000),Object)+N'> ."^^http://www.w3.org/1999/02/22-rdf-syntax-ns#Statement') TripleHash,
							IsNull(Weight,1) Weight, IsNull(ObjectType,1) ObjectType, IsNull(SortOrder,1) SortOrder, IsNull(ViewSecurityGroup,-1) ViewSecurityGroup,
							Graph
						FROM #Triple
						WHERE Status IN (2,3,4,5)
					) t
					GROUP BY Subject, Predicate, Object, TripleHash
			SELECT @NewTriples = @@ROWCOUNT

			DROP TABLE #DeleteTriples 
			DROP TABLE #DeleteNodes 
			DROP TABLE #NewDeleteTriples 
			DROP TABLE #NewDeleteNodes   
			
			DROP TABLE #Triple
			
		END


		--*******************************************************************************************
		--*******************************************************************************************
		-- Save Log
		--*******************************************************************************************
		--*******************************************************************************************

		INSERT INTO [RDF.Stage].[Log.DataMap] (DataMapID, StartDate, EndDate, RunTimeMS, DataMapType,
												NewNodes, UpdatedNodes, ExistingNodes, DeletedNodes, TotalNodes,
												NewTriples, UpdatedTriples, ExistingTriples, DeletedTriples, TotalTriples)
			SELECT	@DataMapID, @StartDate, GetDate(), DateDiff(ms,@StartDate,GetDate()), @DataMapType,
					@NewNodes, @UpdatedNodes, @ExistingNodes, @DeletedNodes, @TotalNodes,
					@NewTriples, @UpdatedTriples, @ExistingTriples, @DeletedTriples, @TotalTriples
				WHERE @SaveLog = 1

		IF @ShowCounts = 1
			SELECT * FROM [RDF.Stage].[Log.DataMap] WHERE LogID = @@IDENTITY

		DELETE FROM #Queue WHERE DataMapID = @DataMapID
			 
	END

	IF @TurnOffIndexing = 1
	BEGIN
		-- Turn on real-time indexing
		ALTER FULLTEXT INDEX ON [RDF.].vwLiteral SET CHANGE_TRACKING AUTO;
		-- Kick off population FT Catalog and index
		ALTER FULLTEXT INDEX ON [RDF.].vwLiteral START FULL POPULATION 
	END
	
	-- select * from [Ontology.].DataMap

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[Process.AddAuditUpdate]	(@insert_new_record BIT=1,
																								 @ProcessName varchar(1000),
																								 @ProcessStartDate datetime=NULL,
																								 @ProcessEnddate datetime=NULL,
																								 @ProcessedRows INT=NULL,
																								 @Error BIT=0,
																								 @AuditID UNIQUEIDENTIFIER=NULL OUTPUT)
as 
begin
SET NOCOUNT ON 

 

 
	IF @insert_new_record=1
		BEGIN
				SELECT @AuditID = NEWID()
				INSERT INTO [Profile.Cache].[Process.Audit]
				   (AuditID,ProcessName,ProcessStartDate) VALUES(@AuditID,@ProcessName,@ProcessStartDate)
		END
	ELSE
		UPDATE [Profile.Cache].[Process.Audit]
			 SET ProcessEndDate = ISNULL(@ProcessEnddate,GETDATE()),
				   ProcessedRows=@ProcessedRows,
					 Error=@Error
	   WHERE AuditID = @AuditID

end
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create PROCEDURE [Profile.Data].[Person.UpdateUnGeocodedAddress]	 (@latitude VARCHAR(20),
												  @longitude VARCHAR(20),
												  @geoscore VARCHAR(10),
												  @addressstring VARCHAR(2000))
AS
BEGIN
	SET NOCOUNT ON;	

UPDATE [Profile.Data].Person
   SET latitude=@latitude,
	   longitude=@longitude,
	   geoscore=@geoscore
 WHERE addressstring=@addressstring
 

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Person.GetFilters]

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT x.PersonFilterID, x.PersonFilterCategory, x.PersonFilter, x.PersonFilterSort, n.NodeID, n.Value URI
		FROM (
				SELECT PersonFilterID, PersonFilterCategory, PersonFilter, PersonFilterSort
				FROM [Profile.Data].[Person.Filter]
			) x 
			LEFT OUTER JOIN [RDF.Stage].InternalNodeMap m WITH (NOLOCK)
				ON m.class = 'http://profiles.catalyst.harvard.edu/ontology/prns#PersonFilter'
					AND m.InternalType = 'PersonFilter'
					AND m.InternalID = CAST(x.PersonFilterID AS VARCHAR(50))
			LEFT OUTER JOIN [RDF.].Node n WITH (NOLOCK)
				ON m.NodeID = n.NodeID
					AND n.ViewSecurityGroup = -1
		ORDER BY PersonFilterSort

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Person.GetFacultyRanks]
	-- Add the parameters for the stored procedure here

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT x.FacultyRankID, x.FacultyRank,  n.NodeID, n.Value URI
		FROM (
				SELECT CAST(MAX(FacultyRankID) AS VARCHAR(50)) FacultyRankID,
						LTRIM(RTRIM(FacultyRank)) FacultyRank, 	FacultyRankSort							
				FROM [Profile.Data].[Person.FacultyRank] WITH (NOLOCK) where facultyrank <> ''				
				group by FacultyRank ,FacultyRankSort
			) x 
			LEFT OUTER JOIN [RDF.Stage].InternalNodeMap m WITH (NOLOCK)
				ON m.class = 'http://profiles.catalyst.harvard.edu/ontology/prns#FacultyRank'
					AND m.InternalType = 'FacultyRank'
					AND m.InternalID = CAST(x.FacultyRankID AS VARCHAR(50))
			LEFT OUTER JOIN [RDF.].Node n WITH (NOLOCK)
				ON m.NodeID = n.NodeID
					AND n.ViewSecurityGroup = -1
		ORDER BY FacultyRankSort
 

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create procedure [Profile.Data].[Person.GetAffiliations] (@PersonID INT)
AS
BEGIN
	SET NOCOUNT ON;	
		SELECT title,
					 InstitutionFullName,
					 DepartmentFullname,
					 DivisionFullname 
			FROM [Profile.Data].[Person.Affiliation] p
LEFT	JOIN [Profile.Data].[Organization.InstitutionFullName] i on i.institutionfullnameid=p.institutionfullnameid
LEFT	JOIN [Profile.Data].[Organization.DepartmentFullName] d on d.departmentfullnameid = p.departmentfullnameid
LEFT	JOIN [Profile.Data].[Organization.DivisionFullName] di on di.divisionfullnameid = p.divisionfullnameid
		 WHERE PersonID = @PersonID 
			 AND sortorder > 1 
  ORDER BY sortorder 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.DoesPublicationExist](	@pmid INT, @exists BIT OUTPUT)
AS
BEGIN
	SET NOCOUNT ON;

  SELECT @exists=0
  SELECT TOP 1 @exists=0, @exists = CASE WHEN PMID IS NULL THEN 0 ELSE 1 END  
		FROM [Profile.Data].[Publication.PubMed.AllXML] 
	 WHERE pmid = @PMID	 

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE  PROCEDURE  [Profile.Data].[Publication.Pubmed.AddDisambiguationLog] (@batchID UNIQUEIDENTIFIER, 
												@personID INT,
												@actionValue INT,
												@action VARCHAR(200),
												@actionText varchar(max) = null )
AS
BEGIN
	IF @action='StartService'
		BEGIN
			INSERT INTO [Profile.Data].[Publication.PubMed.DisambiguationAudit]  (BatchID,BatchCount,PersonID,ServiceCallStart)
			VALUES (@batchID,@actionValue,@personID,GETDATE())
		END
	IF @action='EndService'
		BEGIN
			UPDATE [Profile.Data].[Publication.PubMed.DisambiguationAudit] 
			   SET ServiceCallEnd = GETDATE(),
				   ServiceCallPubsFound  =@actionValue
			 WHERE batchID=@batchID
			   AND personid=@personID
		END
	IF @action='LocalCounts'
		BEGIN
			UPDATE [Profile.Data].[Publication.PubMed.DisambiguationAudit] 
			   SET ServiceCallNewPubs = @actionValue,
				   ServiceCallExistingPubs  =ServiceCallPubsFound-@actionValue
			 WHERE batchID=@batchID
			   AND personid=@personID
		END
	IF @action='AuthorComplete'
		BEGIN
			UPDATE [Profile.Data].[Publication.PubMed.DisambiguationAudit] 
			   SET ServiceCallPubsAdded = @actionValue,
				   ProcessEnd  =GETDATE(),
				   Success= 1
			 WHERE batchID=@batchID
			   AND personid=@personID
		END
	IF @action='Error'
		BEGIN
			UPDATE [Profile.Data].[Publication.PubMed.DisambiguationAudit] 
			   SET ErrorText = @actionText,
				   ProcessEnd  =GETDATE(),
				   Success=0
			 WHERE batchID=@batchID
			   AND personid=@personID
		END
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Publication.Pubmed.AddPMIDs] (@personid INT,
																		@PMIDxml XML)
AS
BEGIN
	SET NOCOUNT ON;	
	

	BEGIN TRY
		BEGIN TRAN		 
			  delete from [Profile.Data].[Publication.PubMed.Disambiguation] where personid = @personid				 
			  -- Add publications_include records
			  INSERT INTO [Profile.Data].[Publication.PubMed.Disambiguation] (personid,pmid)
			  SELECT @personid,
					 D.element.value('.','INT') pmid		 
				FROM @PMIDxml.nodes('//PMID') AS D(element)
			   WHERE NOT EXISTS(SELECT TOP 1 * FROM [Profile.Data].[Publication.PubMed.Disambiguation]	 dp WHERE personid = @personid and dp.pmid = D.element.value('.','INT'))	

		
		COMMIT
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK

		-- Raise an error with the details of the exception
		SELECT @ErrMsg = 'usp_CheckPMIDList FAILED WITH : ' + ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()

		RAISERROR(@ErrMsg, @ErrSeverity, 1)
			 
	END CATCH				
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [User.Account].[Authenticate] (
	@UserName NVARCHAR(50),
	@Password VARCHAR(128),
	@UserID INT = NULL OUTPUT,
	@PersonID INT = NULL OUTPUT
)
AS
BEGIN
	SET NOCOUNT ON

	BEGIN TRY	
		SELECT @UserID = UserID, @PersonID = PersonID
			FROM [User.Account].[User]
			WHERE UserName = @UserName
				AND Password = @Password	  

	END TRY
	BEGIN CATCH	
		--Check success		
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		IF @@TRANCOUNT > 0  ROLLBACK
			--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [User.Account].[AuthenticateExternal] (
	@UserName NVARCHAR(50),
	@UserID INT = NULL OUTPUT,
	@PersonID INT = NULL OUTPUT
)
AS
BEGIN
	SET NOCOUNT ON

	BEGIN TRY	
		SELECT @UserID = UserID, @PersonID = PersonID
			FROM [User.Account].[User]
			WHERE UserName = @UserName

	END TRY
	BEGIN CATCH	
		--Check success		
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		IF @@TRANCOUNT > 0  ROLLBACK
			--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Concept.Mesh.ParseMeshXML]
AS
BEGIN
	SET NOCOUNT ON;

	-- Clear any existing data
	TRUNCATE TABLE [Profile.Data].[Concept.Mesh.XML]
	TRUNCATE TABLE [Profile.Data].[Concept.Mesh.Descriptor]
	TRUNCATE TABLE [Profile.Data].[Concept.Mesh.Qualifier]
	TRUNCATE TABLE [Profile.Data].[Concept.Mesh.Term]
	TRUNCATE TABLE [Profile.Data].[Concept.Mesh.SemanticType]
	TRUNCATE TABLE [Profile.Data].[Concept.Mesh.SemanticType.XML]
	TRUNCATE TABLE [Profile.Data].[Concept.Mesh.SemanticGroupType]
	TRUNCATE TABLE [Profile.Data].[Concept.Mesh.SemanticGroup]
	TRUNCATE TABLE [Profile.Data].[Concept.Mesh.Tree]
	TRUNCATE TABLE [Profile.Data].[Concept.Mesh.TreeTop]

	-- Extract items from SemGroups.xml
	INSERT INTO [Profile.Data].[Concept.Mesh.SemanticGroupType] (SemanticGroupUI,SemanticGroupName,SemanticTypeUI,SemanticTypeName)
		SELECT 
			S.x.value('SemanticGroupUI[1]','varchar(10)'),
			S.x.value('SemanticGroupName[1]','varchar(50)'),
			S.x.value('SemanticTypeUI[1]','varchar(10)'),
			S.x.value('SemanticTypeName[1]','varchar(50)')
		FROM [Profile.Data].[Concept.Mesh.File] CROSS APPLY Data.nodes('//SemanticType') AS S(x)
		WHERE Name = 'SemGroups.xml'

	-- Extract items from SemTypes.xml
	INSERT INTO [Profile.Data].[Concept.Mesh.SemanticType.XML] (DescriptorUI, x)
		SELECT
				D.x.value('DescriptorUI[1]','varchar(100)'),
				D.x.query('SemanticTypeList[1]') SemanticTypeName
			FROM [Profile.Data].[Concept.Mesh.File] m 
				CROSS APPLY Data.nodes('//DescriptorRecord') AS D(x)
				WHERE Name = 'SemTypes.xml'

	INSERT INTO [Profile.Data].[Concept.Mesh.SemanticType] (DescriptorUI, SemanticTypeUI, SemanticTypeName)
		SELECT
				DescriptorUI,
				D.x.value('SemanticTypeUI[1]','varchar(10)') SemanticTypeUI,
				D.x.value('SemanticTypeName[1]','varchar(50)') SemanticTypeName
			FROM [Profile.Data].[Concept.Mesh.SemanticType.XML] m 
				CROSS APPLY X.nodes('//SemanticType') AS D(x)
		
	INSERT INTO [Profile.Data].[Concept.Mesh.SemanticGroup] (DescriptorUI, SemanticGroupUI, SemanticGroupName)
		SELECT DISTINCT t.DescriptorUI, g.SemanticGroupUI, g.SemanticGroupName
			FROM [Profile.Data].[Concept.Mesh.SemanticGroupType] g, [Profile.Data].[Concept.Mesh.SemanticType] t
			WHERE g.SemanticTypeUI = t.SemanticTypeUI

		-- Extract items from MeSH2011.xml
	INSERT INTO [Profile.Data].[Concept.Mesh.XML] (DescriptorUI, MeSH)
		SELECT D.x.value('DescriptorUI[1]','varchar(10)'), D.x.query('.')
			FROM [Profile.Data].[Concept.Mesh.File] CROSS APPLY Data.nodes('//DescriptorRecord') AS D(x)
			WHERE Name = 'MeSH.xml'


	---------------------------------------
	-- Parse MeSH XML and populate tables
	---------------------------------------


	INSERT INTO [Profile.Data].[Concept.Mesh.Descriptor] (DescriptorUI, DescriptorName)
		SELECT DescriptorUI, MeSH.value('DescriptorRecord[1]/DescriptorName[1]/String[1]','varchar(255)')
			FROM [Profile.Data].[Concept.Mesh.XML]

	INSERT INTO [Profile.Data].[Concept.Mesh.Qualifier] (DescriptorUI, QualifierUI, DescriptorName, QualifierName, Abbreviation)
		SELECT	m.DescriptorUI,
				Q.x.value('QualifierReferredTo[1]/QualifierUI[1]','varchar(10)'),
				m.MeSH.value('DescriptorRecord[1]/DescriptorName[1]/String[1]','varchar(255)'),
				Q.x.value('QualifierReferredTo[1]/QualifierName[1]/String[1]','varchar(255)'),
				Q.x.value('Abbreviation[1]','varchar(2)')
			FROM [Profile.Data].[Concept.Mesh.XML] m CROSS APPLY MeSH.nodes('//AllowableQualifier') AS Q(x)

	SELECT	m.DescriptorUI,
			C.x.value('ConceptUI[1]','varchar(10)') ConceptUI,
			m.MeSH.value('DescriptorRecord[1]/DescriptorName[1]/String[1]','varchar(255)') DescriptorName,
			C.x.value('@PreferredConceptYN[1]','varchar(1)') PreferredConceptYN,
			C.x.value('ConceptRelationList[1]/ConceptRelation[1]/@RelationName[1]','varchar(3)') RelationName,
			C.x.value('ConceptName[1]/String[1]','varchar(255)') ConceptName,
			C.x.query('.') ConceptXML
		INTO #c
		FROM [Profile.Data].[Concept.Mesh.XML] m 
			CROSS APPLY MeSH.nodes('//Concept') AS C(x)

	INSERT INTO [Profile.Data].[Concept.Mesh.Term] (DescriptorUI, ConceptUI, TermUI, TermName, DescriptorName, PreferredConceptYN, RelationName, ConceptName, ConceptPreferredTermYN, IsPermutedTermYN, LexicalTag)
		SELECT	DescriptorUI,
				ConceptUI,
				T.x.value('TermUI[1]','varchar(10)'),
				T.x.value('String[1]','varchar(255)'),
				DescriptorName,
				PreferredConceptYN,
				RelationName,
				ConceptName,
				T.x.value('@ConceptPreferredTermYN[1]','varchar(1)'),
				T.x.value('@IsPermutedTermYN[1]','varchar(1)'),
				T.x.value('@LexicalTag[1]','varchar(3)')
			FROM #c C CROSS APPLY ConceptXML.nodes('//Term') AS T(x)

	INSERT INTO [Profile.Data].[Concept.Mesh.Tree] (DescriptorUI, TreeNumber)
		SELECT	m.DescriptorUI,
				T.x.value('.','varchar(255)')
			FROM [Profile.Data].[Concept.Mesh.XML] m 
				CROSS APPLY MeSH.nodes('//TreeNumber') AS T(x)

	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] (TreeNumber, DescriptorName)
		SELECT	T.x.value('.','varchar(255)'),
				m.MeSH.value('DescriptorRecord[1]/DescriptorName[1]/String[1]','varchar(255)')
			FROM [Profile.Data].[Concept.Mesh.XML] m 
				CROSS APPLY MeSH.nodes('//TreeNumber') AS T(x)
	UPDATE [Profile.Data].[Concept.Mesh.TreeTop]
		SET TreeNumber = left(TreeNumber,1)+'.'+TreeNumber
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('A','Anatomy')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('B','Organisms')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('C','Diseases')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('D','Chemicals and Drugs')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('E','Analytical, Diagnostic and Therapeutic Techniques and Equipment')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('F','Psychiatry and Psychology')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('G','Biological Sciences')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('H','Natural Sciences')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('I','Anthropology, Education, Sociology and Social Phenomena')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('J','Technology, Industry, Agriculture')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('K','Humanities')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('L','Information Science')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('M','Named Groups')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('N','Health Care')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('V','Publication Characteristics')
	INSERT INTO [Profile.Data].[Concept.Mesh.TreeTop] VALUES ('Z','Geographicals')

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Concept.Mesh.GetSimilarMesh]
	@NodeID BIGINT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @DescriptorName NVARCHAR(255)
 	SELECT @DescriptorName = d.DescriptorName
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n,
			[Profile.Data].[Concept.Mesh.Descriptor] d
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
			AND m.InternalID = d.DescriptorUI

 	DECLARE @baseURI NVARCHAR(400)
	SELECT @baseURI = value FROM [Framework.].Parameter WHERE ParameterID = 'baseURI'

	;with a as (
		select SimilarConcept DescriptorName, Weight, SortOrder
		from [Profile.Cache].[Concept.Mesh.SimilarConcept]
		where meshheader = @DescriptorName
	), b as (
		select top 10 DescriptorName, Weight, (select count(*) from a) TotalRecords, SortOrder
		from a
	)
	 SELECT b.*, @baseURI + cast(m.NodeID as varchar(50)) ObjectURI
		 FROM [RDF.Stage].[InternalNodeMap] m, [Profile.Data].[Concept.Mesh.Descriptor] d, b
		 WHERE m.Class = 'http://www.w3.org/2004/02/skos/core#Concept' AND m.InternalType = 'MeshDescriptor'
			AND m.InternalID = d.DescriptorUI AND d.DescriptorName = b.DescriptorName

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Concept.Mesh.GetJournals]
	@NodeID BIGINT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @DescriptorName NVARCHAR(255)
 	SELECT @DescriptorName = d.DescriptorName
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n,
			[Profile.Data].[Concept.Mesh.Descriptor] d
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
			AND m.InternalID = d.DescriptorUI

	select top 10 Journal, JournalTitle, Weight, NumJournals TotalRecords
		from [Profile.Cache].[Concept.Mesh.Journal]
		where meshheader = @DescriptorName
		order by Weight desc

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Concept.Mesh.GetDescriptorXML]
	@NodeID BIGINT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;


	declare @baseURI nvarchar(400)
	select @baseURI = value from [Framework.].Parameter where ParameterID = 'baseURI'


	------------------------------------------------------------
	-- Convert the NodeID to a DescriptorUI
	------------------------------------------------------------

	DECLARE @DescriptorUI VARCHAR(50)
	SELECT @DescriptorUI = m.InternalID
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
 
	IF @DescriptorUI IS NULL
	BEGIN
		SELECT cast(null as xml) DescriptorXML WHERE 1=0
		RETURN
	END


	------------------------------------------------------------
	-- Combine MeSH tables
	------------------------------------------------------------
	/*
	select r.TreeNumber FullTreeNumber, 
			(case when len(r.TreeNumber)=1 then '' else left(r.TreeNumber,len(r.TreeNumber)-4) end) ParentTreeNumber,
			r.DescriptorName, IsNull(t.TreeNumber,r.TreeNumber) TreeNumber, t.DescriptorUI, m.NodeID, f.Value+cast(m.NodeID as varchar(50)) NodeURI
		into #m
		from [Profile.Data].[Concept.Mesh.TreeTop] r
			left outer join [Profile.Data].[Concept.Mesh.Tree] t
				on t.TreeNumber = substring(r.TreeNumber,3,999)
			left outer join [RDF.Stage].[InternalNodeMap] m
				on m.Class = 'http://www.w3.org/2004/02/skos/core#Concept'
					and m.InternalType = 'MeshDescriptor'
					and m.InternalID = cast(t.DescriptorUI as varchar(50))
					and t.DescriptorUI is not null
					and m.Status = 3
			left outer join [Framework.].[Parameter] f
				on f.ParameterID = 'baseURI'
	
	create unique clustered index idx_f on #m(FullTreeNumber)
	create nonclustered index idx_d on #m(DescriptorUI)
	create nonclustered index idx_p on #m(ParentTreeNumber)
	*/

	------------------------------------------------------------
	-- Construct the DescriptorXML
	------------------------------------------------------------

	;with p0 as (
		select distinct b.*
		from [Profile.Cache].[Concept.Mesh.TreeTop] a, [Profile.Cache].[Concept.Mesh.TreeTop] b
		where a.DescriptorUI = @DescriptorUI
			and a.FullTreeNumber like b.FullTreeNumber+'%'
	), r0 as (
		select c.*, b.DescriptorName ParentName, 2 Depth
			from [Profile.Cache].[Concept.Mesh.TreeTop] a, [Profile.Cache].[Concept.Mesh.TreeTop] b, [Profile.Cache].[Concept.Mesh.TreeTop] c
			where a.DescriptorUI = @DescriptorUI
				and a.ParentTreeNumber = b.FullTreeNumber
				and c.ParentTreeNumber = b.FullTreeNumber
		union all
		select b.*, b.DescriptorName ParentName, 1 Depth
			from [Profile.Cache].[Concept.Mesh.TreeTop] a, [Profile.Cache].[Concept.Mesh.TreeTop] b
			where a.DescriptorUI = @DescriptorUI
				and a.ParentTreeNumber = b.FullTreeNumber
	), r1 as (
		select *
		from (
			select *, row_number() over (partition by DescriptorName, ParentName order by TreeNumber) k
			from r0
		) t
		where k = 1
	), c0 as (
		select top 1 DescriptorUI, TreeNumber, DescriptorName,FullTreeNumber
		from [Profile.Cache].[Concept.Mesh.TreeTop]
		where DescriptorUI = @DescriptorUI
		order by FullTreeNumber
	), c1 as (
		select b.DescriptorUI, b.TreeNumber, b.DescriptorName, 2 Depth
			from c0 a, [Profile.Cache].[Concept.Mesh.TreeTop] b
			where b.ParentTreeNumber = a.FullTreeNumber
		union all
		select DescriptorUI, TreeNumber, DescriptorName, 1 Depth
			from c0
	)
	select (
			select
				(
					select MeSH
					from [Profile.Data].[Concept.Mesh.XML]
					where DescriptorUI = @DescriptorUI
					for xml path(''), type
				).query('MeSH[1]/*'),
				(
					select DescriptorUI, TreeNumber, DescriptorName,
						len(FullTreeNumber)-len(replace(FullTreeNumber,'.',''))+1 Depth,
						m.NodeID, @baseURI+cast(m.NodeID as varchar(50)) NodeURI,
						row_number() over (order by FullTreeNumber) SortOrder
					from p0 x
						left outer join [RDF.Stage].[InternalNodeMap] m
							on m.Class = 'http://www.w3.org/2004/02/skos/core#Concept'
								and m.InternalType = 'MeshDescriptor'
								and m.InternalID = x.DescriptorUI
								and x.DescriptorUI is not null
								and m.Status = 3
					for xml path('Descriptor'), type
				) ParentDescriptors,
				(
					select DescriptorUI, TreeNumber, DescriptorName, Depth,
						m.NodeID, @baseURI+cast(m.NodeID as varchar(50)) NodeURI,
						row_number() over (order by ParentName, Depth, DescriptorName) SortOrder
					from r1 x
						left outer join [RDF.Stage].[InternalNodeMap] m
							on m.Class = 'http://www.w3.org/2004/02/skos/core#Concept'
								and m.InternalType = 'MeshDescriptor'
								and m.InternalID = x.DescriptorUI
								and x.DescriptorUI is not null
								and m.Status = 3
					for xml path('Descriptor'), type
				) SiblingDescriptors,
				(
					select DescriptorUI, TreeNumber, DescriptorName, Depth,
						m.NodeID, @baseURI+cast(m.NodeID as varchar(50)) NodeURI,
						row_number() over (order by Depth, DescriptorName) SortOrder
					from c1 x
						left outer join [RDF.Stage].[InternalNodeMap] m
							on m.Class = 'http://www.w3.org/2004/02/skos/core#Concept'
								and m.InternalType = 'MeshDescriptor'
								and m.InternalID = x.DescriptorUI
								and x.DescriptorUI is not null
								and m.Status = 3
					where (select count(*) from c1) > 1
					for xml path('Descriptor'), type
				) ChildDescriptors
			for xml path('DescriptorXML'), type
		) as DescriptorXML


END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[ConnectionDetails.Person.HasResearchArea.GetData]
	@subject BIGINT,
	@object BIGINT,
	@SessionID UNIQUEIDENTIFIER=NULL
AS
BEGIN
 
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	DECLARE @PersonID INT
 	SELECT @PersonID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @subject

	DECLARE @MeshHeader NVARCHAR(255)
 	SELECT @MeshHeader = d.DescriptorName
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n,
			[Profile.Data].[Concept.Mesh.Descriptor] d
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @object
			AND m.InternalID = d.DescriptorUI
	
	;with a as (
		select m.meshheader, m.pmid, m.topicweight, m.authorweight, m.yearweight, m.uniquenessweight, m.meshweight overallweight,
			cast([Profile.Cache].[fnPublication.Pubmed.General2Reference](g.pmid, ArticleDay, ArticleMonth, ArticleYear, ArticleTitle, Authors, AuthorListCompleteYN, Issue, JournalDay, JournalMonth, JournalYear, MedlineDate, MedlinePgn, MedlineTA, Volume, 0) as varchar(8000)) Reference,
			'This phrase is used in ' 
				+ cast(c.numpublications as varchar(10)) 
				+ ' publication' + (case when c.numpublications = 1 then '' else 's' end)
				+ ' by '
				+ cast(c.numfaculty as varchar(10))
				+ ' author' + (case when c.numfaculty = 1 then '' else 's' end)
				+ '.' as UniquenessWeightStr,
			(case when m.topicweight = 1 then 'MeSH major topic' else 'MeSH minor topic' end) TopicWeightStr,
			(case when m.authorweight = 1 then 'First or senior author' when authorweight = 0.25 then 'Middle author' else 'Default author weight' end) AuthorWeightStr,
			(case when g.pubdate < '1/1/1902' then 'Unknown publication date' else 'Published in '+cast(year(g.pubdate) as varchar(10)) end) YearWeightStr
		from [Profile.Cache].[Concept.Mesh.PersonPublication] m, [Profile.Data].[Publication.PubMed.General] g, [Profile.Cache].[Concept.Mesh.Count] c
		where m.personid = @PersonID and m.meshheader = @MeshHeader and m.pmid = g.pmid and m.meshheader = c.meshheader
	), b as (
		select count(*) PublicationCount, sum(overallweight) TotalOverallWeight
		from a
	)
	select *
	from a, b
	order by overallweight desc, pmid

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[ConnectionDetails.Person.CoAuthorOf.GetData]
	@subject BIGINT,
	@object BIGINT,
	@SessionID UNIQUEIDENTIFIER=NULL
AS
BEGIN
 
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	DECLARE @PersonID INT
 	SELECT @PersonID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @subject
 
	DECLARE @PersonID2 INT
 	SELECT @PersonID2 = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @object

	;with c as (
		select a.pmid, a.authorweight a1, b.authorweight a2, a.YearWeight y, a.pubyear d, (a.authorweight * b.authorweight * a.YearWeight) w,
			a.authorposition ap1, b.authorposition ap2
		from [Profile.Cache].[Publication.PubMed.AuthorPosition] a, [Profile.Cache].[Publication.PubMed.AuthorPosition] b
		where a.pmid = b.pmid and a.personid = @PersonID and b.personid = @PersonID2
	), d as (
		select count(*) n, max(d) d, sum(w) tw
		from c
	)
	select @PersonID PersonID1, @PersonID2 PersonID2,
		d.n PublicationCount, d.tw TotalOverallWeight,
		c.a1 AuthorWeight1, c.a2 AuthorWeight2, c.y YearWeight, c.d ArticleYear, c.w OverallWeight, c.pmid PMID,
		(case c.ap1 when 'F' then 'First author' when 'S' then 'First Author' when 'L' then 'Senior Author' when 'M' then 'Middle Author' else 'Default author weight' end) AuthorWeight1Str,
		(case c.ap2 when 'F' then 'First author' when 'S' then 'First Author' when 'L' then 'Senior Author' when 'M' then 'Middle Author' else 'Default author weight' end) AuthorWeight2Str,
		(case when g.pubdate < '1/1/1902' then 'Unknown publication date' else 'Published in '+cast(year(g.pubdate) as varchar(10)) end) YearWeightStr,
		[Profile.Cache].[fnPublication.Pubmed.General2Reference](g.pmid, ArticleDay, ArticleMonth, ArticleYear, ArticleTitle, Authors, AuthorListCompleteYN, Issue, JournalDay, JournalMonth, JournalYear, MedlineDate, MedlinePgn, MedlineTA, Volume, 0) Reference
	from c, d, [Profile.Data].[Publication.PubMed.General] g
	where c.pmid = g.pmid
	order by c.w desc

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Framework.].[CreateInstallData]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	declare @x xml

	select @x = (
		select
			(
				select
					--------------------------------------------------------
					-- [Framework.]
					--------------------------------------------------------
					(
						select	'[Framework.].[Parameter]' 'Table/@Name',
								(
									select	ParameterID 'ParameterID', 
											Value 'Value'
									from [Framework.].[Parameter]
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					(
						select	'[Framework.].[RestPath]' 'Table/@Name',
								(
									select	ApplicationName 'ApplicationName',
											Resolver 'Resolver'
									from [Framework.].[RestPath]
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					(
						select	'[Framework.].[Job]' 'Table/@Name',
								(
									select	JobGroup 'JobGroup',
											Step 'Step',
											IsActive 'IsActive',
											Script 'Script'
									from [Framework.].[Job]
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					(
						select	'[Framework.].[JobGroup]' 'Table/@Name',
								(
									SELECT  JobGroup 'JobGroup',
											Name 'Name',
											Type 'Type',
											Description 'Description'	
									from [Framework.].JobGroup
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					--------------------------------------------------------
					-- [Ontology.]
					--------------------------------------------------------
					(
						select	'[Ontology.].[ClassGroup]' 'Table/@Name',
								(
									select	ClassGroupURI 'ClassGroupURI',
											SortOrder 'SortOrder',
											IsVisible 'IsVisible'
									from [Ontology.].[ClassGroup]
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					(
						select	'[Ontology.].[ClassGroupClass]' 'Table/@Name',
								(
									select	ClassGroupURI 'ClassGroupURI',
											ClassURI 'ClassURI',
											SortOrder 'SortOrder'
									from [Ontology.].[ClassGroupClass]
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					(
						select	'[Ontology.].[ClassProperty]' 'Table/@Name',
								(
									select	Class 'Class',
											NetworkProperty 'NetworkProperty',
											Property 'Property',
											IsDetail 'IsDetail',
											Limit 'Limit',
											IncludeDescription 'IncludeDescription',
											IncludeNetwork 'IncludeNetwork',
											SearchWeight 'SearchWeight',
											CustomDisplay 'CustomDisplay',
											CustomEdit 'CustomEdit',
											ViewSecurityGroup 'ViewSecurityGroup',
											EditSecurityGroup 'EditSecurityGroup',
											EditPermissionsSecurityGroup 'EditPermissionsSecurityGroup',
											EditExistingSecurityGroup 'EditExistingSecurityGroup',
											EditAddNewSecurityGroup 'EditAddNewSecurityGroup',
											EditAddExistingSecurityGroup 'EditAddExistingSecurityGroup',
											EditDeleteSecurityGroup 'EditDeleteSecurityGroup',
											MinCardinality 'MinCardinality',
											MaxCardinality 'MaxCardinality',
											CustomDisplayModule 'CustomDisplayModule',
											CustomEditModule 'CustomEditModule'
									from [Ontology.].ClassProperty
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					(
						select	'[Ontology.].[ClassPropertyCustom]' 'Table/@Name',
								(
									select	
											ClassPropertyCustomTypeID 'ClassPropertyCustomTypeID',
											Class 'Class',
											NetworkProperty 'NetworkProperty',
											Property 'Property',
											IncludeProperty 'IncludeProperty',
											Limit 'Limit',
											IncludeNetwork 'IncludeNetwork',
											IncludeDescription 'IncludeDescription',
											IsDetail 'IsDetail'
									from [Ontology.].ClassPropertyCustom
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					(
						select	'[Ontology.].[DataMap]' 'Table/@Name',
						
								(
									select  DataMapGroup 'DataMapGroup',
											IsAutoFeed 'IsAutoFeed',
											Graph 'Graph',
											Class 'Class',
											NetworkProperty 'NetworkProperty',
											Property 'Property',
											MapTable 'MapTable',
											sInternalType 'sInternalType',
											sInternalID 'sInternalID',
											cClass 'cClass',
											cInternalType 'cInternalType',
											cInternalID 'cInternalID',
											oClass 'oClass',
											oInternalType 'oInternalType',
											oInternalID 'oInternalID',
											oValue 'oValue',
											oDataType 'oDataType',
											oLanguage 'oLanguage',
											oStartDate 'oStartDate',
											oStartDatePrecision 'oStartDatePrecision',
											oEndDate 'oEndDate',
											oEndDatePrecision 'oEndDatePrecision',
											oObjectType 'oObjectType',
											Weight 'Weight',
											OrderBy 'OrderBy',
											ViewSecurityGroup 'ViewSecurityGroup',
											EditSecurityGroup 'EditSecurityGroup'
									from [Ontology.].[DataMap]
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					(
						select	'[Ontology.].[Namespace]' 'Table/@Name',
								(
									select	URI 'URI',
											Prefix 'Prefix'
									from [Ontology.].[Namespace]
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					(
						select	'[Ontology.].[PropertyGroup]' 'Table/@Name',
								(
									select	PropertyGroupURI 'PropertyGroupURI',
											SortOrder 'SortOrder',
											_PropertyGroupLabel '_PropertyGroupLabel'
									from [Ontology.].[PropertyGroup]
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					(
						select	'[Ontology.].[PropertyGroupProperty]' 'Table/@Name',
								(
									select	PropertyGroupURI 'PropertyGroupURI',
											PropertyURI 'PropertyURI',
											SortOrder 'SortOrder',
											CustomDisplayModule 'CustomDisplayModule',
											CustomEditModule 'CustomEditModule',
											_TagName '_TagName',
											_PropertyLabel '_PropertyLabel'
									from [Ontology.].[PropertyGroupProperty]
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					--------------------------------------------------------
					-- [Ontology.Presentation]
					--------------------------------------------------------
					(
						select	'[Ontology.Presentation].[XML]' 'Table/@Name',
								(
									select	type 'type',
											subject 'subject',
											predicate 'predicate',
											object 'object',
											presentationXML 'presentationXML'
									from [Ontology.Presentation].[XML]
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					--------------------------------------------------------
					-- [RDF.Security]
					--------------------------------------------------------
					(
						select	'[RDF.Security].[Group]' 'Table/@Name',
								(
									select	SecurityGroupID 'SecurityGroupID',
											Label 'Label',
											HasSpecialViewAccess 'HasSpecialViewAccess',
											HasSpecialEditAccess 'HasSpecialEditAccess',
											Description 'Description'
									from [RDF.Security].[Group]
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					--------------------------------------------------------
					-- [Utility.NLP]
					--------------------------------------------------------
					(
						select	'[Utility.NLP].[ParsePorterStemming]' 'Table/@Name',
								(
									select	step 'Step',
											Ordering 'Ordering',
											phrase1 'phrase1',
											phrase2 'phrase2'
									from [Utility.NLP].ParsePorterStemming
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					(
						select	'[Utility.NLP].[StopWord]' 'Table/@Name',
								(
									select	word 'word',
											stem 'stem',
											scope 'scope'
									from [Utility.NLP].[StopWord]
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					(
						select	'[Utility.NLP].[Thesaurus.Source]' 'Table/@Name',
								(
									select	Source 'Source',
											SourceName 'SourceName'
									from [Utility.NLP].[Thesaurus.Source]
									for xml path('Row'), type
								) 'Table'
						for xml path(''), type
					),
					--------------------------------------------------------
					-- [User.Session]
					--------------------------------------------------------
					(
						select	'[User.Session].Bot' 'Table/@Name',
							(
								SELECT UserAgent 'UserAgent' 
								  FROM [User.Session].Bot
				  					for xml path('Row'), type
			   				) 'Table'  
						for xml path(''), type
					),
					--------------------------------------------------------
					-- [Direct.]
					--------------------------------------------------------
					(
						select	'[Direct.].[Sites]' 'Table/@Name',
							(
								SELECT SiteID 'SiteID',
										BootstrapURL 'BootstrapURL',
										SiteName 'SiteName',
										QueryURL 'QueryURL',
										SortOrder 'SortOrder',
										IsActive 'IsActive'  
								  FROM [Direct.].[Sites] 
			 					for xml path('Row'), type
					 		) 'Table'   
						for xml path(''), TYPE
					),
					--------------------------------------------------------
					-- [Profile.Data]
					--------------------------------------------------------
					(
						select	'[Profile.Data].[Publication.Type]' 'Table/@Name',
							(
								SELECT	pubidtype_id 'pubidtype_id',
										name 'name',
										sort_order 'sort_order'
								  FROM [Profile.Data].[Publication.Type]
				  					for xml path('Row'), type
			   				) 'Table'  
						for xml path(''), type
					),
					(
						select	'[Profile.Data].[Publication.MyPub.Category]' 'Table/@Name',
							(
								SELECT	HmsPubCategory 'HmsPubCategory',
										CategoryName 'CategoryName'
								  FROM [Profile.Data].[Publication.MyPub.Category]
				  					for xml path('Row'), type
							) 'Table'  
						for xml path(''), type
					),
					--------------------------------------------------------
					-- [ORCID.]
					--------------------------------------------------------
					(
						select '[ORCID.].[REF_Permission]' 'Table/@Name',
						(
							SELECT	PermissionScope 'PermissionScope', 
									PermissionDescription 'PermissionDescription', 
									MethodAndRequest 'MethodAndRequest',
									SuccessMessage 'SuccessMessage',
									FailedMessage 'FailedMessage'
								from [ORCID.].[REF_Permission]
									for xml path('Row'), type
						) 'Table'  
						for xml path(''), type
					),
					(
						select '[ORCID.].[REF_PersonStatusType]' 'Table/@Name',
						(
							SELECT	StatusDescription 'StatusDescription'
								from [ORCID.].[REF_PersonStatusType]
									for xml path('Row'), type
						) 'Table'  
						for xml path(''), type
					),
					(
						select '[ORCID.].[REF_WorkExternalType]' 'Table/@Name',
						(
							SELECT	WorkExternalType 'WorkExternalType',
									WorkExternalDescription 'WorkExternalDescription'
								from [ORCID.].[REF_WorkExternalType]
									for xml path('Row'), type
						) 'Table'  
						for xml path(''), type
					),
					(
						select '[ORCID.].[REF_RecordStatus]' 'Table/@Name',
						(
							SELECT	RecordStatusID 'RecordStatusID',
									StatusDescription, 'StatusDescription'
								from [ORCID.].[REF_RecordStatus]
									for xml path('Row'), type
						) 'Table'  
						for xml path(''), type
					),
					(
						select '[ORCID.].[REF_Decision]' 'Table/@Name',
						(
							SELECT	DecisionDescription 'DecisionDescription',
									DecisionDescriptionLong 'DecisionDescriptionLong'
								from [ORCID.].[REF_Decision]
									for xml path('Row'), type
						) 'Table'  
						for xml path(''), type
					),
					(
						select '[ORCID.].[RecordLevelAuditType]' 'Table/@Name',
						(
							SELECT	AuditType 'AuditType'
								from [ORCID.].[RecordLevelAuditType]
									for xml path('Row'), type
						) 'Table'  
						for xml path(''), type
					),
					(
						select '[ORCID.].[DefaultORCIDDecisionIDMapping]' 'Table/@Name',
						(
							SELECT	SecurityGroupID 'SecurityGroupID',
									DefaultORCIDDecisionID 'DefaultORCIDDecisionID'
								from [ORCID.].[DefaultORCIDDecisionIDMapping]
									for xml path('Row'), type
						) 'Table'  
						for xml path(''), type
					),
					--------------------------------------------------------
					-- [Profile.Module].[GenericRDF.Plugins]
					--------------------------------------------------------					
					(
						select '[Profile.Module].[GenericRDF.Plugins]' 'Table/@Name',
						(
							SELECT	Name 'Name',
									EnabledForPerson 'EnabledForPerson',
									EnabledForGroup 'EnabledForGroup',
									Label 'Label',
									PropertyGroupURI 'PropertyGroupURI',
									[CustomDisplayModule] 'CustomDisplayModule',
									[CustomEditModule] 'CustomEditModule'
								from [Profile.Module].[GenericRDF.Plugins]
									for xml path('Row'), type
						) 'Table'  
						for xml path(''), type
					),
 				    ---------------------------------------------------------------
					-- [Profile.Import].[PRNSWebservice.*]
					---------------------------------------------------------------
					(					(
						select '[Profile.Import].[PRNSWebservice.Options]' 'Table/@Name',
						(
							SELECT	job 'job',
									url 'url',
									options 'options',
									logLevel 'logLevel',
									batchSize 'batchSize',
									GetPostDataProc 'GetPostDataProc',
									ImportDataProc 'ImportDataProc'
								from [Profile.Import].[PRNSWebservice.Options]
									for xml path('Row'), type
						) 'Table'  
						for xml path(''), type
					)
				)
				for xml path(''), type
			) 'Import'
		for xml path(''), type
	)


	insert into [Framework.].[InstallData] (Data)
		select @x


   --Use to generate select lists for new tables
   --SELECT    c.name +  ' ''' + name + ''','
   --FROM sys.columns c  
   --WHERE object_id IN (SELECT object_id FROM sys.tables WHERE name = 'Publication.MyPub.Category')  

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Ontology.Presentation].[ConvertXML2Tables]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	truncate table [Ontology.Presentation].[General]
	insert into [Ontology.Presentation].[General]
		select	PresentationID, 
				Type,
				Subject,
				Predicate,
				Object,
				PresentationXML.value('Presentation[1]/PageOptions[1]/@Columns[1]','varchar(max)') PageColumns,
				PresentationXML.value('Presentation[1]/WindowName[1]','varchar(max)') WindowName,
				PresentationXML.value('Presentation[1]/PageTitle[1]','varchar(max)') PageTitle,
				PresentationXML.value('Presentation[1]/PageBackLinkName[1]','varchar(max)') PageBackLinkName,
				PresentationXML.value('Presentation[1]/PageBackLinkURL[1]','varchar(max)') PageBackLinkURL,
				PresentationXML.value('Presentation[1]/PageSubTitle[1]','varchar(max)') PageSubTitle,
				PresentationXML.value('Presentation[1]/PageDescription[1]','varchar(max)') PageDescription,
				PresentationXML.value('Presentation[1]/PanelTabType[1]','varchar(max)') PanelTabType,
				(CASE WHEN CAST(PresentationXML.query('Presentation[1]/ExpandRDFList[1]/*') AS NVARCHAR(MAX)) <> ''
					THEN PresentationXML.query('Presentation[1]/ExpandRDFList[1]/*')
					ELSE NULL END) ExpandRDFList
			from [Ontology.Presentation].[XML]

	truncate table [Ontology.Presentation].[Panel]
	insert into [Ontology.Presentation].[Panel]
		select	o.PresentationID,
				p.x.value('@Type','varchar(max)') Type, 
				IsNull(p.x.value('@TabSort','varchar(max)'),-1) TabSort, 
				p.x.value('@TabType','varchar(max)') TabType,
				p.x.value('@Alias','varchar(max)') Alias,
				p.x.value('@Name','varchar(max)') Name,
				p.x.value('@Icon','varchar(max)') Icon,
				p.x.value('@DisplayRule','varchar(max)') DisplayRule,
				(CASE WHEN CAST(p.x.query('./*') AS NVARCHAR(MAX)) <> ''
					THEN p.x.query('./*')
					ELSE NULL END) ModuleXML
			from [Ontology.Presentation].[XML] o CROSS APPLY o.PresentationXML.nodes('Presentation[1]/PanelList[1]/Panel') as p(x)
			where p.x.value('@Type','varchar(max)') <> ''

	-- SELECT * FROM [Ontology.Presentation].[General]
	-- SELECT * FROM [Ontology.Presentation].[Panel]

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Ontology.Import].[ConvertTriple2OWL]
	@OWL varchar(50),
	@Graph bigint = NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- This stored procedure is currently only intended for use with @OWL = 'PRNS_1.0' (and @Graph = 3)

	select t.subject, n.prefix+':'+right(t.predicate,len(t.predicate)-len(n.uri)) predicate, t.object
		into #t
		from [Ontology.Import].Triple t, [Ontology.].Namespace n
		where t.OWL = @OWL and t.Predicate like n.URI+'%'
		order by t.subject, predicate, t.object

	declare @z as varchar(max)

	select @z =
		(select 
				'<rdf:Description rdf:about="'+subject+'">'
				+(
					select '<'+v.predicate+' rdf:resource="'+v.object+'"/>' 
					from #t v 
					where v.subject = t.subject 
					order by v.predicate, v.object
					for xml path(''), type
				).value('(./text())[1]','nvarchar(max)')
				+'</rdf:Description>'
			from (select distinct subject from #t) t
			order by t.subject
			for xml path(''), type
		).value('(./text())[1]','nvarchar(max)')

	declare @x as varchar(max)
	select @x = '<rdf:RDF'
	select @x = @x + ' xmlns:'+Prefix+'="'+URI+'"' 
		from [Ontology.].Namespace
	select @x = @x + ' >' + @z + '</rdf:RDF>'

	-- select cast(@x as xml) RDF
	BEGIN TRY
		begin transaction

			delete 
				from [Ontology.Import].[OWL] 
				where Name = @OWL

			insert into [Ontology.Import].[OWL] (Name, Data, Graph)
				select @OWL, cast(@x as xml), @Graph

		commit transaction
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK

		-- Raise an error with the details of the exception
		SELECT @ErrMsg =  ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()

		RAISERROR(@ErrMsg, @ErrSeverity, 1)

	END CATCH		


	-- select * from [Ontology.Import].[OWL]

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[NetworkTimeline.Person.HasResearchArea.GetData]
	@NodeID BIGINT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @PersonID INT
 	SELECT @PersonID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
 
 	DECLARE @baseURI NVARCHAR(400)
	SELECT @baseURI = value FROM [Framework.].Parameter WHERE ParameterID = 'baseURI'

	;with a as (
		select t.*, g.pubdate
		from (
			select top 20 *, 
				--numpubsthis/sqrt(numpubsall+100)/sqrt((LastPublicationYear+1 - FirstPublicationYear)*1.00000) w
				--numpubsthis/sqrt(numpubsall+100)/((LastPublicationYear+1 - FirstPublicationYear)*1.00000) w
				--WeightNTA/((LastPublicationYear+2 - FirstPublicationYear)*1.00000) w
				weight w
			from [Profile.Cache].[Concept.Mesh.Person]
			where personid = @PersonID
			order by w desc, meshheader
		) t, [Profile.Cache].[Concept.Mesh.PersonPublication] m, [Profile.Data].[Publication.PubMed.General] g
		where t.meshheader = m.meshheader and t.personid = m.personid and m.pmid = g.pmid and year(g.pubdate) > 1900
	), b as (
		select min(firstpublicationyear)-1 a, max(lastpublicationyear)+1 b,
			cast(cast('1/1/'+cast(min(firstpublicationyear)-1 as varchar(10)) as datetime) as float) f,
			cast(cast('1/1/'+cast(max(lastpublicationyear)+1 as varchar(10)) as datetime) as float) g
		from a
	), c as (
		select a.*, (cast(pubdate as float)-f)/(g-f) x, a, b, f, g
		from a, b
	), d as (
		select meshheader, min(x) MinX, max(x) MaxX, avg(x) AvgX
				--, (select avg(cast(g.pubdate as float))
				--from resnav_people_hmsopen.dbo.pm_pubs_general g, (
				--	select distinct pmid
				--	from resnav_people_hmsopen.dbo.cache_pub_mesh m
				--	where m.meshheader = c.meshheader
				--) t
				--where g.pmid = t.pmid) AvgAllX
		from c
		group by meshheader
	)
	select c.*, d.MinX, d.MaxX, d.AvgX,	c.meshheader label, (select count(distinct meshheader) from a) n, p.DescriptorUI
		into #t
		from c, d, [Profile.Data].[Concept.Mesh.Descriptor] p
		where c.meshheader = d.meshheader and d.meshheader = p.DescriptorName

	select t.*, @baseURI + cast(m.NodeID as varchar(50)) ObjectURI
		from #t t, [RDF.Stage].[InternalNodeMap] m
		where t.DescriptorUI = m.InternalID
			and m.Class = 'http://www.w3.org/2004/02/skos/core#Concept' and m.InternalType = 'MeshDescriptor'
		order by AvgX, firstpublicationyear, lastpublicationyear, meshheader, pubdate

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Search.Cache].[History.UpdateTopSearchPhrase]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	CREATE TABLE #TopSearchPhrase (
		TimePeriod CHAR(1) NOT NULL,
		Phrase VARCHAR(100) NOT NULL,
		NumberOfQueries INT
	)

	-- Get top day, week, and month phrases
	
	INSERT INTO #TopSearchPhrase (TimePeriod, Phrase, NumberOfQueries)
		SELECT TOP 10 'd', Phrase, COUNT(*) n
			FROM [Search.].[History.Phrase]
			WHERE NumberOfConnections > 0
				AND LEN(Phrase) >= 4
				AND LEN(Phrase) <= 100
				AND IsBot = 0
				AND EndDate >= DATEADD(DAY,-1,GETDATE())
			GROUP BY Phrase
			HAVING MAX(NumberOfConnections) < 1000
			ORDER BY n DESC

	INSERT INTO #TopSearchPhrase (TimePeriod, Phrase, NumberOfQueries)
		SELECT TOP 10 'w', Phrase, COUNT(*) n
			FROM [Search.].[History.Phrase]
			WHERE NumberOfConnections > 0
				AND LEN(Phrase) >= 4
				AND LEN(Phrase) <= 100
				AND IsBot = 0
				AND EndDate >= DATEADD(WEEK,-1,GETDATE())
			GROUP BY Phrase
			HAVING MAX(NumberOfConnections) < 1000
			ORDER BY n DESC

	INSERT INTO #TopSearchPhrase (TimePeriod, Phrase, NumberOfQueries)
		SELECT TOP 10 'm', Phrase, COUNT(*) n
			FROM [Search.].[History.Phrase]
			WHERE NumberOfConnections > 0
				AND LEN(Phrase) >= 4
				AND LEN(Phrase) <= 100
				AND IsBot = 0
				AND EndDate >= DATEADD(MONTH,-1,GETDATE())
			GROUP BY Phrase
			HAVING MAX(NumberOfConnections) < 1000
			ORDER BY n DESC

	-- Add phrases to try to get to 10 phrases per time period

	DECLARE @n INT
	
	SELECT @n = 10 - (SELECT COUNT(*) FROM #TopSearchPhrase WHERE TimePeriod = 'd')
	IF @n > 0
		INSERT INTO #TopSearchPhrase (TimePeriod, Phrase, NumberOfQueries)
			SELECT TOP(@n) 'd', Phrase, NumberOfQueries
				FROM #TopSearchPhrase
				WHERE TimePeriod = 'w'
					AND Phrase NOT IN (SELECT Phrase FROM #TopSearchPhrase WHERE TimePeriod = 'd')
				ORDER BY NumberOfQueries DESC

	SELECT @n = 10 - (SELECT COUNT(*) FROM #TopSearchPhrase WHERE TimePeriod = 'd')
	IF @n > 0
		INSERT INTO #TopSearchPhrase (TimePeriod, Phrase, NumberOfQueries)
			SELECT TOP(@n) 'd', Phrase, NumberOfQueries
				FROM #TopSearchPhrase
				WHERE TimePeriod = 'm'
					AND Phrase NOT IN (SELECT Phrase FROM #TopSearchPhrase WHERE TimePeriod = 'd')
				ORDER BY NumberOfQueries DESC

	SELECT @n = 10 - (SELECT COUNT(*) FROM #TopSearchPhrase WHERE TimePeriod = 'w')
	IF @n > 0
		INSERT INTO #TopSearchPhrase (TimePeriod, Phrase, NumberOfQueries)
			SELECT TOP(@n) 'w', Phrase, NumberOfQueries
				FROM #TopSearchPhrase
				WHERE TimePeriod = 'm'
					AND Phrase NOT IN (SELECT Phrase FROM #TopSearchPhrase WHERE TimePeriod = 'w')
				ORDER BY NumberOfQueries DESC

	-- Update the cache table

	TRUNCATE TABLE [Search.Cache].[History.TopSearchPhrase]
	INSERT INTO [Search.Cache].[History.TopSearchPhrase] (TimePeriod, Phrase, NumberOfQueries)
		SELECT TimePeriod, Phrase, NumberOfQueries 
			FROM #TopSearchPhrase

	--DROP TABLE #TopSearchPhrase
	--SELECT * FROM [Search.Cache].[History.TopSearchPhrase]
	
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [RDF.].[GetPropertyList]
	@RDF xml = NULL,
	@RDFStr nvarchar(max) = NULL,
	@PresentationXML xml,
	@RootPath nvarchar(max) = 'rdf:RDF[1]/rdf:Description[1]',
	@ShowAllProperties bit = 0,
	@CountsOnly bit = 0,
	@PropertyGroupURI varchar(400) = NULL,
	@PropertyURI varchar(400) = NULL,
	@returnTable bit = 0,
	@returnXML bit = 1,
	@returnXMLasStr bit = 0,
	@PropertyListXML xml = NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-----------------------------------------------------
	-- Copy the @RDFStr value to the @RDF variable
	-----------------------------------------------------

	if (@RDF is null and @RDFStr is not null)
		select @RDF = cast(replace(@RDFStr,char(13),'&#13;') as xml)

	-----------------------------------------------------
	-- Define temp tables and variables
	-----------------------------------------------------
		
	create table #RDFData (
		ItemSortOrder int identity(0,1) primary key,
		TagName varchar(400),
		ObjectValue nvarchar(max),
		ObjectURI varchar(400),
		ObjectClass varchar(400),
		ObjectClassName varchar(max)
	)

	declare @sql nvarchar(max)



	-----------------------------------------------------
	-- Parse the RDF data
	-----------------------------------------------------

	select @sql = ''
	select @sql = @sql + ' '''+URI+''' as '+Prefix+','
		from [Ontology.].Namespace
	select @sql = left(@sql,len(@sql)-1)
		
	select @sql = '
		;WITH XMLNAMESPACES (
			'+@sql+'
		), RDFDescriptions as (
			select	z.value(''@rdf:about'',''varchar(max)'') About,
					z.value(''rdfs:label[1]'',''varchar(max)'') Label,
					(select top 1 t.ClassURI
						from (select x.value(''@rdf:resource[1]'',''varchar(max)'') ClassURI
								from z.nodes(''rdf:type'') as t(x)
							) t
							left outer join [Ontology.].ClassTreeDepth d
							on t.ClassURI = d.Class
						order by (case when d._TreeDepth is null then 1 else 0 end), d._TreeDepth desc
					) Class
			from (select @RDF as x) t cross apply x.nodes(''rdf:RDF[1]/rdf:Description'') as R(z)
		), RDFTagsTemp as (
			select	z.value(''namespace-uri(.)'',''varchar(max)'') NamespaceURI,
					z.value(''local-name(.)'',''varchar(max)'') LocalName,
					z.value(''@rdf:resource'',''varchar(max)'') Resource,
					z.value(''.'',''nvarchar(max)'') Value
			from (select @RDF.query('''+@RootPath+''') as x) t cross apply x.nodes(''rdf:Description/*'') as R(z)
		)
		select	o.Prefix+'':''+b.LocalName TagName, 
					Coalesce(a.Label,b.Resource,b.Value) ObjectValue, 
					b.Resource ObjectURI,
					a.Class ObjectClass,
					c.Label ObjectClassName
			from RDFTagsTemp b 
				inner join [Ontology.].[Namespace] o on o.URI = b.NamespaceURI
				left outer join RDFDescriptions a on b.Resource = a.About
				left outer join RDFDescriptions c on a.Class = c.About
		'
		
	insert into #RDFData (TagName, ObjectValue, ObjectURI, ObjectClass, ObjectClassName)
			EXEC sp_executesql @sql, N'@RDF xml', @RDF = @RDF

	--create nonclustered index idx_TagName on #RDFData(TagName)

	-----------------------------------------------------
	-- Parse the PresentationXML
	-----------------------------------------------------

	select p.*, s.Label ViewSecurityGroupLabel
		into #Properties
		from (
			select	R.p.value('../@URI','varchar(400)') PropertyGroupURI,
					R.p.value('../@Label','varchar(max)') PropertyGroupLabel,
					R.p.value('../@SortOrder','int') PropertyGroupSortOrder,
					R.p.value('@URI','varchar(400)') PropertyURI,
					R.p.value('@Label','varchar(max)') PropertyLabel,
					R.p.value('@SortOrder','int') PropertySortOrder,
					R.p.value('@TagName','varchar(400)') TagName,
					R.p.value('@CustomDisplay','varchar(max)') CustomDisplay,
					R.p.value('@CustomEdit','varchar(max)') CustomEdit,
					R.p.value('@ViewSecurityGroup','bigint') ViewSecurityGroup,
					R.p.value('@EditPermissions','varchar(max)') EditPermissions,
					R.p.value('@EditExisting','varchar(max)') EditExisting,
					R.p.value('@EditAddNew','varchar(max)') EditAddNew,
					R.p.value('@EditAddExisting','varchar(max)') EditAddExisting,
					R.p.value('@EditDelete','varchar(max)') EditDelete,
					R.p.value('@MinCardinality','varchar(max)') MinCardinality,
					R.p.value('@MaxCardinality','varchar(max)') MaxCardinality,
					R.p.value('@ObjectType','bit') ObjectType,
					R.p.value('@HasDataFeed','varchar(max)') HasDataFeed,
					(case when cast(R.p.query('./*') as nvarchar(max))='' then null else R.p.query('./*') end) CustomModule
				from (select @PresentationXML x) t cross apply t.x.nodes('Presentation/PropertyList/PropertyGroup/Property') as R(p)
		) p left outer join (
			select	R.p.value('@ID','bigint') ID,
					R.p.value('@Label','varchar(max)') Label
				from (select @PresentationXML x) t cross apply t.x.nodes('Presentation/SecurityGroupList/SecurityGroup') as R(p)
		) s on p.ViewSecurityGroup = s.ID
		where PropertyGroupURI = IsNull(@PropertyGroupURI,PropertyGroupURI)
			and PropertyURI = IsNull(@PropertyURI,PropertyURI)
			and (@ShowAllProperties = 1 or (TagName in (select TagName from #RDFData)))

	--create nonclustered index idx_TagName on #Properties(TagName)
	--create nonclustered index idx_PropertyGroupURI on #Properties(PropertyGroupURI)
	--create nonclustered index idx_PropertyURI on #Properties(PropertyURI)

	-----------------------------------------------------
	-- Create the Property List
	-----------------------------------------------------

	if @returnTable = 1 and @CountsOnly = 0
		select	p.PropertyGroupURI, p.PropertyGroupLabel, p.PropertyGroupSortOrder, IsNull(gn.Items,0) NumberOfPropertyGroupConnections,
				p.PropertyURI, p.PropertyLabel, p.PropertySortOrder, p.TagName, IsNull(pn.Items,0) NumberOfPropertyConnections,
				r.ItemSortOrder, r.ObjectValue, r.ObjectURI, r.ObjectClass, r.ObjectClassName,
				p.CustomDisplay, p.ViewSecurityGroup, p.ViewSecurityGroupLabel, p.CustomEdit,
				p.EditPermissions, p.EditExisting, p.EditAddNew, p.EditAddExisting, p.EditDelete,
				p.MinCardinality, p.MaxCardinality, p.OjbectType, p.HasDataFeed,
				p.CustomModule
			from #Properties p
				left outer join (
					select p.PropertyGroupURI, count(*) Items
						from #Properties p inner join #RDFData r
							on p.TagName = r.TagName
					group by p.PropertyGroupURI
				) gn on gn.PropertyGroupURI = p.PropertyGroupURI
				left outer join (
					select p.PropertyURI, count(*) Items
						from #Properties p inner join #RDFData r
							on p.TagName = r.TagName
					group by p.PropertyURI
				) pn on pn.PropertyURI = p.PropertyURI
				left outer join #RDFData r
					on p.TagName = r.TagName
			where (@ShowAllProperties = 1 or r.ItemSortOrder is not null)
			order by p.PropertyGroupSortOrder, p.PropertySortOrder, r.ItemSortOrder


	if @returnTable = 1 and @CountsOnly = 1
		select	p.PropertyGroupURI, p.PropertyGroupLabel, p.PropertyGroupSortOrder, IsNull(gn.Items,0) NumberOfPropertyGroupConnections,
				p.PropertyURI, p.PropertyLabel, p.PropertySortOrder, p.TagName, IsNull(pn.Items,0) NumberOfPropertyConnections,
				p.CustomDisplay, p.ViewSecurityGroup, p.ViewSecurityGroupLabel, p.CustomEdit,
				p.EditPermissions, p.EditExisting, p.EditAddNew, p.EditAddExisting, p.EditDelete,
				p.MinCardinality, p.MaxCardinality, p.ObjectType, p.HasDataFeed,
				p.CustomModule
			from #Properties p
				left outer join (
					select p.PropertyGroupURI, count(*) Items
						from #Properties p inner join #RDFData r
							on p.TagName = r.TagName
					group by p.PropertyGroupURI
				) gn on gn.PropertyGroupURI = p.PropertyGroupURI
				left outer join (
					select p.PropertyURI, count(*) Items
						from #Properties p inner join #RDFData r
							on p.TagName = r.TagName
					group by p.PropertyURI
				) pn on pn.PropertyURI = p.PropertyURI
			where (@ShowAllProperties = 1 or pn.PropertyURI is not null)
			order by p.PropertyGroupSortOrder, p.PropertySortOrder


	if (@returnTable = 0 or @returnXML = 1)
		select @PropertyListXML = (
			select (
				select	g.PropertyGroupURI "@URI",
						g.PropertyGroupLabel "@Label",
						g.PropertyGroupSortOrder "@SortOrder",
						(select	count(*)
							from #Properties p, #RDFData r
							where p.PropertyGroupURI = g.PropertyGroupURI and r.TagName = p.TagName
						) "@NumberOfConnections",
						(
							select	p.PropertyURI "@URI",
									p.PropertyLabel "@Label",
									p.PropertySortOrder "@SortOrder",
									p.TagName "@TagName",
									(select	count(*)
										from #RDFData r
										where r.TagName = p.TagName
									) "@NumberOfConnections",
									p.CustomDisplay "@CustomDisplay",
									p.ViewSecurityGroup "@ViewSecurityGroup",
									p.ViewSecurityGroupLabel "@ViewSecurityGroupLabel",
									p.CustomEdit "@CustomEdit",
									p.EditPermissions "@EditPermissions",
									p.EditExisting "@EditExisting",
									p.EditAddNew "@EditAddNew",
									p.EditAddExisting "@EditAddExisting",
									p.EditDelete "@EditDelete",
									p.MinCardinality "@MinCardinality",
									p.MaxCardinality "@MaxCardinality",
									p.ObjectType "@ObjectType",
									p.HasDataFeed "@HasDataFeed",
									p.CustomModule "CustomModule",
									(case when @CountsOnly = 1 then null else (
											select	row_number() over (order by r.ItemSortOrder) "Connection/@SortOrder",
													r.ObjectURI "Connection/@ResourceURI",
													r.ObjectClass "Connection/@ClassURI",
													r.ObjectClassName "Connection/@ClassName",
													r.ObjectValue "Connection"
												from #RDFData r
												where r.TagName = p.TagName
												order by r.ItemSortOrder
												for xml path(''), type
										) end) "Network"
								from #Properties p
								where p.PropertyGroupURI = g.PropertyGroupURI
								order by p.PropertySortOrder
								for xml path('Property'), type
						)
					from (select distinct PropertyGroupURI, PropertyGroupLabel, PropertyGroupSortOrder from #Properties) g
					order by g.PropertyGroupSortOrder
					for xml path('PropertyGroup'), type
			) "PropertyList"
			for xml path(''), type
		)
		
	if @PropertyListXML is null or (cast(@PropertyListXML as nvarchar(max)) = '')
		select @PropertyListXML = cast('<PropertyList />' as xml)
	
	if @returnXML = 1 and @returnXMLasStr = 0
		select @PropertyListXML PropertyList

	if @returnXML = 1 and @returnXMLasStr = 1
		select cast(@PropertyListXML as nvarchar(max)) PropertyList

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Search.].[GetTopSearchPhrase]
	@TimePeriod CHAR(1)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT *
		FROM [Search.Cache].[History.TopSearchPhrase]
		WHERE TimePeriod = @TimePeriod
		ORDER BY NumberOfQueries DESC

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Organization.GetInstitutions]
	@OnlyActivePrimaryAffiliation int = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF @OnlyActivePrimaryAffiliation = 1
	BEGIN
		SELECT x.InstitutionID, x.InstitutionName, x.InstitutionAbbreviation, n.NodeID, n.Value URI
			FROM (
					SELECT CAST(MAX(InstitutionID) AS VARCHAR(50)) InstitutionID,
							LTRIM(RTRIM(InstitutionName)) InstitutionName, 
							MIN(institutionabbreviation) InstitutionAbbreviation
					FROM [Profile.Data].[Organization.Institution] WITH (NOLOCK)
					WHERE InstitutionAbbreviation in (select distinct institutionAbbreviation from [Profile.Cache].[Person])
					GROUP BY LTRIM(RTRIM(InstitutionName))
				) x 
				LEFT OUTER JOIN [RDF.Stage].InternalNodeMap m WITH (NOLOCK)
					ON m.class = 'http://xmlns.com/foaf/0.1/Organization'
						AND m.InternalType = 'Institution'
						AND m.InternalID = CAST(x.InstitutionID AS VARCHAR(50))
				LEFT OUTER JOIN [RDF.].Node n WITH (NOLOCK)
					ON m.NodeID = n.NodeID
						AND n.ViewSecurityGroup = -1
			ORDER BY InstitutionName
	END
	ELSE
	BEGIN
		SELECT x.InstitutionID, x.InstitutionName, x.InstitutionAbbreviation, n.NodeID, n.Value URI
			FROM (
					SELECT CAST(MAX(InstitutionID) AS VARCHAR(50)) InstitutionID,
							LTRIM(RTRIM(InstitutionName)) InstitutionName, 
							MIN(institutionabbreviation) InstitutionAbbreviation
					FROM [Profile.Data].[Organization.Institution] WITH (NOLOCK)
					GROUP BY LTRIM(RTRIM(InstitutionName))
				) x 
				LEFT OUTER JOIN [RDF.Stage].InternalNodeMap m WITH (NOLOCK)
					ON m.class = 'http://xmlns.com/foaf/0.1/Organization'
						AND m.InternalType = 'Institution'
						AND m.InternalID = CAST(x.InstitutionID AS VARCHAR(50))
				LEFT OUTER JOIN [RDF.].Node n WITH (NOLOCK)
					ON m.NodeID = n.NodeID
						AND n.ViewSecurityGroup = -1
			ORDER BY InstitutionName
	END
END
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Organization.GetDivisions]

AS
BEGIN

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT x.DivisionID, x.DivisionName, n.NodeID, n.Value URI
		FROM (
				SELECT *
				FROM [Profile.Data].[Organization.Division] WITH (NOLOCK)
				WHERE LTRIM(RTRIM(DivisionName))<>''
			) x 
			LEFT OUTER JOIN [RDF.Stage].InternalNodeMap m WITH (NOLOCK)
				ON m.class = 'http://xmlns.com/foaf/0.1/Organization'
					AND m.InternalType = 'Division'
					AND m.InternalID = CAST(x.DivisionID AS VARCHAR(50))
			LEFT OUTER JOIN [RDF.].Node n WITH (NOLOCK)
				ON m.NodeID = n.NodeID
					AND n.ViewSecurityGroup = -1
		ORDER BY DivisionName

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Organization.GetDepartments]

AS
BEGIN

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT x.DepartmentID, x.DepartmentName Department, n.NodeID, n.Value URI
		FROM (
				SELECT *
				FROM [Profile.Data].[Organization.Department] WITH (NOLOCK)
				WHERE Visible = 1 AND LTRIM(RTRIM(DepartmentName))<>''
			) x 
			LEFT OUTER JOIN [RDF.Stage].InternalNodeMap m WITH (NOLOCK)
				ON m.class = 'http://xmlns.com/foaf/0.1/Organization'
					AND m.InternalType = 'Department'
					AND m.InternalID = CAST(x.DepartmentID AS VARCHAR(50))
			LEFT OUTER JOIN [RDF.].Node n WITH (NOLOCK)
				ON m.NodeID = n.NodeID
					AND n.ViewSecurityGroup = -1
		ORDER BY Department

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [RDF.Stage].[LoadTriplesFromOntology]
	@OWL NVARCHAR(100) = NULL,
	@Truncate BIT = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	if @Truncate = 1
		truncate table [RDF.Stage].Triple
 
	insert into [RDF.Stage].Triple (
			sURI,sViewSecurityGroup,sEditSecurityGroup,
			pProperty,pViewSecurityGroup,pEditSecurityGroup,
			oValue,oObjectType,oViewSecurityGroup,oEditSecurityGroup,
			tViewSecurityGroup,Weight,SortOrder,Graph)
		select	Subject, -1, -50,
				Predicate, -1, -50,
				Object, (case when Object like 'http%' then 0 else 1 end), -1, -50,
				-1, 1, row_number() over (partition by Subject, Predicate order by Object),
				Graph
		from [Ontology.Import].Triple
		where OWL = IsNull(@OWL,OWL)
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Module].[NetworkRadial.GetCoauthors]
	@NodeID BIGINT,
	@SessionID UNIQUEIDENTIFIER=NULL,
	@OutputFormat VARCHAR(50)='JSON'
AS
BEGIN
	SET NOCOUNT ON;	
	
	DECLARE @PersonID1 INT
 
	SELECT @PersonID1 = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
 
	SELECT TOP 120
					personid,
					distance,
					numberofpaths,
					weight,
					w2,
					lastname,
					firstname,
					p,
					k,
					cast(-1 as bigint) nodeid,
					cast('' as varchar(400)) uri,
					0 nodeindex
		INTO #network 
		FROM ( 
						SELECT personid, 
										distance, 
										numberofpaths, 
										weight, 
										w2, 
										p.lastname, 
										p.firstname, 
										p.numpublications p, 
										ROW_NUMBER() OVER (PARTITION BY distance ORDER BY w2 DESC) k 
							FROM [Profile.Cache].Person p
							JOIN ( SELECT *, ROW_NUMBER() OVER (PARTITION BY personid2 ORDER BY distance, w2 DESC) k 
									FROM (
										SELECT personid2, 1 distance, n numberofpaths, w weight, w w2 
											FROM [Profile.Cache].[SNA.Coauthor]  
											WHERE personid1 = @personid1
										UNION ALL 
											SELECT b.personid2, 2 distance, b.n numberofpaths, b.w weight,a.w*b.w w2 
											FROM [Profile.Cache].[SNA.Coauthor] a JOIN [Profile.Cache].[SNA.Coauthor] b ON a.personid2 = b.personid1 
											WHERE a.personid1 = @personid1  
										UNION ALL 
											SELECT @personid1 personid2, 0 distance, 1 numberofpaths, 1 weight, 1 w2 
									) t 
								) t ON p.personid = t.personid2 
							WHERE k = 1  AND p.IsActive = 1
					) t 
		WHERE k <= 80 
	ORDER BY distance, k
	
	UPDATE n
		SET n.NodeID = m.NodeID, n.URI = p.Value + cast(m.NodeID as varchar(50))
		FROM #network n, [RDF.Stage].InternalNodeMap m, [Framework.].Parameter p
		WHERE p.ParameterID = 'baseURI' AND m.InternalHash = [RDF.].fnValueHash(null,null,'http://xmlns.com/foaf/0.1/Person^^Person^^'+cast(n.PersonID as varchar(50)))
 
	DELETE FROM #network WHERE IsNull(URI,'') = ''	
	
	UPDATE a
		SET a.nodeindex = b.ni
		FROM #network a, (
			SELECT *, row_number() over (order by distance desc, k desc)-1 ni
			FROM #network
		) b
		WHERE a.personid = b.personid

	SELECT c.personid1 id1, c.personid2	id2, c.n, CAST(c.w AS VARCHAR) w, 
			(CASE WHEN YEAR(firstpubdate)<1980 THEN 1980 ELSE YEAR(firstpubdate) END) y1, 
			(CASE WHEN YEAR(lastpubdate)<1980 THEN 1980 ELSE YEAR(lastpubdate) END) y2,
			(case when c.personid1 = @personid1 or c.personid2 = @personid1 then 1 else 0 end) k,
			a.nodeid n1, b.nodeid n2, a.uri u1, b.uri u2, a.nodeindex ni1, b.nodeindex ni2
		into #network2
		from #network a
			JOIN #network b on a.personid < b.personid  
			JOIN [Profile.Cache].[SNA.Coauthor] c ON a.personid = c.personid1 and b.personid = c.personid2  
 
	;with a as (
		select id1, id2, w, k from #network2
		union all
		select id2, id1, w, k from #network2
	), b as (
		select a.*, row_number() over (partition by a.id1 order by a.w desc, a.id2) s
		from a, 
			(select id1 from a group by id1 having max(k) = 0) b,
			(select id1 from a group by id1 having max(k) > 0) c
		where a.id1 = b.id1 and a.id2 = c.id1
	)
	update n
		set n.k = 2
		from #network2 n, b
		where (n.id1 = b.id1 and n.id2 = b.id2 and b.s = 1) or (n.id1 = b.id2 and n.id2 = b.id1 and b.s = 1)
 
	update n
		set n.k = 3
		from #network2 n, (
			select *, row_number() over (order by k desc, w desc) r 
			from #network2 
		) r
		where n.id1=r.id1 and n.id2=r.id2 and n.k=0 and r.r<=360
 
	IF @OutputFormat = 'XML'
	BEGIN
		SELECT (
			SELECT (
				SELECT personid "@id", nodeid "@nodeid", uri "@uri", distance "@d", p "@pubs", firstname "@fn", lastname "@ln", cast(w2 as varchar(50)) "@w2"
				FROM #network
				FOR XML PATH('NetworkPerson'),ROOT('NetworkPeople'),TYPE
			), (
				SELECT id1 "@id1", id2 "@id2", n "@n", cast(w as varchar(50)) "@w", y1 "@y1", y2 "@y2",
					n1 "@nodeid1", n2 "@nodeid2", u1 "@uri1", u2 "@uri2"
				FROM #network2
				WHERE k > 0
				FOR XML PATH('NetworkCoAuthor'),ROOT('NetworkCoAuthors'),TYPE
			)
			FOR XML PATH('LocalNetwork'), TYPE) [XML]
	END

	IF @OutputFormat = 'JSON'
	BEGIN
		SELECT
			'{'+CHAR(10)
			+'"NetworkPeople":['+CHAR(10)
			+SUBSTRING(ISNULL(CAST((
				SELECT	',{'
						+'"id":'+cast(personid as varchar(50))+','
						+'"nodeid":'+cast(nodeid as varchar(50))+','
						+'"uri":"'+uri+'",'
						+'"d":'+cast(distance as varchar(50))+',' 
						+'"pubs":'+cast(p as varchar(50))+',' 
						+'"fn":"'+firstname+'",' 
						+'"ln":"'+lastname+'",'
						+'"w2":'+cast(w2 as varchar(50))
						+'}'+CHAR(10)
				FROM #network
				ORDER BY nodeindex
				FOR XML PATH(''),TYPE
			) as VARCHAR(MAX)),''),2,9999999)
			+'],'+CHAR(10)
			+'"NetworkCoAuthors":['+CHAR(10)
			+SUBSTRING(ISNULL(CAST((
				SELECT	',{'
						+'"source":'+cast(ni2 as varchar(50))+','
						+'"target":'+cast(ni1 as varchar(50))+','
						+'"n":'+cast(n as varchar(50))+','
						+'"w":'+cast(w as varchar(50))+',' 
						+'"id1":'+cast(id1 as varchar(50))+','
						+'"id2":'+cast(id2 as varchar(50))+','
						+'"y1":'+cast(y1 as varchar(50))+',' 
						+'"y2":'+cast(y2 as varchar(50))+',' 
						+'"nodeid1":'+cast(n1 as varchar(50))+','
						+'"nodeid2":'+cast(n2 as varchar(50))+','
						+'"uri1":"'+u1+'",'
						+'"uri2":"'+u2+'"'
						+'}'+CHAR(10)
				FROM #network2
				ORDER BY ni2, ni1
				FOR XML PATH(''),TYPE
			) as VARCHAR(MAX)),''),2,9999999)
			+']'+CHAR(10)
			+'}' JSON
	END  
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[NetworkAuthorshipTimeline.Concept.GetData]
	@NodeID BIGINT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @DescriptorName NVARCHAR(255)
 	SELECT @DescriptorName = d.DescriptorName
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n,
			[Profile.Data].[Concept.Mesh.Descriptor] d
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
			AND m.InternalID = d.DescriptorUI

    -- Insert statements for procedure here
	declare @gc varchar(max)

	declare @y table (
		y int,
		A int,
		B int
	)

	insert into @y (y,A,B)
		select n.n y, coalesce(t.A,0) A, coalesce(t.B,0) B
		from [Utility.Math].[N] left outer join (
			select (case when y < 1970 then 1970 else y end) y,
				sum(A) A,
				sum(B) B
			from (
				select pmid, pubyear y, (case when w = 1 then 1 else 0 end) A, (case when w < 1 then 1 else 0 end) B
				from (
					select distinct pmid, pubyear, topicweight w
					from [Profile.Cache].[Concept.Mesh.PersonPublication]
					where meshheader = @DescriptorName
				) t
			) t
			group by y
		) t on n.n = t.y
		where n.n between year(getdate())-30 and year(getdate())

	declare @x int

	select @x = max(A+B)
		from @y

	if coalesce(@x,0) > 0
	begin
		declare @v varchar(1000)
		declare @z int
		declare @k int
		declare @i int

		set @z = power(10,floor(log(@x)/log(10)))
		set @k = floor(@x/@z)
		if @x > @z*@k
			select @k = @k + 1
		if @k > 5
			select @k = floor(@k/2.0+0.5), @z = @z*2

		set @v = ''
		set @i = 0
		while @i <= @k
		begin
			set @v = @v + '|' + cast(@z*@i as varchar(50))
			set @i = @i + 1
		end
		set @v = '|0|'+cast(@x as varchar(50))
		--set @v = '|0|50|100'

		declare @h varchar(1000)
		set @h = ''
		select @h = @h + '|' + (case when y % 2 = 1 then '' else ''''+right(cast(y as varchar(50)),2) end)
			from @y
			order by y 

		declare @w float
		--set @w = @k*@z
		set @w = @x

		declare @d varchar(max)
		set @d = ''
		select @d = @d + cast(floor(0.5 + 100*A/@w) as varchar(50)) + ','
			from @y
			order by y
		set @d = left(@d,len(@d)-1) + '|'
		select @d = @d + cast(floor(0.5 + 100*B/@w) as varchar(50)) + ','
			from @y
			order by y
		set @d = left(@d,len(@d)-1)

		declare @c varchar(50)
		set @c = 'FB8072,80B1D3'
		--set @c = 'FB8072,B3DE69,80B1D3'
		--set @c = 'F96452,a8dc4f,68a4cc'
		--set @c = 'fea643,76cbbd,b56cb5'

		--select @v, @h, @d

		--set @gc = '//chart.googleapis.com/chart?chs=595x100&chf=bg,s,ffffff|c,s,ffffff&chxt=x,y&chxl=0:' + @h + '|1:' + @v + '&cht=bvs&chd=t:' + @d + '&chdl=First+Author|Middle or Unkown|Last+Author&chco='+@c+'&chbh=10'
		set @gc = '//chart.googleapis.com/chart?chs=595x100&chf=bg,s,ffffff|c,s,ffffff&chxt=x,y&chxl=0:' + @h + '|1:' + @v + '&cht=bvs&chd=t:' + @d + '&chdl=Major+Topic|Minor+Topic&chco='+@c+'&chbh=10'


		declare @asText varchar(max)
		set @asText = '<table style="width:592px"><tr><th>Year</th><th>Major Topic</th><th>Minor Topic</th><th>Total</th></tr>'
		select @asText = @asText + '<tr><td style="text-align:center;">' + cast(y as varchar(50)) + '</td><td style="text-align:center;">' + cast(A as varchar(50)) + '</td><td style="text-align:center;">' + cast(B as varchar(50)) + '</td><td>' + cast(A + B as varchar(50)) + '</td></tr>'
			from @y
			where A + B > 0
			order by y 
		select @asText = @asText + '</table>'

		declare @alt varchar(max)
		select @alt = 'Bar chart showing ' + cast(sum(A + B) as varchar(50))+ ' publications over ' + cast(count(*) as varchar(50)) + ' distinct years, with a maximum of ' + cast(@x as varchar(50)) + ' publications in ' from @y where A + B > 0
		select @alt = @alt + cast(y as varchar(50)) + ' and '
			from @y
			where A + B = @x
			order by y 
		select @alt = left(@alt, len(@alt) - 4)

		select @gc gc, @alt alt, @asText asText --, @w w

		--select * from @y order by y

	end

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Ontology.].[GetClassCounts]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	declare @s as xml
	select @s = (
		select 
			(
				select	
					g.ClassGroupURI as "@rdf_.._resource", 
					g._ClassGroupLabel as "rdfs_.._label", 
					'http://www.w3.org/2001/XMLSchema#int' as "prns_.._numberOfConnections/@rdf_.._datatype",
					g._NumberOfNodes as "prns_.._numberOfConnections",
					(select	c.ClassURI as "@rdf_.._resource",
							c._ClassLabel as "rdfs_.._label",
							'http://www.w3.org/2001/XMLSchema#int' as "prns_.._numberOfConnections/@rdf_.._datatype",
							c._NumberOfNodes as "prns_.._numberOfConnections"
						from [Ontology.].[ClassGroupClass] c
						where c.ClassGroupURI = g.ClassGroupURI
						order by c.SortOrder
						for xml path('prns_.._matchesClass'), type
					)
				from [Ontology.].[ClassGroup] g
				order by g.SortOrder
				for xml path('prns_.._matchesClassGroup'), type
			)
		for xml path('rdf_.._Description'), type
	)

	declare @x as varchar(max)
	select @x = '<rdf:RDF'
	select @x = @x + ' xmlns:'+Prefix+'="'+URI+'"' 
		from [Ontology.].Namespace
	select @x = @x + ' >' + replace(cast(@s as nvarchar(max)),'_.._',':') + '</rdf:RDF>'
	select cast(@x as xml) RDF

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Framework.].[LoadInstallData]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

 DECLARE @x XML
 SELECT @x = ( SELECT TOP 1
                        Data
               FROM     [Framework.].[InstallData]
               ORDER BY InstallDataID DESC
             ) 

---------------------------------------------------------------
-- [Utility.Math]
---------------------------------------------------------------


-- [Utility.Math].N
; WITH   E00 ( N )
          AS ( SELECT   1
               UNION ALL
               SELECT   1
             ),
        E02 ( N )
          AS ( SELECT   1
               FROM     E00 a ,
                        E00 b
             ),
        E04 ( N )
          AS ( SELECT   1
               FROM     E02 a ,
                        E02 b
             ),
        E08 ( N )
          AS ( SELECT   1
               FROM     E04 a ,
                        E04 b
             ),
        E16 ( N )
          AS ( SELECT   1
               FROM     E08 a ,
                        E08 b
             ),
        E32 ( N )
          AS ( SELECT   1
               FROM     E16 a ,
                        E16 b
             ),
        cteTally ( N )
          AS ( SELECT   ROW_NUMBER() OVER ( ORDER BY N )
               FROM     E32
             )
    
    INSERT INTO [Utility.Math].N
    SELECT  N -1
    FROM    cteTally
    WHERE   N <= 100000 ; 
			 
---------------------------------------------------------------
-- [Framework.]
---------------------------------------------------------------
 
             
-- [Framework.].[Parameter]
TRUNCATE TABLE [Framework.].[Parameter]
INSERT INTO [Framework.].Parameter
	( ParameterID, Value )        
SELECT	R.x.value('ParameterID[1]', 'varchar(max)') ,
		R.x.value('Value[1]', 'varchar(max)')
FROM    ( SELECT
			@x.query
			('Import[1]/Table[@Name=''[Framework.].[Parameter]'']')
			x
		) t
CROSS APPLY x.nodes('//Row') AS R ( x )

  
       
-- [Framework.].[RestPath] 
INSERT INTO [Framework.].RestPath
        ( ApplicationName, Resolver )   
SELECT  R.x.value('ApplicationName[1]', 'varchar(max)') ,
        R.x.value('Resolver[1]', 'varchar(max)') 
FROM    ( SELECT
                    @x.query
                    ('Import[1]/Table[@Name=''[Framework.].[RestPath]'']')
                    x
        ) t
CROSS APPLY x.nodes('//Row') AS R ( x )

   
--[Framework.].[Job]
INSERT INTO [Framework.].Job
        ( JobID,
		  JobGroup,
          Step,
          IsActive,
          Script
        ) 
SELECT	Row_Number() OVER (ORDER BY (SELECT 1)),
		R.x.value('JobGroup[1]','varchar(max)'),
		R.x.value('Step[1]','varchar(max)'),
		R.x.value('IsActive[1]','varchar(max)'),
		R.x.value('Script[1]','varchar(max)')
FROM    ( SELECT
                  @x.query
                  ('Import[1]/Table[@Name=''[Framework.].[Job]'']')
                  x
      ) t
CROSS APPLY x.nodes('//Row') AS R ( x )

	
--[Framework.].[JobGroup]
INSERT INTO [Framework.].JobGroup
        ( JobGroup, Name, Type, Description ) 
SELECT	R.x.value('JobGroup[1]','varchar(max)'),
		R.x.value('Name[1]','varchar(max)'),
		R.x.value('Type[1]','varchar(max)'),
		R.x.value('Description[1]','varchar(max)')
FROM    ( SELECT
                  @x.query
                  ('Import[1]/Table[@Name=''[Framework.].[JobGroup]'']')
                  x
      ) t
CROSS APPLY x.nodes('//Row') AS R ( x )
       
  

---------------------------------------------------------------
-- [Ontology.]
---------------------------------------------------------------
 
 --[Ontology.].[ClassGroup]
 TRUNCATE TABLE [Ontology.].[ClassGroup]
 INSERT INTO [Ontology.].ClassGroup
         ( ClassGroupURI,
           SortOrder,
           IsVisible
         )
  SELECT  R.x.value('ClassGroupURI[1]', 'varchar(max)') ,
          R.x.value('SortOrder[1]', 'varchar(max)'),
          R.x.value('IsVisible[1]', 'varchar(max)')
  FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Ontology.].[ClassGroup]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x ) 
  
 --[Ontology.].[ClassGroupClass]
 TRUNCATE TABLE [Ontology.].[ClassGroupClass]
 INSERT INTO [Ontology.].ClassGroupClass
         ( ClassGroupURI,
           ClassURI,
           SortOrder
         )
  SELECT  R.x.value('ClassGroupURI[1]', 'varchar(max)') ,
          R.x.value('ClassURI[1]', 'varchar(max)'),
          R.x.value('SortOrder[1]', 'varchar(max)')
  FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Ontology.].[ClassGroupClass]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )

  
--[Ontology.].[ClassProperty]
INSERT INTO [Ontology.].ClassProperty
        ( ClassPropertyID,
          Class,
          NetworkProperty,
          Property,
          IsDetail,
          Limit,
          IncludeDescription,
          IncludeNetwork,
          SearchWeight,
          CustomDisplay,
          CustomEdit,
          ViewSecurityGroup,
          EditSecurityGroup,
          EditPermissionsSecurityGroup,
          EditExistingSecurityGroup,
          EditAddNewSecurityGroup,
          EditAddExistingSecurityGroup,
          EditDeleteSecurityGroup,
          MinCardinality,
          MaxCardinality,
          CustomDisplayModule,
          CustomEditModule
        )
SELECT  Row_Number() OVER (ORDER BY (SELECT 1)),
		R.x.value('Class[1]','varchar(max)'),
		R.x.value('NetworkProperty[1]','varchar(max)'),
		R.x.value('Property[1]','varchar(max)'),
		R.x.value('IsDetail[1]','varchar(max)'),
		R.x.value('Limit[1]','varchar(max)'),
		R.x.value('IncludeDescription[1]','varchar(max)'),
		R.x.value('IncludeNetwork[1]','varchar(max)'),
		R.x.value('SearchWeight[1]','varchar(max)'),
		R.x.value('CustomDisplay[1]','varchar(max)'),
		R.x.value('CustomEdit[1]','varchar(max)'),
		R.x.value('ViewSecurityGroup[1]','varchar(max)'),
		R.x.value('EditSecurityGroup[1]','varchar(max)'),
		R.x.value('EditPermissionsSecurityGroup[1]','varchar(max)'),
		R.x.value('EditExistingSecurityGroup[1]','varchar(max)'),
		R.x.value('EditAddNewSecurityGroup[1]','varchar(max)'),
		R.x.value('EditAddExistingSecurityGroup[1]','varchar(max)'),
		R.x.value('EditDeleteSecurityGroup[1]','varchar(max)'),
		R.x.value('MinCardinality[1]','varchar(max)'),
		R.x.value('MaxCardinality[1]','varchar(max)'),
		(case when CAST(R.x.query('CustomDisplayModule[1]/*') AS NVARCHAR(MAX))<>'' then R.x.query('CustomDisplayModule[1]/*') else NULL end),
		(case when CAST(R.x.query('CustomEditModule[1]/*') AS NVARCHAR(MAX))<>'' then R.x.query('CustomEditModule[1]/*') else NULL end)
  FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Ontology.].[ClassProperty]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )

  
    --[Ontology.].[ClassPropertyCustom]
  INSERT INTO [Ontology.].ClassPropertyCustom
        ( _ClassPropertyID,
		  ClassPropertyCustomTypeID,
          Class,
          NetworkProperty,
          Property,
		  IncludeProperty,
          IsDetail,
          Limit,
          IncludeDescription,
          IncludeNetwork
        )
  SELECT  Row_Number() OVER (ORDER BY (SELECT 1) + 1000),
		R.x.value('ClassPropertyCustomTypeID[1]','varchar(max)'),
		R.x.value('Class[1]','varchar(max)'),
		R.x.value('NetworkProperty[1]','varchar(max)'),
		R.x.value('Property[1]','varchar(max)'),
		R.x.value('IncludeProperty[1]','varchar(max)'),
		R.x.value('IsDetail[1]','varchar(max)'),
		R.x.value('Limit[1]','varchar(max)'),
		R.x.value('IncludeDescription[1]','varchar(max)'),
		R.x.value('IncludeNetwork[1]','varchar(max)')
  FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Ontology.].[ClassPropertyCustom]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )
  
  
  --[Ontology.].[DataMap]
  TRUNCATE TABLE [Ontology.].DataMap
  INSERT INTO [Ontology.].DataMap
          ( DataMapID,
			DataMapGroup ,
            IsAutoFeed ,
            Graph ,
            Class ,
            NetworkProperty ,
            Property ,
            MapTable ,
            sInternalType ,
            sInternalID ,
            cClass ,
            cInternalType ,
            cInternalID ,
            oClass ,
            oInternalType ,
            oInternalID ,
            oValue ,
            oDataType ,
            oLanguage ,
            oStartDate ,
            oStartDatePrecision ,
            oEndDate ,
            oEndDatePrecision ,
            oObjectType ,
            Weight ,
            OrderBy ,
            ViewSecurityGroup ,
            EditSecurityGroup
          )
  SELECT    Row_Number() OVER (ORDER BY (SELECT 1)),
			R.x.value('DataMapGroup[1]','varchar(max)'),
			R.x.value('IsAutoFeed[1]','varchar(max)'),
			R.x.value('Graph[1]','varchar(max)'),
			R.x.value('Class[1]','varchar(max)'),
			R.x.value('NetworkProperty[1]','varchar(max)'),
			R.x.value('Property[1]','varchar(max)'),
			R.x.value('MapTable[1]','varchar(max)'),
			R.x.value('sInternalType[1]','varchar(max)'),
			R.x.value('sInternalID[1]','varchar(max)'),
			R.x.value('cClass[1]','varchar(max)'),
			R.x.value('cInternalType[1]','varchar(max)'),
			R.x.value('cInternalID[1]','varchar(max)'),
			R.x.value('oClass[1]','varchar(max)'),
			R.x.value('oInternalType[1]','varchar(max)'),
			R.x.value('oInternalID[1]','varchar(max)'),
			R.x.value('oValue[1]','varchar(max)'),
			R.x.value('oDataType[1]','varchar(max)'),
			R.x.value('oLanguage[1]','varchar(max)'),
			R.x.value('oStartDate[1]','varchar(max)'),
			R.x.value('oStartDatePrecision[1]','varchar(max)'),
			R.x.value('oEndDate[1]','varchar(max)'),
			R.x.value('oEndDatePrecision[1]','varchar(max)'),
			R.x.value('oObjectType[1]','varchar(max)'),
			R.x.value('Weight[1]','varchar(max)'),
			R.x.value('OrderBy[1]','varchar(max)'),
			R.x.value('ViewSecurityGroup[1]','varchar(max)'),
			R.x.value('EditSecurityGroup[1]','varchar(max)')
  FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Ontology.].[DataMap]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )
  
  
 -- [Ontology.].[Namespace]
 TRUNCATE TABLE [Ontology.].[Namespace]
 INSERT INTO [Ontology.].[Namespace]
        ( URI ,
          Prefix
        )
  SELECT  R.x.value('URI[1]', 'varchar(max)') ,
          R.x.value('Prefix[1]', 'varchar(max)')
  FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Ontology.].[Namespace]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )
  

   --[Ontology.].[PropertyGroup]
   INSERT INTO [Ontology.].PropertyGroup
           ( PropertyGroupURI ,
             SortOrder ,
             [_PropertyGroupLabel]
           ) 
	SELECT	R.x.value('PropertyGroupURI[1]','varchar(max)'),
			R.x.value('SortOrder[1]','varchar(max)'),
			R.x.value('_PropertyGroupLabel[1]','varchar(max)')
	 FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Ontology.].[PropertyGroup]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )
  
  
	--[Ontology.].[PropertyGroupProperty]
	INSERT INTO [Ontology.].PropertyGroupProperty
	        ( PropertyGroupURI ,
	          PropertyURI ,
	          SortOrder ,
	          CustomDisplayModule ,
	          CustomEditModule ,
	          [_TagName] ,
	          [_PropertyLabel]
	        ) 
	SELECT	R.x.value('PropertyGroupURI[1]','varchar(max)'),
			R.x.value('PropertyURI[1]','varchar(max)'),
			R.x.value('SortOrder[1]','varchar(max)'),
			(case when CAST(R.x.query('CustomDisplayModule[1]/*') AS NVARCHAR(MAX))<>'' then R.x.query('CustomDisplayModule[1]/*') else NULL end),
			(case when CAST(R.x.query('CustomEditModule[1]/*') AS NVARCHAR(MAX))<>'' then R.x.query('CustomEditModule[1]/*') else NULL end),
			R.x.value('_TagName[1]','varchar(max)'),
			R.x.value('_PropertyLabel[1]','varchar(max)')
	 FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Ontology.].[PropertyGroupProperty]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )
  

---------------------------------------------------------------
-- [Ontology.Presentation]
---------------------------------------------------------------


 --[Ontology.Presentation].[XML]
 INSERT INTO [Ontology.Presentation].[XML]
         ( PresentationID,
			type ,
           subject ,
           predicate ,
           object ,
           presentationXML ,
           _SubjectNode ,
           _PredicateNode ,
           _ObjectNode
         )       
  SELECT  Row_Number() OVER (ORDER BY (SELECT 1)),
		  R.x.value('type[1]', 'varchar(max)') ,
          R.x.value('subject[1]', 'varchar(max)'),
          R.x.value('predicate[1]', 'varchar(max)'),
          R.x.value('object[1]', 'varchar(max)'),
          (case when CAST(R.x.query('presentationXML[1]/*') AS NVARCHAR(MAX))<>'' then R.x.query('presentationXML[1]/*') else NULL end) , 
          R.x.value('_SubjectNode[1]', 'varchar(max)'),
          R.x.value('_PredicateNode[1]', 'varchar(max)'),
          R.x.value('_ObjectNode[1]', 'varchar(max)')
  FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Ontology.Presentation].[XML]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )

  
---------------------------------------------------------------
-- [RDF.Security]
---------------------------------------------------------------
             
 -- [RDF.Security].[Group]
 TRUNCATE TABLE [RDF.Security].[Group]
 INSERT INTO [RDF.Security].[Group]
 
         ( SecurityGroupID ,
           Label ,
           HasSpecialViewAccess ,
           HasSpecialEditAccess ,
           Description
         )
 SELECT   R.x.value('SecurityGroupID[1]', 'varchar(max)') ,
          R.x.value('Label[1]', 'varchar(max)'),
          R.x.value('HasSpecialViewAccess[1]', 'varchar(max)'),
          R.x.value('HasSpecialEditAccess[1]', 'varchar(max)'),
          R.x.value('Description[1]', 'varchar(max)')
  FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[RDF.Security].[Group]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x ) 



---------------------------------------------------------------
-- [Utility.NLP]
---------------------------------------------------------------
   
	--[Utility.NLP].[ParsePorterStemming]
	INSERT INTO [Utility.NLP].ParsePorterStemming
	        ( Step, Ordering, phrase1, phrase2 ) 
	SELECT	R.x.value('Step[1]','varchar(max)'),
			R.x.value('Ordering[1]','varchar(max)'), 
			R.x.value('phrase1[1]','varchar(max)'), 
			R.x.value('phrase2[1]','varchar(max)')
	 FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Utility.NLP].[ParsePorterStemming]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )
	
	--[Utility.NLP].[StopWord]
	INSERT INTO [Utility.NLP].StopWord
	        ( word, stem, scope ) 
	SELECT	R.x.value('word[1]','varchar(max)'),
			R.x.value('stem[1]','varchar(max)'),
			R.x.value('scope[1]','varchar(max)')
	 FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Utility.NLP].[StopWord]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )
  
	--[Utility.NLP].[Thesaurus.Source]
	INSERT INTO [Utility.NLP].[Thesaurus.Source]
	        ( Source, SourceName ) 
	SELECT	R.x.value('Source[1]','varchar(max)'),
			R.x.value('SourceName[1]','varchar(max)')
	 FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Utility.NLP].[Thesaurus.Source]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )


---------------------------------------------------------------
-- [User.Session]
---------------------------------------------------------------

  --[User.Session].Bot		
  INSERT INTO [User.Session].Bot  ( UserAgent )
   SELECT	R.x.value('UserAgent[1]','varchar(max)') 
	 FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[User.Session].Bot'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )
  
  
  
---------------------------------------------------------------
-- [Direct.]
---------------------------------------------------------------
   
  --[Direct.].[Sites]
  INSERT INTO [Direct.].[Sites]
          ( SiteID ,
            BootstrapURL ,
            SiteName ,
            QueryURL ,
            SortOrder ,
            IsActive
          )
  SELECT	R.x.value('SiteID[1]','varchar(max)'),
			R.x.value('BootstrapURL[1]','varchar(max)'),
			R.x.value('SiteName[1]','varchar(max)'),
			R.x.value('QueryURL[1]','varchar(max)'),
			R.x.value('SortOrder[1]','varchar(max)'),
			R.x.value('IsActive[1]','varchar(max)')
	 FROM    ( SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Direct.].[Sites]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )
	
	
---------------------------------------------------------------
-- [Profile.Data]
---------------------------------------------------------------
 
    --[Profile.Data].[Publication.Type]		
  INSERT INTO [Profile.Data].[Publication.Type]
          ( pubidtype_id, name, sort_order )
           
   SELECT	R.x.value('pubidtype_id[1]','varchar(max)'),
			R.x.value('name[1]','varchar(max)'),
			R.x.value('sort_order[1]','varchar(max)')
	 FROM    (SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Profile.Data].[Publication.Type]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )
   
  --[Profile.Data].[Publication.MyPub.Category]
  TRUNCATE TABLE [Profile.Data].[Publication.MyPub.Category]
  INSERT INTO [Profile.Data].[Publication.MyPub.Category]
          ( [HmsPubCategory] ,
            [CategoryName]
          ) 
   SELECT	R.x.value('HmsPubCategory[1]','varchar(max)'),
			R.x.value('CategoryName[1]','varchar(max)')
	 FROM    (SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Profile.Data].[Publication.MyPub.Category]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )
  
 ---------------------------------------------------------------
-- [ORCID.]
---------------------------------------------------------------
  
	INSERT INTO [ORCID.].[REF_Permission]
		(
			[PermissionScope],
			[PermissionDescription],
			[MethodAndRequest],
			[SuccessMessage],
			[FailedMessage]
		)
   SELECT	R.x.value('PermissionScope[1]','varchar(max)'),
			R.x.value('PermissionDescription[1]','varchar(max)'),
			R.x.value('MethodAndRequest[1]','varchar(max)'),
			R.x.value('SuccessMessage[1]','varchar(max)'),
			R.x.value('FailedMessage[1]','varchar(max)')
	 FROM    (SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[ORCID.].[REF_Permission]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )


	INSERT INTO [ORCID.].[REF_PersonStatusType]
		(
			[StatusDescription]
		)
   SELECT	R.x.value('StatusDescription[1]','varchar(max)')
	 FROM    (SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[ORCID.].[REF_PersonStatusType]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )


	INSERT INTO [ORCID.].[REF_RecordStatus]
		(
			[RecordStatusID],
			[StatusDescription]
		)
   SELECT	R.x.value('RecordStatusID[1]','varchar(max)'),
			R.x.value('StatusDescription[1]','varchar(max)')
	 FROM    (SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[ORCID.].[REF_RecordStatus]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )


	INSERT INTO [ORCID.].[REF_Decision]
		(
			[DecisionDescription],
			[DecisionDescriptionLong]
		)
   SELECT	R.x.value('DecisionDescription[1]','varchar(max)'),
			R.x.value('DecisionDescriptionLong[1]','varchar(max)')
	 FROM    (SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[ORCID.].[REF_Decision]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )

	INSERT INTO [ORCID.].[REF_WorkExternalType]
		(
			[WorkExternalType],
			[WorkExternalDescription]
		)
   SELECT	R.x.value('WorkExternalType[1]','varchar(max)'),
			R.x.value('WorkExternalDescription[1]','varchar(max)')
	 FROM    (SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[ORCID.].[REF_WorkExternalType]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )


	INSERT INTO [ORCID.].[RecordLevelAuditType]
		(
			[AuditType]
		)
   SELECT	R.x.value('AuditType[1]','varchar(max)')
	 FROM    (SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[ORCID.].[RecordLevelAuditType]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )



	INSERT INTO [ORCID.].[DefaultORCIDDecisionIDMapping]
		(
			[SecurityGroupID],
			[DefaultORCIDDecisionID]
		)
   SELECT	R.x.value('SecurityGroupID[1]','varchar(max)'),
			R.x.value('DefaultORCIDDecisionID[1]','varchar(max)')
	 FROM    (SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[ORCID.].[DefaultORCIDDecisionIDMapping]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )

   ---------------------------------------------------------------
-- [Profile.Module].[GenericRDF.*]
---------------------------------------------------------------
	INSERT INTO [Profile.Module].[GenericRDF.Plugins]
		(
			[Name],
			[EnabledForPerson],
			[EnabledForGroup],
			[Label],
			[PropertyGroupURI],
			[CustomDisplayModule],
			[CustomEditModule]
		)
   SELECT	R.x.value('Name[1]','varchar(max)'),
			R.x.value('EnabledForPerson[1]','int'),
			R.x.value('EnabledForGroup[1]','int'),
			R.x.value('Label[1]','varchar(max)'),
			R.x.value('PropertyGroupURI[1]','varchar(max)'),
			R.x.value('CustomDisplayModule[1]','varchar(max)'),
			R.x.value('CustomEditModule[1]','varchar(max)')
	 FROM    (SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Profile.Module].[GenericRDF.Plugins]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )


   ---------------------------------------------------------------
-- [Profile.Import].[PRNSWebservice.*]
---------------------------------------------------------------
	INSERT INTO [Profile.Import].[PRNSWebservice.Options]
		(
			[job],
			[url],
			[options],
			[logLevel],
			[batchSize],
			[GetPostDataProc],
			[ImportDataProc]
		)
   SELECT	R.x.value('job[1]','varchar(max)'),
			R.x.value('url[1]','varchar(max)'),
			R.x.value('options[1]','varchar(max)'),
			R.x.value('logLevel[1]','int'),
			R.x.value('batchSize[1]','int'),
			R.x.value('GetPostDataProc[1]','varchar(max)'),
			R.x.value('ImportDataProc[1]','varchar(max)')
	 FROM    (SELECT
                      @x.query
                      ('Import[1]/Table[@Name=''[Profile.Import].[PRNSWebservice.Options]'']')
                      x
          ) t
  CROSS APPLY x.nodes('//Row') AS R ( x )

  -- Use to generate select lists for new tables
  -- SELECT   'R.x.value(''' + c.name +  '[1]'',' + '''varchar(max)'')'+ ',' ,* 
  -- FROM sys.columns c 
  -- JOIN  sys.types t ON t.system_type_id = c.system_type_id 
  -- WHERE object_id IN (SELECT object_id FROM sys.tables WHERE name = 'Publication.MyPub.Category') 
  -- AND T.NAME<>'sysname'ORDER BY c.column_id
	 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [RDF.Stage].[LoadAliases]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	TRUNCATE TABLE [RDF.].Alias

	INSERT INTO [RDF.].Alias (AliasType, AliasID, NodeID, Preferred)
		SELECT 'Network', 'CoAuthors', [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#coAuthorOf'), 1
	INSERT INTO [RDF.].Alias (AliasType, AliasID, NodeID, Preferred)
		SELECT 'Network', 'SimilarTo', [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#similarTo'), 1
	INSERT INTO [RDF.].Alias (AliasType, AliasID, NodeID, Preferred)
		SELECT 'Network', 'ResearchAreas', [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#hasResearchArea'), 1

	/*
	
	-- Example: PersonID as the preferred alias for a person
	INSERT INTO [RDF.].Alias (AliasType, AliasID, NodeID, Preferred)
		SELECT InternalType, InternalID, NodeID, 1
			FROM [RDF.Stage].InternalNodeMap
			WHERE InternalType='Person' and Class = 'http://xmlns.com/foaf/0.1/Person'

	-- Example: InternalUsername as an alternative alias for a person
	INSERT INTO [RDF.].Alias (AliasType, AliasID, NodeID, Preferred)
		SELECT 'Username', p.InternalUsername, m.NodeID, 0
			FROM [RDF.Stage].InternalNodeMap m, [Profile.Data].[Person] p
			WHERE m.InternalType='Person' and m.Class = 'http://xmlns.com/foaf/0.1/Person'
				and m.InternalID = CAST(p.PersonID as varchar(50))

	*/
	
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- Stored Procedure

CREATE PROCEDURE [Profile.Module].[NetworkCloud.Person.HasResearchArea.GetXML]
	@NodeID BIGINT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @baseURI NVARCHAR(400)
	SELECT @baseURI = value FROM [Framework.].Parameter WHERE ParameterID = 'baseURI'

	DECLARE @hasResearchAreaID BIGINT
	SELECT @hasResearchAreaID = [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#hasResearchArea')	

	DECLARE @labelID BIGINT
	SELECT @labelID = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')	

	SELECT (
		SELECT	'' "@Description",
				'In this concept ''cloud'', the sizes of the concepts are based not only on the number of corresponding publications, but also how relevant the concepts are to the overall topics of the publications, how long ago the publications were written, whether the person was the first or senior author, and how many other people have written about the same topic. The largest concepts are those that are most unique to this person.' "@InfoCaption",
				2 "@Columns",
				(
					SELECT	Value "@ItemURLText", 
							SortOrder "@sortOrder", 
							(CASE WHEN SortOrder <= 5 THEN 'big'
								WHEN Quintile = 1 THEN 'big'
								WHEN Quintile = 5 THEN 'small'
								ELSE 'med' END) "@Weight",
							URI "@ItemURL"
					FROM (
						SELECT t.SortOrder, t.Weight, @baseURI+CAST(t.Object AS VARCHAR(50)) URI, n.Value,
							NTILE(5) OVER (ORDER BY t.SortOrder) Quintile
						FROM [RDF.].[Triple] t
							INNER JOIN [RDF.].[Triple] l
								ON t.Object = l.Subject AND l.Predicate = @labelID
							INNER JOIN [RDF.].[Node] n
								ON l.Object = n.NodeID
						WHERE t.Subject = @NodeID AND t.Predicate = @hasResearchAreaID
					) t
					ORDER BY Value
					FOR XML PATH('Item'), TYPE
				)
		FOR XML PATH('ListView'), TYPE
	) ListViewXML

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- Stored Procedure

CREATE PROCEDURE [Profile.Module].[NetworkCategory.Person.HasResearchArea.GetXML]
	@NodeID BIGINT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @baseURI NVARCHAR(400)
	SELECT @baseURI = value FROM [Framework.].Parameter WHERE ParameterID = 'baseURI'

	DECLARE @hasResearchAreaID BIGINT
	SELECT @hasResearchAreaID = [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#hasResearchArea')	

	DECLARE @labelID BIGINT
	SELECT @labelID = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')	

	DECLARE @meshSemanticGroupNameID BIGINT
	SELECT @meshSemanticGroupNameID = [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#meshSemanticGroupName')	

	SELECT *
		INTO #t
		FROM (
			SELECT t.SortOrder, t.Weight, @baseURI+CAST(t.Object AS VARCHAR(50)) URI, n.Value Concept, m.Value Category,
				ROW_NUMBER() OVER (PARTITION BY s.Object ORDER BY t.Weight DESC) CategoryRank
			FROM [RDF.].[Triple] t
				INNER JOIN [RDF.].[Triple] l
					ON t.Object = l.Subject AND l.Predicate = @labelID
				INNER JOIN [RDF.].[Node] n
					ON l.Object = n.NodeID
				INNER JOIN [RDF.].[Triple] s
					ON t.Object = s.Subject AND s.Predicate = @meshSemanticGroupNameID
				INNER JOIN [RDF.].[Node] m
					ON s.Object = m.NodeID
			WHERE t.Subject = @NodeID AND t.Predicate = @hasResearchAreaID
		) t
		WHERE CategoryRank <= 10

	SELECT (
		SELECT	'Concepts listed here are grouped according to their ''semantic'' categories. Within each category, up to ten concepts are shown, in decreasing order of relevance.' "@InfoCaption",
				(
					SELECT a.Category "DetailList/@Category",
						(SELECT	'' "Item/@ItemURLText",
								URI "Item/@URL",
								Concept "Item"
							FROM #t b
							WHERE b.Category = a.Category
							ORDER BY b.CategoryRank
							FOR XML PATH(''), TYPE
						) "DetailList"
					FROM (SELECT DISTINCT Category FROM #t) a
					ORDER BY a.Category
					FOR XML PATH(''), TYPE
				)
		FOR XML PATH('Items'), TYPE
	) ItemsXML

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
/*

Copyright (c) 2008-2010 by the President and Fellows of Harvard College. All rights reserved.  Profiles Research Networking Software was developed under the supervision of Griffin M Weber, MD, PhD., and Harvard Catalyst: The Harvard Clinical and Translational Science Center, with support from the National Center for Research Resources and Harvard University.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    * Neither the name "Harvard" nor the names of its contributors nor the name "Harvard Catalyst" may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER (PRESIDENT AND FELLOWS OF HARVARD COLLEGE) AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




*/
CREATE procedure [Profile.Import].[LoadProfilesData]
    (
      @use_internalusername_as_pkey BIT = 0
    )
AS 
    BEGIN
        SET NOCOUNT ON;	


	-- Start Transaction. Log load failures, roll back transaction on error.
        BEGIN TRY
            BEGIN TRAN				 

            DECLARE @ErrMsg NVARCHAR(4000) ,
                @ErrSeverity INT


						-- Department
            INSERT  INTO [Profile.Data].[Organization.Department]
                    ( departmentname ,
                      visible
                    )
                    SELECT DISTINCT
                            departmentname ,
                            1
                    FROM    [Profile.Import].PersonAffiliation a
                    WHERE   departmentname IS NOT NULL
                            AND departmentname NOT IN (
                            SELECT  departmentname
                            FROM    [Profile.Data].[Organization.Department] )


						-- institution
            INSERT  INTO [Profile.Data].[Organization.Institution]
                    ( InstitutionName ,
                      InstitutionAbbreviation
										
                    )
                    SELECT  INSTITUTIONNAME ,
                            INSTITUTIONABBREVIATION
                    FROM    ( SELECT    INSTITUTIONNAME ,
                                        INSTITUTIONABBREVIATION ,
                                        COUNT(*) CNT ,
                                        ROW_NUMBER() OVER ( PARTITION BY institutionname ORDER BY SUM(CASE
                                                              WHEN INSTITUTIONABBREVIATION = ''
                                                              THEN 0
                                                              ELSE 1
                                                              END) DESC ) rank
                              FROM      [Profile.Import].PersonAffiliation
                              GROUP BY  INSTITUTIONNAME ,
                                        INSTITUTIONABBREVIATION
                            ) A
                    WHERE   rank = 1
                            AND institutionname <> ''
                            AND NOT EXISTS ( SELECT b.institutionname
                                             FROM   [Profile.Data].[Organization.Institution] b
                                             WHERE  b.institutionname = a.institutionname )


						-- division
            INSERT  INTO [Profile.Data].[Organization.Division]
                    ( DivisionName  
										
                    )
                    SELECT DISTINCT
                            divisionname
                    FROM    [Profile.Import].PersonAffiliation a
                    WHERE   divisionname IS NOT NULL
                            AND NOT EXISTS ( SELECT b.divisionname
                                             FROM   [Profile.Data].[Organization.Division] b
                                             WHERE  b.divisionname = a.divisionname )



					-- Flag deleted people
			DECLARE @deletedPersonIDTable TABLE (PersonID int)
            
			UPDATE  [Profile.Data].Person
            SET     ISactive = 0
			OUTPUT inserted.PersonID into @deletedPersonIDTable
            WHERE  IsActive <> 0 AND internalusername NOT IN (
                    SELECT  internalusername
                    FROM    [Profile.Import].Person where isactive = 1)
			
			INSERT INTO [Framework.].[Log.Activity] (userId, personId, methodName, property, privacyCode, param1, param2) 
			SELECT 0, PersonID, '[Profile.Import].[LoadProfilesData]', null, null, 'Person Delete', null FROM @deletedPersonIDTable

					-- Update person/user records where data has changed. 
			DECLARE @updatedPersonIDTable TABLE (PersonID int)
            
			UPDATE  p
            SET     p.firstname = lp.firstname ,
                    p.lastname = lp.lastname ,
                    p.middlename = lp.middlename ,
                    p.displayname = lp.displayname ,
                    p.suffix = lp.suffix ,
                    p.addressline1 = lp.addressline1 ,
                    p.addressline2 = lp.addressline2 ,
                    p.addressline3 = lp.addressline3 ,
                    p.addressline4 = lp.addressline4 ,
                    p.city = lp.city ,
                    p.state = lp.state ,
                    p.zip = lp.zip ,
                    p.building = lp.building ,
                    p.room = lp.room ,
                    p.phone = lp.phone ,
                    p.fax = lp.fax ,
                    p.EmailAddr = lp.EmailAddr ,
                    p.AddressString = lp.AddressString ,
                    p.isactive = lp.isactive ,
                    p.visible = lp.isvisible
					OUTPUT inserted.PersonID into @updatedPersonIDTable
            FROM    [Profile.Data].Person p
                    JOIN [Profile.Import].Person lp ON lp.internalusername = p.internalusername
                                                       AND ( ISNULL(lp.firstname,
                                                              '') <> ISNULL(p.firstname,
                                                              '')
                                                             OR ISNULL(lp.lastname,
                                                              '') <> ISNULL(p.lastname,
                                                              '')
                                                             OR ISNULL(lp.middlename,
                                                              '') <> ISNULL(p.middlename,
                                                              '')
                                                             OR ISNULL(lp.displayname,
                                                              '') <> ISNULL(p.displayname,
                                                              '')
                                                             OR ISNULL(lp.suffix,
                                                              '') <> ISNULL(p.suffix,
                                                              '')
                                                             OR ISNULL(lp.addressline1,
                                                              '') <> ISNULL(p.addressline1,
                                                              '')
                                                             OR ISNULL(lp.addressline2,
                                                              '') <> ISNULL(p.addressline2,
                                                              '')
                                                             OR ISNULL(lp.addressline3,
                                                              '') <> ISNULL(p.addressline3,
                                                              '')
                                                             OR ISNULL(lp.addressline4,
                                                              '') <> ISNULL(p.addressline4,
                                                              '')
                                                             OR ISNULL(lp.city,
                                                              '') <> ISNULL(p.city,
                                                              '')
                                                             OR ISNULL(lp.state,
                                                              '') <> ISNULL(p.state,
                                                              '')
                                                             OR ISNULL(lp.zip,
                                                              '') <> ISNULL(p.zip,
                                                              '')
                                                             OR ISNULL(lp.building,
                                                              '') <> ISNULL(p.building,
                                                              '')
                                                             OR ISNULL(lp.room,
                                                              '') <> ISNULL(p.room,
                                                              '')
                                                             OR ISNULL(lp.phone,
                                                              '') <> ISNULL(p.phone,
                                                              '')
                                                             OR ISNULL(lp.fax,
                                                              '') <> ISNULL(p.fax,
                                                              '')
                                                             OR ISNULL(lp.EmailAddr,
                                                              '') <> ISNULL(p.EmailAddr,
                                                              '')
                                                             OR ISNULL(lp.AddressString,
                                                              '') <> ISNULL(p.AddressString,
                                                              '')
                                                             OR ISNULL(lp.Isactive,
                                                              '') <> ISNULL(p.Isactive,
                                                              '')
                                                             OR ISNULL(lp.isvisible,
                                                              '') <> ISNULL(p.visible,
                                                              '')
                                                           ) 

			INSERT INTO [Framework.].[Log.Activity] (userId, personId, methodName, property, privacyCode, param1, param2) 
			SELECT 0, PersonID, '[Profile.Import].[LoadProfilesData]', null, null, 'Person Update', null FROM @updatedPersonIDTable
						-- Update changed user info
            UPDATE  u
            SET     u.firstname = up.firstname ,
                    u.lastname = up.lastname ,
                    u.displayname = up.displayname ,
                    u.institution = up.institution ,
                    u.department = up.department ,
                    u.emailaddr = up.emailaddr
            FROM    [User.Account].[User] u
                    JOIN [Profile.Import].[User] up ON up.internalusername = u.internalusername
                                                       AND ( ISNULL(up.firstname,
                                                              '') <> ISNULL(u.firstname,
                                                              '')
                                                             OR ISNULL(up.lastname,
                                                              '') <> ISNULL(u.lastname,
                                                              '')
                                                             OR ISNULL(up.displayname,
                                                              '') <> ISNULL(u.displayname,
                                                              '')
                                                             OR ISNULL(up.institution,
                                                              '') <> ISNULL(u.institution,
                                                              '')
                                                             OR ISNULL(up.department,
                                                              '') <> ISNULL(u.department,
                                                              '')
                                                             OR ISNULL(up.emailaddr,
                                                              '') <> ISNULL(u.emailaddr,
                                                              '')
                                                           )

					-- Remove Affiliations that have changed, so they'll be re-added
            SELECT DISTINCT
                    COALESCE(p.internalusername, pa.internalusername) internalusername
            INTO    #affiliations
            FROM    [Profile.Cache].[Person.Affiliation] cpa
            JOIN	[Profile.Data].Person p ON p.personid = cpa.personid
       FULL JOIN	[Profile.Import].PersonAffiliation pa ON pa.internalusername = p.internalusername
                                                              AND  pa.affiliationorder =  cpa.sortorder  
                                                              AND pa.primaryaffiliation = cpa.isprimary  
                                                              AND pa.title = cpa.title  
                                                              AND pa.institutionabbreviation =  cpa.institutionabbreviation  
                                                              AND pa.departmentname =  cpa.departmentname  
                                                              AND pa.divisionname = cpa.divisionname 
                                                              AND pa.facultyrank  = cpa.facultyrank
                                                              
            WHERE   pa.internalusername IS NULL
                    OR cpa.personid IS NULL

            DELETE  FROM [Profile.Data].[Person.Affiliation]
            WHERE   personid IN ( SELECT    personid
                                  FROM      [Profile.Data].Person
                                  WHERE     internalusername IN ( SELECT
                                                              internalusername
                                                              FROM
                                                              #affiliations ) )

					-- Remove Filters that have changed, so they'll be re-added
            SELECT  internalusername ,
                    personfilter
            INTO    #filter
            FROM    [Profile.Data].[Person.FilterRelationship] pfr
                    JOIN [Profile.Data].Person p ON p.personid = pfr.personid
                    JOIN [Profile.Data].[Person.Filter] pf ON pf.personfilterid = pfr.personfilterid
            CREATE CLUSTERED INDEX tmp ON #filter(internalusername)
            DELETE  FROM [Profile.Data].[Person.FilterRelationship]
            WHERE   personid IN (
                    SELECT  personid
                    FROM    [Profile.Data].Person
                    WHERE   InternalUsername IN (
                            SELECT  COALESCE(a.internalusername,
                                             p.internalusername)
                            FROM    [Profile.Import].PersonFilterFlag pf
                                    JOIN [Profile.Import].Person p ON p.internalusername = pf.internalusername
                                    FULL JOIN #filter a ON a.internalusername = p.internalusername
                                                           AND a.personfilter = pf.personfilter
                            WHERE   a.internalusername IS NULL
                                    OR p.internalusername IS NULL ) )






					-- user
            IF @use_internalusername_as_pkey = 0 
                BEGIN
                    INSERT  INTO [User.Account].[User]
                            ( IsActive ,
                              CanBeProxy ,
                              FirstName ,
                              LastName ,
                              DisplayName ,
                              Institution ,
                              Department ,
                              InternalUserName ,
                              emailaddr 
						        
                            )
                            SELECT  1 ,
                                    canbeproxy ,
                                    ISNULL(firstname, '') ,
                                    ISNULL(lastname, '') ,
                                    ISNULL(displayname, '') ,
                                    institution ,
                                    department ,
                                    InternalUserName ,
                                    emailaddr
                            FROM    [Profile.Import].[User] u
                            WHERE   NOT EXISTS ( SELECT *
                                                 FROM   [User.Account].[User] b
                                                 WHERE  b.internalusername = u.internalusername )
                            UNION
                            SELECT  1 ,
                                    1 ,
                                    ISNULL(firstname, '') ,
                                    ISNULL(lastname, '') ,
                                    ISNULL(displayname, '') ,
                                    institutionname ,
                                    departmentname ,
                                    u.InternalUserName ,
                                    u.emailaddr
                            FROM    [Profile.Import].Person u
                                    LEFT JOIN [Profile.Import].PersonAffiliation pa ON pa.internalusername = u.internalusername
                                                              AND pa.primaryaffiliation = 1
                            WHERE   NOT EXISTS ( SELECT *
                                                 FROM   [User.Account].[User] b
                                                 WHERE  b.internalusername = u.internalusername )
                END
            ELSE 
                BEGIN
                    SET IDENTITY_INSERT [User.Account].[User] ON 

                    INSERT  INTO [User.Account].[User]
                            ( userid ,
                              IsActive ,
                              CanBeProxy ,
                              FirstName ,
                              LastName ,
                              DisplayName ,
                              Institution ,
                              Department ,
                              InternalUserName ,
                              emailaddr 
						        
                            )
                            SELECT  u.internalusername ,
                                    1 ,
                                    canbeproxy ,
                                    ISNULL(firstname, '') ,
                                    ISNULL(lastname, '') ,
                                    ISNULL(displayname, '') ,
                                    institution ,
                                    department ,
                                    InternalUserName ,
                                    emailaddr
                            FROM    [Profile.Import].[User] u
                            WHERE   NOT EXISTS ( SELECT *
                                                 FROM   [User.Account].[User] b
                                                 WHERE  b.internalusername = u.internalusername )
                            UNION ALL
                            SELECT  u.internalusername ,
                                    1 ,
                                    1 ,
                                    ISNULL(firstname, '') ,
                                    ISNULL(lastname, '') ,
                                    ISNULL(displayname, '') ,
                                    institutionname ,
                                    departmentname ,
                                    u.InternalUserName ,
                                    u.emailaddr
                            FROM    [Profile.Import].Person u
                                    LEFT JOIN [Profile.Import].PersonAffiliation pa ON pa.internalusername = u.internalusername
                                                              AND pa.primaryaffiliation = 1
                            WHERE   NOT EXISTS ( SELECT *
                                                 FROM   [User.Account].[User] b
                                                 WHERE  b.internalusername = u.internalusername )
                                    AND NOT EXISTS ( SELECT *
                                                     FROM   [Profile.Import].[User] b
                                                     WHERE  b.internalusername = u.internalusername )

                    SET IDENTITY_INSERT [User.Account].[User] OFF
                END

					-- faculty ranks
            INSERT  INTO [Profile.Data].[Person.FacultyRank]
                    ( FacultyRank ,
                      FacultyRankSort ,
                      Visible
					        
                    )
                    SELECT DISTINCT
                            facultyrank ,
                            facultyrankorder ,
                            1
                    FROM    [Profile.Import].PersonAffiliation p
                    WHERE   NOT EXISTS ( SELECT *
                                         FROM   [Profile.Data].[Person.FacultyRank] a
                                         WHERE  a.facultyrank = p.facultyrank )

					-- person
			DECLARE @newPersonIDTable TABLE (personID INT)	
            IF @use_internalusername_as_pkey = 0 
                BEGIN
								
                    INSERT  INTO [Profile.Data].Person
                            ( UserID ,
                              FirstName ,
                              LastName ,
                              MiddleName ,
                              DisplayName ,
                              Suffix ,
                              IsActive ,
                              EmailAddr ,
                              Phone ,
                              Fax ,
                              AddressLine1 ,
                              AddressLine2 ,
                              AddressLine3 ,
                              AddressLine4 ,
                              city ,
                              state ,
                              zip ,
                              Building ,
                              Floor ,
                              Room ,
                              AddressString ,
                              Latitude ,
                              Longitude ,
                              FacultyRankID ,
                              InternalUsername ,
                              Visible
						        
                            )
							OUTPUT inserted.PersonID into @newPersonIDTable
                            SELECT  UserID ,
                                    ISNULL(p.FirstName, '') ,
                                    ISNULL(p.LastName, '') ,
                                    ISNULL(p.MiddleName, '') ,
                                    ISNULL(p.DisplayName, '') ,
                                    ISNULL(Suffix, '') ,
                                    p.IsActive ,
                                    p.EmailAddr ,
                                    Phone ,
                                    Fax ,
                                    AddressLine1 ,
                                    AddressLine2 ,
                                    AddressLine3 ,
                                    AddressLine4 ,
                                    city ,
                                    state ,
                                    zip ,
                                    Building ,
                                    Floor ,
                                    Room ,
                                    AddressString ,
                                    Latitude ,
                                    Longitude ,
                                    FacultyRankID ,
                                    p.InternalUsername ,
                                    p.isvisible
                            FROM    [Profile.Import].Person p
                                    OUTER APPLY ( SELECT TOP 1
                                                            internalusername ,
                                                            facultyrankid ,
                                                            facultyranksort
                                                  FROM      [Profile.import].[PersonAffiliation] pa
                                                            JOIN [Profile.Data].[Person.FacultyRank] fr ON fr.facultyrank = pa.facultyrank
                                                  WHERE     pa.internalusername = p.internalusername
                                                  ORDER BY  facultyranksort ASC
                                                ) a
                                    JOIN [User.Account].[User] u ON u.internalusername = p.internalusername
                            WHERE   NOT EXISTS ( SELECT *
                                                 FROM   [Profile.Data].Person b
                                                 WHERE  b.internalusername = p.internalusername )	   
                END
            ELSE 
                BEGIN
						
                    SET IDENTITY_INSERT [Profile.Data].Person ON
                    INSERT  INTO [Profile.Data].Person
                            ( personid ,
                              UserID ,
                              FirstName ,
                              LastName ,
                              MiddleName ,
                              DisplayName ,
                              Suffix ,
                              IsActive ,
                              EmailAddr ,
                              Phone ,
                              Fax ,
                              AddressLine1 ,
                              AddressLine2 ,
                              AddressLine3 ,
                              AddressLine4 ,
                              Building ,
                              Floor ,
                              Room ,
                              AddressString ,
                              Latitude ,
                              Longitude ,
                              FacultyRankID ,
                              InternalUsername ,
                              Visible
						        
                            )
							OUTPUT inserted.PersonID into @newPersonIDTable
                            SELECT  p.internalusername ,
                                    userid ,
                                    ISNULL(p.FirstName, '') ,
                                    ISNULL(p.LastName, '') ,
                                    ISNULL(p.MiddleName, '') ,
                                    ISNULL(p.DisplayName, '') ,
                                    ISNULL(Suffix, '') ,
                                    p.IsActive ,
                                    p.EmailAddr ,
                                    Phone ,
                                    Fax ,
                                    AddressLine1 ,
                                    AddressLine2 ,
                                    AddressLine3 ,
                                    AddressLine4 ,
                                    Building ,
                                    Floor ,
                                    Room ,
                                    AddressString ,
                                    Latitude ,
                                    Longitude ,
                                    FacultyRankID ,
                                    p.InternalUsername ,
                                    p.isvisible
                            FROM    [Profile.Import].Person p
                                    OUTER APPLY ( SELECT TOP 1
                                                            internalusername ,
                                                            facultyrankid ,
                                                            facultyranksort
                                                  FROM      [Profile.import].[PersonAffiliation] pa
                                                            JOIN [Profile.Data].[Person.FacultyRank] fr ON fr.facultyrank = pa.facultyrank
                                                  WHERE     pa.internalusername = p.internalusername
                                                  ORDER BY  facultyranksort ASC
                                                ) a
                                    JOIN [User.Account].[User] u ON u.internalusername = p.internalusername
                            WHERE   NOT EXISTS ( SELECT *
                                                 FROM   [Profile.Data].Person b
                                                 WHERE  b.internalusername = p.internalusername )  
                    SET IDENTITY_INSERT [Profile.Data].Person OFF

                END

			INSERT INTO [Framework.].[Log.Activity] (userId, personId, methodName, property, privacyCode, param1, param2) 
			SELECT 0, PersonID, '[Profile.Import].[LoadProfilesData]', null, null, 'Person Insert', null FROM @newPersonIDTable
						-- add personid to user
            UPDATE  u
            SET     u.personid = p.personid
            FROM    [Profile.Data].Person p
                    JOIN [User.Account].[User] u ON u.userid = p.userid


					-- person affiliation
            INSERT  INTO [Profile.Data].[Person.Affiliation]
                    ( PersonID ,
                      SortOrder ,
                      IsActive ,
                      IsPrimary ,
                      InstitutionID ,
                      DepartmentID ,
                      DivisionID ,
                      Title ,
                      EmailAddress ,
                      FacultyRankID
					        
                    )
                    SELECT  p.personid ,
                            affiliationorder ,
                            1 ,
                            primaryaffiliation ,
                            InstitutionID ,
                            DepartmentID ,
                            DivisionID ,
                            c.title ,
                            c.emailaddr ,
                            fr.facultyrankid
                    FROM    [Profile.Import].PersonAffiliation c
                            JOIN [Profile.Data].Person p ON c.internalusername = p.internalusername
                            LEFT JOIN [Profile.Data].[Organization.Institution] i ON i.institutionname = c.institutionname
                            LEFT JOIN [Profile.Data].[Organization.Department] d ON d.departmentname = c.departmentname
                            LEFT JOIN [Profile.Data].[Organization.Division] di ON di.divisionname = c.divisionname
                            LEFT JOIN [Profile.Data].[Person.FacultyRank] fr ON fr.facultyrank = c.facultyrank
                    WHERE   NOT EXISTS ( SELECT *
                                         FROM   [Profile.Data].[Person.Affiliation] a
                                         WHERE  a.personid = p.personid
                                                AND ISNULL(a.InstitutionID, '') = ISNULL(i.InstitutionID,
                                                              '')
                                                AND ISNULL(a.DepartmentID, '') = ISNULL(d.DepartmentID,
                                                              '')
                                                AND ISNULL(a.DivisionID, '') = ISNULL(di.DivisionID,
                                                              '') )


					-- person_filters
            INSERT  INTO [Profile.Data].[Person.Filter]
                    ( PersonFilter 
					        
                    )
                    SELECT DISTINCT
                            personfilter
                    FROM    [Profile.Import].PersonFilterFlag b
                    WHERE   NOT EXISTS ( SELECT *
                                         FROM   [Profile.Data].[Person.Filter] a
                                         WHERE  a.personfilter = b.personfilter )


				-- person_filter_relationships
            INSERT  INTO [Profile.Data].[Person.FilterRelationship]
                    ( PersonID ,
                      PersonFilterid
					        
                    )
                    SELECT DISTINCT
                            p.personid ,
                            personfilterid
                    FROM    [Profile.Import].PersonFilterFlag ptf
                            JOIN [Profile.Data].[Person.Filter] pt ON pt.personfilter = ptf.personfilter
                            JOIN [Profile.Data].Person p ON p.internalusername = ptf.internalusername
                    WHERE   NOT EXISTS ( SELECT *
                                         FROM   [Profile.Data].[Person.FilterRelationship] ptf
                                                JOIN [Profile.Data].[Person.Filter] pt2 ON pt2.personfilterid = ptf.personfilterid
                                                JOIN [Profile.Data].Person p2 ON p2.personid = ptf.personid
                                         WHERE  ( p2.personid = p.personid
                                                  AND pt.personfilterid = pt2.personfilterid
                                                ) )												     										     

			-- update changed affiliation in person table
            UPDATE  p
            SET     facultyrankid = a.facultyrankid
            FROM    [Profile.Data].person p
                    OUTER APPLY ( SELECT TOP 1
                                            internalusername ,
                                            facultyrankid ,
                                            facultyranksort
                                  FROM      [Profile.import].[PersonAffiliation] pa
                                            JOIN [Profile.Data].[Person.FacultyRank] fr ON fr.facultyrank = pa.facultyrank
                                  WHERE     pa.internalusername = p.internalusername
                                  ORDER BY  facultyranksort ASC
                                ) a
            WHERE   p.facultyrankid <> a.facultyrankid
			 
			 
			-- Hide/Show Departments
            UPDATE  d
            SET     d.visible = ISNULL(t.v, 0)
            FROM    [Profile.Data].[Organization.Department] d
                    LEFT OUTER JOIN ( SELECT    a.departmentname ,
                                                MAX(CAST(a.departmentvisible AS INT)) v
                                      FROM      [Profile.Import].PersonAffiliation a ,
                                                [Profile.Import].Person p
                                      WHERE     a.internalusername = p.internalusername
                                                AND p.isactive = 1
                                      GROUP BY  a.departmentname
                                    ) t ON d.departmentname = t.departmentname


			-- Apply person active changes to user table
			UPDATE u 
			   SET isactive  = p.isactive
			  FROM [User.Account].[User] u 
			  JOIN [Profile.Data].Person p ON p.PersonID = u.PersonID 
			  
            COMMIT
        END TRY
        BEGIN CATCH
			--Check success
            IF @@TRANCOUNT > 0 
                ROLLBACK

			-- Raise an error with the details of the exception
            SELECT  @ErrMsg = ERROR_MESSAGE() ,
                    @ErrSeverity = ERROR_SEVERITY()

            RAISERROR(@ErrMsg, @ErrSeverity, 1)
        END CATCH	

    END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [RDF.Security].[GetSessionSecurityGroupNodes]
@SessionID UNIQUEIDENTIFIER=NULL, @Subject BIGINT=NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	/*

	This procedure returns Security Group nodes to which
	the given session has access. However, it only returns
	the NodeID of the session itself if the subject is that
	session node; otherwise, there is no need to include
	node in the result set.

	*/

	-- Get the session's NodeID
	SELECT NodeID SecurityGroupNode
		FROM [User.Session].Session
		WHERE NodeID IS NOT NULL
			AND SessionID = @SessionID
	-- Get the user's NodeID
	UNION
	SELECT m.NodeID SecurityGroupNode
		FROM [User.Session].Session s 
			INNER JOIN [RDF.Stage].InternalNodeMap m
				ON	s.SessionID = @SessionID
					AND s.UserID IS NOT NULL
					AND m.Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#User'
					AND m.InternalType = 'User'
					AND m.InternalID = CAST(s.UserID AS VARCHAR(50))
	-- Get designated proxy NodeIDs
	UNION
	SELECT m.NodeID SecurityGroupNode
		FROM [User.Session].Session s
			INNER JOIN [User.Account].[DesignatedProxy] x
				ON	s.SessionID = @SessionID
					AND s.UserID IS NOT NULL
					AND @Subject IS NOT NULL
					AND x.UserID = s.UserID
			INNER JOIN [RDF.Stage].InternalNodeMap m
				ON	m.Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#User'
					AND m.InternalType = 'User'
					AND m.InternalID = CAST(x.ProxyForUserID AS VARCHAR(50))
			INNER JOIN [RDF.].[Node] n
				ON	n.NodeID = @Subject
					AND m.NodeID IN (@Subject, n.ViewSecurityGroup, n.EditSecurityGroup)
	/*
	SELECT m.NodeID SecurityGroupNode
		FROM [User.Session].Session s
			INNER JOIN [RDF.].[Node] n
				ON	s.SessionID = @SessionID
					AND s.UserID IS NOT NULL
					AND @Subject IS NOT NULL
					AND n.NodeID = @Subject
			INNER JOIN [User.Account].[DesignatedProxy] x
				ON	x.UserID = s.UserID
					AND x.ProxyForUserID IN (@Subject, n.ViewSecurityGroup, n.EditSecurityGroup)
			INNER JOIN [RDF.Stage].InternalNodeMap m
				ON	m.Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#User'
					AND m.InternalType = 'User'
					AND m.InternalID = CAST(x.ProxyForUserID AS VARCHAR(50))
	*/
	-- Get default proxy NodeIDs
	UNION
	SELECT m.NodeID SecurityGroupNode
		FROM [User.Session].Session s
			INNER JOIN [RDF.].[Node] n
				ON	s.SessionID = @SessionID
					AND s.UserID IS NOT NULL
					AND @Subject IS NOT NULL
					AND n.NodeID = @Subject
			INNER JOIN [User.Account].[DefaultProxy] x
				ON	x.UserID = s.UserID
			INNER JOIN [User.Account].[User] u
				ON	((IsNull(x.ProxyForInstitution,'') = '') 
							OR (IsNull(x.ProxyForInstitution,'') = IsNull(u.Institution,'')))
					AND ((IsNull(x.ProxyForDepartment,'') = '') 
							OR (IsNull(x.ProxyForDepartment,'') = IsNull(u.Department,'')))
					AND ((IsNull(x.ProxyForDivision,'') = '') 
							OR (IsNull(x.ProxyForDivision,'') = IsNull(u.Division,'')))
			INNER JOIN [RDF.Stage].InternalNodeMap m
				ON	m.Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#User'
					AND m.InternalType = 'User'
					AND m.InternalID = CAST(u.UserID AS VARCHAR(50))
					AND m.NodeID IN (@Subject, n.ViewSecurityGroup, n.EditSecurityGroup)
	-- Get Group Administrator NodesIDs
	UNION
	SELECT g.GroupNodeID SecurityGroupNode
		FROM [User.Session].Session s
			INNER JOIN [Profile.Data].[Group.Admin] x
				ON	s.SessionID = @SessionID
					AND s.UserID IS NOT NULL
					AND @Subject IS NOT NULL
					AND x.UserID = s.UserID
			INNER JOIN [Profile.Data].[vwGroup.General] g
				ON g.ViewSecurityGroup <> 0
				AND g.GroupNodeID = @Subject
	-- Get Group Manager NodeIDs
	UNION
	SELECT g.GroupNodeID SecurityGroupNode
		FROM [User.Session].Session s
			INNER JOIN [Profile.Data].[Group.Manager] x
				ON	s.SessionID = @SessionID
					AND s.UserID IS NOT NULL
					AND @Subject IS NOT NULL
					AND x.UserID = s.UserID
			INNER JOIN [Profile.Data].[vwGroup.General] g
				ON g.ViewSecurityGroup <> 0
				AND g.GroupID = x.GroupID
				AND g.GroupNodeID = @Subject					
	/*
	SELECT m.NodeID SecurityGroupNode
		FROM [User.Session].Session s
			INNER JOIN [RDF.].[Node] n
				ON	s.SessionID = @SessionID
					AND s.UserID IS NOT NULL
					AND @Subject IS NOT NULL
					AND n.NodeID = @Subject
			INNER JOIN [User.Account].[DefaultProxy] x
				ON	x.UserID = s.UserID
			INNER JOIN [User.Account].[User] u
				ON	u.UserID IN (@Subject, n.ViewSecurityGroup, n.EditSecurityGroup)
					AND ((IsNull(x.ProxyForInstitution,'') = '') 
							OR (IsNull(x.ProxyForInstitution,'') = IsNull(u.Institution,'')))
					AND ((IsNull(x.ProxyForDepartment,'') = '') 
							OR (IsNull(x.ProxyForDepartment,'') = IsNull(u.Department,'')))
					AND ((IsNull(x.ProxyForDivision,'') = '') 
							OR (IsNull(x.ProxyForDivision,'') = IsNull(u.Division,'')))
			INNER JOIN [RDF.Stage].InternalNodeMap m
				ON	m.Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#User'
					AND m.InternalType = 'User'
					AND m.InternalID = CAST(u.UserID AS VARCHAR(50))
	*/

	/*
	This will later be expanded to include all nodes to which a
	session's users is connected through a membership predicate.
	*/


END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [RDF.Security].[GetSessionSecurityGroup]
	@SessionID uniqueidentifier = NULL,
	@SecurityGroupID bigint = -1 OUTPUT,
	@HasSpecialViewAccess bit = 0 OUTPUT,
	@HasSpecialEditAccess bit = 0 OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT	@SecurityGroupID = IsNull(MIN(g.SecurityGroupID),-1),
			@HasSpecialViewAccess = IsNull(MAX(CAST(g.HasSpecialViewAccess AS TINYINT)),0),
			@HasSpecialEditAccess = IsNull(MAX(CAST(g.HasSpecialEditAccess AS TINYINT)),0)
		FROM [User.Session].Session s, [RDF.Security].Member m, [RDF.Security].[Group] g
		WHERE s.SessionID = @SessionID AND s.UserID IS NOT NULL
			AND s.UserID = m.UserID AND m.SecurityGroupID = g.SecurityGroupID
			
	IF @SecurityGroupID > -20
		SELECT @SecurityGroupID = (case when UserID is not null then -20 when IsBot = 1 then -1 else -10 end)
			FROM [User.Session].Session
			WHERE SessionID = @SessionID

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [RDF.].[GetStoreTriple]
	-- Define the triple
	@ExistingTripleID bigint = null,
	@SubjectID bigint = null,
	@PredicateID bigint = null,
	@ObjectID bigint = null,
	@SubjectURI varchar(400) = NULL,
	@PredicateURI varchar(400) = NULL,
	@ObjectURI varchar(400) = NULL,
	-- Attributes
	@ViewSecurityGroup bigint = null,
	@Weight float = null,
	@SortOrder int = null,
	@MoveUpOne bit = null,
	@MoveDownOne bit = null,
	-- Inverse predicate triple
	@StoreInverse bit = 0,
	@InverseViewSecurityGroup bigint = null,
	@InverseWeight float = null,
	-- Other
	@OldObjectID bigint = null,
	@OldObjectURI varchar(400) = NULL,
	-- Security
	@SessionID uniqueidentifier = NULL,
	-- Output variables
	@Error bit = NULL OUTPUT,
	@TripleID bigint = NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	SELECT @Error = 0
	SELECT @TripleID = NULL

	DECLARE @OldTripleID BIGINT
	SELECT @OldTripleID = NULL

	DECLARE @OldSortOrder BIGINT
	DECLARE @NewSortOrder BIGINT
	DECLARE @MaxSortOrder BIGINT

	SELECT @ExistingTripleID = NULL WHERE @ExistingTripleID = 0
	SELECT @SubjectID = NULL WHERE @SubjectID = 0
	SELECT @PredicateID = NULL WHERE @PredicateID = 0
	SELECT @ObjectID = NULL WHERE @ObjectID = 0
	SELECT @OldObjectID = NULL WHERE @OldObjectID = 0

	IF (@SortOrder IS NOT NULL)
		SELECT @MoveUpOne = NULL, @MoveDownOne = NULL

	-- Convert URIs to NodeIDs
 	IF (@SubjectID IS NULL) AND (@SubjectURI IS NOT NULL)
		SELECT @SubjectID = [RDF.].fnURI2NodeID(@SubjectURI)
 	IF (@PredicateID IS NULL) AND (@PredicateURI IS NOT NULL)
		SELECT @PredicateID = [RDF.].fnURI2NodeID(@PredicateURI)
 	IF (@ObjectID IS NULL) AND (@ObjectURI IS NOT NULL)
		SELECT @ObjectID = [RDF.].fnURI2NodeID(@ObjectURI)
 	IF (@OldObjectID IS NULL) AND (@OldObjectURI IS NOT NULL)
		SELECT @OldObjectID = [RDF.].fnURI2NodeID(@OldObjectURI)
 
	-- Confirm ExistingTripleID exists
	IF (@ExistingTripleID IS NOT NULL)
		SELECT @TripleID = TripleID, @SubjectID = subject, @PredicateID = predicate, @ObjectID = object
			FROM [RDF.].Triple
			WHERE TripleID = @ExistingTripleID

	-- Make sure required parameters are defined
	IF (@SubjectID IS NULL OR @PredicateID IS NULL OR @ObjectID IS NULL)
	BEGIN
		SELECT @Error = 1
		RETURN
	END	
	SELECT @Error = 1
		WHERE NOT EXISTS (SELECT * FROM [RDF.].Node WHERE NodeID = @SubjectID)
			OR NOT EXISTS (SELECT * FROM [RDF.].Node WHERE NodeID = @PredicateID)
			OR NOT EXISTS (SELECT * FROM [RDF.].Node WHERE NodeID = @ObjectID)
	IF (@SubjectID IS NULL OR @PredicateID IS NULL OR @ObjectID IS NULL)
	BEGIN
		SELECT @Error = 1
		RETURN
	END	

	-- Determine if a triple already exitsts
	IF (@TripleID IS NULL)
		SELECT @TripleID = TripleID
			FROM [RDF.].Triple
			WHERE subject = @SubjectID AND predicate = @PredicateID AND object = @ObjectID
	
	-- Handle the case where there is an OldObjectID
	IF (@OldObjectID IS NOT NULL) AND (@OldObjectID <> @ObjectID)
	BEGIN
		SELECT @OldTripleID = TripleID,
				@ViewSecurityGroup = IsNull(@ViewSecurityGroup,ViewSecurityGroup),
				@Weight = IsNull(@Weight,Weight),
				@OldSortOrder = SortOrder
			FROM [RDF.].Triple
			WHERE subject = @SubjectID AND predicate = @PredicateID AND object = @OldObjectID
		IF @OldTripleID IS NOT NULL
		BEGIN
			SELECT @SortOrder = @OldSortOrder, @TripleID = @OldTripleID
			UPDATE [RDF.].Triple
				SET object = @ObjectID
				WHERE TripleID = @TripleID
			/*
			DELETE 
				FROM [RDF.].Triple
				WHERE TripleID = @OldTripleID
			UPDATE [RDF.].Triple
				SET SortOrder = SortOrder - 1
				WHERE subject = @SubjectID AND predicate = @PredicateID AND SortOrder >= @OldSortOrder
			SELECT @OldTripleID = NULL
			*/
		END
	END

	-- Incremental SortOrders
	IF (@MoveUpOne = 1 OR @MoveDownOne = 1)
	BEGIN
		IF (@OldSortOrder IS NOT NULL)
			SELECT @SortOrder = @OldSortOrder + (CASE WHEN @MoveUpOne = 1 THEN 1 WHEN @MoveDownOne = 1 THEN -1 ELSE 0 END)
		ELSE IF (@TripleID IS NOT NULL)
			SELECT @SortOrder = SortOrder + (CASE WHEN @MoveUpOne = 1 THEN 1 WHEN @MoveDownOne = 1 THEN -1 ELSE 0 END)
				FROM [RDF.].Triple
				WHERE TripleID = @TripleID
	END

	-- Set SortOrder variables
	IF @TripleID IS NOT NULL
		SELECT @OldSortOrder = SortOrder
			FROM [RDF.].Triple
			WHERE TripleID = @TripleID
	SELECT @MaxSortOrder = MAX(SortOrder)
		FROM [RDF.].Triple
		WHERE subject = @SubjectID AND predicate = @PredicateID
	SELECT @MaxSortOrder = IsNull(@MaxSortOrder,0)
	SELECT @NewSortOrder = (CASE WHEN @MaxSortOrder = 0 THEN 1
								WHEN @SortOrder < 1 THEN 1
								WHEN @SortOrder <= @MaxSortOrder THEN @SortOrder
								WHEN @TripleID IS NOT NULL THEN @MaxSortOrder
								ELSE @MaxSortOrder + 1 END)
 
	-- Update attributes if a triple already exists
	IF (@TripleID IS NOT NULL)
	BEGIN
		IF @ViewSecurityGroup IS NOT NULL
			UPDATE [RDF.].Triple
				SET ViewSecurityGroup = @ViewSecurityGroup
				WHERE TripleID = @TripleID
		IF @Weight IS NOT NULL
			UPDATE [RDF.].Triple
				SET Weight = @Weight
				WHERE TripleID = @TripleID
		IF (@SortOrder IS NOT NULL) AND (@SortOrder <> @OldSortOrder)
			UPDATE [RDF.].Triple
				SET SortOrder = (CASE
									WHEN TripleID = @TripleID 
										THEN @NewSortOrder
									WHEN (@NewSortOrder > @OldSortOrder) AND (SortOrder > @OldSortOrder) AND (SortOrder <= @NewSortOrder)
										THEN SortOrder - 1
									WHEN (@NewSortOrder < @OldSortOrder) AND (SortOrder < @OldSortOrder) AND (SortOrder >= @NewSortOrder)
										THEN SortOrder + 1
									ELSE SortOrder END)
				WHERE subject = @SubjectID AND predicate = @PredicateID 
					AND (SortOrder >= @NewSortOrder OR SortOrder >= @OldSortOrder)
					AND (SortOrder <= @NewSortOrder OR SortOrder <= @OldSortOrder)
	END
 
	-- Create a new triple if needed
	IF (@TripleID IS NULL)
	BEGIN
		-- Get ObjectType
		DECLARE @ObjectType BIT
		SELECT @ObjectType = ObjectType
			FROM [RDF.].[Node]
			WHERE NodeID = @ObjectID
		-- Shift SortOrders of existing triples
		IF @NewSortOrder <= @MaxSortOrder
			UPDATE [RDF.].Triple
				SET SortOrder = SortOrder + 1
				WHERE subject = @SubjectID AND predicate = @PredicateID
					AND SortOrder >= @NewSortOrder
		-- Get default @ViewSecurityGroup
		IF @ViewSecurityGroup IS NULL
		BEGIN
			SELECT @ViewSecurityGroup = MAX(IsNull(p.ViewSecurityGroup,c.ViewSecurityGroup))
				FROM [RDF.].Triple t
						INNER JOIN [Ontology.].ClassProperty c
							ON t.subject = @SubjectID
								AND t.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
								AND t.object = c._ClassNode
								AND c._PropertyNode = @PredicateID
								AND c._NetworkPropertyNode IS NULL
						LEFT OUTER JOIN [RDF.Security].NodeProperty p
							ON p.NodeID = @SubjectID
								AND p.Property = @PredicateID
			SELECT @ViewSecurityGroup = IsNull(@ViewSecurityGroup,-1)
		END
		-- Create the triple
		INSERT INTO [RDF.].[Triple] (ViewSecurityGroup, Subject, Predicate, Object, ObjectType, Weight, SortOrder, TripleHash)
			SELECT @ViewSecurityGroup, @SubjectID, @PredicateID, @ObjectID, @ObjectType, IsNull(@Weight,1), @NewSortOrder,
					[RDF.].fnTripleHash(@SubjectID, @PredicateID, @ObjectID) 
		SET @TripleID = @@IDENTITY
		-- Create the inverse triple
		IF (@StoreInverse IS NOT NULL)
		BEGIN	
			-- Determine if there is an inverse property
			DECLARE @InversePredicateID BIGINT
			SELECT @InversePredicateID = object
				FROM [RDF.].Triple
				WHERE subject = @PredicateID
					AND predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2002/07/owl#inverseOf')
			IF @InversePredicateID IS NOT NULL
			BEGIN
				-- Get default @InverseWeight
				SELECT @InverseWeight = IsNull(@InverseWeight,@Weight)
				-- Create the inverse triple
				EXEC [RDF.].GetStoreTriple	@SubjectID = @ObjectID,
											@PredicateID = @InversePredicateID,
											@ObjectID = @SubjectID,
											@ViewSecurityGroup = @InverseViewSecurityGroup,
											@Weight = @InverseWeight,
											@SortOrder = NULL,
											@SessionID = @SessionID,
											@Error = @Error OUTPUT
			END
		END
	END

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Ontology.Presentation].[ConvertTables2XML]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	TRUNCATE TABLE [Ontology.Presentation].[XML]
	INSERT INTO [Ontology.Presentation].[XML]
		SELECT PresentationID, Type, Subject, Predicate, Object,
			(SELECT	(CASE Type WHEN 'P' THEN 'profile' WHEN 'N' THEN 'network' WHEN 'C' THEN 'connection' WHEN 'E' THEN 'profile' END) "@PresentationClass",
					PageColumns "PageOptions/@Columns",
					WindowName,
					PageColumns,
					PageTitle,
					PageBackLinkName,
					PageBackLinkURL,
					PageSubTitle,
					PageDescription,
					PanelTabType,
					(SELECT	Type "Panel/@Type",
							(CASE WHEN TabSort = -1 THEN NULL ELSE TabSort END) "Panel/@TabSort",
							TabType "Panel/@TabType",
							Alias "Panel/@Alias",
							Name "Panel/@Name",
							Icon "Panel/@Icon",
							DisplayRule "Panel/@DisplayRule",
							ModuleXML "Panel"
						FROM [Ontology.Presentation].[Panel] p
						WHERE p.PresentationID = g.PresentationID
						FOR XML PATH(''), TYPE
					) PanelList,
					ExpandRDFList ExpandRDFList
				FOR XML PATH('Presentation'), TYPE
			) PresentationXML,
			[RDF.].fnURI2NodeID(subject) _SubjectNode,
			[RDF.].fnURI2NodeID(predicate) _PredicateNode,
			[RDF.].fnURI2NodeID(object) _ObjectNode
		FROM [Ontology.Presentation].[General] g

	-- SELECT * FROM [Ontology.Presentation].[XML]

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Ontology.Import].[ConvertOWL2Triple]
	@OWL varchar(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
BEGIN TRY 
    begin transaction

		delete 
			from [Ontology.Import].Triple
			where OWL = @OWL

		insert into [Ontology.Import].Triple (OWL, Graph, Subject, Predicate, Object)
			select OWL, Graph, Subject, Predicate, Object 
			from [Ontology.Import].vwOwlTriple
			where OWL = @OWL

	commit transaction
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
 
		-- Raise an error with the details of the exception
		SELECT @ErrMsg =  ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()
 
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
			 
	END CATCH		

	-- select * from [Ontology.Import].Triple
	-- select * from [Ontology.Import].vwOwlTriple
	-- exec [Ontology.Import].[ConvertOWL2Triple] @OWL = 'VIVO_1.4'

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[ConnectionDetails.Person.SimilarTo.GetData]
	@subject BIGINT,
	@object BIGINT,
	@SessionID UNIQUEIDENTIFIER=NULL
AS
BEGIN
 
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	DECLARE @PersonID INT
 	SELECT @PersonID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @subject
 
	DECLARE @PersonID2 INT
 	SELECT @PersonID2 = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @object

	DECLARE @baseURI NVARCHAR(400)
	SELECT @baseURI = value FROM [Framework.].Parameter WHERE ParameterID = 'baseURI'

	DECLARE @hasResearchAreaID BIGINT
	SELECT @hasResearchAreaID = [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#hasResearchArea')

	;with a as (
		select a.PersonID PersonID1, b.PersonID PersonID2, a.MeshHeader, 
			a.NumPubsThis PublicationCount1, b.NumPubsThis PublicationCount2,
			a.Weight KeywordWeight1, b.Weight KeywordWeight2,
			a.Weight*b.Weight OverallWeight
		from [Profile.Cache].[Concept.Mesh.Person] a, [Profile.Cache].[Concept.Mesh.Person] b
		where a.personid = @PersonID and b.personid = @PersonID2
			and a.meshheader = b.meshheader
	), b as (
		select count(*) SharedKeywords, sum(OverallWeight) TotalOverallWeight 
		from a
	)
	select a.*, b.*, @baseURI + cast(m.NodeID as varchar(50)) ObjectURI,
		@baseURI + cast(@subject as varchar(50)) + '/' + cast(@hasResearchAreaID as varchar(50)) + '/' + cast(m.NodeID as varchar(50)) ConnectionURI1,
		@baseURI + cast(@object as varchar(50)) + '/' + cast(@hasResearchAreaID as varchar(50)) + '/' + cast(m.NodeID as varchar(50)) ConnectionURI2
	from a, b, [Profile.Data].[Concept.Mesh.Descriptor] d, [RDF.Stage].[InternalNodeMap] m
	where a.MeshHeader = d.DescriptorName and d.DescriptorUI = m.InternalID
		and m.Class = 'http://www.w3.org/2004/02/skos/core#Concept' and m.InternalType = 'MeshDescriptor'
	order by OverallWeight desc, MeshHeader

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[Concept.Mesh.UpdateWord2Mesh]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER,@rows BIGINT 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
 
	select a.word, a.mesh_header
		into #cache_word2mesh
		from [Profile.Cache].[Concept.Mesh.Word2mesh2All] a, [Profile.Cache].[Concept.Mesh.Count] c
		where a.mesh_header = c.meshheader
	select a.word, a.mesh_header
		into #cache_word2mesh2
		from [Profile.Cache].[Concept.Mesh.Word2mesh2All] a, [Profile.Cache].[Concept.Mesh.Count] c
		where a.mesh_header = c.meshheader
	select a.word, a.mesh_term, a.mesh_header, a.num_words
		into #cache_word2mesh3
		from [Profile.Cache].[Concept.Mesh.Word2Mesh3All] a, [Profile.Cache].[Concept.Mesh.Count] c
		where a.mesh_header = c.meshheader
 
	BEGIN TRY
		BEGIN TRAN
			truncate TABLE [Profile.Cache].[Concept.Mesh.Word2mesh]
			insert into [Profile.Cache].[Concept.Mesh.Word2mesh](word, meshheader)
				select word, mesh_header from #cache_word2mesh
			truncate table [Profile.Cache].[Concept.Mesh.Word2mesh2]
			insert into [Profile.Cache].[Concept.Mesh.Word2mesh2](word, mesh_header)
				select word, mesh_header from #cache_word2mesh2
			truncate table [Profile.Cache].[Concept.Mesh.Word2mesh3]
			insert into [Profile.Cache].[Concept.Mesh.Word2mesh3](word, meshterm, meshheader, numwords)
				select word, mesh_term, mesh_header, num_words from #cache_word2mesh3
			SELECT @rows = @@ROWCOUNT
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=0
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@ProcessedRows = @rows,@insert_new_record=0
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Cache].[Concept.Mesh.UpdateTreeTop]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
	DECLARE @proc VARCHAR(200)
	SELECT @proc = OBJECT_NAME(@@PROCID)
	DECLARE @date DATETIME,@auditid UNIQUEIDENTIFIER, @rows int
	SELECT @date=GETDATE() 
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
 
 	select r.TreeNumber FullTreeNumber, 
			(case when len(r.TreeNumber)=1 then '' else left(r.TreeNumber,len(r.TreeNumber)-4) end) ParentTreeNumber,
			r.DescriptorName, IsNull(t.TreeNumber,r.TreeNumber) TreeNumber, t.DescriptorUI
		into #TreeTop
		from [Profile.Data].[Concept.Mesh.TreeTop] r
			left outer join [Profile.Data].[Concept.Mesh.Tree] t
				on t.TreeNumber = substring(r.TreeNumber,3,999)
			left outer join [Framework.].[Parameter] f
				on f.ParameterID = 'baseURI'
 
	BEGIN TRY
		BEGIN TRAN
			TRUNCATE TABLE [Profile.Cache].[Concept.Mesh.TreeTop]
			INSERT INTO [Profile.Cache].[Concept.Mesh.TreeTop] (FullTreeNumber, ParentTreeNumber, TreeNumber, DescriptorName, DescriptorUI)
				SELECT FullTreeNumber, ParentTreeNumber, TreeNumber, DescriptorName, DescriptorUI
				FROM #TreeTop
			SELECT @rows = @@ROWCOUNT
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=0
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName ='Concept.Mesh.UpdateTreeTop',@ProcessEndDate=@date,@ProcessedRows = @rows,@insert_new_record=0
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[Concept.Mesh.UpdateSimilarConcept]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
  /* 
	create table dbo.cache_similar_concepts (
		MeshHeader nvarchar(255) not null,
		SortOrder int not null, 
		SimilarConcept nvarchar(255), 
		Weight float
	)
	alter table cache_similar_concepts add primary key (MeshHeader, SortOrder)
*/
 
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER,@rows BIGINT 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
 
 
	create table #cache_similar_concepts(meshheader nvarchar(255), sortorder int, similarconcept nvarchar(255), weight float)
 
	create table #cache_similar_concepts_tmp(m int, sortorder int, similarm int, weight float)
 
	select MeshHeader, Weight, row_number() over (order by MeshHeader) m 
		into #mesh2num
		from [Profile.Cache].[Concept.Mesh.Count]
	alter table #mesh2num add primary key (MeshHeader)
	create table #num2mesh (m int not null, MeshHeader nvarchar(255))
	insert into #num2mesh (m, MeshHeader) select m, MeshHeader from #mesh2num
	alter table #num2mesh add primary key (m)
 
	create table #cache_user_mesh (m int not null, personid int not null, weight float, meshweight float)
	insert into #cache_user_mesh (m, personid, weight, meshweight)
		select m.m, c.PersonID, c.Weight, m.Weight MeshWeight
		from [Profile.Cache].[Concept.Mesh.Person] c, #mesh2num m
		where c.meshheader = m.meshheader
	alter table #cache_user_mesh add primary key (m, personid)
 
	declare @maxp int
	declare @p int
	select @maxp = max(m) from #num2mesh
	set @p = 1
	while @p <= @maxp
	begin
		INSERT INTO #cache_similar_concepts_tmp(m,sortorder,similarm,weight)
			SELECT m, k, similarm, weight
			FROM (
				SELECT m, similarm, weight, row_number() over (partition by m order by weight desc) k
				FROM (
					SELECT a.m,
						b.m similarm,
						SUM(a.weight * b.weight * b.meshweight) weight
					FROM #cache_user_mesh a inner join #cache_user_mesh b 
						ON a.personid = b.personid 
							AND a.m <> b.m 
							AND a.m between @p and @p+999
					GROUP BY a.m, b.m
				) t
			) t
			WHERE k <= 60
		set @p = @p + 1000
	end
 
	insert into #cache_similar_concepts(meshheader, sortorder, similarconcept, weight)
		select a.meshheader, c.sortorder, b.meshheader, c.weight
		from #cache_similar_concepts_tmp c, #num2mesh a, #num2mesh b
		where c.m = a.m and c.similarm = b.m
 
 
	BEGIN TRY
		BEGIN TRAN
			TRUNCATE TABLE [Profile.Cache].[Concept.Mesh.SimilarConcept]
			INSERT INTO [Profile.Cache].[Concept.Mesh.SimilarConcept] (meshheader, sortorder, similarconcept, weight)
				SELECT meshheader, sortorder, similarconcept, weight FROM #cache_similar_concepts
			SELECT @rows = @@ROWCOUNT
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=0
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@ProcessedRows = @rows,@insert_new_record=0
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[CustomViewPersonSameDepartment.GetList]
	@NodeID BIGINT,
	@SessionID UNIQUEIDENTIFIER = NULL
AS
BEGIN
 
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	declare @labelID bigint
	select @labelID = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')

	declare @baseURI nvarchar(400)
	select @baseURI = value from [Framework.].Parameter where ParameterID = 'baseURI'

	DECLARE @PersonID INT
 	SELECT @PersonID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID

	declare @i nvarchar(500)
	declare @d nvarchar(500)
	declare @v nvarchar(500)

	select @i = institutionname, @d = departmentname, @v = divisionfullname
		from [Profile.Cache].[Person]
		where personid = @personid

	declare @InstitutionURI varchar(400)
	declare @DepartmentURI varchar(400)

	select	@InstitutionURI = @baseURI + cast(j.NodeID as varchar(50)),
			@DepartmentURI = @baseURI + cast(e.NodeID as varchar(50))
		from [Profile.Data].[Organization.Institution] i,
			[Profile.Data].[Organization.Department] d,
			[RDF.Stage].[InternalNodeMap] j,
			[RDF.Stage].[InternalNodeMap] e
		where i.InstitutionName = @i and d.DepartmentName = @d
			and j.InternalType = 'Institution' and j.Class = 'http://xmlns.com/foaf/0.1/Organization' and j.InternalID = cast(i.InstitutionID as varchar(50))
			and e.InternalType = 'Department' and e.Class = 'http://xmlns.com/foaf/0.1/Organization' and e.InternalID = cast(d.DepartmentID as varchar(50))

	declare @x xml

	;with a as (
		select a.personid, 
			max(case when a.divisionname = @v then 1 else 0 end) v,
			max(case when s.numpublications > 0 then 1 else 0 end) p
			--row_number() over (order by newid()) k
		from [Profile.Cache].[Person.Affiliation] a, [Profile.Cache].[Person] s
		where a.personid <> @personid
			and a.instititutionname = @i and a.departmentname = @d
			and a.personid = s.personid
		group by a.personid
	), b as (
		select top(5) *
		from a
		order by v desc, p desc, newid()
	), c as (
		select m.NodeID, n.Value URI, l.Value Label
		from b
			inner join [RDF.Stage].[InternalNodeMap] m
				on m.InternalType = 'Person' and m.Class = 'http://xmlns.com/foaf/0.1/Person' and m.InternalID = cast(b.personid as varchar(50))
			inner join [RDF.].[Node] n
				on n.NodeID = m.NodeID and n.ViewSecurityGroup = -1
			inner join [RDF.].[Triple] t
				on t.subject = n.NodeID and t.predicate = @labelID and t.ViewSecurityGroup = -1
			inner join [RDF.].[Node] l
				on l.NodeID = t.object and l.ViewSecurityGroup = -1
	)
	select @x = (
			select	(select count(*) from a) "NumberOfConnections",
					@InstitutionURI "InstitutionURI",
					@DepartmentURI "DepartmentURI",
					(select	NodeID "Connection/@NodeID",
							URI "Connection/@URI",
							Label "Connection"
						from c
						order by Label
						for xml path(''), type
					)
			for xml path('Network'), type
		)

	select @x XML

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [RDF.].[DeleteTriple]
	@TripleID bigint = NULL,
	@SubjectID bigint = NULL,
	@PredicateID bigint = NULL,
	@ObjectID bigint = NULL,
	@SubjectURI varchar(400) = NULL,
	@PredicateURI varchar(400) = NULL,
	@ObjectURI varchar(400) = NULL,
	@DeleteInverse bit = 0,
	@DeleteType tinyint = 0,
	@SessionID uniqueidentifier = NULL,
	-- Output variables
	@Error bit = NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	SELECT @Error = 0

	SELECT @TripleID = NULL WHERE @TripleID = 0
	SELECT @SubjectID = NULL WHERE @SubjectID = 0
	SELECT @PredicateID = NULL WHERE @PredicateID = 0
	SELECT @ObjectID = NULL WHERE @ObjectID = 0
	
	-- Convert URIs to NodeIDs
	
 	IF (@SubjectID IS NULL) AND (@SubjectURI IS NOT NULL)
	BEGIN
		SELECT @SubjectID = [RDF.].fnURI2NodeID(@SubjectURI)
		IF @SubjectID IS NULL
			SELECT @Error = 1
	END
		
 	IF (@PredicateID IS NULL) AND (@PredicateURI IS NOT NULL)
	BEGIN
		SELECT @PredicateID = [RDF.].fnURI2NodeID(@PredicateURI)
		IF @PredicateID IS NULL
			SELECT @Error = 1
	END

 	IF (@ObjectID IS NULL) AND (@ObjectURI IS NOT NULL)
	BEGIN
		SELECT @ObjectID = [RDF.].fnURI2NodeID(@ObjectURI)
		IF @ObjectID IS NULL
			SELECT @Error = 1
	END

	IF Coalesce(@TripleID, @SubjectID, @PredicateID, @ObjectID) IS NULL
		SELECT @Error = 1

	IF @Error = 1
	BEGIN
		RETURN
	END

	-- Determine if there is an inverse predicate
	DECLARE @InversePredicateID BIGINT
	SELECT @InversePredicateID = NULL
	IF (@DeleteInverse IS NOT NULL) AND (@TripleID IS NOT NULL) AND (@PredicateID IS NULL)
		SELECT @PredicateID = predicate
			FROM [RDF.].Triple
			WHERE TripleID = @TripleID
	IF (@DeleteInverse IS NOT NULL) AND (@PredicateID IS NOT NULL)
		SELECT @InversePredicateID = object
			FROM [RDF.].Triple
			WHERE subject = @PredicateID
				AND predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2002/07/owl#inverseOf')
BEGIN TRY
	BEGIN TRANSACTION
 
		-- Get a list of TripleIDs to delete
		CREATE TABLE #DeleteTriples (
			TripleID bigint primary key,
			subject bigint,
			predicate bigint
		)
		DECLARE @sql NVARCHAR(max)
		SELECT @sql = ''
			+ 'SELECT TripleID, subject, predicate '
			+ 'FROM [RDF.].[Triple] '
			+ 'WHERE 1=1 '
			+ (CASE WHEN @TripleID IS NOT NULL THEN ' AND TripleID = '+CAST(@TripleID AS VARCHAR(50)) ELSE '' END)
			+ (CASE WHEN @SubjectID IS NOT NULL THEN ' AND Subject = '+CAST(@SubjectID AS VARCHAR(50)) ELSE '' END)
			+ (CASE WHEN @PredicateID IS NOT NULL THEN ' AND Predicate = '+CAST(@PredicateID AS VARCHAR(50)) ELSE '' END)
			+ (CASE WHEN @ObjectID IS NOT NULL THEN ' AND Object = '+CAST(@ObjectID AS VARCHAR(50)) ELSE '' END)
		INSERT INTO #DeleteTriples
			EXEC sp_executesql @sql
		
		-- Add inverse triples to list
		IF @InversePredicateID IS NOT NULL
			INSERT INTO #DeleteTriples (TripleID, subject, predicate)
				SELECT t.TripleID, t.subject, t.predicate
					FROM [RDF.].Triple t, [RDF.].Triple v, #DeleteTriples d
					WHERE	t.subject = v.object
						and t.predicate = @InversePredicateID
						and t.object = v.subject
						and v.TripleID = d.TripleID
						and t.TripleID not in (select TripleID from #DeleteTriples)
		
		-- Delete triples
 
		IF @DeleteType = 0 -- True delete
		BEGIN
			-- Delete triples
			DELETE FROM [RDF.].[Triple] WHERE TripleID IN (SELECT TripleID FROM #DeleteTriples)
			-- Update sort orders
			UPDATE t
				SET t.SortOrder = x.SortOrder
				FROM [RDF.].[Triple] t
					INNER JOIN (
						SELECT v.TripleID, row_number() over (partition by v.subject, v.predicate order by v.sortorder) SortOrder
						FROM [RDF.].[Triple] v
							INNER JOIN (
								SELECT DISTINCT subject, predicate
									FROM #DeleteTriples
							) w
							ON v.subject = w.subject AND v.predicate = w.predicate
					) x ON t.TripleID = x.TripleID AND t.SortOrder <> x.SortOrder 
			-- TODO: Delete reitification 
		END
 
		IF @DeleteType = 1 -- Change security groups
		BEGIN
			UPDATE [RDF.].[Triple] SET ViewSecurityGroup = 0 WHERE TripleID IN (SELECT TripleID FROM #DeleteTriples)
		END
 
	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
 
		-- Raise an error with the details of the exception
		SELECT @ErrMsg =  ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()
 
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
			 
	END CATCH		
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Import].[Beta.SetDisplayPreferences]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	select m.NodeID, p.Property, (case when p.n=3 then -1 else v.NodeID end) ViewSecurityGroup
		into #NodeProperty
		from [User.Account].[User] u, [Profile.Import].[Beta.DisplayPreference] d, 
			[RDF.Stage].InternalNodeMap m, [RDF.Stage].InternalNodeMap v, (
				select 0 n, [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#authorInAuthorship') Property
				union all
				select 1 n, [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#awardOrHonor') Property
				union all
				select 2 n, [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#overview') Property
				union all
				select 3 n, [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#mainImage') Property
			) p
		where u.PersonID = d.PersonID
			and m.Class = 'http://xmlns.com/foaf/0.1/Person'
			and m.InternalType = 'Person'
			and m.InternalID = cast(u.PersonID as nvarchar(50))
			and v.Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#User'
			and v.InternalType = 'User'
			and v.InternalID = cast(u.UserID as nvarchar(50))
			and ( (p.n=0 and d.ShowPublications='N') or (p.n=1 and d.ShowAwards='N') or (p.n=2 and d.ShowNarrative='N') or (p.n=3 and d.ShowPhoto='Y') )
	create unique clustered index idx_np on #NodeProperty (NodeID, Property)

	insert into [RDF.Security].NodeProperty (NodeID, Property, ViewSecurityGroup)
		select NodeID, Property, ViewSecurityGroup
			from #NodeProperty a
			where not exists (
				select *
				from [RDF.Security].NodeProperty s
				where a.NodeID = s.NodeID and a.Property = s.Property
			)

	update t
		set t.ViewSecurityGroup = n.ViewSecurityGroup
		from #NodeProperty n, [RDF.].Triple t
		where n.NodeID = t.Subject and n.Property = t.Predicate
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[Concept.Mesh.UpdatePerson]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER,@rows BIGINT 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
 
	SELECT *, 1 WeightCategory, row_number() over (partition by personid order by weight desc, meshheader) k
		INTO #cache_user_mesh
		FROM (
			SELECT PersonID, MeshHeader, max(NumPubsAll) NumPubsAll, count(*) NumPubsThis, sum(MeshWeight) Weight, 
				min(PubYear) FirstPublicationYear, max(PubYear) LastPublicationYear, max(AuthorWeight) MaxAuthorWeight,
				min(PubDate) FirstPubDate, max(PubDate) LastPubDate
			FROM [Profile.Cache].[Concept.Mesh.PersonPublication]
			GROUP BY PersonID, MeshHeader
		) t
	CREATE UNIQUE CLUSTERED INDEX idx_pm ON #cache_user_mesh(personid, meshheader)
 
	UPDATE c
		SET c.WeightCategory = 
			(case	when k <= (case when n.n >= 50 then floor(n.n*0.1) else 5 end) then 2 
					when k >= (n.n - floor((n.n-5)/2)) then 0 
					else 1 end)
		FROM #cache_user_mesh c, (
			select personid, count(*) n
			from #cache_user_mesh
			group by personid
		) n
		WHERE c.personid = n.personid
 
	BEGIN TRY
		BEGIN TRAN
			TRUNCATE TABLE [Profile.Cache].[Concept.Mesh.Person]
			INSERT INTO [Profile.Cache].[Concept.Mesh.Person] (PersonID, MeshHeader, NumPubsAll, NumPubsThis, Weight, FirstPublicationYear, LastPublicationYear, MaxAuthorWeight, WeightCategory, FirstPubDate, LastPubDate)
				SELECT PersonID, MeshHeader, NumPubsAll, NumPubsThis, Weight, FirstPublicationYear, LastPublicationYear, MaxAuthorWeight, WeightCategory, FirstPubDate, LastPubDate
				FROM #cache_user_mesh
			SELECT @rows = @@ROWCOUNT
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=0
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@ProcessedRows = @rows,@insert_new_record=0
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Cache].[Concept.Mesh.UpdateJournal]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER,@rows BIGINT 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1

 
	;WITH a AS (
		SELECT m.DescriptorName, g.MedlineTA, max(g.JournalTitle) JournalTitle, sum(Weight) Weight
		FROM [Profile.Data].[Publication.PubMed.General] g
			INNER JOIN (
				SELECT m.DescriptorName, m.PMID, max(case when MajorTopicYN = 'Y' then 1 else 0.25 end) Weight
				FROM [Profile.Data].[Publication.PubMed.Mesh] m
					INNER JOIN [Profile.Data].[Publication.Entity.InformationResource] e
						on m.PMID = e.PMID AND e.IsActive = 1
				GROUP BY m.DescriptorName, m.PMID
			) m ON g.PMID = m.PMID
		GROUP BY m.DescriptorName, g.MedlineTA
	), b AS (
		SELECT DescriptorName, COUNT(*) NumJournals
		FROM a
		GROUP BY DescriptorName
	), c AS (
		SELECT a.DescriptorName MeshHeader, 
			ROW_NUMBER() OVER (PARTITION BY a.DescriptorName ORDER BY Weight DESC, a.MedlineTA) SortOrder,
			a.MedlineTA Journal,
			a.JournalTitle,
			a.Weight,
			b.NumJournals
		FROM a INNER JOIN b ON a.DescriptorName = b.DescriptorName
	)
	SELECT *
		INTO #ConceptMeshJournal
		FROM c
		WHERE SortOrder <= 10

	CREATE UNIQUE CLUSTERED INDEX idx_ms ON #ConceptMeshJournal (MeshHeader, SortOrder)

	BEGIN TRY
		BEGIN TRAN
			TRUNCATE TABLE [Profile.Cache].[Concept.Mesh.Journal]
			INSERT INTO [Profile.Cache].[Concept.Mesh.Journal] (MeshHeader, SortOrder, Journal, JournalTitle, Weight, NumJournals)
				SELECT MeshHeader, SortOrder, Journal, JournalTitle, Weight, NumJournals
				FROM #ConceptMeshJournal
			SELECT @rows = @@ROWCOUNT
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=0
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@ProcessedRows = @rows,@insert_new_record=0
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.PubMed.GetPersonInfoForDisambiguation] 
AS
BEGIN
SET nocount  ON;
 
 
DECLARE  @search XML,
            @batchID UNIQUEIDENTIFIER,
            @batchcount INT,
            @threshold FLOAT,
            @baseURI NVARCHAR(max),
			@orcidNodeID NVARCHAR(max)

--SET Custom Threshold based on internal Institutional Logic, default is .98
SELECT @threshold = .98

SELECT @batchID=NEWID()

SELECT @baseURI = [Value] FROM [Framework.].[Parameter] WHERE [ParameterID] = 'baseURI'
SELECT @orcidNodeID = NodeID from [RDF.].Node where Value = 'http://vivoweb.org/ontology/core#orcidId'

SELECT personid, 
                   (SELECT ISNULL(RTRIM(firstname),'')  "Name/First",
                                          ISNULL(RTRIM(middlename),'') "Name/Middle",
                                          ISNULL(RTRIM(p.lastname),'') "Name/Last",
                                          ISNULL(RTRIM(suffix),'')     "Name/Suffix",
                                          CASE 
                                                 WHEN a.n IS NOT NULL OR b.n IS NOT NULL 
                                                          /*  Below is example of a custom piece of logic to alter the disambiguation by telling the disambiguation service
                                                            to Require First Name usage in the algorithm for faculty who are lower in rank */
                                                      OR facultyranksort > 4 
                                                      THEN 'true'
                                                ELSE 'false'
                                          END "RequireFirstName",
                                          d.cnt                                                                              "LocalDuplicateNames",
                                          @threshold                                                                   "MatchThreshold",
                                          (SELECT DISTINCT ISNULL(LTRIM(ISNULL(emailaddress,p.emailaddr)),'') Email
                                                      FROM [Profile.Data].[Person.Affiliation] pa
                                                WHERE pa.personid = p.personid
                                                FOR XML PATH(''),TYPE) AS "EmailList",
                                          (SELECT Affiliation
                                                      FROM [Profile.Data].[Publication.PubMed.DisambiguationAffiliation]
                                                FOR XML PATH(''),TYPE) AS "AffiliationList",
                                          (SELECT PMID
                                             FROM [Profile.Data].[Publication.Person.Add]
                                            WHERE personid =p2.personid
                                        FOR XML PATH(''),ROOT('PMIDAddList'),TYPE),
                                          (SELECT PMID
                                             FROM [Profile.Data].[Publication.Person.Exclude]
                                            WHERE personid =p2.personid
                                        FOR XML PATH(''),ROOT('PMIDExcludeList'),TYPE),
                                          (SELECT @baseURI + CAST(i.NodeID AS VARCHAR) 
                                        FOR XML PATH(''),ROOT('URI'),TYPE),
										  (select n.Value as '*' from [RDF.].Node n join
											[RDF.].Triple t  on n.NodeID = t.Object
											and t.Subject = i.NodeID
											and t.Predicate = @orcidNodeID
										FOR XML PATH(''),ROOT('ORCID'),TYPE)
                              FROM [Profile.Data].Person p
                                       LEFT JOIN ( 
                                                
                                                         --case 1
                                                            SELECT LEFT(firstname,1)  f,
                                                                              LEFT(middlename,1) m,
                                                                              lastname,
                                                                              COUNT(* )          n
                                                              FROM [Profile.Data].Person
                                                            GROUP BY LEFT(firstname,1),
                                                                              LEFT(middlename,1),
                                                                              lastname
                                                            HAVING COUNT(* ) > 1
                                                      )A ON a.lastname = p.lastname
                                                        AND a.f=LEFT(firstname,1)
                                                        AND a.m = LEFT(middlename,1)
                              LEFT JOIN (               
 
                                                      --case 2
                                                      SELECT LEFT(firstname,1) f,
                                                                        lastname,
                                                                        COUNT(* )         n
                                                        FROM [Profile.Data].Person
                                                      GROUP BY LEFT(firstname,1),
                                                                        lastname
                                                      HAVING COUNT(* ) > 1
                                                                        AND SUM(CASE 
                                                                                                       WHEN middlename = '' THEN 1
                                                                                                      ELSE 0
                                                                                                END) > 0
                                                                                                
                                                )B ON b.f = LEFT(firstname,1)
                                                  AND b.lastname = p.lastname
                              LEFT JOIN ( SELECT [Utility.NLP].[fnNamePart1](firstname)F,
                                                                                          lastname,
                                                                                          COUNT(*)cnt
                                                                              FROM [Profile.Data].Person 
                                                                         GROUP BY [Utility.NLP].[fnNamePart1](firstname), 
                                                                                          lastname
                                                                  )d ON d.f = [Utility.NLP].[fnNamePart1](p2.firstname)
                                                                        AND d.lastname = p2.lastname

                              LEFT JOIN [RDF.Stage].[InternalNodeMap] i
								 ON [InternalType] = 'Person' AND [Class] = 'http://xmlns.com/foaf/0.1/Person' AND [InternalID] = CAST(p2.personid AS VARCHAR(50))                             
                         WHERE p.personid = p2.personid
                        
                        FOR XML PATH(''),ROOT('FindPMIDs')) XML--as xml)
  INTO #batch
  FROM [Profile.Data].vwperson  p2 where PersonID not in (select PersonID from [Profile.Data].[Publication.Pubmed.DisambiguationSettings] where Enabled = 0)
  
   
SELECT @batchcount=@@ROWCOUNT

SELECT @BatchID,@batchcount,*
  FROM #batch 
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE	 procedure [Profile.Data].[Publication.Pubmed.AddOneAuthorPosition]
	@PersonID INT,
	@pmid int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	select distinct @pmid pmid, p.personid, p.lastname, p.firstname, '' middlename,
			left(p.lastname,1) ln, left(p.firstname,1) fn, left('',1) mn
		into #pmid_person_name
		from [Profile.Cache].Person p
		where p.personid = @personid
	create unique clustered index idx_pu on #pmid_person_name(pmid,personid)

	select distinct pmid, personid, pmpubsauthorid
		into #authorid_personid
		from (
			select a.pmid, a.PmPubsAuthorID, p.personid, dense_rank() over (partition by a.pmid, p.personid order by 
				(case when a.lastname = p.lastname and (a.forename like p.firstname + left(p.middlename,1) + '%') then 1
					when a.lastname = p.lastname and (a.forename like p.firstname + '%') and len(p.firstname) > 1 then 2
					when a.lastname = p.lastname and a.initials = p.fn+p.mn then 3
					when a.lastname = p.lastname and left(a.initials,1) = p.fn then 4
					when a.lastname = p.lastname then 5
					else 6 end) ) k
			from [Profile.Data].[Publication.PubMed.Author]	 a inner join #pmid_person_name p 
				on a.pmid = p.pmid and a.validyn = 'Y' and left(a.lastname,1) = p.ln
		) t
		where k = 1
	create unique clustered index idx_ap on #authorid_personid(pmid, personid, pmpubsauthorid)

	select pmid, min(pmpubsauthorid) a, max(pmpubsauthorid) b
		into #pmid_authorid_range
		from [Profile.Data].[Publication.PubMed.Author]
		group by pmid
	create unique clustered index idx_p on #pmid_authorid_range(pmid)

	select PersonID, pmid, a AuthorPosition, 
			(case when a in ('F','L','S') then 1.00
				when a in ('M') then 0.25
				else 0.50 end) AuthorWeight
		into #cache_author_position
		from (
			select pmid, personid, a, row_number() over (partition by pmid, personid order by k) k
			from (
				select a.pmid, a.personid,
						(case when a.pmpubsauthorid = r.a then 'F'
							when a.pmpubsauthorid = r.b then 'L'
							else 'M'
							end) a,
						(case when a.pmpubsauthorid = r.a then 1
							when a.pmpubsauthorid = r.b then 2
							else 3
							end) k
					from #authorid_personid a, #pmid_authorid_range r
					where a.pmid = r.pmid and r.b <> r.a
				union all
				select p.pmid, p.personid, 'S' a, 0 k
					from #pmid_person_name p, #pmid_authorid_range r
					where p.pmid = r.pmid and r.a = r.b
				union all
				select pmid, personid, 'U' a, 9 k
					from #pmid_person_name
			) t
		) t
		where k = 1
	create clustered index idx_pmid on #cache_author_position(pmid)

	select PersonID, a.pmid, AuthorPosition, AuthorWeight, g.PubDate, year(g.PubDate) PubYear,
			(case when g.PubDate = '1900-01-01 00:00:00.000' then 0.5
				else power(cast(0.5 as float),cast(datediff(d,g.PubDate,GetDate()) as float)/365.25/10)
				end) YearWeight
		into #cache_pm_author_position
		from #cache_author_position a, [Profile.Data].[Publication.PubMed.General] g
		where a.pmid = g.pmid
	update #cache_pm_author_position
		set PubYear = Year(GetDate()), YearWeight = 1
		where YearWeight > 1

	delete t
		from #cache_pm_author_position t, [Profile.Cache].[Publication.PubMed.AuthorPosition] c
		where t.personid = c.personid and t.pmid = c.pmid

	INSERT INTO [Profile.Cache].[Publication.PubMed.AuthorPosition]
	         (PersonID, pmid, AuthorPosition, AuthorWeight, PubDate, PubYear, YearWeight)
		SELECT PersonID, pmid, AuthorPosition, AuthorWeight, PubDate, PubYear, YearWeight 
		FROM #cache_pm_author_position

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Publication.MyPub.GetPublication](	@mpid NVARCHAR(50))
AS
BEGIN
	SET NOCOUNT ON;

	SELECT	HmsPubCategory, 
					AdditionalInfo, 
					authors, 
					PlaceOfPub, 
					NewspaperCol, 
					ConfDTS, 
					ConfEditors, 
					ConfNM, 
					ContractNum, 
					PublicationDT, 
					edition, 
					IssuePub, 
					ConfLoc, 
					publisher, 
					url, 
					PaginationPub, 
					ReptNumber, 
					NewspaperSect, 
					PubTitle, 
					ArticleTitle, 
					DissUnivNM, 
					VolNum, 
					abstract 
    FROM	[Profile.Data].[Publication.MyPub.General] 
   WHERE	mpid =@mpid

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[Person.UpdateAffiliation]
as
begin
 
DECLARE @date DATETIME,@auditid UNIQUEIDENTIFIER, @rows int
SELECT @date=GETDATE() 
EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName ='Person.UpdateAffiliation',@ProcessStartDate =@date,@insert_new_record=1
 
 
truncate table [Profile.Cache].[Person.Affiliation]
insert into [Profile.Cache].[Person.Affiliation]
SELECT personid, sortorder,isprimary,title,institutionname,institutionabbreviation,departmentname,divisionname,facultyrank
												FROM [Profile.Data].[Person.Affiliation] pa  
												JOIN [Profile.Data].[Organization.Department] d on  d.departmentid=pa.departmentid 
			    						  JOIN [Profile.Data].[Organization.Institution] ins ON ins.institutionid=pa.institutionid 
									 LEFT JOIN [Profile.Data].[Organization.Division] di on di.divisionid=pa.divisionid
									 LEFT JOIN [Profile.Data].[Person.FacultyRank] fr on fr.facultyrankid = pa.facultyrankid
 
 
SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName ='Person.UpdateAffiliation',@ProcessEndDate =@date,@ProcessedRows = @rows,@insert_new_record=0
 
 
end
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Search.Cache].[Public.UpdateCache]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	--------------------------------------------------
	-- Prepare lookup tables
	--------------------------------------------------

	-- Get a list of valid nodes
	create table #Node (
		NodeID bigint primary key
	)
	insert into #Node 
		select NodeID 
		from [RDF.].[Node] with (nolock)
		where ViewSecurityGroup = -1
	--[6776391 in 00:00:05]
	delete n
		from #Node n 
			inner join [RDF.].[Triple] t with (nolock)
				on n.NodeID = t.Reitification
	--[3186019 in 00:00:14]

	-- Get a list of valid classes
	create table #Class (
		ClassNode bigint primary key,
		TreeDepth int,
		ClassSort int,
		Searchable bit,
		ClassName varchar(400)
	)
	insert into #Class
		select c._ClassNode, c._TreeDepth,
				row_number() over (order by IsNull(c._TreeDepth,0) desc, c._ClassName),
				(case when c._ClassNode in (select _ClassNode from [Ontology.].ClassGroupClass) then 1 else 0 end),
				c._ClassName
			from [Ontology.].ClassTreeDepth c with (nolock)
				inner join #Node n
					on c._ClassNode = n.NodeID
			where c._ClassNode <> [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#Connection')
				and c._ClassNode <> [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#ConnectionDetails')
				and c._ClassNode <> [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#Network')

	-- Get a list of searchable properties
	create table #ClassPropertySearch (
		ClassNode bigint not null,
		PropertyNode bigint not null,
		SearchWeight float
	)
	alter table #ClassPropertySearch add primary key (ClassNode, PropertyNode)
	insert into #ClassPropertySearch
		select p._ClassNode ClassNode, p._PropertyNode PropertyNode, p.SearchWeight
			from [Ontology.].[ClassProperty] p with (nolock)
				inner join #Class c
					on p._ClassNode = c.ClassNode
				inner join #Node n
					on p._PropertyNode = n.NodeID
			where p._NetworkPropertyNode IS NULL
				and p.SearchWeight > 0

	-- Get a list of view properties
	create table #ClassPropertyView (
		ClassNode bigint not null,
		PropertyNode bigint not null,
		Limit int,
		IncludeDescription tinyint,
		TagName nvarchar(1000)
	)
	alter table #ClassPropertyView add primary key (ClassNode, PropertyNode)
	insert into #ClassPropertyView
		select p._ClassNode ClassNode, p._PropertyNode PropertyNode, p.Limit, p.IncludeDescription, p._TagName
			from [Ontology.].[ClassProperty] p with (nolock)
				inner join #Class c
					on p._ClassNode = c.ClassNode
				inner join #Node n
					on p._PropertyNode = n.NodeID
			where p._NetworkPropertyNode IS NULL
				and p.IsDetail = 0


	--------------------------------------------------
	-- NodeClass
	--------------------------------------------------

	create table #NodeClass (
		NodeID bigint not null,
		ClassNode bigint not null,
		ClassSort int,
		Searchable bit
	)
	alter table #NodeClass add primary key (NodeID, ClassNode)
	declare @typeID bigint
	select @typeID = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
	insert into #NodeClass
		select distinct n.NodeID, c.ClassNode, c.ClassSort, c.Searchable
			from [RDF.].[Triple] t with (nolock)
				inner join #Node n
					on t.Subject = n.NodeID
				inner join #Class c
					on t.Object = c.ClassNode
			where t.Predicate = @typeID
	--[2388097 in 00:00:06]
	create nonclustered index #c on #NodeClass (ClassNode) include (NodeID)
	--[00:00:02]
	create nonclustered index #s on #NodeClass (Searchable, ClassSort)
	--[00:00:05]


	--------------------------------------------------
	-- NodeMap
	--------------------------------------------------

	create table #NodeSearchProperty (
		NodeID bigint not null,
		PropertyNode bigint not null,
		SearchWeight float
	)
	alter table #NodeSearchProperty add primary key (NodeID, PropertyNode)
	insert into #NodeSearchProperty
		select n.NodeID, p.PropertyNode, max(p.SearchWeight) SearchWeight
			from #NodeClass n
				inner join #ClassPropertySearch p
					on n.ClassNode = p.ClassNode
			group by n.NodeID, p.PropertyNode
	--[7281981 in 00:00:17]

	create table #NodeMap (
		NodeID bigint not null,
		MatchedByNodeID bigint not null,
		Distance int,
		Paths int,
		Weight float
	)
	alter table #NodeMap add primary key (NodeID, MatchedByNodeID)

	insert into #NodeMap (NodeID, MatchedByNodeID, Distance, Paths, Weight)
		select x.NodeID, t.Object, 1, count(*), 1-exp(sum(log(case when x.SearchWeight*t.Weight > 0.999999 then 0.000001 else 1-x.SearchWeight*t.Weight end)))
			from [RDF.].[Triple] t with (nolock)
				inner join #NodeSearchProperty x
					on t.subject = x.NodeID
						and t.predicate = x.PropertyNode
				inner join #Node n
					on t.object = n.NodeID
			where x.SearchWeight*t.Weight > 0
				and t.ViewSecurityGroup = -1
			group by x.NodeID, t.object
	--[5540963 in 00:00:43]

	declare @i int
	select @i = 1
	while @i < 10
	begin
		insert into #NodeMap (NodeID, MatchedByNodeID, Distance, Paths, Weight)
			select s.NodeID, t.MatchedByNodeID, @i+1, count(*), 1-exp(sum(log(case when s.Weight*t.Weight > 0.999999 then 0.000001 else 1-s.Weight*t.Weight end)))
				from #NodeMap s, #NodeMap t
				where s.MatchedByNodeID = t.NodeID
					and s.Distance = @i
					and t.Distance = 1
					and t.NodeID <> s.NodeID
					and not exists (
						select *
						from #NodeMap u
						where u.NodeID = s.NodeID and u.MatchedByNodeID = t.MatchedByNodeID
					)
				group by s.NodeID, t.MatchedByNodeID
		if @@ROWCOUNT = 0
			select @i = 10
		select @i = @i + 1
	end
	--[11421133, 1542809, 0 in 00:02:28]


	--------------------------------------------------
	-- NodeSummary
	--------------------------------------------------

	create table #NodeSummaryTemp (
		NodeID bigint primary key,
		ShortLabel varchar(500)
	)
	declare @labelID bigint
	select @labelID = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')
	insert into #NodeSummaryTemp
		select t.subject NodeID, min(case when len(n.Value)>500 then left(n.Value,497)+'...' else n.Value end) Label
			from [RDF.].Triple t with (nolock)
				inner join [RDF.].Node n with (nolock)
					on t.object = n.NodeID
						and t.predicate = @labelID
						and t.subject in (select NodeID from #NodeMap)
						and t.ViewSecurityGroup = -1
						and n.ViewSecurityGroup = -1
			group by t.subject
	--[1155480 in 00:00:19]

	create table #NodeSummary (
		NodeID bigint primary key,
		ShortLabel varchar(500),
		ClassName varchar(255),
		SortOrder bigint
	)
	insert into #NodeSummary
		select s.NodeID, s.ShortLabel, c.ClassName, row_number() over (order by s.ShortLabel, s.NodeID) SortOrder
		from (
				select NodeID, ClassNode, ShortLabel
				from (
					select c.NodeID, c.ClassNode, s.ShortLabel, row_number() over (partition by c.NodeID order by c.ClassSort) k
					from #NodeClass c
						inner join #NodeSummaryTemp s
							on c.NodeID = s.NodeID
					where c.Searchable = 1
				) s
				where k = 1
			) s
			inner join #Class c
				on s.ClassNode = c.ClassNode
	--[468900 in 00:00:04]


	--------------------------------------------------
	-- NodeRDF
	--------------------------------------------------

	create table #NodePropertyExpand (
		NodeID bigint not null,
		PropertyNode bigint not null,
		Limit int,
		IncludeDescription tinyint,
		TagName nvarchar(1000)
	)
	alter table #NodePropertyExpand add primary key (NodeID, PropertyNode)
	insert into #NodePropertyExpand
		select n.NodeID, p.PropertyNode, max(p.Limit) Limit, max(p.IncludeDescription) IncludeDescription, max(p.TagName) TagName
			from #NodeClass n
				inner join #ClassPropertyView p
					on n.ClassNode = p.ClassNode
			group by n.NodeID, p.PropertyNode
	--[7698214 in 00:00:21]

	create table #NodeTag (
		NodeID bigint not null,
		TagSort int not null,
		ExpandNodeID bigint not null,
		IncludeDescription tinyint,
		TagStart nvarchar(max),
		TagValue nvarchar(max),
		TagEnd nvarchar(max)
	)
	alter table #NodeTag add primary key (NodeID, TagSort)
	insert into #NodeTag
		select e.NodeID,
				row_number() over (partition by e.NodeID order by e.TagName, o.Value, o.NodeID),
				o.NodeID, e.IncludeDescription,
 				'_TAGLT_'+e.TagName
					+(case when o.ObjectType = 0 
							then ' rdf:resource="' 
							else IsNull(' xml:lang="'+o.Language+'"','')
								+IsNull(' rdf:datatype="'+o.DataType+'"','')
								+'_TAGGT_'
							end),
				o.Value,
				(case when o.ObjectType = 0 then '"/_TAGGT_' else '_TAGLT_/'+e.TagName+'_TAGGT_' end)
			from #NodePropertyExpand e
				inner join [RDF.].[Triple] t with (nolock)
					on e.NodeID = t.subject
						and e.PropertyNode = t.predicate
						and t.ViewSecurityGroup = -1
						and ((e.Limit is null) or (t.SortOrder <= e.Limit))
				inner join [RDF.].[Node] o with (nolock)
					on t.object = o.NodeID
						and o.ViewSecurityGroup = -1
	--[7991231 in 00:04:35]

	update #NodeTag
		set TagValue = (case when charindex(char(0),cast(TagValue as varchar(max))) > 0
						then replace(replace(replace(replace(cast(TagValue as varchar(max)),char(0),''),'&','&amp;'),'<','&lt;'),'>','&gt;')
						else replace(replace(replace(TagValue,'&','&amp;'),'<','&lt;'),'>','&gt;')
						end)
		where cast(TagValue as varchar(max)) like '%[&<>'+char(0)+']%'
	--[32573 in 00:00:31]

	create unique nonclustered index idx_sn on #NodeTag (TagSort, NodeID)
	--[00:00:07]

	create table #NodeRDF (
		NodeID bigint primary key,
		RDF nvarchar(max)
	)
	insert into #NodeRDF
		select t.NodeID, 
				'_TAGLT_rdf:Description rdf:about="' + replace(replace(replace(n.Value,'&','&amp;'),'<','&lt;'),'>','&gt;') + '"_TAGGT_'
				+ t.TagStart+t.TagValue+t.TagEnd
			from #NodeTag t
				inner join [RDF.].Node n with (nolock)
					on t.NodeID = n.NodeID
			where t.TagSort = 1
	--[1157272 in 00:00:24]

	declare @k int
	select @k = 2
	while (@k > 0) and (@k < 25)
	begin
		update r
			set r.RDF = r.RDF + t.TagStart+t.TagValue+t.TagEnd
			from #NodeRDF r
				inner join #NodeTag t
					on r.NodeID = t.NodeID and t.TagSort = @k
		if @@ROWCOUNT = 0
			select @k = -1
		else
			select @k = @k + 1			
	end
	--[1157247, 1102278, 1056348, 503981, 499321, 497457, 457981, 425030, 416171, 367566, 350579, 0]
	--[00:01:35]

	update #NodeRDF
		set RDF = RDF + '_TAGLT_/rdf:Description_TAGGT_'
	--[1157272 in 00:00:08]


	--------------------------------------------------
	-- NodeExpand
	--------------------------------------------------

	create table #NodeExpand (
		NodeID bigint not null,
		ExpandNodeID bigint not null
	)
	alter table #NodeExpand add primary key (NodeID, ExpandNodeID)
	insert into #NodeExpand
		select distinct NodeID, ExpandNodeID
		from #NodeTag
		where IncludeDescription = 1
	--[3601932 in 00:00:05]


	--------------------------------------------------
	-- NodePrefix
	--------------------------------------------------

	create table #NodePrefix (
		Prefix varchar(800) not null,
		NodeID bigint not null
	)
	alter table #NodePrefix add primary key (Prefix, NodeID)
	insert into #NodePrefix (Prefix,NodeID)
		select left(n.Value,800), n.NodeID
			from [RDF.].Node n with (nolock)
				inner join #Node m
					on n.NodeID = m.NodeID
	--[3590372 in 00:00:16]


	--------------------------------------------------
	-- Update actual tables
	--------------------------------------------------

	BEGIN TRY
		BEGIN TRAN
		
			truncate table [Search.Cache].[Public.NodeMap]
			insert into [Search.Cache].[Public.NodeMap] (NodeID, MatchedByNodeID, Distance, Paths, Weight)
				select NodeID, MatchedByNodeID, Distance, Paths, Weight
					from #NodeMap
			--[18504905 in 00:02:02]

			truncate table [Search.Cache].[Public.NodeSummary]
			insert into [Search.Cache].[Public.NodeSummary] (NodeID, ShortLabel, ClassName, SortOrder)
				select NodeID, ShortLabel, ClassName, SortOrder
					from #NodeSummary
			--[468900 in 00:00:03]

			truncate table [Search.Cache].[Public.NodeClass]
			insert into [Search.Cache].[Public.NodeClass] (NodeID, Class)
				select NodeID, ClassNode
					from #NodeClass
			--[2388097 in 00:00:05]

			truncate table [Search.Cache].[Public.NodeExpand]
			insert into [Search.Cache].[Public.NodeExpand] (NodeID, ExpandNodeID)
				select NodeID, ExpandNodeID
					from #NodeExpand
			--[3601932 in 00:00:08]

			truncate table [Search.Cache].[Public.NodeRDF]
			insert into [Search.Cache].[Public.NodeRDF] (NodeID, RDF)
				select NodeID, RDF
					from #NodeRDF
			--[1157272 in 00:00:36]

			truncate table [Search.Cache].[Public.NodePrefix]
			insert into [Search.Cache].[Public.NodePrefix] (Prefix, NodeID)
				select Prefix, NodeID
					from #NodePrefix
			--[3590372 in 00:00:34]

		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		--Raise an error with the details of the exception
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[Person.UpdatePhysicalNeighbor]
AS
BEGIN
 
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER,@rows BIGINT 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
 
	SELECT personid, neighborid, distance, displayname, myneighbors
		INTO #neighbors
		FROM (
			SELECT personid, neighborid, d distance, displayname, lf myneighbors, row_number() over (partition by personid order by d, newid()) k
			FROM (
				select p.personid, q.personid neighborid, q.displayname, q.lastname + ', ' + q.firstname lf,
					(CASE
						WHEN p.room <> '' and p.room = q.room THEN 1
						WHEN p.floor <> '' and p.floor = q.floor THEN 2
						WHEN p.building <> '' and p.building = q.building THEN 3
						WHEN p.institutionname <> '' and p.departmentname <> '' and p.divisionfullname <> '' and p.institutionname = q.institutionname and p.departmentname = q.departmentname and p.divisionfullname = q.divisionfullname THEN 4
						WHEN p.institutionname <> '' and p.departmentname <> '' and p.institutionname = q.institutionname and p.departmentname = q.departmentname THEN 5
						WHEN p.institutionname <> '' and p.institutionname = q.institutionname THEN 6
						ELSE 7
					END) d
				from [Profile.Cache].Person p, [Profile.Cache].Person q
				where p.personid <> q.personid and p.latitude = q.latitude and p.longitude = q.longitude 
					and p.latitude is not null and p.longitude is not null
					and q.latitude is not null and q.longitude is not null
				--where p.personid <> q.personid and p.addressline3 <> '' and p.addressline4 <> '' and p.addressline3 = q.addressline3 and p.addressline4 = q.addressline4
			) t
		) t
		WHERE k <= 5
 
 
	BEGIN TRY
		BEGIN TRAN
			TRUNCATE TABLE [Profile.Cache].[Person.PhysicalNeighbor]
			INSERT INTO [Profile.Cache].[Person.PhysicalNeighbor]
				SELECT * FROM #neighbors
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
 
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate =@date,@error = 1,@insert_new_record=0
 
		-- Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
 
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate =@date,@ProcessedRows = @rows,@insert_new_record=0
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [User.Account].[Proxy.GetProxies] 
	@SessionID UNIQUEIDENTIFIER,
	@Operation VARCHAR(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET nocount  ON;


	/**************************************************************
	This stored procedure supports three operations:
	
	1) GetDefaultUsersWhoseNodesICanEdit
	2) GetDesignatedUsersWhoseNodesICanEdit
	3) GetAllUsersWhoCanEditMyNodes
	
	Operation #1 returns a list of organizations.
	Operations #2 and #3 return a list of user accounts, some of
	  which also have person profiles (PersonURI).
	Operation #3 also indicates which proxies can be deleted.
	**************************************************************/
	
	
	-- Get the UserID of the SessionID. Exit if not found.
	DECLARE @SessionUserID INT
	SELECT @SessionUserID = UserID
		FROM [User.Session].[Session]
		WHERE SessionID = @SessionID
	IF @SessionUserID IS NULL
		RETURN


	IF @Operation = 'GetDefaultUsersWhoseNodesICanEdit'
		SELECT Institution, Department, Division, MAX(IsVisible*1) IsVisible
			FROM (
				-- Default Proxies
				SELECT	(case when IsNull(ProxyForInstitution,'')='' then 'All' else ProxyForInstitution end) Institution,
						(case when IsNull(ProxyForDepartment,'')='' then 'All' else ProxyForDepartment end) Department,
						(case when IsNull(ProxyForDivision,'')='' then 'All' else ProxyForDivision end) Division,
						IsVisible
					FROM [User.Account].[DefaultProxy]
					WHERE UserID = @SessionUserID
				-- Security Groups with Special Edit Access
				UNION ALL
				SELECT 'All' Institution, 'All' Department, 'All' Division, m.IsVisible
					FROM [RDF.Security].[Member] m
						INNER JOIN [RDF.Security].[Group] g
							ON m.SecurityGroupID = g.SecurityGroupID
							AND g.HasSpecialEditAccess = 1
			) t
			GROUP BY Institution, Department, Division
			ORDER BY	(case when Institution = 'All' then 0 else 1 end), Institution,
						(case when Department = 'All' then 0 else 1 end), Department,
						(case when Division = 'All' then 0 else 1 end), Division


	IF @Operation = 'GetDesignatedUsersWhoseNodesICanEdit'
		SELECT u.UserID, u.DisplayName, u.Institution, u.Department, u.EmailAddr,
				o.Value+cast(p.NodeID as varchar(50)) PersonURI
			FROM [User.Account].[User] u
				INNER JOIN (
					-- Designated Proxies
					SELECT ProxyForUserID
						FROM [User.Account].[DesignatedProxy]
						WHERE UserID = @SessionUserID
				) x ON u.UserID = x.ProxyForUserID
				INNER JOIN [Framework.].Parameter o
					ON o.ParameterID = 'baseURI'
				LEFT OUTER JOIN [RDF.Stage].[InternalNodeMap] p
					ON u.PersonID IS NOT NULL
						AND cast(u.PersonID as varchar(50)) = p.InternalID
						AND p.Class = 'http://xmlns.com/foaf/0.1/Person'
						AND p.InternalType = 'Person'
						AND p.NodeID IS NOT NULL
			ORDER BY u.LastName, u.FirstName


	IF @Operation = 'GetAllUsersWhoCanEditMyNodes'
		SELECT u.UserID, u.DisplayName, u.Institution, u.Department, u.EmailAddr, 
				o.Value+cast(p.NodeID as varchar(50)) PersonURI, x.CanDelete
			FROM [User.Account].[User] u
				INNER JOIN (
					SELECT UserID, MIN(CanDelete) CanDelete
						FROM (
							-- Designated Proxies
							SELECT UserID, 1 CanDelete
								FROM [User.Account].[DesignatedProxy]
								WHERE ProxyForUserID = @SessionUserID
							-- Default Proxies
							UNION ALL
							SELECT x.UserID, 0 CanDelete
								FROM [User.Account].[DefaultProxy] x
									INNER JOIN [User.Account].[User] u
										ON ((IsNull(x.ProxyForInstitution,'') = '') 
												OR (IsNull(x.ProxyForInstitution,'') = IsNull(u.Institution,'')))
										AND ((IsNull(x.ProxyForDepartment,'') = '') 
												OR (IsNull(x.ProxyForDepartment,'') = IsNull(u.Department,'')))
										AND ((IsNull(x.ProxyForDivision,'') = '') 
												OR (IsNull(x.ProxyForDivision,'') = IsNull(u.Division,'')))
										AND u.UserID = @SessionUserID
										AND x.IsVisible = 1
							-- Security Groups with Special Edit Access
							UNION ALL
							SELECT m.UserID, 0 CanDelete
								FROM [RDF.Security].[Member] m
									INNER JOIN [RDF.Security].[Group] g
										ON m.SecurityGroupID = g.SecurityGroupID
										AND m.IsVisible = 1
										AND g.HasSpecialEditAccess = 1
						) t
						GROUP BY UserID
				) x ON u.UserID = x.UserID
				INNER JOIN [Framework.].Parameter o
					ON o.ParameterID = 'baseURI'
				LEFT OUTER JOIN [RDF.Stage].[InternalNodeMap] p
					ON u.PersonID IS NOT NULL
						AND cast(u.PersonID as varchar(50)) = p.InternalID
						AND p.Class = 'http://xmlns.com/foaf/0.1/Person'
						AND p.InternalType = 'Person'
						AND p.NodeID IS NOT NULL
			ORDER BY u.LastName, u.FirstName

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [User.Account].[Proxy.DeleteDesignatedProxy]
	@SessionID UNIQUEIDENTIFIER,
	@UserID VARCHAR(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET nocount  ON;


	-- Get the UserID of the SessionID. Exit if not found.
	DECLARE @SessionUserID INT
	SELECT @SessionUserID = UserID
		FROM [User.Session].[Session]
		WHERE SessionID = @SessionID
	IF @SessionUserID IS NULL
		RETURN
	
	-- Add the designated proxy
	DELETE
		FROM [User.Account].[DesignatedProxy]
		WHERE UserID = @UserID AND ProxyForUserID = @SessionUserID

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [User.Account].[Proxy.AddDesignatedProxy]
	@SessionID UNIQUEIDENTIFIER,
	@UserID VARCHAR(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET nocount  ON;


	-- Get the UserID of the SessionID. Exit if not found.
	DECLARE @SessionUserID INT
	SELECT @SessionUserID = UserID
		FROM [User.Session].[Session]
		WHERE SessionID = @SessionID
	IF @SessionUserID IS NULL
		RETURN
	
	-- Add the designated proxy
	INSERT INTO [User.Account].[DesignatedProxy] (UserID, ProxyForUserID)
		SELECT @UserID, @SessionUserID
			WHERE NOT EXISTS (
				SELECT *
					FROM [User.Account].[DesignatedProxy]
					WHERE UserID = @UserID AND ProxyForUserID = @SessionUserID
			)

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Search.Cache].[Private.UpdateCache]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	--------------------------------------------------
	-- Prepare lookup tables
	--------------------------------------------------

	-- Get a list of valid nodes
	create table #Node (
		NodeID bigint primary key
	)
	insert into #Node 
		select NodeID 
		from [RDF.].[Node] with (nolock)
		where ViewSecurityGroup between -30 and -1
	--[6776391 in 00:00:05]
	delete n
		from #Node n 
			inner join [RDF.].[Triple] t with (nolock)
				on n.NodeID = t.Reitification
	--[3186019 in 00:00:14]

	-- Get a list of valid classes
	create table #Class (
		ClassNode bigint primary key,
		TreeDepth int,
		ClassSort int,
		Searchable bit,
		ClassName varchar(400)
	)
	insert into #Class
		select c._ClassNode, c._TreeDepth,
				row_number() over (order by IsNull(c._TreeDepth,0) desc, c._ClassName),
				(case when c._ClassNode in (select _ClassNode from [Ontology.].ClassGroupClass) then 1 else 0 end),
				c._ClassName
			from [Ontology.].ClassTreeDepth c with (nolock)
				inner join #Node n
					on c._ClassNode = n.NodeID
			where c._ClassNode <> [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#Connection')
				and c._ClassNode <> [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#ConnectionDetails')
				and c._ClassNode <> [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#Network')

	-- Get a list of searchable properties
	create table #ClassPropertySearch (
		ClassNode bigint not null,
		PropertyNode bigint not null,
		SearchWeight float
	)
	alter table #ClassPropertySearch add primary key (ClassNode, PropertyNode)
	insert into #ClassPropertySearch
		select p._ClassNode ClassNode, p._PropertyNode PropertyNode, p.SearchWeight
			from [Ontology.].[ClassProperty] p with (nolock)
				inner join #Class c
					on p._ClassNode = c.ClassNode
				inner join #Node n
					on p._PropertyNode = n.NodeID
			where p._NetworkPropertyNode IS NULL
				and p.SearchWeight > 0

	-- Get a list of view properties
	create table #ClassPropertyView (
		ClassNode bigint not null,
		PropertyNode bigint not null,
		Limit int,
		IncludeDescription tinyint,
		TagName nvarchar(1000)
	)
	alter table #ClassPropertyView add primary key (ClassNode, PropertyNode)
	insert into #ClassPropertyView
		select p._ClassNode ClassNode, p._PropertyNode PropertyNode, p.Limit, p.IncludeDescription, p._TagName
			from [Ontology.].[ClassProperty] p with (nolock)
				inner join #Class c
					on p._ClassNode = c.ClassNode
				inner join #Node n
					on p._PropertyNode = n.NodeID
			where p._NetworkPropertyNode IS NULL
				and p.IsDetail = 0


	--------------------------------------------------
	-- NodeClass
	--------------------------------------------------

	create table #NodeClass (
		NodeID bigint not null,
		ClassNode bigint not null,
		ClassSort int,
		Searchable bit
	)
	alter table #NodeClass add primary key (NodeID, ClassNode)
	declare @typeID bigint
	select @typeID = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
	insert into #NodeClass
		select distinct n.NodeID, c.ClassNode, c.ClassSort, c.Searchable
			from [RDF.].[Triple] t with (nolock)
				inner join #Node n
					on t.Subject = n.NodeID
				inner join #Class c
					on t.Object = c.ClassNode
			where t.Predicate = @typeID
	--[2388097 in 00:00:06]
	create nonclustered index #c on #NodeClass (ClassNode) include (NodeID)
	--[00:00:02]
	create nonclustered index #s on #NodeClass (Searchable, ClassSort)
	--[00:00:05]


	--------------------------------------------------
	-- NodeMap
	--------------------------------------------------

	create table #NodeSearchProperty (
		NodeID bigint not null,
		PropertyNode bigint not null,
		SearchWeight float
	)
	alter table #NodeSearchProperty add primary key (NodeID, PropertyNode)
	insert into #NodeSearchProperty
		select n.NodeID, p.PropertyNode, max(p.SearchWeight) SearchWeight
			from #NodeClass n
				inner join #ClassPropertySearch p
					on n.ClassNode = p.ClassNode
			group by n.NodeID, p.PropertyNode
	--[7281981 in 00:00:17]

	create table #NodeMap (
		NodeID bigint not null,
		MatchedByNodeID bigint not null,
		Distance int,
		Paths int,
		Weight float
	)
	alter table #NodeMap add primary key (NodeID, MatchedByNodeID)

	insert into #NodeMap (NodeID, MatchedByNodeID, Distance, Paths, Weight)
		select x.NodeID, t.Object, 1, count(*), 1-exp(sum(log(case when x.SearchWeight*t.Weight > 0.999999 then 0.000001 else 1-x.SearchWeight*t.Weight end)))
			from [RDF.].[Triple] t with (nolock)
				inner join #NodeSearchProperty x
					on t.subject = x.NodeID
						and t.predicate = x.PropertyNode
				inner join #Node n
					on t.object = n.NodeID
			where x.SearchWeight*t.Weight > 0
				and t.ViewSecurityGroup between -30 and -1
			group by x.NodeID, t.object
	--[5540963 in 00:00:43]

	declare @i int
	select @i = 1
	while @i < 10
	begin
		insert into #NodeMap (NodeID, MatchedByNodeID, Distance, Paths, Weight)
			select s.NodeID, t.MatchedByNodeID, @i+1, count(*), 1-exp(sum(log(case when s.Weight*t.Weight > 0.999999 then 0.000001 else 1-s.Weight*t.Weight end)))
				from #NodeMap s, #NodeMap t
				where s.MatchedByNodeID = t.NodeID
					and s.Distance = @i
					and t.Distance = 1
					and t.NodeID <> s.NodeID
					and not exists (
						select *
						from #NodeMap u
						where u.NodeID = s.NodeID and u.MatchedByNodeID = t.MatchedByNodeID
					)
				group by s.NodeID, t.MatchedByNodeID
		if @@ROWCOUNT = 0
			select @i = 10
		select @i = @i + 1
	end
	--[11421133, 1542809, 0 in 00:02:28]


	--------------------------------------------------
	-- NodeSummary
	--------------------------------------------------

	create table #NodeSummaryTemp (
		NodeID bigint primary key,
		ShortLabel varchar(500)
	)
	declare @labelID bigint
	select @labelID = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')
	insert into #NodeSummaryTemp
		select t.subject NodeID, min(case when len(n.Value)>500 then left(n.Value,497)+'...' else n.Value end) Label
			from [RDF.].Triple t with (nolock)
				inner join [RDF.].Node n with (nolock)
					on t.object = n.NodeID
						and t.predicate = @labelID
						and t.subject in (select NodeID from #NodeMap)
						and t.ViewSecurityGroup between -30 and -1
						and n.ViewSecurityGroup between -30 and -1
			group by t.subject
	--[1155480 in 00:00:19]

	create table #NodeSummary (
		NodeID bigint primary key,
		ShortLabel varchar(500),
		ClassName varchar(255),
		SortOrder bigint
	)
	insert into #NodeSummary
		select s.NodeID, s.ShortLabel, c.ClassName, row_number() over (order by s.ShortLabel, s.NodeID) SortOrder
		from (
				select NodeID, ClassNode, ShortLabel
				from (
					select c.NodeID, c.ClassNode, s.ShortLabel, row_number() over (partition by c.NodeID order by c.ClassSort) k
					from #NodeClass c
						inner join #NodeSummaryTemp s
							on c.NodeID = s.NodeID
					where c.Searchable = 1
				) s
				where k = 1
			) s
			inner join #Class c
				on s.ClassNode = c.ClassNode
	--[468900 in 00:00:04]


	--------------------------------------------------
	-- NodeRDF
	--------------------------------------------------

	create table #NodePropertyExpand (
		NodeID bigint not null,
		PropertyNode bigint not null,
		Limit int,
		IncludeDescription tinyint,
		TagName nvarchar(1000)
	)
	alter table #NodePropertyExpand add primary key (NodeID, PropertyNode)
	insert into #NodePropertyExpand
		select n.NodeID, p.PropertyNode, max(p.Limit) Limit, max(p.IncludeDescription) IncludeDescription, max(p.TagName) TagName
			from #NodeClass n
				inner join #ClassPropertyView p
					on n.ClassNode = p.ClassNode
			group by n.NodeID, p.PropertyNode
	--[7698214 in 00:00:21]

	create table #NodeTag (
		NodeID bigint not null,
		TagSort int not null,
		ExpandNodeID bigint not null,
		IncludeDescription tinyint,
		TagStart nvarchar(max),
		TagValue nvarchar(max),
		TagEnd nvarchar(max)
	)
	alter table #NodeTag add primary key (NodeID, TagSort)
	insert into #NodeTag
		select e.NodeID,
				row_number() over (partition by e.NodeID order by e.TagName, o.Value, o.NodeID),
				o.NodeID, e.IncludeDescription,
 				'_TAGLT_'+e.TagName
					+(case when o.ObjectType = 0 
							then ' rdf:resource="' 
							else IsNull(' xml:lang="'+o.Language+'"','')
								+IsNull(' rdf:datatype="'+o.DataType+'"','')
								+'_TAGGT_'
							end),
				o.Value,
				(case when o.ObjectType = 0 then '"/_TAGGT_' else '_TAGLT_/'+e.TagName+'_TAGGT_' end)
			from #NodePropertyExpand e
				inner join [RDF.].[Triple] t with (nolock)
					on e.NodeID = t.subject
						and e.PropertyNode = t.predicate
						and t.ViewSecurityGroup between -30 and -1
						and ((e.Limit is null) or (t.SortOrder <= e.Limit))
				inner join [RDF.].[Node] o with (nolock)
					on t.object = o.NodeID
						and o.ViewSecurityGroup between -30 and -1
	--[7991231 in 00:04:35]

	update #NodeTag
		set TagValue = (case when charindex(char(0),cast(TagValue as varchar(max))) > 0
						then replace(replace(replace(replace(cast(TagValue as varchar(max)),char(0),''),'&','&amp;'),'<','&lt;'),'>','&gt;')
						else replace(replace(replace(TagValue,'&','&amp;'),'<','&lt;'),'>','&gt;')
						end)
		where cast(TagValue as varchar(max)) like '%[&<>'+char(0)+']%'
	--[32573 in 00:00:31]

	create unique nonclustered index idx_sn on #NodeTag (TagSort, NodeID)
	--[00:00:07]

	create table #NodeRDF (
		NodeID bigint primary key,
		RDF nvarchar(max)
	)
	insert into #NodeRDF
		select t.NodeID, 
				'_TAGLT_rdf:Description rdf:about="' + replace(replace(replace(n.Value,'&','&amp;'),'<','&lt;'),'>','&gt;') + '"_TAGGT_'
				+ t.TagStart+t.TagValue+t.TagEnd
			from #NodeTag t
				inner join [RDF.].Node n with (nolock)
					on t.NodeID = n.NodeID
			where t.TagSort = 1
	--[1157272 in 00:00:24]

	declare @k int
	select @k = 2
	while (@k > 0) and (@k < 25)
	begin
		update r
			set r.RDF = r.RDF + t.TagStart+t.TagValue+t.TagEnd
			from #NodeRDF r
				inner join #NodeTag t
					on r.NodeID = t.NodeID and t.TagSort = @k
		if @@ROWCOUNT = 0
			select @k = -1
		else
			select @k = @k + 1			
	end
	--[1157247, 1102278, 1056348, 503981, 499321, 497457, 457981, 425030, 416171, 367566, 350579, 0]
	--[00:01:35]

	update #NodeRDF
		set RDF = RDF + '_TAGLT_/rdf:Description_TAGGT_'
	--[1157272 in 00:00:08]


	--------------------------------------------------
	-- NodeExpand
	--------------------------------------------------

	create table #NodeExpand (
		NodeID bigint not null,
		ExpandNodeID bigint not null
	)
	alter table #NodeExpand add primary key (NodeID, ExpandNodeID)
	insert into #NodeExpand
		select distinct NodeID, ExpandNodeID
		from #NodeTag
		where IncludeDescription = 1
	--[3601932 in 00:00:05]


	--------------------------------------------------
	-- NodePrefix
	--------------------------------------------------

	create table #NodePrefix (
		Prefix varchar(800) not null,
		NodeID bigint not null
	)
	alter table #NodePrefix add primary key (Prefix, NodeID)
	insert into #NodePrefix (Prefix,NodeID)
		select left(n.Value,800), n.NodeID
			from [RDF.].Node n with (nolock)
				inner join #Node m
					on n.NodeID = m.NodeID
	--[3590372 in 00:00:16]


	--------------------------------------------------
	-- Update actual tables
	--------------------------------------------------

	BEGIN TRY
		BEGIN TRAN
		
			truncate table [Search.Cache].[Private.NodeMap]
			insert into [Search.Cache].[Private.NodeMap] (NodeID, MatchedByNodeID, Distance, Paths, Weight)
				select NodeID, MatchedByNodeID, Distance, Paths, Weight
					from #NodeMap
			--[18504905 in 00:02:02]

			truncate table [Search.Cache].[Private.NodeSummary]
			insert into [Search.Cache].[Private.NodeSummary] (NodeID, ShortLabel, ClassName, SortOrder)
				select NodeID, ShortLabel, ClassName, SortOrder
					from #NodeSummary
			--[468900 in 00:00:03]

			truncate table [Search.Cache].[Private.NodeClass]
			insert into [Search.Cache].[Private.NodeClass] (NodeID, Class)
				select NodeID, ClassNode
					from #NodeClass
			--[2388097 in 00:00:05]

			truncate table [Search.Cache].[Private.NodeExpand]
			insert into [Search.Cache].[Private.NodeExpand] (NodeID, ExpandNodeID)
				select NodeID, ExpandNodeID
					from #NodeExpand
			--[3601932 in 00:00:08]

			truncate table [Search.Cache].[Private.NodeRDF]
			insert into [Search.Cache].[Private.NodeRDF] (NodeID, RDF)
				select NodeID, RDF
					from #NodeRDF
			--[1157272 in 00:00:36]

			truncate table [Search.Cache].[Private.NodePrefix]
			insert into [Search.Cache].[Private.NodePrefix] (Prefix, NodeID)
				select Prefix, NodeID
					from #NodePrefix
			--[3590372 in 00:00:34]

		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		--Raise an error with the details of the exception
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Person.GetPhotos](@NodeID bigINT, @SessionID UNIQUEIDENTIFIER=NULL)
AS
BEGIN

	DECLARE @SecurityGroupID BIGINT, @HasSpecialViewAccess BIT, @HasSecurityGroupNodes BIT
	EXEC [RDF.Security].GetSessionSecurityGroup @SessionID, @SecurityGroupID OUTPUT, @HasSpecialViewAccess OUTPUT
	CREATE TABLE #SecurityGroupNodes (SecurityGroupNode BIGINT PRIMARY KEY)
	INSERT INTO #SecurityGroupNodes (SecurityGroupNode) EXEC [RDF.Security].GetSessionSecurityGroupNodes @SessionID, @NodeID

	DECLARE @PredicateID BIGINT
	SELECT @PredicateID = _PropertyNode FROM [Ontology.].ClassProperty WHERE Property = 'http://profiles.catalyst.harvard.edu/ontology/prns#mainImage'
	
	DECLARE @ViewSecurityGroup BIGINT
	SELECT @ViewSecurityGroup = isnull(ViewSecurityGroup, -100) from [RDF.].Triple where Subject = @NodeID AND Predicate = @PredicateID

	IF @SessionID is null OR (@ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (@ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (@ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes))
	BEGIN
		DECLARE @InternalID INT, @InternalType NVARCHAR(300)

		SELECT @InternalID = CAST(m.InternalID AS INT),
			@InternalType = InternalType
 			FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
			WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID

		IF @InternalType = 'Person'
		BEGIN
			SELECT  photo,
					p.PhotoID		
				FROM [Profile.Data].[Person.Photo] p WITH(NOLOCK)
				WHERE PersonID=@InternalID  
			END

		ELSE IF @InternalType = 'Group' 
		BEGIN
			SELECT  photo,
					p.PhotoID		
				FROM [Profile.Data].[Group.Photo] p WITH(NOLOCK)
				WHERE GroupID=@InternalID  
			END
		END
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [RDF.].[SetNodePropertySecurity]
	@NodeID bigint,
	@PropertyID bigint = NULL,
	@PropertyURI varchar(400) = NULL,
	@ViewSecurityGroup bigint
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	SELECT @NodeID = NULL WHERE @NodeID = 0
	SELECT @PropertyID = NULL WHERE @PropertyID = 0

	IF (@PropertyID IS NULL) AND (@PropertyURI IS NOT NULL)
		SELECT @PropertyID = [RDF.].fnURI2NodeID(@PropertyURI)

	-- If node+property, then save setting so that it does
	-- not get overwritten through data loads
	IF (@NodeID IS NOT NULL) AND (@PropertyID IS NOT NULL) AND (@ViewSecurityGroup IS NOT NULL)
	BEGIN
		-- Save setting
		UPDATE [RDF.Security].NodeProperty
			SET ViewSecurityGroup = @ViewSecurityGroup
			WHERE NodeID = @NodeID AND Property = @PropertyID
		INSERT INTO [RDF.Security].NodeProperty (NodeID, Property, ViewSecurityGroup)
			SELECT @NodeID, @PropertyID, @ViewSecurityGroup
			WHERE NOT EXISTS (
				SELECT *
				FROM [RDF.Security].NodeProperty
				WHERE NodeID = @NodeID AND Property = @PropertyID
			)
		-- Update existing triples
		UPDATE [RDF.].Triple
			SET ViewSecurityGroup = @ViewSecurityGroup
			WHERE Subject = @NodeID AND Predicate = @PropertyID
		-- Change ViewSecurityGroup of object nodes to be at least as permissive as the triples
		UPDATE n
			SET n.ViewSecurityGroup = t.v
			FROM [RDF.].[Node] n
				INNER JOIN (
					SELECT NodeID, MAX(v) v
					FROM (
						SELECT n.NodeID, n.ViewSecurityGroup,
							(CASE	WHEN t.ViewSecurityGroup < 0 AND n.ViewSecurityGroup > 0 THEN -1
									WHEN t.ViewSecurityGroup < 0 AND n.ViewSecurityGroup < t.ViewSecurityGroup THEN t.ViewSecurityGroup
									WHEN t.ViewSecurityGroup > 0 AND n.ViewSecurityGroup > 0 AND t.ViewSecurityGroup <> n.ViewSecurityGroup THEN -20
									WHEN t.ViewSecurityGroup > 0 AND n.ViewSecurityGroup < -20 THEN -20
									ELSE n.ViewSecurityGroup END) v
						FROM [RDF.].[Triple] t
							INNER JOIN [RDF.].[Node] n ON t.Object = n.NodeID
						WHERE t.Subject = @NodeID AND t.Predicate = @PropertyID
					) t
					WHERE ViewSecurityGroup <> v
					GROUP BY NodeID
				) t
				ON n.NodeID = t.NodeID
	END
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [User.Account].[Relationship.SetRelationship]
	@SessionID UNIQUEIDENTIFIER,
	@Subject BIGINT,
	@RelationshipType VARCHAR(50) = NULL,
	@SetToExists BIT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;


	-- Get the UserID of the SessionID. Exit if not found.
	DECLARE @SessionUserID INT
	SELECT @SessionUserID = UserID
		FROM [User.Session].[Session]
		WHERE SessionID = @SessionID
	IF @SessionUserID IS NULL
		RETURN


	-- Convert the Subject to a PersonID. Exit if not found.
	DECLARE @PersonID INT
	SELECT @PersonID = CAST(InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap]
		WHERE @Subject IS NOT NULL
			AND NodeID = @Subject
			AND Class = 'http://xmlns.com/foaf/0.1/Person'
			AND InternalType = 'Person'
	IF @PersonID IS NULL
		RETURN


	-- Check that the RelationshipType is valid
	IF (@RelationshipType NOT IN ('Collaborator','CurrentAdvisor','PastAdvisor','CurrentAdvisee','PastAdvisee')) AND (@SetToExists = 1)
		RETURN


	-- Delete an existing relationship
	IF @SetToExists = 0
		DELETE
		FROM [User.Account].[Relationship]
		WHERE UserID = @SessionUserID
			AND PersonID = @PersonID
			AND RelationshipType = IsNull(@RelationshipType,RelationshipType)
	

	-- Add a relationship if it doesn't exist
	IF @SetToExists = 1
		INSERT INTO [User.Account].[Relationship] (UserID, PersonID, RelationshipType)
			SELECT @SessionUserID, @PersonID, @RelationshipType
			WHERE NOT EXISTS (
				SELECT *
				FROM [User.Account].[Relationship]
				WHERE UserID = @SessionUserID
					AND PersonID = @PersonID
					AND RelationshipType = @RelationshipType
			)

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [User.Account].[Relationship.GetRelationship]
	@SessionID UNIQUEIDENTIFIER,
	@Details BIT = 0,
	@Subject BIGINT = NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	/***********************************************************************
	This procedure does one of five things, based on the input parameters:
	
	1) If the Session is not logged in (i.e. not a user), then..
		Nothing is returned.
		
	2) If a Subject is provided and it is not a person, then...
		Nothing is returned.
	
	3) If a Subject is provided and it is a person, then...
		A list of relationship types is returned, with a flag "DoesExist"
		that indicates whether the Session user has a relationship with
		the Subject person.
	
	4) If a Subject is not provided and Details = 0, then...
		A list of all people who have at least one relationship with the
		Session user is returned.
	
	5) If a Subject is not provided and Details = 1, then...
		A list of all people who have a relationship with the Session user
		is returned, grouped by relationship type.
		
	***********************************************************************/

	-- Get the UserID of the SessionID. Exit if not found.
	DECLARE @SessionUserID INT
	SELECT @SessionUserID = UserID
		FROM [User.Session].[Session]
		WHERE SessionID = @SessionID
	IF @SessionUserID IS NULL
		RETURN


	-- Convert the Subject to a PersonID
	DECLARE @PersonID INT
	SELECT @PersonID = NULL
	SELECT @PersonID = CAST(InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap]
		WHERE @Subject IS NOT NULL
			AND NodeID = @Subject
			AND Class = 'http://xmlns.com/foaf/0.1/Person'
			AND InternalType = 'Person'
	IF (@Subject IS NOT NULL) AND (@PersonID IS NULL)
		RETURN


	-- Build a list of relationship types
	DECLARE @r TABLE (
		RelationshipType varchar(50),
		RelationshipName varchar(50),
		SortOrder int
	)
	INSERT INTO @r (RelationshipType, RelationshipName, SortOrder)
		SELECT 'Collaborator', 'Collaborator', 0 
		UNION ALL
		SELECT 'CurrentAdvisor', 'Advisor (Current)', 1 
		UNION ALL
		SELECT 'PastAdvisor', 'Advisor (Past)', 2 
		UNION ALL 
		SELECT 'CurrentAdvisee', 'Advisee (Current)', 3 
		UNION ALL
		SELECT 'PastAdvisee', 'Advisee (Past)', 4
	
	
	-- Return the relationships between the session user and the PersonID
	IF (@PersonID IS NOT NULL)
		SELECT r.RelationshipType, r.RelationshipName, r.SortOrder, 
				(CASE WHEN u.PersonID IS NULL THEN 0 ELSE 1 END) DoesExist
			FROM @r r
				LEFT OUTER JOIN [User.Account].[Relationship] u
					ON u.UserID = @SessionUserID
						AND u.PersonID = @PersonID
						AND r.RelationshipType = u.RelationshipType
			ORDER BY r.SortOrder

	-- Create a temp table to store a list of PersonIDs before converting to NodeIDs
	DECLARE @p AS TABLE (
		RelationshipType VARCHAR(50),
		RelationshipName VARCHAR(100),
		SortOrder INT,
		PersonID INT,
		Name NVARCHAR(100)
	)

	-- Return a list of people who have at least one relationship to the session user
	IF (@PersonID IS NULL) AND (@Details = 0)
	BEGIN
		INSERT INTO @p (PersonID, Name)
			SELECT PersonID,
				LastName + (CASE WHEN LastName<>'' AND FirstName<>'' THEN ', ' ELSE '' END) + FirstName AS Name
			FROM [Profile.Data].[Person] p
			WHERE p.PersonID IN (
					SELECT PersonID
						FROM [User.Account].[Relationship]
						WHERE UserID = @SessionUserID
				) AND p.IsActive = 1

		SELECT	p.PersonID,
				p.Name,
				m.NodeID,
				o.Value + CAST(m.NodeID AS VARCHAR(50)) URI
			FROM @p p
				INNER JOIN [RDF.Stage].[InternalNodeMap] m
					ON m.Class = 'http://xmlns.com/foaf/0.1/Person'
						AND m.InternalType = 'Person'
						AND m.InternalID = CAST(p.PersonID as VARCHAR(50))
				INNER JOIN [Framework.].[Parameter] o
					ON o.ParameterID = 'baseURI'
			ORDER BY p.Name
	END


	-- Return people who have a relationship to the session user, grouped by relationship type
	IF (@PersonID IS NULL) AND (@Details = 1)
	BEGIN
		;WITH a AS (
			SELECT r.RelationshipType, r.RelationshipName, r.SortOrder,
					p.PersonID,
					p.LastName + (CASE WHEN p.LastName<>'' AND p.FirstName<>'' THEN ', ' ELSE '' END) + p.FirstName AS Name
				FROM @r r
					INNER JOIN [User.Account].[Relationship] u
						ON u.UserID = @SessionUserID
							AND r.RelationshipType = u.RelationshipType
					INNER JOIN [Profile.Data].[Person] p
						ON u.PersonID = p.PersonID AND p.IsActive = 1
		), b AS (
			SELECT RelationshipType, COUNT(*) N
				FROM a
				GROUP BY RelationshipType
		)
		INSERT INTO @p (RelationshipType, RelationshipName, SortOrder, PersonID, Name)
			SELECT a.*
				FROM a INNER JOIN b ON a.RelationshipType = b.RelationshipType

		SELECT	p.RelationshipType, 
				p.RelationshipName, 
				p.SortOrder, 
				p.PersonID,
				p.Name,
				m.NodeID,
				o.Value + CAST(m.NodeID AS VARCHAR(50)) URI
			FROM @p p
				INNER JOIN [RDF.Stage].[InternalNodeMap] m
					ON m.Class = 'http://xmlns.com/foaf/0.1/Person'
						AND m.InternalType = 'Person'
						AND m.InternalID = CAST(p.PersonID as VARCHAR(50))
				INNER JOIN [Framework.].[Parameter] o
					ON o.ParameterID = 'baseURI'
			ORDER BY p.SortOrder, p.Name, p.PersonID
	END


END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE Procedure [Profile.Data].[Publication.Pubmed.UpdateAuthor2Person]
	@UseStagePMIDs bit = 0,
	@PMID int = null
AS 
BEGIN
	create table #tmp (
		PMPubsAuthorID int,
		PersonID int not null,
		PMID int not null)
	ALTER TABLE #tmp add primary key (PersonID, PMID)

	if @pmid is not null
		insert into #tmp (personID, PMID) select distinct PersonID, PMID from [Profile.Data].[Publication.Person.Include] where pmid = @PMID
	else if @UseStagePMIDs = 1
		insert into #tmp (personID, PMID) select distinct PersonID, PMID from [Profile.Data].[Publication.Person.Include] where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
	else 
		insert into #tmp (personID, PMID) select distinct PersonID, PMID from [Profile.Data].[Publication.Person.Include] where pmid is not null

	create table #t (PMPubsAuthorID int primary key not null)
	insert into #t select PMPubsAuthorID from [Profile.Data].[Publication.PubMed.Author] 

	update b set b.PMPubsAuthorID = a.PMPubsAuthorID from [Profile.Data].[Publication.PubMed.Author] a 
		join #t i on a.PmPubsAuthorID = i.PMPubsAuthorID
		join #tmp b
		on a.PMID = b.PMID
		and b.PMPubsAuthorID is null
		join [Profile.Data].Person c
		on b.PersonID = c.PersonID
		and a.LastName = c.LastName
		and a.ForeName = c.FirstName + ' ' + MiddleName
		and c.IsActive = 1

	delete from #t where PMPubsAuthorID in (select PMPubsAuthorID from #tmp)

	update b set b.PMPubsAuthorID = a.PMPubsAuthorID from [Profile.Data].[Publication.PubMed.Author] a 
		join #t i on a.PmPubsAuthorID = i.PMPubsAuthorID
		join #tmp b
		on a.PMID = b.PMID
		and b.PMPubsAuthorID is null
		join [Profile.Data].Person c
		on b.PersonID = c.PersonID
		and a.LastName = c.LastName
		and a.ForeName = c.FirstName
		and (substring(Initials,2,1) = substring(c.MiddleName, 1, 1))
		and c.IsActive = 1

	delete from #t where PMPubsAuthorID in (select PMPubsAuthorID from #tmp)

	update b set b.PMPubsAuthorID = a.PMPubsAuthorID from [Profile.Data].[Publication.PubMed.Author] a 
		join #t i on a.PmPubsAuthorID = i.PMPubsAuthorID
		join #tmp b
		on a.PMID = b.PMID
		and b.PMPubsAuthorID is null
		join [Profile.Data].Person c
		on b.PersonID = c.PersonID
		and a.LastName = c.LastName
		and (substring(forename, 1, 1) = substring(c.firstname, 1, 1) )
		and (substring(Initials,2,1) = substring(c.MiddleName, 1, 1))
		and c.IsActive = 1

	delete from #t where PMPubsAuthorID in (select PMPubsAuthorID from #tmp)

	update b set b.PMPubsAuthorID = a.PMPubsAuthorID from [Profile.Data].[Publication.PubMed.Author] a 
		join #t i on a.PmPubsAuthorID = i.PMPubsAuthorID
		join #tmp b
		on a.PMID = b.PMID
		and b.PMPubsAuthorID is null
		join [Profile.Data].Person c
		on b.PersonID = c.PersonID
		and a.LastName = c.LastName
		and (substring(forename, 1, 1) = substring(c.firstname, 1, 1) )
		and (len(initials) = 1 or MiddleName = '')
		and c.IsActive = 1

	delete from #t where PMPubsAuthorID in (select PMPubsAuthorID from #tmp)

	update b set b.PMPubsAuthorID = a.PMPubsAuthorID from [Profile.Data].[Publication.PubMed.Author] a 
		join #t i on a.PmPubsAuthorID = i.PMPubsAuthorID
		join #tmp b
		on a.PMID = b.PMID
		and b.PMPubsAuthorID is null
		join [Profile.Data].Person c
		on b.PersonID = c.PersonID
		and a.LastName = c.LastName
		and c.IsActive = 1

	if @pmid is not null
	BEGIN
		delete a from [Profile.Data].[Publication.PubMed.Author2Person] a 
			join [Profile.Data].[Publication.PubMed.Author] b on a.PmPubsAuthorID = b.PmPubsAuthorID and b.pmid = @PMID
		insert into [Profile.Data].[Publication.PubMed.Author2Person] (PMPubsAuthorID, PersonID ) select PMPubsAuthorID, PersonID from #tmp where PMPubsAuthorID is not null
	END
	else if @UseStagePMIDs = 1
	BEGIN
		delete a from [Profile.Data].[Publication.PubMed.Author2Person] a 
			join [Profile.Data].[Publication.PubMed.Author] b on a.PmPubsAuthorID = b.PmPubsAuthorID
			join [Profile.Data].[Publication.PubMed.General.Stage] s on b.PMID = s.PMID
		insert into [Profile.Data].[Publication.PubMed.Author2Person] (PMPubsAuthorID, PersonID ) select PMPubsAuthorID, PersonID from #tmp where PMPubsAuthorID is not null
	END
	else 
	BEGIN
		truncate table [Profile.Data].[Publication.PubMed.Author2Person]
		insert into [Profile.Data].[Publication.PubMed.Author2Person] (PMPubsAuthorID, PersonID ) select PMPubsAuthorID, PersonID from #tmp where PMPubsAuthorID is not null
	END
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.Pubmed.ParsePubMedXML]
	@pmid int
AS
BEGIN
	SET NOCOUNT ON;

	CREATE TABLE #General(
		[PMID] [int] NOT NULL,
		[PMCID] [nvarchar](55) NULL,
		[Owner] [varchar](50) NULL,
		[Status] [varchar](50) NULL,
		[PubModel] [varchar](50) NULL,
		[Volume] [varchar](255) NULL,
		[Issue] [varchar](255) NULL,
		[MedlineDate] [varchar](255) NULL,
		[JournalYear] [varchar](50) NULL,
		[JournalMonth] [varchar](50) NULL,
		[JournalDay] [varchar](50) NULL,
		[JournalTitle] [varchar](1000) NULL,
		[ISOAbbreviation] [varchar](100) NULL,
		[MedlineTA] [varchar](1000) NULL,
		[ArticleTitle] [varchar](4000) NULL,
		[MedlinePgn] [varchar](255) NULL,
		[AbstractText] [text] NULL,
		[ArticleDateType] [varchar](50) NULL,
		[ArticleYear] [varchar](10) NULL,
		[ArticleMonth] [varchar](10) NULL,
		[ArticleDay] [varchar](10) NULL,
		[Affiliation] [varchar](8000) NULL,
		[AuthorListCompleteYN] [varchar](1) NULL,
		[GrantListCompleteYN] [varchar](1) NULL,
		[PubDate] [datetime] NULL,
		[Authors] [varchar](4000) NULL,
		[doi] [varchar](100) NULL,
	PRIMARY KEY CLUSTERED 
	(
		[PMID] ASC
	)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
	) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]


	CREATE TABLE #Author(
		[PmPubsAuthorID] [int] IDENTITY(1,1) NOT NULL,
		[PMID] [int] NOT NULL,
		[ValidYN] [varchar](1) NULL,
		[LastName] [varchar](100) NULL,
		[FirstName] [varchar](100) NULL,
		[ForeName] [varchar](100) NULL,
		[Suffix] [varchar](20) NULL,
		[Initials] [varchar](20) NULL,
		[Affiliation] [varchar](8000) NULL,
		[CollectiveName] [nvarchar](1000) NULL,
		[ORCID] [varchar](50) NULL,
		[ExistingPmPubsAuthorID] [int] NULL,
		[ValueHash] [varbinary](32) NULL,
		PRIMARY KEY CLUSTERED 
	(
		[PmPubsAuthorID] ASC
	)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
	) ON [PRIMARY]


	CREATE TABLE #Mesh(
		[PMID] [int] NOT NULL,
		[DescriptorName] [varchar](255) NOT NULL,
		[QualifierName] [varchar](255) NOT NULL,
		[MajorTopicYN] [char](1) NULL,
	PRIMARY KEY CLUSTERED 
	(
		[PMID] ASC,
		[DescriptorName] ASC,
		[QualifierName] ASC
	)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
	) ON [PRIMARY]


	
	--*** general ***
	insert into #General (pmid, Owner, Status, PubModel, Volume, Issue, MedlineDate, JournalYear, JournalMonth, JournalDay, JournalTitle, ISOAbbreviation, MedlineTA, ArticleTitle, MedlinePgn, AbstractText, ArticleDateType, ArticleYear, ArticleMonth, ArticleDay, Affiliation, AuthorListCompleteYN, GrantListCompleteYN,PMCID, DOI)
		select pmid, 
			nref.value('MedlineCitation[1]/@Owner[1]','varchar(50)') Owner,
			nref.value('MedlineCitation[1]/@Status[1]','varchar(50)') Status,
			nref.value('MedlineCitation[1]/Article[1]/@PubModel','varchar(50)') PubModel,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/JournalIssue[1]/Volume[1]','varchar(255)') Volume,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/JournalIssue[1]/Issue[1]','varchar(255)') Issue,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/JournalIssue[1]/PubDate[1]/MedlineDate[1]','varchar(255)') MedlineDate,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/JournalIssue[1]/PubDate[1]/Year[1]','varchar(50)') JournalYear,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/JournalIssue[1]/PubDate[1]/Month[1]','varchar(50)') JournalMonth,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/JournalIssue[1]/PubDate[1]/Day[1]','varchar(50)') JournalDay,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/Title[1]','varchar(1000)') JournalTitle,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/ISOAbbreviation[1]','varchar(100)') ISOAbbreviation,
			nref.value('MedlineCitation[1]/MedlineJournalInfo[1]/MedlineTA[1]','varchar(1000)') MedlineTA,
			nref.value('MedlineCitation[1]/Article[1]/ArticleTitle[1]','nvarchar(4000)') ArticleTitle,
			nref.value('MedlineCitation[1]/Article[1]/Pagination[1]/MedlinePgn[1]','varchar(255)') MedlinePgn,
			nref.value('MedlineCitation[1]/Article[1]/Abstract[1]/AbstractText[1]','varchar(max)') AbstractText,
			nref.value('MedlineCitation[1]/Article[1]/ArticleDate[1]/@DateType[1]','varchar(50)') ArticleDateType,
			NULLIF(nref.value('MedlineCitation[1]/Article[1]/ArticleDate[1]/Year[1]','varchar(10)'),'') ArticleYear,
			NULLIF(nref.value('MedlineCitation[1]/Article[1]/ArticleDate[1]/Month[1]','varchar(10)'),'') ArticleMonth,
			NULLIF(nref.value('MedlineCitation[1]/Article[1]/ArticleDate[1]/Day[1]','varchar(10)'),'') ArticleDay,
			Affiliation = COALESCE(nref.value('MedlineCitation[1]/Article[1]/AuthorList[1]/Author[1]/AffiliationInfo[1]/Affiliation[1]','varchar(8000)'),
				nref.value('MedlineCitation[1]/Article[1]/AuthorList[1]/Author[1]/Affiliation[1]','varchar(8000)'),
				nref.value('MedlineCitation[1]/Article[1]/Affiliation[1]','varchar(8000)')) ,
			nref.value('MedlineCitation[1]/Article[1]/AuthorList[1]/@CompleteYN[1]','varchar(1)') AuthorListCompleteYN,
			nref.value('MedlineCitation[1]/Article[1]/GrantList[1]/@CompleteYN[1]','varchar(1)') GrantListCompleteYN,
			--PMCID=COALESCE(nref.value('(OtherID[@Source="NLM" and text()[contains(.,"PMC")]])[1]', 'varchar(55)'), nref.value('(OtherID[@Source="NLM"][1])','varchar(55)'))
			nref.value('PubmedData[1]/ArticleIdList[1]/ArticleId[@IdType="pmc"][1]', 'varchar(100)') pmcid,
			nref.value('PubmedData[1]/ArticleIdList[1]/ArticleId[@IdType="doi"][1]', 'varchar(100)') doi
		from [Profile.Data].[Publication.PubMed.AllXML] cross apply x.nodes('//PubmedArticle[1]') as R(nref)
		where PMID = @pmid

		update #General
		set MedlineDate = (case when right(MedlineDate,4) like '20__' then ltrim(rtrim(right(MedlineDate,4)+' '+left(MedlineDate,len(MedlineDate)-4))) else null end)
		where MedlineDate is not null and MedlineDate not like '[0-9][0-9][0-9][0-9]%'

		
		update #General
		set PubDate = [Profile.Data].[fnPublication.Pubmed.GetPubDate](medlinedate,journalyear,journalmonth,journalday,articleyear,articlemonth,articleday)


	--*** authors ***
	insert into #Author (pmid, ValidYN, LastName, FirstName, ForeName, CollectiveName, Suffix, Initials, ORCID, Affiliation)
		select pmid, 
			nref.value('@ValidYN','varchar(1)') ValidYN, 
			nref.value('LastName[1]','nvarchar(100)') LastName, 
			nref.value('FirstName[1]','nvarchar(100)') FirstName,
			nref.value('ForeName[1]','nvarchar(100)') ForeName,
			nref.value('CollectiveName[1]', 'nvarchar(100)') CollectiveName,
			nref.value('Suffix[1]','nvarchar(20)') Suffix,
			nref.value('Initials[1]','nvarchar(20)') Initials,
			nref.value('Identifier[@Source="ORCID"][1]', 'varchar(50)') ORCID,
			COALESCE(nref.value('AffiliationInfo[1]/Affiliation[1]','varchar(1000)'),
				nref.value('Affiliation[1]','varchar(max)')) Affiliation

		from [Profile.Data].[Publication.PubMed.AllXML] cross apply x.nodes('//AuthorList/Author') as R(nref)
		where PMID = @pmid
		

	
		update #Author set orcid = replace(ORCID, 'http://orcid.org/', '')
		update #Author set orcid = replace(ORCID, 'https://orcid.org/', '')
		update #Author SET ORCID =  SUBSTRING(ORCID, 1, 4) + '-' + SUBSTRING(ORCID, 5, 4) + '-' + SUBSTRING(ORCID, 9, 4) + '-' + SUBSTRING(ORCID, 13, 4) where ORCID is not null and len(ORCID) = 16
		update #Author SET ORCID = LTRIM(RTRIM(ORCID))

		update #Author set valueHash = HASHBYTES('SHA1', cast(pmid as varchar(100)) + '|||' + isnull(LastName, '') + '|||' + isnull(ValidYN, '') + '|||' + isnull(FirstName, '') + '|||' + isnull(ForeName, '') + '|||' + isnull(Suffix, '') + '|||' + isnull(Initials, '') + '|||' + isnull(CollectiveName, '') + '|||' + isnull(ORCID, '') + '|||' + isnull(Affiliation, ''))

	--*** general (authors) ***

	create table #a (pmid int primary key, authors nvarchar(4000))
	insert into #a(pmid,authors)
		select pmid,
			(case	when len(s) < 3990 then s
					when charindex(',',reverse(left(s,3990)))>0 then
						left(s,3990-charindex(',',reverse(left(s,3990))))+', et al'
					else left(s,3990)
					end) authors
		from (
			select pmid, substring(s,3,len(s)) s
			from (
				select pmid, isnull(cast((
					select isnull(', '+lastname+' '+initials, ', '+CollectiveName)
					from #Author q
					where q.pmid = p.pmid
					order by PmPubsAuthorID
					for xml path(''), type
				) as nvarchar(max)),'') s
				from #General p
			) t
		) t

	--[10132 in 00:00:01]
	update g
		set g.authors = isnull(a.authors,'')
		from #General g, #a a
		where g.pmid = a.pmid
	update #General
		set authors = ''
		where authors is null
		
		
		
	--*** mesh ***
	insert into #Mesh (pmid, DescriptorName, QualifierName, MajorTopicYN)
		select pmid, DescriptorName, IsNull(QualifierName,''), max(MajorTopicYN)
		from (
			select pmid, 
				nref.value('@MajorTopicYN[1]','varchar(1)') MajorTopicYN, 
				nref.value('.','varchar(255)') DescriptorName,
				null QualifierName
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//MeshHeadingList/MeshHeading/DescriptorName') as R(nref)
			where PMID = @pmid
			union all
			select pmid, 
				nref.value('@MajorTopicYN[1]','varchar(1)') MajorTopicYN, 
				nref.value('../DescriptorName[1]','varchar(255)') DescriptorName,
				nref.value('.','varchar(255)') QualifierName
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//MeshHeadingList/MeshHeading/QualifierName') as R(nref)
			where PMID = @pmid
		) t where DescriptorName is not null
		group by pmid, DescriptorName, QualifierName

		
	--******************************************************************
	--******************************************************************
	--*** Update General
	--******************************************************************
	--******************************************************************

	update g
		set 
			g.pmid=a.pmid,
			g.pmcid=a.pmcid,
			g.doi = a.doi,
			g.Owner=a.Owner,
			g.Status=a.Status,
			g.PubModel=a.PubModel,
			g.Volume=a.Volume,
			g.Issue=a.Issue,
			g.MedlineDate=a.MedlineDate,
			g.JournalYear=a.JournalYear,
			g.JournalMonth=a.JournalMonth,
			g.JournalDay=a.JournalDay,
			g.JournalTitle=a.JournalTitle,
			g.ISOAbbreviation=a.ISOAbbreviation,
			g.MedlineTA=a.MedlineTA,
			g.ArticleTitle=a.ArticleTitle,
			g.MedlinePgn=a.MedlinePgn,
			g.AbstractText=a.AbstractText,
			g.ArticleDateType=a.ArticleDateType,
			g.ArticleYear=a.ArticleYear,
			g.ArticleMonth=a.ArticleMonth,
			g.ArticleDay=a.ArticleDay,
			g.Affiliation=a.Affiliation,
			g.AuthorListCompleteYN=a.AuthorListCompleteYN,
			g.GrantListCompleteYN=a.GrantListCompleteYN,
			g.PubDate = a.PubDate,
			g.Authors = a.Authors
		from [Profile.Data].[Publication.PubMed.General] (nolock) g
			inner join #General a
				on g.pmid = a.pmid
				
	insert into [Profile.Data].[Publication.PubMed.General] (pmid, pmcid, Owner, Status, PubModel, Volume, Issue, MedlineDate, JournalYear, JournalMonth, JournalDay, JournalTitle, ISOAbbreviation, MedlineTA, ArticleTitle, MedlinePgn, AbstractText, ArticleDateType, ArticleYear, ArticleMonth, ArticleDay, Affiliation, AuthorListCompleteYN, GrantListCompleteYN, PubDate, Authors, doi)
		select pmid, pmcid, Owner, Status, PubModel, Volume, Issue, MedlineDate, JournalYear, JournalMonth, JournalDay, JournalTitle, ISOAbbreviation, MedlineTA, ArticleTitle, MedlinePgn, AbstractText, ArticleDateType, ArticleYear, ArticleMonth, ArticleDay, Affiliation, AuthorListCompleteYN, GrantListCompleteYN, PubDate, Authors, doi
			from #General
			where pmid not in (select pmid from [Profile.Data].[Publication.PubMed.General])
	
	
	--******************************************************************
	--******************************************************************
	--*** Update Authors
	--******************************************************************
	--******************************************************************
	update a set a.ExistingPmPubsAuthorID = b.PmPubsAuthorID 
		from #Author a 
			join [Profile.Data].[Publication.PubMed.Author] b
			on a.ValueHash = b.ValueHash

	select PmPubsAuthorID into #DeletedAuthors from [Profile.Data].[Publication.PubMed.Author] where PMID = @pmid
		and PmPubsAuthorID not in (select ExistingPmPubsAuthorID from #Author)

	delete from [Profile.Data].[Publication.PubMed.Author2Person] where PmPubsAuthorID in (select PmPubsAuthorID from #DeletedAuthors)

	delete from [Profile.Data].[Publication.PubMed.Author] where PmPubsAuthorID in (select PmPubsAuthorID from #DeletedAuthors)
	insert into [Profile.Data].[Publication.PubMed.Author] (pmid, ValidYN, LastName, FirstName, ForeName, CollectiveName, Suffix, Initials, ORCID, Affiliation, ValueHash)
		select pmid, ValidYN, LastName, FirstName, ForeName, CollectiveName, Suffix, Initials, ORCID, Affiliation, ValueHash
		from #Author where ExistingPmPubsAuthorID is null
		order by PmPubsAuthorID

	exec [Profile.Data].[Publication.Pubmed.UpdateAuthor2Person] @pmid = @pmid
	
	--******************************************************************
	--******************************************************************
	--*** Update MeSH
	--******************************************************************
	--******************************************************************


	--*** mesh ***
	delete from [Profile.Data].[Publication.PubMed.Mesh] where pmid = @pmid
	--[16593 in 00:00:11]
	insert into [Profile.Data].[Publication.PubMed.Mesh]
		select * from #Mesh
	--[86375 in 00:00:17]

		
		
		
	--*** investigators ***
	delete from [Profile.Data].[Publication.PubMed.Investigator] where pmid = @pmid
	insert into [Profile.Data].[Publication.PubMed.Investigator] (pmid, LastName, FirstName, ForeName, Suffix, Initials, Affiliation)
		select pmid, 
			nref.value('LastName[1]','varchar(100)') LastName, 
			nref.value('FirstName[1]','varchar(100)') FirstName,
			nref.value('ForeName[1]','varchar(100)') ForeName,
			nref.value('Suffix[1]','varchar(20)') Suffix,
			nref.value('Initials[1]','varchar(20)') Initials,
			COALESCE(nref.value('AffiliationInfo[1]/Affiliation[1]','varchar(1000)'),
				nref.value('Affiliation[1]','varchar(1000)')) Affiliation
		from [Profile.Data].[Publication.PubMed.AllXML] cross apply x.nodes('//InvestigatorList/Investigator') as R(nref)
		where pmid = @pmid
		

	--*** pubtype ***
	delete from [Profile.Data].[Publication.PubMed.PubType] where pmid = @pmid
	insert into [Profile.Data].[Publication.PubMed.PubType] (pmid, PublicationType)
		select * from (
			select distinct pmid, nref.value('.','varchar(100)') PublicationType
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//PublicationTypeList/PublicationType') as R(nref)
			where pmid = @pmid
		) t where PublicationType is not null


	--*** chemicals
	delete from [Profile.Data].[Publication.PubMed.Chemical] where pmid = @pmid
	insert into [Profile.Data].[Publication.PubMed.Chemical] (pmid, NameOfSubstance)
		select * from (
			select distinct pmid, nref.value('.','varchar(255)') NameOfSubstance
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//ChemicalList/Chemical/NameOfSubstance') as R(nref)
			where pmid = @pmid
		) t where NameOfSubstance is not null


	--*** databanks ***
	delete from [Profile.Data].[Publication.PubMed.Databank] where pmid = @pmid
	insert into [Profile.Data].[Publication.PubMed.Databank] (pmid, DataBankName)
		select * from (
			select distinct pmid, 
				nref.value('.','varchar(100)') DataBankName
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//DataBankList/DataBank/DataBankName') as R(nref)
			where pmid = @pmid
		) t where DataBankName is not null


	--*** accessions ***
	delete from [Profile.Data].[Publication.PubMed.Accession] where pmid = @pmid
	insert into [Profile.Data].[Publication.PubMed.Accession] (pmid, DataBankName, AccessionNumber)
		select * from (
			select distinct pmid, 
				nref.value('../../DataBankName[1]','varchar(100)') DataBankName,
				nref.value('.','varchar(50)') AccessionNumber
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//DataBankList/DataBank/AccessionNumberList/AccessionNumber') as R(nref)
			where pmid = @pmid
		) t where DataBankName is not null and AccessionNumber is not null


	--*** keywords ***
	delete from [Profile.Data].[Publication.PubMed.Keyword] where pmid = @pmid
	insert into [Profile.Data].[Publication.PubMed.Keyword] (pmid, Keyword, MajorTopicYN)
		select pmid, Keyword, max(MajorTopicYN)
		from (
			select pmid, 
				nref.value('.','varchar(895)') Keyword,
				nref.value('@MajorTopicYN','varchar(1)') MajorTopicYN
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//KeywordList/Keyword') as R(nref)
			where pmid = @pmid
		) t where Keyword is not null
		group by pmid, Keyword


	--*** grants ***
	delete from [Profile.Data].[Publication.PubMed.Grant] where pmid = @pmid
	insert into [Profile.Data].[Publication.PubMed.Grant] (pmid, GrantID, Acronym, Agency)
		select pmid, GrantID, max(Acronym), max(Agency)
		from (
			select pmid, 
				nref.value('GrantID[1]','varchar(100)') GrantID, 
				nref.value('Acronym[1]','varchar(50)') Acronym,
				nref.value('Agency[1]','varchar(1000)') Agency
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//GrantList/Grant') as R(nref)
			where pmid = @pmid
		) t where GrantID is not null
		group by pmid, GrantID


	--******************************************************************
	--******************************************************************
	--*** Update parse date
	--******************************************************************
	--******************************************************************

	update [Profile.Data].[Publication.PubMed.AllXML] set ParseDT = GetDate() where pmid = @pmid
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.Pubmed.ParseALLPubMedXML]
AS
BEGIN
	SET NOCOUNT ON;

	--*** general ***
	truncate table [Profile.Data].[Publication.PubMed.General.Stage]
	insert into [Profile.Data].[Publication.PubMed.General.Stage] (pmid, Owner, Status, PubModel, Volume, Issue, MedlineDate, JournalYear, JournalMonth, JournalDay, JournalTitle, ISOAbbreviation, MedlineTA, ArticleTitle, MedlinePgn, AbstractText, ArticleDateType, ArticleYear, ArticleMonth, ArticleDay, Affiliation, AuthorListCompleteYN, GrantListCompleteYN,PMCID, DOI)
		select pmid, 
			nref.value('MedlineCitation[1]/@Owner[1]','varchar(50)') Owner,
			nref.value('MedlineCitation[1]/@Status[1]','varchar(50)') Status,
			nref.value('MedlineCitation[1]/Article[1]/@PubModel','varchar(50)') PubModel,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/JournalIssue[1]/Volume[1]','varchar(255)') Volume,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/JournalIssue[1]/Issue[1]','varchar(255)') Issue,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/JournalIssue[1]/PubDate[1]/MedlineDate[1]','varchar(255)') MedlineDate,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/JournalIssue[1]/PubDate[1]/Year[1]','varchar(50)') JournalYear,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/JournalIssue[1]/PubDate[1]/Month[1]','varchar(50)') JournalMonth,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/JournalIssue[1]/PubDate[1]/Day[1]','varchar(50)') JournalDay,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/Title[1]','varchar(1000)') JournalTitle,
			nref.value('MedlineCitation[1]/Article[1]/Journal[1]/ISOAbbreviation[1]','varchar(100)') ISOAbbreviation,
			nref.value('MedlineCitation[1]/MedlineJournalInfo[1]/MedlineTA[1]','varchar(1000)') MedlineTA,
			nref.value('MedlineCitation[1]/Article[1]/ArticleTitle[1]','nvarchar(4000)') ArticleTitle,
			nref.value('MedlineCitation[1]/Article[1]/Pagination[1]/MedlinePgn[1]','varchar(255)') MedlinePgn,
			nref.value('MedlineCitation[1]/Article[1]/Abstract[1]/AbstractText[1]','varchar(max)') AbstractText,
			nref.value('MedlineCitation[1]/Article[1]/ArticleDate[1]/@DateType[1]','varchar(50)') ArticleDateType,
			NULLIF(nref.value('MedlineCitation[1]/Article[1]/ArticleDate[1]/Year[1]','varchar(10)'),'') ArticleYear,
			NULLIF(nref.value('MedlineCitation[1]/Article[1]/ArticleDate[1]/Month[1]','varchar(10)'),'') ArticleMonth,
			NULLIF(nref.value('MedlineCitation[1]/Article[1]/ArticleDate[1]/Day[1]','varchar(10)'),'') ArticleDay,
			Affiliation = COALESCE(nref.value('MedlineCitation[1]/Article[1]/AuthorList[1]/Author[1]/AffiliationInfo[1]/Affiliation[1]','varchar(8000)'),
				nref.value('MedlineCitation[1]/Article[1]/AuthorList[1]/Author[1]/Affiliation[1]','varchar(8000)'),
				nref.value('MedlineCitation[1]/Article[1]/Affiliation[1]','varchar(8000)')) ,
			nref.value('MedlineCitation[1]/Article[1]/AuthorList[1]/@CompleteYN[1]','varchar(1)') AuthorListCompleteYN,
			nref.value('MedlineCitation[1]/Article[1]/GrantList[1]/@CompleteYN[1]','varchar(1)') GrantListCompleteYN,
			--PMCID=COALESCE(nref.value('(OtherID[@Source="NLM" and text()[contains(.,"PMC")]])[1]', 'varchar(55)'), nref.value('(OtherID[@Source="NLM"][1])','varchar(55)'))
			nref.value('PubmedData[1]/ArticleIdList[1]/ArticleId[@IdType="pmc"][1]', 'varchar(100)') pmcid,
			nref.value('PubmedData[1]/ArticleIdList[1]/ArticleId[@IdType="doi"][1]', 'varchar(100)') doi
		from [Profile.Data].[Publication.PubMed.AllXML] cross apply x.nodes('//PubmedArticle[1]') as R(nref)
		where ParseDT is null and x is not null

		update [Profile.Data].[Publication.PubMed.General.Stage]
		set MedlineDate = (case when right(MedlineDate,4) like '20__' then ltrim(rtrim(right(MedlineDate,4)+' '+left(MedlineDate,len(MedlineDate)-4))) else null end)
		where MedlineDate is not null and MedlineDate not like '[0-9][0-9][0-9][0-9]%'

		
		update [Profile.Data].[Publication.PubMed.General.Stage]
		set PubDate = [Profile.Data].[fnPublication.Pubmed.GetPubDate](medlinedate,journalyear,journalmonth,journalday,articleyear,articlemonth,articleday)


	--*** authors ***
	truncate table [Profile.Data].[Publication.PubMed.Author.Stage]
	insert into [Profile.Data].[Publication.PubMed.Author.Stage] (pmid, ValidYN, LastName, FirstName, ForeName, CollectiveName, Suffix, Initials, ORCID, Affiliation)
		select pmid, 
			nref.value('@ValidYN','varchar(1)') ValidYN, 
			nref.value('LastName[1]','nvarchar(100)') LastName, 
			nref.value('FirstName[1]','nvarchar(100)') FirstName,
			nref.value('ForeName[1]','nvarchar(100)') ForeName,
			nref.value('CollectiveName[1]', 'nvarchar(100)') CollectiveName,
			nref.value('Suffix[1]','nvarchar(20)') Suffix,
			nref.value('Initials[1]','nvarchar(20)') Initials,
			nref.value('Identifier[@Source="ORCID"][1]', 'varchar(50)') ORCID,
			COALESCE(nref.value('AffiliationInfo[1]/Affiliation[1]','varchar(1000)'),
				nref.value('Affiliation[1]','varchar(max)')) Affiliation

		from [Profile.Data].[Publication.PubMed.AllXML] cross apply x.nodes('//AuthorList/Author') as R(nref)
		where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
		

	
		update [Profile.Data].[Publication.PubMed.Author.Stage] set orcid = replace(ORCID, 'http://orcid.org/', '')
		update [Profile.Data].[Publication.PubMed.Author.Stage] set orcid = replace(ORCID, 'https://orcid.org/', '')
		update [Profile.Data].[Publication.PubMed.Author.Stage] SET ORCID =  SUBSTRING(ORCID, 1, 4) + '-' + SUBSTRING(ORCID, 5, 4) + '-' + SUBSTRING(ORCID, 9, 4) + '-' + SUBSTRING(ORCID, 13, 4) where ORCID is not null and len(ORCID) = 16
		update [Profile.Data].[Publication.PubMed.Author.Stage] SET ORCID = LTRIM(RTRIM(ORCID))

		update [Profile.Data].[Publication.PubMed.Author.Stage] set valueHash = HASHBYTES('SHA1', cast(pmid as varchar(100)) + '|||' + isnull(LastName, '') + '|||' + isnull(ValidYN, '') + '|||' + isnull(FirstName, '') + '|||' + isnull(ForeName, '') + '|||' + isnull(Suffix, '') + '|||' + isnull(Initials, '') + '|||' + isnull(CollectiveName, '') + '|||' + isnull(ORCID, '') + '|||' + isnull(Affiliation, ''))

	--*** general (authors) ***

	create table #a (pmid int primary key, authors nvarchar(4000))
	insert into #a(pmid,authors)
		select pmid,
			(case	when len(s) < 3990 then s
					when charindex(',',reverse(left(s,3990)))>0 then
						left(s,3990-charindex(',',reverse(left(s,3990))))+', et al'
					else left(s,3990)
					end) authors
		from (
			select pmid, substring(s,3,len(s)) s
			from (
				select pmid, isnull(cast((
					select isnull(', '+lastname+' '+initials, ', '+CollectiveName)
					from [Profile.Data].[Publication.PubMed.Author.Stage] q
					where q.pmid = p.pmid
					order by PmPubsAuthorID
					for xml path(''), type
				) as nvarchar(max)),'') s
				from [Profile.Data].[Publication.PubMed.General.Stage] p
			) t
		) t

	--[10132 in 00:00:01]
	update g
		set g.authors = isnull(a.authors,'')
		from [Profile.Data].[Publication.PubMed.General.Stage] g, #a a
		where g.pmid = a.pmid
	update [Profile.Data].[Publication.PubMed.General.Stage]
		set authors = ''
		where authors is null
		
		
		
	--*** mesh ***
	truncate table [Profile.Data].[Publication.PubMed.Mesh.Stage]
	insert into [Profile.Data].[Publication.PubMed.Mesh.Stage] (pmid, DescriptorName, QualifierName, MajorTopicYN)
		select pmid, DescriptorName, IsNull(QualifierName,''), max(MajorTopicYN)
		from (
			select pmid, 
				nref.value('@MajorTopicYN[1]','varchar(1)') MajorTopicYN, 
				nref.value('.','varchar(255)') DescriptorName,
				null QualifierName
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//MeshHeadingList/MeshHeading/DescriptorName') as R(nref)
			where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
			union all
			select pmid, 
				nref.value('@MajorTopicYN[1]','varchar(1)') MajorTopicYN, 
				nref.value('../DescriptorName[1]','varchar(255)') DescriptorName,
				nref.value('.','varchar(255)') QualifierName
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//MeshHeadingList/MeshHeading/QualifierName') as R(nref)
			where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
		) t where DescriptorName is not null
		group by pmid, DescriptorName, QualifierName

		
	--******************************************************************
	--******************************************************************
	--*** Update General
	--******************************************************************
	--******************************************************************

	update g
		set 
			g.pmid=a.pmid,
			g.pmcid=a.pmcid,
			g.doi = a.doi,
			g.Owner=a.Owner,
			g.Status=a.Status,
			g.PubModel=a.PubModel,
			g.Volume=a.Volume,
			g.Issue=a.Issue,
			g.MedlineDate=a.MedlineDate,
			g.JournalYear=a.JournalYear,
			g.JournalMonth=a.JournalMonth,
			g.JournalDay=a.JournalDay,
			g.JournalTitle=a.JournalTitle,
			g.ISOAbbreviation=a.ISOAbbreviation,
			g.MedlineTA=a.MedlineTA,
			g.ArticleTitle=a.ArticleTitle,
			g.MedlinePgn=a.MedlinePgn,
			g.AbstractText=a.AbstractText,
			g.ArticleDateType=a.ArticleDateType,
			g.ArticleYear=a.ArticleYear,
			g.ArticleMonth=a.ArticleMonth,
			g.ArticleDay=a.ArticleDay,
			g.Affiliation=a.Affiliation,
			g.AuthorListCompleteYN=a.AuthorListCompleteYN,
			g.GrantListCompleteYN=a.GrantListCompleteYN,
			g.PubDate = a.PubDate,
			g.Authors = a.Authors
		from [Profile.Data].[Publication.PubMed.General] (nolock) g
			inner join [Profile.Data].[Publication.PubMed.General.Stage] a
				on g.pmid = a.pmid
				
	insert into [Profile.Data].[Publication.PubMed.General] (pmid, pmcid, Owner, Status, PubModel, Volume, Issue, MedlineDate, JournalYear, JournalMonth, JournalDay, JournalTitle, ISOAbbreviation, MedlineTA, ArticleTitle, MedlinePgn, AbstractText, ArticleDateType, ArticleYear, ArticleMonth, ArticleDay, Affiliation, AuthorListCompleteYN, GrantListCompleteYN, PubDate, Authors, doi)
		select pmid, pmcid, Owner, Status, PubModel, Volume, Issue, MedlineDate, JournalYear, JournalMonth, JournalDay, JournalTitle, ISOAbbreviation, MedlineTA, ArticleTitle, MedlinePgn, AbstractText, ArticleDateType, ArticleYear, ArticleMonth, ArticleDay, Affiliation, AuthorListCompleteYN, GrantListCompleteYN, PubDate, Authors, doi
			from [Profile.Data].[Publication.PubMed.General.Stage]
			where pmid not in (select pmid from [Profile.Data].[Publication.PubMed.General])
	
	
	--******************************************************************
	--******************************************************************
	--*** Update Authors
	--******************************************************************
	--******************************************************************
	update a set a.ExistingPmPubsAuthorID = b.PmPubsAuthorID 
		from [Profile.Data].[Publication.PubMed.Author.Stage] a 
			join [Profile.Data].[Publication.PubMed.Author] b
			on a.ValueHash = b.ValueHash

	select PmPubsAuthorID into #DeletedAuthors from [Profile.Data].[Publication.PubMed.Author] where PMID in (select PMID from [Profile.Data].[Publication.PubMed.General.Stage])
		and PmPubsAuthorID not in (select ExistingPmPubsAuthorID from [Profile.Data].[Publication.PubMed.Author.Stage])

	delete from [Profile.Data].[Publication.PubMed.Author2Person] where PmPubsAuthorID in (select PmPubsAuthorID from #DeletedAuthors)

	delete from [Profile.Data].[Publication.PubMed.Author] where PmPubsAuthorID in (select PmPubsAuthorID from #DeletedAuthors)
	insert into [Profile.Data].[Publication.PubMed.Author] (pmid, ValidYN, LastName, FirstName, ForeName, CollectiveName, Suffix, Initials, ORCID, Affiliation, ValueHash)
		select pmid, ValidYN, LastName, FirstName, ForeName, CollectiveName, Suffix, Initials, ORCID, Affiliation, ValueHash
		from [Profile.Data].[Publication.PubMed.Author.Stage] where ExistingPmPubsAuthorID is null
		order by PmPubsAuthorID

	exec [Profile.Data].[Publication.Pubmed.UpdateAuthor2Person] @UseStagePMIDs = 1

	--******************************************************************
	--******************************************************************
	--*** Update MeSH
	--******************************************************************
	--******************************************************************


	--*** mesh ***
	delete from [Profile.Data].[Publication.PubMed.Mesh] where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
	--[16593 in 00:00:11]
	insert into [Profile.Data].[Publication.PubMed.Mesh]
		select * from [Profile.Data].[Publication.PubMed.Mesh.Stage]
	--[86375 in 00:00:17]

		
		
		
	--*** investigators ***
	delete from [Profile.Data].[Publication.PubMed.Investigator] where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
	insert into [Profile.Data].[Publication.PubMed.Investigator] (pmid, LastName, FirstName, ForeName, Suffix, Initials, Affiliation)
		select pmid, 
			nref.value('LastName[1]','varchar(100)') LastName, 
			nref.value('FirstName[1]','varchar(100)') FirstName,
			nref.value('ForeName[1]','varchar(100)') ForeName,
			nref.value('Suffix[1]','varchar(20)') Suffix,
			nref.value('Initials[1]','varchar(20)') Initials,
			COALESCE(nref.value('AffiliationInfo[1]/Affiliation[1]','varchar(1000)'),
				nref.value('Affiliation[1]','varchar(1000)')) Affiliation
		from [Profile.Data].[Publication.PubMed.AllXML] cross apply x.nodes('//InvestigatorList/Investigator') as R(nref)
		where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
		

	--*** pubtype ***
	delete from [Profile.Data].[Publication.PubMed.PubType] where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
	insert into [Profile.Data].[Publication.PubMed.PubType] (pmid, PublicationType)
		select * from (
			select distinct pmid, nref.value('.','varchar(100)') PublicationType
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//PublicationTypeList/PublicationType') as R(nref)
			where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
		) t where PublicationType is not null


	--*** chemicals
	delete from [Profile.Data].[Publication.PubMed.Chemical] where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
	insert into [Profile.Data].[Publication.PubMed.Chemical] (pmid, NameOfSubstance)
		select * from (
			select distinct pmid, nref.value('.','varchar(255)') NameOfSubstance
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//ChemicalList/Chemical/NameOfSubstance') as R(nref)
			where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
		) t where NameOfSubstance is not null


	--*** databanks ***
	delete from [Profile.Data].[Publication.PubMed.Databank] where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
	insert into [Profile.Data].[Publication.PubMed.Databank] (pmid, DataBankName)
		select * from (
			select distinct pmid, 
				nref.value('.','varchar(100)') DataBankName
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//DataBankList/DataBank/DataBankName') as R(nref)
			where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
		) t where DataBankName is not null


	--*** accessions ***
	delete from [Profile.Data].[Publication.PubMed.Accession] where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
	insert into [Profile.Data].[Publication.PubMed.Accession] (pmid, DataBankName, AccessionNumber)
		select * from (
			select distinct pmid, 
				nref.value('../../DataBankName[1]','varchar(100)') DataBankName,
				nref.value('.','varchar(50)') AccessionNumber
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//DataBankList/DataBank/AccessionNumberList/AccessionNumber') as R(nref)
			where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
		) t where DataBankName is not null and AccessionNumber is not null


	--*** keywords ***
	delete from [Profile.Data].[Publication.PubMed.Keyword] where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
	insert into [Profile.Data].[Publication.PubMed.Keyword] (pmid, Keyword, MajorTopicYN)
		select pmid, Keyword, max(MajorTopicYN)
		from (
			select pmid, 
				nref.value('.','varchar(895)') Keyword,
				nref.value('@MajorTopicYN','varchar(1)') MajorTopicYN
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//KeywordList/Keyword') as R(nref)
			where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
		) t where Keyword is not null
		group by pmid, Keyword


	--*** grants ***
	delete from [Profile.Data].[Publication.PubMed.Grant] where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
	insert into [Profile.Data].[Publication.PubMed.Grant] (pmid, GrantID, Acronym, Agency)
		select pmid, GrantID, max(Acronym), max(Agency)
		from (
			select pmid, 
				nref.value('GrantID[1]','varchar(100)') GrantID, 
				nref.value('Acronym[1]','varchar(50)') Acronym,
				nref.value('Agency[1]','varchar(1000)') Agency
			from [Profile.Data].[Publication.PubMed.AllXML]
				cross apply x.nodes('//GrantList/Grant') as R(nref)
			where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
		) t where GrantID is not null
		group by pmid, GrantID


	--******************************************************************
	--******************************************************************
	--*** Update parse date
	--******************************************************************
	--******************************************************************

	update [Profile.Data].[Publication.PubMed.AllXML] set ParseDT = GetDate() where pmid in (select pmid from [Profile.Data].[Publication.PubMed.General.Stage])
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [User.Session].[UpdateSession]
	@SessionID UNIQUEIDENTIFIER, 
	@UserID INT=NULL, 
	@LastUsedDate DATETIME=NULL, 
	@LogoutDate DATETIME=NULL,
	@SessionPersonNodeID BIGINT = NULL OUTPUT,
	@SessionPersonURI VARCHAR(400) = NULL OUTPUT,
	@UserURI VARCHAR(400) = NULL OUTPUT,
	@SecurityGroupID BIGINT = NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	-- See if there is a PersonID associated with this session	
	DECLARE @PersonID INT
	SELECT @PersonID = PersonID
		FROM [User.Session].[Session]
		WHERE SessionID = @SessionID
	IF @PersonID IS NULL AND @UserID IS NOT NULL
		SELECT @PersonID = PersonID
			FROM [User.Account].[User]
			WHERE UserID = @UserID

	-- Get the NodeID and URI of the PersonID
	IF EXISTS (SELECT 1 FROM [Profile.Data].Person WHERE PersonID = @PersonID AND IsActive = 1)
	BEGIN
		SELECT @SessionPersonNodeID = m.NodeID, @SessionPersonURI = p.Value + CAST(m.NodeID AS VARCHAR(50))
			FROM [RDF.Stage].InternalNodeMap m, [Framework.].[Parameter] p
			WHERE m.InternalID = @PersonID
				AND m.InternalType = 'person'
				AND m.Class = 'http://xmlns.com/foaf/0.1/Person'
				AND p.ParameterID = 'baseURI'
	END

	-- Update the session data
    IF EXISTS (SELECT * FROM [User.Session].[Session] WHERE SessionID = @SessionID)
		UPDATE [User.Session].[Session]
			SET	UserID = IsNull(@UserID,UserID),
				UserNode = IsNull((SELECT NodeID FROM [User.Account].[User] WHERE UserID = @UserID AND @UserID IS NOT NULL),UserNode),
				PersonID = IsNull(@PersonID,PersonID),
				LastUsedDate = IsNull(@LastUsedDate,LastUsedDate),
				LogoutDate = IsNull(@LogoutDate,LogoutDate)
			WHERE SessionID = @SessionID

	IF @UserID IS NOT NULL
	BEGIN
		SELECT @UserURI = p.Value + CAST(m.NodeID AS VARCHAR(50))
			FROM [RDF.Stage].InternalNodeMap m, [Framework.].[Parameter] p
			WHERE m.InternalID = @UserID
				AND m.InternalType = 'User'
				AND m.Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#User'
				AND p.ParameterID = 'baseURI'
	END

	-- Get the security group of the session
	EXEC [RDF.Security].[GetSessionSecurityGroup] @SessionID = @SessionID, @SecurityGroupID = @SecurityGroupID OUTPUT
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Ontology.].[UpdateDerivedFields]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Triple
	UPDATE o
		SET	_SubjectNode = [RDF.].fnURI2NodeID(subject),
			_PredicateNode = [RDF.].fnURI2NodeID(predicate),
			_ObjectNode = [RDF.].fnURI2NodeID(object),
			_TripleID = NULL
		FROM [Ontology.Import].[Triple] o
	UPDATE o
		SET o._TripleID = r.TripleID
		FROM [Ontology.Import].[Triple] o, [RDF.].Triple r
		WHERE o._SubjectNode = r.Subject AND o._PredicateNode = r.Predicate AND o._ObjectNode = r.Object

	-- DataMap
	UPDATE o
		SET	_ClassNode = [RDF.].fnURI2NodeID(Class),
			_NetworkPropertyNode = [RDF.].fnURI2NodeID(NetworkProperty),
			_PropertyNode = [RDF.].fnURI2NodeID(property)
		FROM [Ontology.].DataMap o

	-- ClassProperty
	UPDATE o
		SET	_ClassNode = [RDF.].fnURI2NodeID(Class),
			_NetworkPropertyNode = [RDF.].fnURI2NodeID(NetworkProperty),
			_PropertyNode = [RDF.].fnURI2NodeID(property),
			_TagName = (select top 1 n.Prefix+':'+substring(o.property,len(n.URI)+1,len(o.property)) t
						from [Ontology.].Namespace n
						where o.property like n.uri+'%'
						)
		FROM [Ontology.].ClassProperty o
	UPDATE e
		SET e._PropertyLabel = o.value
		FROM [ontology.].ClassProperty e
			LEFT OUTER JOIN [RDF.].[Triple] t
				ON e._PropertyNode = t.subject AND t.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label') 
			LEFT OUTER JOIN [RDF.].[Node] o
				ON t.object = o.nodeid
	UPDATE e
		SET e._ObjectType = (CASE WHEN o.value = 'http://www.w3.org/2002/07/owl#ObjectProperty' THEN 0 ELSE 1 END)
		FROM [ontology.].ClassProperty e
			LEFT OUTER JOIN [RDF.].[Triple] t
				ON e._PropertyNode = t.subject AND t.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type') 
			LEFT OUTER JOIN [RDF.].[Node] o
				ON t.object = o.nodeid and o.value in ('http://www.w3.org/2002/07/owl#DatatypeProperty','http://www.w3.org/2002/07/owl#ObjectProperty')

	-- ClassGroup
	UPDATE o
		SET	_ClassGroupNode = [RDF.].fnURI2NodeID(ClassGroupURI)
		FROM [Ontology.].ClassGroup o
	UPDATE e
		SET e._ClassGroupLabel = o.value
		FROM [ontology.].ClassGroup e
			LEFT OUTER JOIN [RDF.].[Triple] t
				ON e._ClassGroupNode = t.subject AND t.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label') 
			LEFT OUTER JOIN [RDF.].[Node] o
				ON t.object = o.nodeid

	-- ClassGroupClass
	UPDATE o
		SET	_ClassGroupNode = [RDF.].fnURI2NodeID(ClassGroupURI),
			_ClassNode = [RDF.].fnURI2NodeID(ClassURI)
		FROM [Ontology.].ClassGroupClass o
	UPDATE e
		SET e._ClassLabel = o.value
		FROM [ontology.].ClassGroupClass e
			LEFT OUTER JOIN [RDF.].[Triple] t
				ON e._ClassNode = t.subject AND t.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label') 
			LEFT OUTER JOIN [RDF.].[Node] o
				ON t.object = o.nodeid
				
	-- ClassTreeDepth
	declare @ClassDepths table (
		NodeID bigint,
		SubClassOf bigint,
		Depth int,
		ClassURI varchar(400),
		ClassName varchar(400)
	)
	;with x as (
		select t.subject NodeID, 
			max(case when w.subject is null then null else v.object end) SubClassOf
		from [RDF.].Triple t
			left outer join [RDF.].Triple v
				on v.subject = t.subject 
				and v.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#subClassOf')
			left outer join [RDF.].Triple w
				on w.subject = v.object
				and w.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type') 
				and w.object = [RDF.].fnURI2NodeID('http://www.w3.org/2002/07/owl#Class')
		where t.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type') 
			and t.object = [RDF.].fnURI2NodeID('http://www.w3.org/2002/07/owl#Class') 
		group by t.subject
	)
	insert into @ClassDepths (NodeID, SubClassOf, Depth, ClassURI)
		select x.NodeID, x.SubClassOf, (case when x.SubClassOf is null then 0 else null end) Depth, n.Value
		from x, [RDF.].Node n
		where x.NodeID = n.NodeID
	;with a as (
		select NodeID, SubClassOf, Depth
			from @ClassDepths
		union all
		select b.NodeID, IsNull(a.NodeID,b.SubClassOf), a.Depth+1
			from a, @ClassDepths b
			where b.SubClassOf = a.NodeID
				and a.Depth is not null
				and b.Depth is null
	), b as (
		select NodeID, SubClassOf, Max(Depth) Depth
		from a
		group by NodeID, SubClassOf
	)
	update c
		set c.Depth = b.Depth
		from @ClassDepths c, b
		where c.NodeID = b.NodeID
	;with a as (
		select c.NodeID, max(n.Value) ClassName
			from @ClassDepths c
				inner join [RDF.].Triple t
					on t.subject = c.NodeID
						and t.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')
				inner join [RDF.].Node n
					on t.object = n.NodeID
			group by c.NodeID
	)
	update c
		set c.ClassName = a.ClassName
		from @ClassDepths c, a
		where c.NodeID = a.NodeID
	truncate table [Ontology.].ClassTreeDepth
	insert into [Ontology.].ClassTreeDepth (Class, _TreeDepth, _ClassNode, _ClassName)
		select ClassURI, Depth, NodeID, ClassName
			from @ClassDepths

	-- PropertyGroup
	UPDATE o
		SET	_PropertyGroupNode = [RDF.].fnURI2NodeID(PropertyGroupURI)
		FROM [Ontology.].PropertyGroup o
	UPDATE e
		SET e._PropertyGroupLabel = o.value
		FROM [ontology.].PropertyGroup e
			LEFT OUTER JOIN [RDF.].[Triple] t
				ON e._PropertyGroupNode = t.subject AND t.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label') 
			LEFT OUTER JOIN [RDF.].[Node] o
				ON t.object = o.nodeid

	-- PropertyGroupProperty
	UPDATE o
		SET	_PropertyGroupNode = [RDF.].fnURI2NodeID(PropertyGroupURI),
			_PropertyNode = [RDF.].fnURI2NodeID(PropertyURI),
			_TagName = (select top 1 n.Prefix+':'+substring(o.PropertyURI,len(n.URI)+1,len(o.PropertyURI)) t
						from [Ontology.].Namespace n
						where o.PropertyURI like n.uri+'%'
						)
		FROM [Ontology.].PropertyGroupProperty o
	UPDATE e
		SET e._PropertyLabel = o.value
		FROM [ontology.].PropertyGroupProperty e
			LEFT OUTER JOIN [RDF.].[Triple] t
				ON e._PropertyNode = t.subject AND t.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label') 
			LEFT OUTER JOIN [RDF.].[Node] o
				ON t.object = o.nodeid


	-- Presentation
	UPDATE o
		SET	_SubjectNode = [RDF.].fnURI2NodeID(subject),
			_PredicateNode = [RDF.].fnURI2NodeID(predicate),
			_ObjectNode = [RDF.].fnURI2NodeID(object)
		FROM [Ontology.Presentation].[XML] o


	-- Funding
	UPDATE [Ontology.].[ClassProperty]
		SET _PropertyLabel = 'research activities and funding' --'research activities'
		WHERE Class='http://xmlns.com/foaf/0.1/Person' AND Property='http://vivoweb.org/ontology/core#hasResearcherRole' AND NetworkProperty IS NULL

	-- Groups
	UPDATE [Ontology.].[ClassProperty]
		SET _PropertyLabel = 'members' --'research activities'
		WHERE Class='http://xmlns.com/foaf/0.1/Group' AND Property='http://vivoweb.org/ontology/core#contributingRole' AND NetworkProperty IS NULL

	UPDATE [Ontology.].[ClassProperty]
		SET _PropertyLabel = 'groups' --'research activities'
		WHERE Class='http://xmlns.com/foaf/0.1/Person' AND Property='http://vivoweb.org/ontology/core#hasMemberRole' AND NetworkProperty IS NULL

	UPDATE [Ontology.].[ClassProperty]
		SET _PropertyLabel = 'groups' --'research activities'
		WHERE Class='http://xmlns.com/foaf/0.1/Agent' AND Property='http://vivoweb.org/ontology/core#hasMemberRole' AND NetworkProperty IS NULL

	UPDATE [Ontology.].[ClassProperty]
		SET _PropertyLabel = 'selected publications' --'research activities'
		WHERE Class='http://xmlns.com/foaf/0.1/Group' AND Property='http://profiles.catalyst.harvard.edu/ontology/prns#associatedInformationResource' AND NetworkProperty IS NULL


	-- select * from [Ontology.Import].[Triple]
	-- select * from [Ontology.].ClassProperty
	-- select * from [Ontology.].ClassGroup
	-- select * from [Ontology.].ClassGroupClass
	-- select * from [Ontology.].ClassTreeDepth
	-- select * from [Ontology.].PropertyGroup
	-- select * from [Ontology.].PropertyGroupProperty
	-- select * from [Ontology.Presentation].[XML]

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Ontology.].[UpdateCounts]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @typeID BIGINT
	SELECT @typeID = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')

	-- Get ClassGroup counts
	SELECT g.ClassGroupURI, COUNT(DISTINCT t.Subject) NumberOfNodes
		INTO #ClassGroup
		FROM [Ontology.].[ClassGroup] g, [Ontology.].[ClassGroupClass] c, [RDF.].[Triple] t,
			[RDF.].[Node] s, [RDF.].[Node] p, [RDF.].[Node] o
		WHERE g.ClassGroupURI = c.ClassGroupURI and c._ClassNode = t.Object and t.Predicate = @typeID
			and t.ViewSecurityGroup = -1
			and t.subject = s.nodeid and s.ViewSecurityGroup = -1
			and t.predicate = p.nodeid and p.ViewSecurityGroup = -1
			and t.object = o.nodeid and o.ViewSecurityGroup = -1
		GROUP BY g.ClassGroupURI

	-- Get ClassGroupClass counts
	SELECT c.ClassGroupURI, c.ClassURI, COUNT(DISTINCT t.Subject) NumberOfNodes
		INTO #ClassGroupClass
		FROM [Ontology.].[ClassGroupClass] c, [RDF.].[Triple] t,
			[RDF.].[Node] s, [RDF.].[Node] p, [RDF.].[Node] o
		WHERE c._ClassNode = t.Object and t.Predicate = @typeID
			and t.ViewSecurityGroup = -1
			and t.subject = s.nodeid and s.ViewSecurityGroup = -1
			and t.predicate = p.nodeid and p.ViewSecurityGroup = -1
			and t.object = o.nodeid and o.ViewSecurityGroup = -1
		GROUP BY c.ClassGroupURI, c.ClassURI

	-- Get ClassProperty counts
	SELECT c.ClassPropertyID, COUNT(DISTINCT t.Subject) NumberOfNodes, COUNT(DISTINCT t2.TripleID) NumberOfTriples
		INTO #ClassProperty
		FROM [Ontology.].[ClassProperty] c, [RDF.].[Triple] t,
			[RDF.].[Node] s, [RDF.].[Node] p, [RDF.].[Node] o,
			[RDF.].[Triple] t2,
			[RDF.].[Node] p2, [RDF.].[Node] o2
		WHERE c._ClassNode = t.Object 
			and c._NetworkPropertyNode is null
			and t.Predicate = @typeID 
			and t.ViewSecurityGroup = -1
			and t.subject = s.nodeid and s.ViewSecurityGroup = -1
			and t.predicate = p.nodeid and p.ViewSecurityGroup = -1
			and t.object = o.nodeid and o.ViewSecurityGroup = -1
			and t2.subject = t.subject
			and t2.predicate = c._PropertyNode
			and t2.ViewSecurityGroup = -1
			and t2.predicate = p2.nodeid and p2.ViewSecurityGroup = -1
			and t2.object = o2.nodeid and o2.ViewSecurityGroup = -1
		GROUP BY c.ClassPropertyID
BEGIN TRY 
	begin transaction
		
		-- Update ClassGroup
		UPDATE o
			SET	o._NumberOfNodes = IsNull(g.NumberOfNodes,0)
			FROM [Ontology.].[ClassGroup] o
				left outer join #ClassGroup g on o.ClassGroupURI = g.ClassGroupURI

		-- Update ClassGroupClass
		UPDATE o
			SET	o._NumberOfNodes = IsNull(c.NumberOfNodes,0)
			FROM [Ontology.].[ClassGroupClass] o
				left outer join #ClassGroupClass c on o.ClassGroupURI = c.ClassGroupURI and o.ClassURI = c.ClassURI

		-- Update ClassProperty
		UPDATE o
			SET	o._NumberOfNodes = IsNull(c.NumberOfNodes,0), o._NumberOfTriples = IsNull(c.NumberOfTriples,0)
			FROM [Ontology.].[ClassProperty] o
				left outer join #ClassProperty c on o.ClassPropertyID = c.ClassPropertyID

	commit transaction
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
 
		-- Raise an error with the details of the exception
		SELECT @ErrMsg =  ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()
 
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
			 
	END CATCH		

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[SNA.Coauthor.UpdateReach]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER,@rows BIGINT 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
 
	select PersonID1 PersonID, Distance, count(*) NumPeople
		into #sna_reach_tmp
		from [Profile.Cache].[SNA.Coauthor.Distance]
		group by PersonID1, Distance
	create unique clustered index idx_pd on #sna_reach_tmp(PersonID, Distance)
 
	select 99 n into #n
	insert into #n(n)
		select n
		from [Utility.Math].N
		where n > 0 and n <= (select max(Distance) from #sna_reach_tmp where Distance < 99)
	create unique clustered index idx_n on #n(n)
 
	select p.PersonID, n.n Distance, 0 NumPeople
		into #sna_reach
		from #n n, (select distinct PersonID from #sna_reach_tmp) p
	create unique clustered index idx_pd on #sna_reach(PersonID, Distance)
 
	update s
		set s.NumPeople = t.NumPeople
		from #sna_reach s, #sna_reach_tmp t
		where s.PersonID = t.PersonID and s.Distance = t.Distance
 
 
	BEGIN TRY
		BEGIN TRAN
			TRUNCATE TABLE [Profile.Cache].[SNA.Coauthor.Reach]
				INSERT INTO [Profile.Cache].[SNA.Coauthor.Reach] (PersonID,Distance,NumPeople)
					SELECT PersonID,Distance,NumPeople FROM #sna_reach
			SELECT @rows = @@ROWCOUNT
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=0
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@ProcessedRows = @rows,@insert_new_record=0
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[SNA.Coauthor.UpdateDistance]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER,@rows BIGINT 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
 
	insert into [Profile.Cache].[SNA.Coauthor.DistanceLog] (x,d) values ('Start',getdate())
 
	create table #sna_distance(PersonID1 int, PersonID2 int, Distance tinyint, NumPaths smallint) 
 
	--create a copy of sna_coauthors so we don't lock up that table
	select PersonID1, PersonID2
		into #sna_coauthors
		from [Profile.Cache].[SNA.Coauthor]
	alter table #sna_coauthors add primary key (PersonID1, PersonID2)
 
	select i, row_number() over (order by i) k
		into #p
		from (select distinct PersonID1 i from #sna_coauthors) t
	create unique clustered index idx_k on #p(k)
	create unique nonclustered index idx_i on #p(i)
 
	DECLARE @d INT
 
	declare @maxp int
	declare @p int
	select @maxp = max(k) from #p
	set @p = 1
	while @p <= @maxp
	begin
 
		insert into [Profile.Cache].[SNA.Coauthor.DistanceLog] (x,d) values ('Started p = '+cast(@p as varchar(50)),getdate())
 
		--create empty table
		;with a as (
			select distinct personid1 i from #sna_coauthors
		)
		select a.i, b.i j, cast(99 as tinyint) d, cast(0 as smallint) s
			into #z
			from (select i from #p where k between @p and @p+999) a, #p b
			where a.i <> b.i
		set @p = @p + 1000
 
		CREATE UNIQUE CLUSTERED INDEX idx_ij ON #z(i,j)
		
		--seed table (i.e. coauthors) with default distances, num_paths
		UPDATE z 
			SET d = 1, s = 1
			FROM #z z INNER JOIN #sna_coauthors y ON z.i = y.PersonID1 and z.j = y.PersonID2
 
		
		--iterate over network by distance level, derive distances and number of paths
		SELECT @d = 1
		WHILE @d < 15 --Max depth that we will search
		BEGIN
			
			SELECT z.i, y.PersonID2 j, sum(z.s) t
				INTO #x
				FROM #z z  	   
        JOIN #sna_coauthors y ON z.d = @d AND z.j = y.PersonID1
	      JOIN #z w ON w.i = z.i AND w.j = y.PersonID2 AND w.d = 99
				GROUP BY z.i, y.PersonID2
				--OPTION(RECOMPILE)
			CREATE UNIQUE CLUSTERED INDEX idx_ij on #x(i,j)
			SELECT @d = @d + 1
			UPDATE z 
				SET d = @d, s = t
				FROM #z z  
			  JOIN #x t ON z.i = t.i AND z.j = t.j
			DROP TABLE #x
		END
 
	 
		INSERT INTO #sna_distance(PersonID1,PersonID2,Distance,NumPaths)
			SELECT i,j,d,s FROM #z
 
		drop table #z
 
	end
 
	insert into [Profile.Cache].[SNA.Coauthor.DistanceLog]  (x,d) values ('Finished loops',getdate())
 
	BEGIN TRY
		BEGIN TRAN
			TRUNCATE TABLE [Profile.Cache].[SNA.Coauthor.Distance]
				INSERT INTO [Profile.Cache].[SNA.Coauthor.Distance] (PersonID1,PersonID2,Distance,NumPaths)
					SELECT PersonID1,PersonID2,Distance,NumPaths FROM #sna_distance
			SELECT @rows = @@ROWCOUNT
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=0
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@ProcessedRows = @rows,@insert_new_record=0
 
	insert INTO [Profile.Cache].[SNA.Coauthor.DistanceLog] (x,d) values ('Completed Insert',getdate())
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[SNA.Coauthor.UpdateCoauthor]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER,@rows BIGINT 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
 
	select a.personid PersonID1, b.personid PersonID2, sum(a.AuthorWeight*b.AuthorWeight*a.YearWeight) w, min(a.PubDate) FirstPubDate, max(b.PubDate) LastPubDate, count(*) n
		into #sna_coauthors
		from [Profile.Cache].[Publication.PubMed.AuthorPosition] a, [Profile.Cache].[Publication.PubMed.AuthorPosition] b
		where a.pmid = b.pmid and a.personid <> b.personid
		group by a.personid, b.personid
 
	BEGIN TRY
		BEGIN TRAN
			TRUNCATE TABLE [Profile.Cache].[SNA.Coauthor]
			INSERT INTO [Profile.Cache].[SNA.Coauthor](personid1,personid2,w,FirstPubDate,LastPubDate,N)
				SELECT personid1,personid2,w,FirstPubDate,LastPubDate,N FROM #sna_coauthors
			SELECT @rows = @@ROWCOUNT
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=0
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@ProcessedRows = @rows,@insert_new_record=0
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Person.DeletePhoto](@PhotoID INT)
AS
BEGIN

	-- Delete the triple
	DECLARE @NodeID BIGINT
	SELECT @NodeID = PersonNodeID
		FROM [Profile.Data].[vwPerson.Photo]
		WHERE PhotoID = @PhotoID
	IF (@NodeID IS NOT NULL)
		EXEC [RDF.].[DeleteTriple] @SubjectID = @NodeID, @PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#mainImage'

	-- Delete the photo
	DELETE 
		FROM [Profile.Data].[Person.Photo]
		WHERE PhotoID=@PhotoID 

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[Person.UpdateSimilarPerson]
AS
BEGIN

	 
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER,@rows BIGINT 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
 
	create table #cache_similar_people (personid int, similarpersonid int, weight float, coauthor bit, numberOfSubjectAreas int)
 
 
 
	-- minutes
	select * into #cache_user_mesh from [Profile.Cache].[Concept.Mesh.Person]
	create unique clustered index idx_pm on #cache_user_mesh(personid,meshheader)
	declare @maxp int
	declare @p int
	select @maxp = max(personid) from [Profile.Cache].[Concept.Mesh.Person]
	set @p = 1
	while @p <= @maxp
	begin
		INSERT INTO #cache_similar_people(personid,similarpersonid,weight,coauthor,numberOfSubjectAreas)
			SELECT personid, similarpersonid, weight, 0 coauthor, numberOfSubjectAreas
			FROM (
				SELECT personid, similarpersonid, weight, numberOfSubjectAreas,
						row_number() over (partition by personid order by weight desc) k
				FROM (
					SELECT a.personid,
						b.personid similarpersonid,
						SUM(a.weight * b.weight) weight,
						count(*) numberOfSubjectAreas
					FROM #cache_user_mesh a inner join #cache_user_mesh b 
						ON a.meshheader = b.meshheader 
							AND a.personid <> b.personid 
							AND a.personid between @p and @p+999
					GROUP BY a.personid, b.personid
				) t
			) t
			WHERE k <= 60
		set @p = @p + 1000
	end
 
 
 
 
	-- Set CoAuthor Flag
	create unique clustered index idx_ps on #cache_similar_people(personid,similarpersonid)
	select distinct a.personid a, b.personid b
		into #coauthors
		from [Profile.Data].[Publication.Person.Include] a, [Profile.Data].[Publication.Person.Include] b
		where a.pmid = b.pmid and a.personid <> b.personid
	create unique clustered index idx_ab on #coauthors(a,b)
	update t 
		set coauthor = 1
		from #cache_similar_people t, #coauthors c
		where t.personid = c.a and t.similarpersonid = c.b
 
	BEGIN TRY
		BEGIN TRAN
			truncate table [Profile.Cache].[Person.SimilarPerson]
			insert into [Profile.Cache].[Person.SimilarPerson](PersonID, SimilarPersonID, Weight, CoAuthor, numberOfSubjectAreas)
				select PersonID, SimilarPersonID, Weight, CoAuthor, numberOfSubjectAreas
				from #cache_similar_people
			select @rows = @@ROWCOUNT
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate =@date,@error = 1,@insert_new_record=0
		-- Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate =@date,@ProcessedRows = @rows,@insert_new_record=0
 
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.DeleteOnePublication]
	@PersonID INT,
	@PubID varchar(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
BEGIN TRY 	 
	BEGIN TRANSACTION

		if exists (select * from [Profile.Data].[Publication.Person.Include]  where pubid = @PubID and PersonID = @PersonID)
		begin

			declare @pmid int
			declare @mpid varchar(50)

			set @pmid = (select pmid from [Profile.Data].[Publication.Person.Include] where pubid = @PubID)
			set @mpid = (select mpid from [Profile.Data].[Publication.Person.Include] where pubid = @PubID)

			insert into [Profile.Data].[Publication.Person.Exclude](pubid,PersonID,pmid,mpid)
				values (@pubid,@PersonID,@pmid,@mpid)

			delete from [Profile.Data].[Publication.Person.Include] where pubid = @PubID
			delete from [Profile.Data].[Publication.Person.Add] where pubid = @PubID

			if @pmid is not null
				delete from [Profile.Cache].[Publication.PubMed.AuthorPosition] where personid = @PersonID and pmid = @pmid

			if @pmid is not null
				delete from [Profile.Data].[Publication.PubMed.Disambiguation] where personid = @PersonID and pmid = @pmid 
				
		end

	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
 
		-- Raise an error with the details of the exception
		SELECT @ErrMsg =  ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()
 
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
			 
	END CATCH		

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.DeleteAllPublications]
	@PersonID INT,
	@deletePMID BIT = 0,
	@deleteMPID BIT = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	declare @pubids table (pubid uniqueidentifier primary key)

	insert into @pubids(pubid)
		select pubid 
			from [Profile.Data].[Publication.Person.Include] 
			where PersonID = @PersonID AND (
					( (@deletePMID = 1) AND (@deleteMPID = 0) AND (pmid is not null) )
				or	( (@deletePMID = 0) AND (@deleteMPID = 1) AND (pmid is null) AND (mpid is not null) )
				or	( (@deletePMID = 1) AND (@deleteMPID = 1) )
			)
BEGIN TRY 
	BEGIN TRANSACTION

			insert into [Profile.Data].[Publication.Person.Exclude]
			         (pubid,PersonID,pmid,mpid)
				select pubid,@PersonID,pmid,mpid 
					from [Profile.Data].[Publication.Person.Include] 
					where pubid in (select pubid from @pubids)

			delete a
				from [Profile.Cache].[Publication.PubMed.AuthorPosition] a, (
					select distinct pmid
					from [Profile.Data].[Publication.Person.Include] 
					where pubid in (select pubid from @pubids)
						and pmid is not null
				) t
				where a.personid = @PersonID and a.pmid = t.pmid

			delete from [Profile.Data].[Publication.Person.Include] 
					where pubid in (select pubid from @pubids)

			delete from [Profile.Data].[Publication.Person.Add]
					where pubid in (select pubid from @pubids)

	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
 
		-- Raise an error with the details of the exception
		SELECT @ErrMsg =  ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()
 
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
			 
	END CATCH		

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Publication.Entity.UpdateEntityOnePerson]
	@PersonID INT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

 
	-- *******************************************************************
	-- *******************************************************************
	-- Update InformationResource entities
	-- *******************************************************************
	-- *******************************************************************
 
 
	----------------------------------------------------------------------
	-- Get a list of current publications
	----------------------------------------------------------------------
 
	CREATE TABLE #Publications
	(
		PMID INT NULL ,
		MPID NVARCHAR(50) NULL ,
		PMCID NVARCHAR(55) NULL,
		doi [varchar](100) NULL,				  
		EntityDate DATETIME NULL ,
		Authors NVARCHAR(4000) NULL,
		Reference NVARCHAR(MAX) NULL ,
		Source VARCHAR(25) NULL ,
		URL VARCHAR(1000) NULL ,
		Title NVARCHAR(4000) NULL ,
		EntityID INT NULL
	)
 
	-- Add PMIDs to the publications temp table
	INSERT  INTO #Publications
            ( PMID ,
			  PMCID,
              EntityDate ,
			  Authors,
              Reference ,
              Source ,
              URL ,
              Title
            )
            SELECT -- Get Pub Med pubs
                    PG.PMID ,
					PG.PMCID,
                    EntityDate = PG.PubDate,
					authors = case when right(PG.Authors,5) = 'et al' then PG.Authors+'. '
						when PG.AuthorListCompleteYN = 'N' then PG.Authors+', et al. '
						when PG.Authors <> '' then PG.Authors+'. '
						else '' end,
                    Reference = REPLACE([Profile.Cache].[fnPublication.Pubmed.General2Reference](PG.PMID,
                                                              PG.ArticleDay,
                                                              PG.ArticleMonth,
                                                              PG.ArticleYear,
                                                              PG.ArticleTitle,
                                                              PG.Authors,
                                                              PG.AuthorListCompleteYN,
                                                              PG.Issue,
                                                              PG.JournalDay,
                                                              PG.JournalMonth,
                                                              PG.JournalYear,
                                                              PG.MedlineDate,
                                                              PG.MedlinePgn,
                                                              PG.MedlineTA,
                                                              PG.Volume, 0),
                                        CHAR(11), '') ,
                    Source = 'PubMed',
                    URL = 'http://www.ncbi.nlm.nih.gov/pubmed/' + CAST(ISNULL(PG.pmid, '') AS VARCHAR(20)),
                    Title = left((case when IsNull(PG.ArticleTitle,'') <> '' then PG.ArticleTitle else 'Untitled Publication' end),4000)
            FROM    [Profile.Data].[Publication.PubMed.General] PG
			WHERE	PG.PMID IN (
						SELECT PMID 
						FROM [Profile.Data].[Publication.Person.Include]
						WHERE PMID IS NOT NULL AND PersonID = @PersonID
					)
					AND PG.PMID NOT IN (
						SELECT PMID
						FROM [Profile.Data].[Publication.Entity.InformationResource]
						WHERE PMID IS NOT NULL)
 
	-- Add MPIDs to the publications temp table
	INSERT  INTO #Publications
            ( MPID ,
              EntityDate ,
			  Authors,
			  Reference ,
			  Source ,
              URL ,
              Title
            )
            SELECT  MPID ,
                    EntityDate ,
					Authors = REPLACE(authors, CHAR(11), '') ,
                    Reference = REPLACE( (CASE WHEN IsNull(article,'') <> '' THEN article + '. ' ELSE '' END)
										+ (CASE WHEN IsNull(pub,'') <> '' THEN pub + '. ' ELSE '' END)
										+ y
                                        + CASE WHEN y <> ''
                                                    AND vip <> '' THEN '; '
                                               ELSE ''
                                          END + vip
                                        + CASE WHEN y <> ''
                                                    OR vip <> '' THEN '.'
                                               ELSE ''
                                          END, CHAR(11), '') ,
                    Source = 'Custom' ,
                    URL = url,
                    Title = left((case when IsNull(article,'')<>'' then article when IsNull(pub,'')<>'' then pub else 'Untitled Publication' end),4000)
            FROM    ( SELECT    MPID ,
                                EntityDate ,
                                url ,
                                authors = CASE WHEN authors = '' THEN ''
                                               WHEN RIGHT(authors, 1) = '.'
                                               THEN LEFT(authors,
                                                         LEN(authors) - 1)
                                               ELSE authors
                                          END ,
                                article = CASE WHEN article = '' THEN ''
                                               WHEN RIGHT(article, 1) = '.'
                                               THEN LEFT(article,
                                                         LEN(article) - 1)
                                               ELSE article
                                          END ,
                                pub = CASE WHEN pub = '' THEN ''
                                           WHEN RIGHT(pub, 1) = '.'
                                           THEN LEFT(pub, LEN(pub) - 1)
                                           ELSE pub
                                      END ,
                                y ,
                                vip
                      FROM      ( SELECT    MPG.mpid ,
											EntityDate = MPG.publicationdt ,
                                            authors = CASE WHEN RTRIM(LTRIM(COALESCE(MPG.authors,
                                                              ''))) = ''
                                                           THEN ''
                                                           WHEN RIGHT(COALESCE(MPG.authors,
                                                              ''), 1) = '.'
                                                            THEN  COALESCE([Profile.Data].[fnPublication.MyPub.HighlightAuthors] (MPG.authors, p.FirstName, p.MiddleName, p.LastName),
                                                              '') + ' '
                                                           ELSE COALESCE([Profile.Data].[fnPublication.MyPub.HighlightAuthors] (MPG.authors, p.FirstName, p.MiddleName, p.LastName),
                                                              '') + '. '
                                                      END ,
                                            url = CASE WHEN COALESCE(MPG.url,
                                                              '') <> ''
                                                            AND LEFT(COALESCE(MPG.url,
                                                              ''), 4) = 'http'
                                                       THEN MPG.url
                                                       WHEN COALESCE(MPG.url,
                                                              '') <> ''
                                                       THEN 'http://' + MPG.url
                                                       ELSE ''
                                                  END ,
                                            article = LTRIM(RTRIM(COALESCE(MPG.articletitle,
                                                              ''))) ,
                                            pub = LTRIM(RTRIM(COALESCE(MPG.pubtitle,
                                                              ''))) ,
                                            y = CASE WHEN MPG.publicationdt > '1/1/1901'
                                                     THEN CONVERT(VARCHAR(50), YEAR(MPG.publicationdt))
                                                     ELSE ''
                                                END ,
                                            vip = COALESCE(MPG.volnum, '')
                                            + CASE WHEN COALESCE(MPG.issuepub,
                                                              '') <> ''
                                                   THEN '(' + MPG.issuepub
                                                        + ')'
                                                   ELSE ''
                                              END
                                            + CASE WHEN ( COALESCE(MPG.paginationpub,
                                                              '') <> '' )
                                                        AND ( COALESCE(MPG.volnum,
                                                              '')
                                                              + COALESCE(MPG.issuepub,
                                                              '') <> '' )
                                                   THEN ':'
                                                   ELSE ''
                                              END + COALESCE(MPG.paginationpub,
                                                             '')
                                  FROM      [Profile.Data].[Publication.MyPub.General] MPG
                                  INNER JOIN [Profile.Data].[Publication.Person.Include] PL ON MPG.mpid = PL.mpid
                                                           AND PL.mpid NOT LIKE 'DASH%'
                                                           AND PL.mpid NOT LIKE 'ISI%'
                                                           AND PL.pmid IS NULL
                                                           AND PL.PersonID = @PersonID
									join [Profile.Data].Person p on pl.PersonID = p.PersonID
									WHERE MPG.MPID NOT IN (
										SELECT MPID
										FROM [Profile.Data].[Publication.Entity.InformationResource]
										WHERE (MPID IS NOT NULL)
									)
                                ) T0
                    ) T0
 
	CREATE NONCLUSTERED INDEX idx_pmid on #publications(pmid)
	CREATE NONCLUSTERED INDEX idx_mpid on #publications(mpid)

	declare @baseURI varchar(255)
	select @baseURI = Value From [Framework.].Parameter where ParameterID = 'baseURI'
	select a.PmPubsAuthorID, a.pmid, a2p.personID, isnull(Lastname + ' ' + Initials, CollectiveName) as Name, case when nodeID is not null then'<a href="' + @baseURI + cast(i.nodeID as varchar(55)) + '">'+ Lastname + ' ' + Initials + '</a>' else isnull(Lastname + ' ' + Initials, CollectiveName) END as link into #tmpAuthorLinks from [Profile.Data].[Publication.PubMed.Author] a
		join [Profile.Data].[Publication.Person.Include] p on a.pmid = p.pmid and p.PersonID = @personID
		left outer join [Profile.Data].[Publication.PubMed.Author2Person] a2p on a.PmPubsAuthorID = a2p.PmPubsAuthorID
		left outer join [RDF.Stage].InternalNodeMap i on a2p.PersonID = i.InternalID and i.class = 'http://xmlns.com/foaf/0.1/Person'

	select pmid, [Profile.Data].[fnPublication.Pubmed.ShortenAuthorLengthString](replace(replace(isnull(cast((
		select ', '+ link
		from #tmpAuthorLinks q
		where q.pmid = p.pmid
		order by PmPubsAuthorID
		for xml path(''), type
		) as nvarchar(max)),''), '&lt;' , '<'), '&gt;', '>')) s
		into #tmpPublicationLinks from #publications p where pmid is not null

	update g set g.Authors = t.s from #publications g
		join #tmpPublicationLinks t on g.PMID = t.PMID
	----------------------------------------------------------------------
	-- Update the Publication.Entity.InformationResource table
	--
	-- Commented out, we don't update publications in the one person/group version
	----------------------------------------------------------------------
 /*
	-- Determine which publications already exist
	UPDATE p
		SET p.EntityID = e.EntityID
		FROM #publications p, [Profile.Data].[Publication.Entity.InformationResource] e
		WHERE p.PMID = e.PMID and p.PMID is not null
	UPDATE p
		SET p.EntityID = e.EntityID
		FROM #publications p, [Profile.Data].[Publication.Entity.InformationResource] e
		WHERE p.MPID = e.MPID and p.MPID is not null
	CREATE NONCLUSTERED INDEX idx_entityid on #publications(EntityID)

	-- Deactivate old publications
	UPDATE e
		SET e.IsActive = 0
		FROM [Profile.Data].[Publication.Entity.InformationResource] e
		WHERE e.EntityID NOT IN (SELECT EntityID FROM #publications)											  
	-- Update the data for existing publications
	UPDATE e
		SET e.EntityDate = p.EntityDate,
			e.pmcid = p.pmcid,
			e.doi = p.doi,	 
			e.Authors = p.Authors,
			e.Reference = p.Reference,
			e.Source = p.Source,
			e.URL = p.URL,
			e.EntityName = p.Title,
			e.IsActive = 1,
			e.PubYear = year(p.EntityDate),
            e.YearWeight = (case when p.EntityDate is null then 0.5
                when year(p.EntityDate) <= 1901 then 0.5
                else power(cast(0.5 as float),cast(datediff(d,p.EntityDate,GetDate()) as float)/365.25/10)
                end)
		FROM #publications p, [Profile.Data].[Publication.Entity.InformationResource] e
		WHERE p.EntityID = e.EntityID and p.EntityID is not null
*/
	-- Insert new publications
	INSERT INTO [Profile.Data].[Publication.Entity.InformationResource] (
			PMID,
			PMCID,
			MPID,
			EntityName,
			EntityDate,
			Authors,
			Reference,
			Source,
			URL,
			IsActive,
			PubYear,
			YearWeight
		)
		SELECT 	PMID,
				PMCID,
				MPID,
				Title,
				EntityDate,
				Authors,
				Reference,
				Source,
				URL,
				1 IsActive,
				PubYear = year(EntityDate),
				YearWeight = (case when EntityDate is null then 0.5
								when year(EntityDate) <= 1901 then 0.5
								else power(cast(0.5 as float),cast(datediff(d,EntityDate,GetDate()) as float)/365.25/10)
								end)
		FROM #publications
		WHERE EntityID IS NULL
 
	-- *******************************************************************
	-- *******************************************************************
	-- Update Authorship entities
	-- *******************************************************************
	-- *******************************************************************
 
 	----------------------------------------------------------------------
	-- Get a list of current Authorship records
	----------------------------------------------------------------------

	CREATE TABLE #Authorship
	(
		EntityDate DATETIME NULL ,
		authorRank INT NULL,
		numberOfAuthors INT NULL,
		authorNameAsListed VARCHAR(255) NULL,
		AuthorWeight FLOAT NULL,
		AuthorPosition VARCHAR(1) NULL,
		PubYear INT NULL ,
		YearWeight FLOAT NULL ,
		PersonID INT NULL ,
		InformationResourceID INT NULL,
		PMID INT NULL,
		IsActive BIT,
		EntityID INT,			   
		AuthorsString varchar(max)	   
	)
 
	INSERT INTO #Authorship (EntityDate, PersonID, InformationResourceID, PMID, IsActive)
		SELECT e.EntityDate, i.PersonID, e.EntityID, e.PMID, 1 IsActive
			FROM [Profile.Data].[Publication.Entity.InformationResource] e,
				[Profile.Data].[Publication.Person.Include] i
			WHERE (e.PMID = i.PMID) and (e.PMID is not null) and (i.PersonID = @PersonID)
	INSERT INTO #Authorship (EntityDate, PersonID, InformationResourceID, PMID, IsActive)
		SELECT e.EntityDate, i.PersonID, e.EntityID, null PMID, 1 IsActive
			FROM [Profile.Data].[Publication.Entity.InformationResource] e,
				[Profile.Data].[Publication.Person.Include] i
			WHERE (e.MPID = i.MPID) and (e.MPID is not null) and (e.PMID is null) and (i.PersonID = @PersonID)
	CREATE NONCLUSTERED INDEX idx_person_pmid ON #Authorship(PersonID, PMID)
	CREATE NONCLUSTERED INDEX idx_person_pub ON #Authorship(PersonID, InformationResourceID)
 
	UPDATE a
		SET	a.authorRank=p.authorRank,
			a.numberOfAuthors=p.numberOfAuthors,
			a.authorNameAsListed=p.authorNameAsListed, 
			a.AuthorWeight=p.AuthorWeight, 
			a.AuthorPosition=p.AuthorPosition,
			a.PubYear=p.PubYear,
			a.YearWeight=p.YearWeight
		FROM #Authorship a, [Profile.Cache].[Publication.PubMed.AuthorPosition]  p
		WHERE a.PersonID = p.PersonID and a.PMID = p.PMID and a.PMID is not null
	UPDATE #authorship
		SET authorWeight = 0.5
		WHERE authorWeight IS NULL
	UPDATE #authorship
		SET authorPosition = 'U'
		WHERE authorPosition IS NULL
	UPDATE #authorship
		SET PubYear = year(EntityDate)
		WHERE PubYear IS NULL
	UPDATE #authorship
		SET	YearWeight = (case when EntityDate is null then 0.5
							when year(EntityDate) <= 1901 then 0.5
							else power(cast(0.5 as float),cast(datediff(d,EntityDate,GetDate()) as float)/365.25/10)
							end)
		WHERE YearWeight IS NULL

																												select pmid, personID, [Profile.Data].[fnPublication.Pubmed.ShortenAuthorLengthString](replace(replace(isnull(cast((
		select ', '+case when p.personID = q.personID then '<b>' + name + '</b>' else link end
		from #tmpAuthorLinks q
		where q.pmid = p.pmid
		order by PmPubsAuthorID
		for xml path(''), type
	) as nvarchar(max)),''), '&lt;' , '<'), '&gt;', '>')) s
	into #tmp2 from #Authorship p where pmid is not null

	update a set a.s = case when right(a.s,5) = 'et al' then a.s+'. '
								when g.AuthorListCompleteYN = 'N' then a.s+', et al. '
								when a.s <> '' then a.s+'. '
								else '' end
		from #tmp2 a join [Profile.Data].[Publication.PubMed.General] g on a.PMID = g.PMID


	update a set a.AuthorsString = b.s from #Authorship a join #tmp2 b on a.pmid = b.PMID and a.PersonID = b.PersonID																																																											   
	----------------------------------------------------------------------
	-- Update the Publication.Authorship table
	----------------------------------------------------------------------
 
	-- Determine which authorships already exist
	UPDATE a
		SET a.EntityID = e.EntityID
		FROM #authorship a, [Profile.Data].[Publication.Entity.Authorship] e
		WHERE a.PersonID = e.PersonID and a.InformationResourceID = e.InformationResourceID
 	CREATE NONCLUSTERED INDEX idx_entityid on #authorship(EntityID)											 

	-- Deactivate old authorships				
	UPDATE a
		SET a.IsActive = 0
		FROM [Profile.Data].[Publication.Entity.Authorship] a							
		WHERE a.EntityID NOT IN (SELECT EntityID FROM #authorship)
			and PersonID = @PersonID

	-- Update the data for existing authorships										
	UPDATE e
		SET e.EntityDate = a.EntityDate,
			e.authorRank = a.authorRank,
			e.numberOfAuthors = a.numberOfAuthors,
			e.authorNameAsListed = a.authorNameAsListed,
			e.authorWeight = a.authorWeight,
			e.authorPosition = a.authorPosition,
			e.PubYear = a.PubYear,
			e.YearWeight = a.YearWeight,
			e.IsActive = 1,
			e.AuthorsString = a.AuthorsString						
		FROM #authorship a, [Profile.Data].[Publication.Entity.Authorship] e
		WHERE a.EntityID = e.EntityID and a.EntityID is not null
	-- Insert new Authorships
	INSERT INTO [Profile.Data].[Publication.Entity.Authorship] (
			EntityDate,
			authorRank,
			numberOfAuthors,
			authorNameAsListed,
			authorWeight,
			authorPosition,
			PubYear,
			YearWeight,
			PersonID,
			InformationResourceID,
			IsActive,
			AuthorsString
		)
		SELECT 	EntityDate,
				authorRank,
				numberOfAuthors,
				authorNameAsListed,
				authorWeight,
				authorPosition,
				PubYear,
				YearWeight,
				PersonID,
				InformationResourceID,
				IsActive,
				AuthorsString
		FROM #authorship a
		WHERE EntityID IS NULL
		
	-- Assign an EntityName
	UPDATE [Profile.Data].[Publication.Entity.Authorship]
		SET EntityName = 'Authorship ' + CAST(EntityID as VARCHAR(50))
		WHERE PersonID = @PersonID AND EntityName is null


	-- *******************************************************************
	-- *******************************************************************
	-- Update RDF
	-- *******************************************************************
	-- *******************************************************************



	--------------------------------------------------------------
	-- Version 3 : Create stub RDF
	--------------------------------------------------------------

	CREATE TABLE #sql (
		i INT IDENTITY(0,1) PRIMARY KEY,
		s NVARCHAR(MAX)
	)
	INSERT INTO #sql (s)
		SELECT	'EXEC [RDF.Stage].ProcessDataMap '
					+'  @DataMapID = '+CAST(DataMapID AS VARCHAR(50))
					+', @InternalIdIn = '+InternalIdIn
					+', @TurnOffIndexing=0, @SaveLog=0; '
		FROM (
			SELECT *, '''SELECT CAST(EntityID AS VARCHAR(50)) FROM [Profile.Data].[Publication.Entity.Authorship] WHERE PersonID = '+CAST(@PersonID AS VARCHAR(50))+'''' InternalIdIn
				FROM [Ontology.].DataMap
				WHERE class = 'http://vivoweb.org/ontology/core#Authorship'
					AND NetworkProperty IS NULL
					AND Property IS NULL
			UNION ALL
			SELECT *, '''' + CAST(@PersonID AS VARCHAR(50)) + '''' InternalIdIn
				FROM [Ontology.].DataMap
				WHERE class = 'http://xmlns.com/foaf/0.1/Person' 
					AND property = 'http://vivoweb.org/ontology/core#authorInAuthorship'
					AND NetworkProperty IS NULL
		) t
		ORDER BY DataMapID

	DECLARE @s NVARCHAR(MAX)
	WHILE EXISTS (SELECT * FROM #sql)
	BEGIN
		SELECT @s = s
			FROM #sql
			WHERE i = (SELECT MIN(i) FROM #sql)
		print @s
		EXEC sp_executesql @s
		DELETE
			FROM #sql
			WHERE i = (SELECT MIN(i) FROM #sql)
	END

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Publication.Entity.UpdateEntity]

AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

 
	-- *******************************************************************
	-- *******************************************************************
	-- Update InformationResource entities
	-- *******************************************************************
	-- *******************************************************************
 
 
	----------------------------------------------------------------------
	-- Get a list of current publications
	----------------------------------------------------------------------

	CREATE TABLE #Publications
	(
		PMID INT NULL ,
		MPID NVARCHAR(50) NULL ,
		PMCID NVARCHAR(55) NULL,
		doi [varchar](100) NULL,
		EntityDate DATETIME NULL ,
		Authors NVARCHAR(4000) NULL,
		Reference NVARCHAR(MAX) NULL ,
		Source VARCHAR(25) NULL ,
		URL VARCHAR(1000) NULL ,
		Title NVARCHAR(4000) NULL ,
		EntityID INT NULL
	)
 
	-- Add PMIDs to the publications temp table
	INSERT  INTO #Publications
            ( PMID ,
			  PMCID,
			  doi,
              EntityDate ,
			  Authors,
              Reference ,
              Source ,
              URL ,
              Title
            )
            SELECT -- Get Pub Med pubs
                    PG.PMID ,
					PG.PMCID,
					PG.doi,
                    EntityDate = PG.PubDate,
					authors = case when right(PG.Authors,5) = 'et al' then PG.Authors+'. '
								when PG.AuthorListCompleteYN = 'N' then PG.Authors+', et al. '
								when PG.Authors <> '' then PG.Authors+'. '
								else '' end,
                    Reference = REPLACE([Profile.Cache].[fnPublication.Pubmed.General2Reference](PG.PMID,
                                                              PG.ArticleDay,
                                                              PG.ArticleMonth,
                                                              PG.ArticleYear,
                                                              PG.ArticleTitle,
                                                              PG.Authors,
                                                              PG.AuthorListCompleteYN,
                                                              PG.Issue,
                                                              PG.JournalDay,
                                                              PG.JournalMonth,
                                                              PG.JournalYear,
                                                              PG.MedlineDate,
                                                              PG.MedlinePgn,
                                                              PG.MedlineTA,
                                                              PG.Volume, 0),
                                        CHAR(11), '') ,
                    Source = 'PubMed',
                    URL = 'http://www.ncbi.nlm.nih.gov/pubmed/' + CAST(ISNULL(PG.pmid, '') AS VARCHAR(20)),
                    Title = left((case when IsNull(PG.ArticleTitle,'') <> '' then PG.ArticleTitle else 'Untitled Publication' end),4000)
            FROM    [Profile.Data].[Publication.PubMed.General] PG
			WHERE	PG.PMID IN (
						SELECT PMID 
							FROM [Profile.Data].[Publication.Person.Include]
							WHERE PMID IS NOT NULL
						UNION
						SELECT PMID 
							FROM [Profile.Data].[Publication.Group.Include]
							WHERE PMID IS NOT NULL)
	   
	-- Add MPIDs to the publications temp table
	INSERT  INTO #Publications
            ( MPID ,
              EntityDate ,
			  Authors,
			  Reference ,
			  Source ,
              URL ,
              Title
            )
            SELECT  MPID ,
                    EntityDate ,
					Authors = REPLACE(authors, CHAR(11), '') ,
                    Reference = REPLACE( (CASE WHEN IsNull(article,'') <> '' THEN article + '. ' ELSE '' END)
										+ (CASE WHEN IsNull(pub,'') <> '' THEN pub + '. ' ELSE '' END)
										+ y
                                        + CASE WHEN y <> ''
                                                    AND vip <> '' THEN '; '
                                               ELSE ''
                                          END + vip
                                        + CASE WHEN y <> ''
                                                    OR vip <> '' THEN '.'
                                               ELSE ''
                                          END, CHAR(11), '') ,
                    Source = 'Custom' ,
                    URL = url,
                    Title = left((case when IsNull(article,'')<>'' then article when IsNull(pub,'')<>'' then pub else 'Untitled Publication' end),4000)
            FROM    ( SELECT    MPID ,
                                EntityDate ,
                                url ,
                                authors = CASE WHEN authors = '' THEN ''
                                               WHEN RIGHT(authors, 1) = '.'
                                               THEN LEFT(authors,
                                                         LEN(authors) - 1)
                                               ELSE authors
                                          END ,
                                article = CASE WHEN article = '' THEN ''
                                               WHEN RIGHT(article, 1) = '.'
                                               THEN LEFT(article,
                                                         LEN(article) - 1)
                                               ELSE article
                                          END ,
                                pub = CASE WHEN pub = '' THEN ''
                                           WHEN RIGHT(pub, 1) = '.'
                                           THEN LEFT(pub, LEN(pub) - 1)
                                           ELSE pub
                                      END ,
                                y ,
                                vip
                      FROM      ( SELECT    MPG.mpid ,
                                            EntityDate = MPG.publicationdt ,
                                            authors = CASE WHEN RTRIM(LTRIM(COALESCE(MPG.authors,
                                                              ''))) = ''
                                                           THEN ''
                                                           WHEN RIGHT(COALESCE(MPG.authors,
                                                              ''), 1) = '.'
                                                            THEN  COALESCE([Profile.Data].[fnPublication.MyPub.HighlightAuthors] (MPG.authors, p.FirstName, p.MiddleName, p.LastName),
                                                              '') + ' '
                                                           ELSE COALESCE([Profile.Data].[fnPublication.MyPub.HighlightAuthors] (MPG.authors, p.FirstName, p.MiddleName, p.LastName),
                                                              '') + '. '
                                                      END ,
                                            url = CASE WHEN COALESCE(MPG.url,
                                                              '') <> ''
                                                            AND LEFT(COALESCE(MPG.url,
                                                              ''), 4) = 'http'
                                                       THEN MPG.url
                                                       WHEN COALESCE(MPG.url,
                                                              '') <> ''
                                                       THEN 'http://' + MPG.url
                                                       ELSE ''
                                                  END ,
                                            article = LTRIM(RTRIM(COALESCE(MPG.articletitle,
                                                              ''))) ,
                                            pub = LTRIM(RTRIM(COALESCE(MPG.pubtitle,
                                                              ''))) ,
                                            y = CASE WHEN MPG.publicationdt > '1/1/1901'
                                                     THEN CONVERT(VARCHAR(50), YEAR(MPG.publicationdt))
                                                     ELSE ''
                                                END ,
                                            vip = COALESCE(MPG.volnum, '')
                                            + CASE WHEN COALESCE(MPG.issuepub,
                                                              '') <> ''
                                                   THEN '(' + MPG.issuepub
                                                        + ')'
                                                   ELSE ''
                                              END
                                            + CASE WHEN ( COALESCE(MPG.paginationpub,
                                                              '') <> '' )
                                                        AND ( COALESCE(MPG.volnum,
                                                              '')
                                                              + COALESCE(MPG.issuepub,
                                                              '') <> '' )
                                                   THEN ':'
                                                   ELSE ''
                                              END + COALESCE(MPG.paginationpub,
                                                             '')
                                  FROM      [Profile.Data].[Publication.MyPub.General] MPG
                                  INNER JOIN [Profile.Data].[Publication.Person.Include] PL ON MPG.mpid = PL.mpid
                                                           AND PL.mpid NOT LIKE 'DASH%'
                                                           AND PL.mpid NOT LIKE 'ISI%'
                                                           AND PL.pmid IS NULL
									join [Profile.Data].Person p on pl.PersonID = p.PersonID
                                ) T0
                    ) T0
 
	CREATE NONCLUSTERED INDEX idx_pmid on #publications(pmid)
	CREATE NONCLUSTERED INDEX idx_mpid on #publications(mpid)

	declare @baseURI varchar(255)
	select @baseURI = Value From [Framework.].Parameter where ParameterID = 'baseURI'
	select a.PmPubsAuthorID, a.pmid, a2p.personID, isnull(Lastname + ' ' + Initials, CollectiveName) as Name, case when nodeID is not null then'<a href="' + @baseURI + cast(i.nodeID as varchar(55)) + '">'+ Lastname + ' ' + Initials + '</a>' else isnull(Lastname + ' ' + Initials, CollectiveName) END as link into #tmpAuthorLinks from [Profile.Data].[Publication.PubMed.Author] a 
		left outer join [Profile.Data].[Publication.PubMed.Author2Person] a2p on a.PmPubsAuthorID = a2p.PmPubsAuthorID
		left outer join [RDF.Stage].InternalNodeMap i on a2p.PersonID = i.InternalID and i.class = 'http://xmlns.com/foaf/0.1/Person'

	select pmid, [Profile.Data].[fnPublication.Pubmed.ShortenAuthorLengthString](replace(replace(isnull(cast((
		select ', '+ link
		from #tmpAuthorLinks q
		where q.pmid = p.pmid
		order by PmPubsAuthorID
		for xml path(''), type
		) as nvarchar(max)),''), '&lt;' , '<'), '&gt;', '>')) s
		into #tmpPublicationLinks from #publications p where pmid is not null

	update g set g.Authors = t.s from #publications g
		join #tmpPublicationLinks t on g.PMID = t.PMID 

	----------------------------------------------------------------------
	-- Update the Publication.Entity.InformationResource table
	----------------------------------------------------------------------

	-- Determine which publications already exist
	UPDATE p
		SET p.EntityID = e.EntityID
		FROM #publications p, [Profile.Data].[Publication.Entity.InformationResource] e
		WHERE p.PMID = e.PMID and p.PMID is not null
	UPDATE p
		SET p.EntityID = e.EntityID
		FROM #publications p, [Profile.Data].[Publication.Entity.InformationResource] e
		WHERE p.MPID = e.MPID and p.MPID is not null
	CREATE NONCLUSTERED INDEX idx_entityid on #publications(EntityID)

	-- Deactivate old publications
	UPDATE e
		SET e.IsActive = 0
		FROM [Profile.Data].[Publication.Entity.InformationResource] e
		WHERE e.EntityID NOT IN (SELECT EntityID FROM #publications)

	-- Update the data for existing publications
	UPDATE e
		SET e.EntityDate = p.EntityDate,
			e.pmcid = p.pmcid,
			e.doi = p.doi,
			e.Authors = p.Authors,
			e.Reference = p.Reference,
			e.Source = p.Source,
			e.URL = p.URL,
			e.EntityName = p.Title,
			e.IsActive = 1,
			e.PubYear = year(p.EntityDate),
            e.YearWeight = (case when p.EntityDate is null then 0.5
                when year(p.EntityDate) <= 1901 then 0.5
                else power(cast(0.5 as float),cast(datediff(d,p.EntityDate,GetDate()) as float)/365.25/10)
                end)
		FROM #publications p, [Profile.Data].[Publication.Entity.InformationResource] e
		WHERE p.EntityID = e.EntityID and p.EntityID is not null

	-- Insert new publications
	INSERT INTO [Profile.Data].[Publication.Entity.InformationResource] (
			PMID,
			PMCID,
			doi,
			MPID,
			EntityName,
			EntityDate,
			Authors,
			Reference,
			Source,
			URL,
			IsActive,
			PubYear,
			YearWeight
		)
		SELECT 	PMID,
				PMCID,
				doi,
				MPID,
				Title,
				EntityDate,
				Authors,
				Reference,
				Source,
				URL,
				1 IsActive,
				PubYear = year(EntityDate),
				YearWeight = (case when EntityDate is null then 0.5
								when year(EntityDate) <= 1901 then 0.5
								else power(cast(0.5 as float),cast(datediff(d,EntityDate,GetDate()) as float)/365.25/10)
								end)
		FROM #publications
		WHERE EntityID IS NULL

 
	-- *******************************************************************
	-- *******************************************************************
	-- Update Authorship entities
	-- *******************************************************************
	-- *******************************************************************
 
 	----------------------------------------------------------------------
	-- Get a list of current Authorship records
	----------------------------------------------------------------------

	CREATE TABLE #Authorship
	(
		EntityDate DATETIME NULL ,
		authorRank INT NULL,
		numberOfAuthors INT NULL,
		authorNameAsListed VARCHAR(255) NULL,
		AuthorWeight FLOAT NULL,
		AuthorPosition VARCHAR(1) NULL,
		PubYear INT NULL ,
		YearWeight FLOAT NULL ,
		PersonID INT NULL ,
		InformationResourceID INT NULL,
		PMID INT NULL,
		IsActive BIT,
		EntityID INT,
		AuthorsString varchar(max)
	)
 
	INSERT INTO #Authorship (EntityDate, PersonID, InformationResourceID, PMID, IsActive)
		SELECT e.EntityDate, i.PersonID, e.EntityID, e.PMID, 1 IsActive
			FROM [Profile.Data].[Publication.Entity.InformationResource] e,
				[Profile.Data].[Publication.Person.Include] i
			WHERE e.PMID = i.PMID and e.PMID is not null
	INSERT INTO #Authorship (EntityDate, PersonID, InformationResourceID, PMID, IsActive)
		SELECT e.EntityDate, i.PersonID, e.EntityID, null PMID, 1 IsActive
			FROM [Profile.Data].[Publication.Entity.InformationResource] e,
				[Profile.Data].[Publication.Person.Include] i
			WHERE (e.MPID = i.MPID) and (e.MPID is not null) and (e.PMID is null)
	CREATE NONCLUSTERED INDEX idx_person_pmid ON #Authorship(PersonID, PMID)
	CREATE NONCLUSTERED INDEX idx_person_pub ON #Authorship(PersonID, InformationResourceID)

	UPDATE a
		SET	a.authorRank=p.authorRank,
			a.numberOfAuthors=p.numberOfAuthors,
			a.authorNameAsListed=p.authorNameAsListed, 
			a.AuthorWeight=p.AuthorWeight, 
			a.AuthorPosition=p.AuthorPosition,
			a.PubYear=p.PubYear,
			a.YearWeight=p.YearWeight
		FROM #Authorship a, [Profile.Cache].[Publication.PubMed.AuthorPosition]  p
		WHERE a.PersonID = p.PersonID and a.PMID = p.PMID and a.PMID is not null
	UPDATE #authorship
		SET authorWeight = 0.5
		WHERE authorWeight IS NULL
	UPDATE #authorship
		SET authorPosition = 'U'
		WHERE authorPosition IS NULL
	UPDATE #authorship
		SET PubYear = year(EntityDate)
		WHERE PubYear IS NULL
	UPDATE #authorship
		SET	YearWeight = (case when EntityDate is null then 0.5
							when year(EntityDate) <= 1901 then 0.5
							else power(cast(0.5 as float),cast(datediff(d,EntityDate,GetDate()) as float)/365.25/10)
							end)
		WHERE YearWeight IS NULL

		select pmid, personID, [Profile.Data].[fnPublication.Pubmed.ShortenAuthorLengthString](replace(replace(isnull(cast((
		select ', '+case when p.personID = q.personID then '<b>' + name + '</b>' else link end
		from #tmpAuthorLinks q
		where q.pmid = p.pmid
		order by PmPubsAuthorID
		for xml path(''), type
	) as nvarchar(max)),''), '&lt;' , '<'), '&gt;', '>')) s
	into #tmp2 from #Authorship p where pmid is not null

	update a set a.s = case when right(a.s,5) = 'et al' then a.s+'. '
								when g.AuthorListCompleteYN = 'N' then a.s+', et al. '
								when a.s <> '' then a.s+'. '
								else '' end
		from #tmp2 a join [Profile.Data].[Publication.PubMed.General] g on a.PMID = g.PMID


	update a set a.AuthorsString = b.s from #Authorship a join #tmp2 b on a.pmid = b.PMID and a.PersonID = b.PersonID
	----------------------------------------------------------------------
	-- Update the Publication.Authorship table
	----------------------------------------------------------------------

	-- Determine which authorships already exist
	UPDATE a
		SET a.EntityID = e.EntityID
		FROM #authorship a, [Profile.Data].[Publication.Entity.Authorship] e
		WHERE a.PersonID = e.PersonID and a.InformationResourceID = e.InformationResourceID
 	CREATE NONCLUSTERED INDEX idx_entityid on #authorship(EntityID)

	-- Deactivate old authorships
	UPDATE a
		SET a.IsActive = 0
		FROM [Profile.Data].[Publication.Entity.Authorship] a
		WHERE a.EntityID NOT IN (SELECT EntityID FROM #authorship)

	-- Update the data for existing authorships
	UPDATE e
		SET e.EntityDate = a.EntityDate,
			e.authorRank = a.authorRank,
			e.numberOfAuthors = a.numberOfAuthors,
			e.authorNameAsListed = a.authorNameAsListed,
			e.authorWeight = a.authorWeight,
			e.authorPosition = a.authorPosition,
			e.PubYear = a.PubYear,
			e.YearWeight = a.YearWeight,
			e.IsActive = 1,
			e.AuthorsString = a.AuthorsString
		FROM #authorship a, [Profile.Data].[Publication.Entity.Authorship] e
		WHERE a.EntityID = e.EntityID and a.EntityID is not null

	-- Insert new Authorships
	INSERT INTO [Profile.Data].[Publication.Entity.Authorship] (
			EntityDate,
			authorRank,
			numberOfAuthors,
			authorNameAsListed,
			authorWeight,
			authorPosition,
			PubYear,
			YearWeight,
			PersonID,
			InformationResourceID,
			IsActive,
			AuthorsString
		)
		SELECT 	EntityDate,
				authorRank,
				numberOfAuthors,
				authorNameAsListed,
				authorWeight,
				authorPosition,
				PubYear,
				YearWeight,
				PersonID,
				InformationResourceID,
				IsActive,
				AuthorsString
		FROM #authorship a
		WHERE EntityID IS NULL

	-- Assign an EntityName
	UPDATE [Profile.Data].[Publication.Entity.Authorship]
		SET EntityName = 'Authorship ' + CAST(EntityID as VARCHAR(50))
		WHERE EntityName is null
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[Person.UpdatePerson]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER,@rows BIGINT 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
 
 
 
	SELECT p2.*,
				 (SELECT CAST((SELECT p.personid                                                                                               "PersonID",
					displayname                                                                                              "Name/FullName",
					firstname                                                                                                "Name/FirstName",
					NULL                                                                                                     "Name/MiddleName",
					lastname                                                                                                 "Name/LastName",
					NULL                                                                                                     "Name/SuffixString", 
					addressline1                                                                                             "Address/Address1",
					addressline2                                                                                             "Address/Address2",
					addressline3                                                                                             "Address/Address3",
					addressline4                                                                                             "Address/Address4",
					phone                                                                                                    "Address/Telephone",
					LTRIM(RTRIM(fax))                                                                                        "Address/Fax",
					latitude                                                                                                 "Address/Latitude",
					longitude                                                                                                "Address/Longitude",
					(SELECT personfiltercategory "PersonFilter/@Category",
									personfilter         "PersonFilter"
						 FROM [Profile.Data].[Person.FilterRelationship]  ptr
					   JOIN [Profile.Data].[Person.Filter] pf ON pf.personfilterid = ptr.personfilterid
						WHERE ptr.personid = p.personid
						ORDER BY personfiltersort ASC
					 FOR XML PATH(''),TYPE) AS "PersonFilterList",
					'true'                                                                                                   "AffiliationList/@Visible",
					(SELECT CASE 
										WHEN isprimary = 1 THEN 'true'
										ELSE 'false'
									END "Affiliation/@Primary",
									ROW_NUMBER()
									OVER(PARTITION BY p.personid ORDER BY institutionname) "Affiliation/AffiliationID",
									institutionabbreviation                                "Affiliation/InstitutionAbbreviation",
									institutionname                                        "Affiliation/InstitutionName",
									departmentname                                         "Affiliation/DepartmentName",
									divisionname                                       "Affiliation/DivisionName",
									title                                                  "Affiliation/JobTitle",
									fr.facultyranksort										"Affiliation/FacultyType/@FacultyTypeSort",
									fr.facultyrank                                          "Affiliation/FacultyType"
						 FROM [Profile.Data].[Person.Affiliation] p2 
			  LEFT JOIN [Profile.Data].[Organization.Institution] ins ON p2.institutionid = ins.institutionid 
				LEFT JOIN [Profile.Data].[Organization.Department] dp 	ON dp.departmentid = p2.departmentid 
			  LEFT JOIN [Profile.Data].[Person.FacultyRank] fr 	ON fr.facultyrankid = p2.facultyrankid
						WHERE p2.personid = p.personid
						ORDER BY isprimary DESC
					 FOR XML		PATH(''),TYPE) AS "AffiliationList",
 
 
 
					(SELECT TOP 1 fr.facultyranksort
						FROM [Profile.Data].[Person.Affiliation] p2 
							INNER JOIN [Profile.Data].[Person.FacultyRank] fr
								ON fr.facultyrankid = p2.facultyrankid
						WHERE p2.personid = p.personid
						ORDER BY fr.facultyranksort)																		"AcademicRank/@AcademicRankSort",
					(SELECT TOP 1 fr.facultyrank 
						FROM [Profile.Data].[Person.Affiliation] p2 
							INNER JOIN [Profile.Data].[Person.FacultyRank] fr
								ON fr.facultyrankid = p2.facultyrankid
						WHERE p2.personid = p.personid
						ORDER BY fr.facultyranksort)																		"AcademicRank",
 
 
 
 
					'true'                                                                                                   "ProfileURL/@Visible",
					(SELECT VALUE
						 FROM [Framework.].[Parameter]
						WHERE value = 'ProfilesURL') +  CAST(p.personid AS VARCHAR(20)) "ProfileURL", 
					'true' "EmailImageUrl/@Visible",
					emailaddr                                                                                                "EmailImageUrl",
					CASE 
						WHEN showphoto = 'Y' THEN 'true'
						ELSE 'false'
					END                                             "PhotoUrl/@Visible",
					CASE 
						WHEN showphoto = 'Y' THEN ''
						ELSE ''
					END        
    FROM [Profile.Data].vwPerson p
		WHERE p.personid = p2.personid
		FOR XML  PATH(''),TYPE) AS XML)) person_xml,
		0 HasPublications, 0 HasSNA, 0 Reach1, 0 Reach2, cast(0 as float) Closeness, cast(0 as float) Betweenness
	into #cache_person
	FROM [Profile.Data].vwperson p2
 
	select p.personid, 
			isnull(i.n,0) NumPublications,
			(case when isnull(i.n,0) > 0 then 1 else 0 end) HasPublications,
			(case when isnull(s.clustersize,0)>1000 then 1 else 0 end) HasSNA,
			isnull(d.NumPeople,0) Reach1,
			isnull(r.NumPeople,0) Reach2,
			isnull(c.Closeness,0) Closeness,
			isnull(b.b,0) Betweenness
		into #cache_sna
		from #cache_person p
			left outer join (select personid, count(*) n from [Profile.Data].[Publication.Person.Include] group by personid) i on p.personid = i.personid
			left outer join (select * from [Profile.Cache].[SNA.Coauthor.Reach] where distance = 1) d on p.personid = d.personid
			left outer join (select * from [Profile.Cache].[SNA.Coauthor.Reach] where distance = 2) r on p.personid = r.personid
			left outer join (select personid, sum(cast(NumPeople as float)*Distance)/sum(cast(NumPeople as float)) closeness from [Profile.Cache].[SNA.Coauthor.Reach] where distance < 99 group by personid) c on p.personid = c.personid
			left outer join (select personid, sum(cast(NumPeople as int)) clustersize from [Profile.Cache].[SNA.Coauthor.Reach] where distance < 99 group by personid) s on p.personid = s.personid
			left outer join (select * from [Profile.Cache].[SNA.Coauthor.Betweenness]) b on p.personid = b.personid
	alter table #cache_sna add primary key (personid)
 
	update p
		set p.NumPublications = s.NumPublications,
			p.HasPublications = s.HasPublications,
			p.HasSNA = s.HasSNA,
			p.Reach1 = s.Reach1,
			p.Reach2 = s.Reach2,
			p.Closeness = s.Closeness,
			p.Betweenness = s.Betweenness
		from #cache_person p inner join #cache_sna s on p.personid = s.personid
 
	BEGIN TRY
		BEGIN TRAN
			TRUNCATE TABLE [Profile.Cache].Person
			INSERT INTO [Profile.Cache].Person
				SELECT * FROM #cache_person
			SELECT @rows = @@ROWCOUNT
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=0
		--Raise an error with the details of 
 
SELECT	@ErrSeverity=ERROR_SEVERITY ()
RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@ProcessedRows = @rows,@insert_new_record=0
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE  procedure [Profile.Data].[Publication.GetPersonPublications3](@UserID INT,@UserID2 INT, @Keyword Varchar(2000), @ExactKeyword BIT, @Pubs XML OUTPUT)
 as
BEGIN
DECLARE  @encode_html INT
declare  @dash_url varchar(max) 
select @dash_url = ISNULL('http://dash.harvard.edu/handle/1/','')
SELECT @encode_html = 0; 
 

	 SELECT 
						category																																									"Publication/@CustomCategory" ,
					  CAST(pubid AS VARCHAR(50))																																"Publication/PublicationID",
						PUBLICATIONS   																																								"Publication/PublicationReference",
						t.pmid																	 																									"Publication/PublicationSourceList/PublicationSource/@ID",
					  CASE WHEN frompubmed=1 THEN 'http://www.ncbi.nlm.nih.gov/pubmed/'+CAST(ISNULL(t.pmid,'')AS VARCHAR(20))ELSE URL END"Publication/PublicationSourceList/PublicationSource/@URL",
						 'true'																																											"Publication/PublicationSourceList/PublicationSource/@Primary",
					  sourcename    															"Publication/PublicationSourceList/PublicationSource/@Name" ,
						 null																	 "Publication/PublicationDetails" 
																		 
					 FROM (SELECT  DISTINCT 
												 p.pmid,
												 NULL                                              AS mpid,
												 [Profile.Cache].[fnPublication.Pubmed.General2Reference]	(p.pmid ,ArticleDay,ArticleMonth,ArticleYear,ArticleTitle,Authors,AuthorListCompleteYN,Issue,JournalDay,JournalMonth,JournalYear,MedlineDate,MedlinePgn,MedlineTA,Volume,0) AS publications,
												 1                                                 AS frompubmed,
												 [Profile.Data].[fnPublication.Pubmed.GetPubDate]( MedlineDate,JournalYear,JournalMonth,JournalDay,ArticleYear,ArticleMonth,ArticleDay)                                           AS publication_dt,
												 i.pubid,
												 NULL                                              category,
												 NULL                                              url,
												 'PubMed'										   sourcename
									 FROM  [Profile.Data].[Publication.Person.Include] i    
									 JOIN [Profile.Data].[Publication.Person.Include] i2 ON i2.PMID = i.PMID AND i2.PersonID = @userid2
									 JOIN [Profile.Data].[Publication.PubMed.General] p ON i.pmid = p.pmid
									WHERE  i.personid = @UserID
									  AND p.pmid IS NOT NULL
								 UNION ALL
								 SELECT  DISTINCT 
												 m.pmid,
												 m.mpid,
												 --dbo.fn_GetPubli ' cations			,
												 (SELECT authors + 
																(CASE 
																	WHEN url < > ''
 
																		 AND article <> ''
																			 AND pub <> '' THEN url + article + '</a>. ' + pub + '. '
																	WHEN url <> ''
																			 AND article <> '' THEN url + article + '</a>. '
																	WHEN url <> ''
																			 AND pub <> '' THEN url + pub + '</a>. '
																	WHEN article <> ''
																			 AND pub <> '' THEN article + '. ' + pub + '. '
																	WHEN article <> '' THEN article + '. '
																	WHEN pub <> '' THEN pub + '. '
																	ELSE ''
																END) + 
																y + 
															 (CASE 
																	 WHEN y <> ''
																				AND vip <> '' THEN '; '
																	 ELSE ''
																END) + 
																vip + 
																(CASE 
																	WHEN y <> ''
																				OR vip <> '' THEN '.'
																	ELSE ''
																END)
													FROM (SELECT url,
																			 (CASE 
																					WHEN authors = '' THEN ''
																					WHEN RIGHT(authors,1) = '.' THEN LEFT(authors,LEN(authors) - 1)
																					ELSE authors
																				END) authors,
																			 (CASE 
																					WHEN article = '' THEN ''
																					WHEN RIGHT(article,1) = '.' THEN LEFT(article,LEN(article) - 1)
																					ELSE article
																				END) article,
																			 (CASE 
																					WHEN pub = '' THEN ''
																					WHEN RIGHT(pub,1) = '.' THEN LEFT(pub,LEN(pub) - 1)
																					ELSE pub
																				END) pub,
																			 y,
																			 vip,
																			 frompubmed,
																			 publicationdt
														     FROM (SELECT (CASE 
																									WHEN RTRIM(LTRIM(COALESCE(authors,''))) = '' THEN ''
																									WHEN RIGHT(COALESCE(authors,''),1) = '.' THEN COALESCE(authors,'') + ' '
																									ELSE COALESCE(authors,'') + '. '
																								END) authors,
																							 (CASE 
																									WHEN COALESCE(url,'') <> ''
																											 AND LEFT(COALESCE(url,''),4) = 'http' THEN '<a href="' + url + '" target="_blank">'
																									WHEN COALESCE(url,'') <> '' THEN '<a href="http://' + url + '" target="_blank">'
																									ELSE ''
																								END) url,
																							 LTRIM(RTRIM(COALESCE(articletitle,'')))     article,
																							 LTRIM(RTRIM(COALESCE(pubtitle,'')))         pub,
																							 (CASE 
																									WHEN publicationdt > '1/1/1901' THEN CONVERT(VARCHAR(50),YEAR(publicationdt))
																									ELSE ''
																								END) y,
																							 COALESCE(volnum,'') + 
																							(CASE 
																									WHEN COALESCE(issuepub,'') <> '' THEN '(' + issuepub + ')'
																									ELSE ''
																								END) +	
																							(CASE 
																								WHEN (COALESCE(paginationpub,'') <> '') AND (COALESCE(volnum,'') + COALESCE(issuepub,'') <> '') THEN ':'
																								ELSE ''
																						  END) + 
																							COALESCE(paginationpub,'') vip,
																							0                                           AS frompubmed,
																							publicationdt
																			FROM		[Profile.Data].[Publication.MyPub.General] m2
																	   WHERE		m2.mpid = m.mpid) t) 
																 t) AS publications,
																 0,
																 publicationdt,
																 i.pubid,
																 hmspubcategory,
																 url,
																'Custom'										   sourcename
									  FROM [Profile.Data].[Publication.MyPub.General] m
								    JOIN [Profile.Data].[Publication.Person.Include] i  	 ON i.mpid = m.mpid
								    JOIN [Profile.Data].[Publication.Person.Include] i2  	 ON i2.mpid = i.mpid AND i2.PersonID = @userid2
								   WHERE m.personid = @UserID	
								     AND i.mpid IS NOT NULL
		 						
anD 
i.mpid NOT LIKE 'DASH%'
								     AND i.mpid NOT LIKE 'ISI%'
								     AND i.pmid IS NULL 
									UNION ALL 
									SELECT		null as pmid, 
										p.mpid,
										g.BibliographicCitation publications, 
										0 as FromPubMed, 
										m.publicationdt,
										pubid,
										m.hmspubcategory,
										@dash_url+cast(g.dashid as varchar(10)) url,
										'DASH' sourcename
									FROM	[Profile.Data].[Publication.MyPub.General] m, [Profile.Data].[Publication.Person.Include] p, [Profile.Data].[Publication.DSpace.MPID] d, [Profile.Data].[Publication.DSpace.PubGeneral] g
									WHERE	p.personid = @UserID
										and m.mpid = p.mpid
										and p.mpid is not null and p.pmid is null
										and p.mpid like 'DASH%' 
										and p.mpid = d.mpid and d.dashid = g.dashid
									UNION ALL
									SELECT 
										null as pmid, 
										p.mpid,
										(g.authors + '. ' 
										+ g.itemtitle + (case when right(g.itemtitle,1) not in ('.','?','!') then '. ' else ' ' end) 
										+ coalesce(g.sourceabbrev, g.sourcetitle) 
										+ '. ' + g.bibid + '.')
										publications,
										0 as FromPubMed, 
										m.publicationdt,
										pubid,
										m.hmspubcategory,
										'http://dx.doi.org/' + doi url,
										'DOI' sourcename
									FROM [Profile.Data].[Publication.MyPub.General] m,[Profile.Data].[Publication.Person.Include] p, [Profile.Data].[Publication.ISI.MPID] d, [Profile.Data].[Publication.ISI.PubGeneral] g
									where p.personid = @UserID
										and m.mpid = p.mpid
										and p.mpid is not null and p.pmid is null
										and p.mpid like 'ISI%' 
										and p.mpid = d.mpid and d.recid = g.recid
		 			     
								     ) t 
OUTER APPLY (SELECT DISTINCT pmid 
			  from [Search.Cache].APIQueryMatchedPublication c where  c.personid=@UserID AND c.keywordstring = @keyword AND c.pmid=t.pmid and c.exactkeyword = ISNULL(@exactkeyword,0)) c 								
where CASE WHEN ISNULL(@Keyword,'')<>''  THEN c.pmid ELSE '' END IS NOT NULL 									
ORDER BY publication_dt DESC
 	
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE  procedure [Profile.Data].[Publication.GetPersonPublications2](@UserID INT,@Keyword Varchar(2000), @ExactKeyword BIT, @Pubs XML OUTPUT)
 as
BEGIN
DECLARE  @encode_html INT
declare  @dash_url varchar(max) 
select @dash_url = ISNULL('http://dash.harvard.edu/handle/1/','')
SELECT @encode_html = 0; 
 
SELECT @Pubs = (
	 SELECT 
						category																																									"Publication/@CustomCategory" ,
					  CAST(pubid AS VARCHAR(50))																																"Publication/PublicationID",
						PUBLICATIONS   																																								"Publication/PublicationReference",
						t.pmid																	 																									"Publication/PublicationSourceList/PublicationSource/@ID",
					  CASE WHEN frompubmed=1 THEN 'http://www.ncbi.nlm.nih.gov/pubmed/'+CAST(ISNULL(t.pmid,'')AS VARCHAR(20))ELSE URL END"Publication/PublicationSourceList/PublicationSource/@URL",
						 'true'																																											"Publication/PublicationSourceList/PublicationSource/@Primary",
					  sourcename    															"Publication/PublicationSourceList/PublicationSource/@Name" ,
						 null																																											"Publication/PublicationDetails" ,
																		 (
																				SELECT SearchPhrase "@SearchPhrase",
																							 (
																								SELECT meshheader "@PublicationPhrase", nodeid "@EntityID",
																											 (
																												SELECT	 CASE MAX(c3.SearchWeight)
																																			WHEN 1 THEN 'Exact match' 
																																			ELSE 'Partial match or synonym'
																																 END																													"SearchWeight/@SearchWeightText",
																																 CAST(MAX(c3.SearchWeight)AS VARCHAR)													"SearchWeight", 
																																 CAST(MAX(uniquenessweight)AS VARCHAR)												"UniquenessWeight" ,
																																 CASE MAX(ROUND(topicweight,4))	
																																		 WHEN 1 THEN 'MeSH major topic'
																																	  	 WHEN .25 THEN 'MeSH minor topic'
																																 END																													"TopicWeight/@TopicWeightText",
																																 CAST(MAX(topicweight)AS VARCHAR)															"TopicWeight" ,
																																 CASE  CONVERT(DEC(3,2),MAX(ROUND(authorweight,4)))
																																				WHEN 1 THEN 'First or Senior Author'
																																				WHEN .5 THEN 'Unknown Position'
																																				WHEN .25 THEN 'Middle Author'
																																 END																													"AuthorWeight/@AuthorWeightText",
																																 CAST(MAX(authorweight)AS VARCHAR)														"AuthorWeight",
								 																								 'Published In '+CAST(YEAR(publication_dt)AS VARCHAR(4))							"YearWeight/@YearWeightText",
																																 CAST(MAX(yearweight )	AS VARCHAR)														"YearWeight" , 
																																 CAST(MAX(OverallWeight)*MAX(c3.SearchWeight)AS VARCHAR)			"OverallWeight"
																													FROM [Search.Cache].APIQueryMatchedPublication c3
																												 WHERE c3.pmid = t.pmid
																													 AND c3.personid = @UserID
																													 AND c3.meshheader = c2.meshheader
																													 AND c3.exactkeyword = ISNULL(@exactkeyword,0)
																													 --AND c3.searchprhase = c2.searchphrase
																											 FOR XML PATH('PhraseMeasurements'),TYPE
																												)
																										FROM [Search.Cache].APIQueryMatchedPublication c2 
																					          --JOIN [ER.].Entity e ON e.EntityType = 'Concept' AND e.EntityName = c2.MeshHeader
																					          JOIN [RDF.].Node e ON e.ValueHash = [RDF.].fnValueHash(null,null,c2.MeshHeader)
																								 WHERE	KeywordString = @Keyword
																									 AND c2.pmid=t.pmid
																									 And C2.personid=@UserID
																									 and c2.searchphrase = c1.searchphrase
																									 and c2.exactkeyword = ISNULL(@exactkeyword,0)
																								 GROUP BY meshheader,nodeid
																							 FOR XML PATH('PublicationPhraseDetail'),ROOT('PublicationPhraseDetailList'), TYPE
																							 )
																				  FROM [Search.Cache].APIQueryMatchedPublication c1 
																				 WHERE KeywordString = @Keyword
																					 AND c1.pmid=t.pmid
																					 And C1.personid=@UserID
																					 and c1.exactkeyword = ISNULL(@exactkeyword,0)
																				 GROUP BY SearchPhrase
																			 FOR XML PATH('PublicationMatchDetail'),TYPE
 
																		 ) AS "Publication/PublicationMatchDetailList"
					 FROM (SELECT  DISTINCT 
												 p.pmid,
												 NULL                                              AS mpid,
												 [Profile.Cache].[fnPublication.Pubmed.General2Reference]	(p.pmid ,ArticleDay,ArticleMonth,ArticleYear,ArticleTitle,Authors,AuthorListCompleteYN,Issue,JournalDay,JournalMonth,JournalYear,MedlineDate,MedlinePgn,MedlineTA,Volume,0) AS publications,
												 1                                                 AS frompubmed,
												 [Profile.Data].[fnPublication.Pubmed.GetPubDate]( MedlineDate,JournalYear,JournalMonth,JournalDay,ArticleYear,ArticleMonth,ArticleDay)                                           AS publication_dt,
												 pubid,
												 NULL                                              category,
												 NULL                                              url,
												 'PubMed'										   sourcename
									 FROM  [Profile.Data].[Publication.Person.Include] i    
									 JOIN [Profile.Data].[Publication.PubMed.General] p ON i.pmid = p.pmid
									WHERE  i.personid = @UserID
									  AND p.pmid IS NOT NULL
								 UNION ALL
								 SELECT  DISTINCT 
												 m.pmid,
												 m.mpid,
												 --dbo.fn_GetPubli ' cations			,
												 (SELECT authors + 
																(CASE 
																	WHEN url < > ''
 
																		 AND article <> ''
																			 AND pub <> '' THEN url + article + '</a>. ' + pub + '. '
																	WHEN url <> ''
																			 AND article <> '' THEN url + article + '</a>. '
																	WHEN url <> ''
																			 AND pub <> '' THEN url + pub + '</a>. '
																	WHEN article <> ''
																			 AND pub <> '' THEN article + '. ' + pub + '. '
																	WHEN article <> '' THEN article + '. '
																	WHEN pub <> '' THEN pub + '. '
																	ELSE ''
																END) + 
																y + 
															 (CASE 
																	 WHEN y <> ''
																				AND vip <> '' THEN '; '
																	 ELSE ''
																END) + 
																vip + 
																(CASE 
																	WHEN y <> ''
																				OR vip <> '' THEN '.'
																	ELSE ''
																END)
													FROM (SELECT url,
																			 (CASE 
																					WHEN authors = '' THEN ''
																					WHEN RIGHT(authors,1) = '.' THEN LEFT(authors,LEN(authors) - 1)
																					ELSE authors
																				END) authors,
																			 (CASE 
																					WHEN article = '' THEN ''
																					WHEN RIGHT(article,1) = '.' THEN LEFT(article,LEN(article) - 1)
																					ELSE article
																				END) article,
																			 (CASE 
																					WHEN pub = '' THEN ''
																					WHEN RIGHT(pub,1) = '.' THEN LEFT(pub,LEN(pub) - 1)
																					ELSE pub
																				END) pub,
																			 y,
																			 vip,
																			 frompubmed,
																			 publicationdt
														     FROM (SELECT (CASE 
																									WHEN RTRIM(LTRIM(COALESCE(authors,''))) = '' THEN ''
																									WHEN RIGHT(COALESCE(authors,''),1) = '.' THEN COALESCE(authors,'') + ' '
																									ELSE COALESCE(authors,'') + '. '
																								END) authors,
																							 (CASE 
																									WHEN COALESCE(url,'') <> ''
																											 AND LEFT(COALESCE(url,''),4) = 'http' THEN '<a href="' + url + '" target="_blank">'
																									WHEN COALESCE(url,'') <> '' THEN '<a href="http://' + url + '" target="_blank">'
																									ELSE ''
																								END) url,
																							 LTRIM(RTRIM(COALESCE(articletitle,'')))     article,
																							 LTRIM(RTRIM(COALESCE(pubtitle,'')))         pub,
																							 (CASE 
																									WHEN publicationdt > '1/1/1901' THEN CONVERT(VARCHAR(50),YEAR(publicationdt))
																									ELSE ''
																								END) y,
																							 COALESCE(volnum,'') + 
																							(CASE 
																									WHEN COALESCE(issuepub,'') <> '' THEN '(' + issuepub + ')'
																									ELSE ''
																								END) +	
																							(CASE 
																								WHEN (COALESCE(paginationpub,'') <> '') AND (COALESCE(volnum,'') + COALESCE(issuepub,'') <> '') THEN ':'
																								ELSE ''
																						  END) + 
																							COALESCE(paginationpub,'') vip,
																							0                                           AS frompubmed,
																							publicationdt
																			FROM		[Profile.Data].[Publication.MyPub.General] m2
																	   WHERE		m2.mpid = m.mpid) t) 
																 t) AS publications,
																 0,
																 publicationdt,
																 pubid,
																 hmspubcategory,
																 url,
																'Custom'										   sourcename
									  FROM [Profile.Data].[Publication.MyPub.General] m
								    JOIN [Profile.Data].[Publication.Person.Include] i  	 ON i.mpid = m.mpid
								   WHERE m.personid = @UserID	
								     AND i.mpid IS NOT NULL
		 						
anD 
i.mpid NOT LIKE 'DASH%'
								     AND i.mpid NOT LIKE 'ISI%'
								     AND i.pmid IS NULL 
									UNION ALL 
									SELECT		null as pmid, 
										p.mpid,
										g.BibliographicCitation publications, 
										0 as FromPubMed, 
										m.publicationdt,
										pubid,
										m.hmspubcategory,
										@dash_url+cast(g.dashid as varchar(10)) url,
										'DASH' sourcename
									FROM	[Profile.Data].[Publication.MyPub.General] m, [Profile.Data].[Publication.Person.Include] p, [Profile.Data].[Publication.DSpace.MPID] d, [Profile.Data].[Publication.DSpace.PubGeneral] g
									WHERE	p.personid = @UserID
										and m.mpid = p.mpid
										and p.mpid is not null and p.pmid is null
										and p.mpid like 'DASH%' 
										and p.mpid = d.mpid and d.dashid = g.dashid
									UNION ALL
									SELECT 
										null as pmid, 
										p.mpid,
										(g.authors + '. ' 
										+ g.itemtitle + (case when right(g.itemtitle,1) not in ('.','?','!') then '. ' else ' ' end) 
										+ coalesce(g.sourceabbrev, g.sourcetitle) 
										+ '. ' + g.bibid + '.')
										publications,
										0 as FromPubMed, 
										m.publicationdt,
										pubid,
										m.hmspubcategory,
										'http://dx.doi.org/' + doi url,
										'DOI' sourcename
									FROM [Profile.Data].[Publication.MyPub.General] m,[Profile.Data].[Publication.Person.Include] p, [Profile.Data].[Publication.ISI.MPID] d, [Profile.Data].[Publication.ISI.PubGeneral] g
									where p.personid = @UserID
										and m.mpid = p.mpid
										and p.mpid is not null and p.pmid is null
										and p.mpid like 'ISI%' 
										and p.mpid = d.mpid and d.recid = g.recid
		 			     
								     ) t 
OUTER APPLY (SELECT DISTINCT pmid 
			  from [Search.Cache].APIQueryMatchedPublication c where  c.personid=@UserID AND c.keywordstring = @keyword AND c.pmid=t.pmid and c.exactkeyword = ISNULL(@exactkeyword,0)) c 								
where CASE WHEN ISNULL(@Keyword,'')<>''  THEN c.pmid ELSE '' END IS NOT NULL 									
ORDER BY publication_dt DESC
 	FOR  XML PATH('')	,TYPE					
	)
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.MyPub.UpdatePublication]
	@mpid nvarchar(50),
	@HMS_PUB_CATEGORY nvarchar(60) = '',
	@PUB_TITLE nvarchar(2000) = '',
	@ARTICLE_TITLE nvarchar(2000) = '',
	@CONF_EDITORS nvarchar(2000) = '',
	@CONF_LOC nvarchar(2000) = '',
	@EDITION nvarchar(30) = '',
	@PLACE_OF_PUB nvarchar(60) = '',
	@VOL_NUM nvarchar(30) = '',
	@PART_VOL_PUB nvarchar(15) = '',
	@ISSUE_PUB nvarchar(30) = '',
	@PAGINATION_PUB nvarchar(30) = '',
	@ADDITIONAL_INFO nvarchar(2000) = '',
	@PUBLISHER nvarchar(255) = '',
	@CONF_NM nvarchar(2000) = '',
	@CONF_DTS nvarchar(60) = '',
	@REPT_NUMBER nvarchar(35) = '',
	@CONTRACT_NUM nvarchar(35) = '',
	@DISS_UNIV_NM nvarchar(2000) = '',
	@NEWSPAPER_COL nvarchar(15) = '',
	@NEWSPAPER_SECT nvarchar(15) = '',
	@PUBLICATION_DT smalldatetime = '',
	@ABSTRACT varchar(max) = '',
	@AUTHORS varchar(max) = '',
	@URL varchar(1000) = '',
	@updated_by varchar(50) = ''
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	---------------------------------------------------
	-- Update the MyPub General information
	---------------------------------------------------
 
	UPDATE [Profile.Data].[Publication.MyPub.General] SET
		HmsPubCategory = @HMS_PUB_CATEGORY,
		PubTitle = @PUB_TITLE,
		ArticleTitle = @ARTICLE_TITLE,
		ConfEditors = @CONF_EDITORS,
		ConfLoc = @CONF_LOC,
		EDITION = @EDITION,
		PlaceOfPub = @PLACE_OF_PUB,
		VolNum = @VOL_NUM,
		PartVolPub = @PART_VOL_PUB,
		IssuePub = @ISSUE_PUB,
		PaginationPub = @PAGINATION_PUB,
		AdditionalInfo = @ADDITIONAL_INFO,
		PUBLISHER = @PUBLISHER,
		ConfNm = @CONF_NM,
		ConfDTs = @CONF_DTS,
		ReptNumber = @REPT_NUMBER,
		ContractNum = @CONTRACT_NUM,
		DissUnivNm = @DISS_UNIV_NM,
		NewspaperCol = @NEWSPAPER_COL,
		NewspaperSect = @NEWSPAPER_SECT,
		PublicationDT = @PUBLICATION_DT,
		ABSTRACT = @ABSTRACT,
		AUTHORS = @AUTHORS,
		URL = @URL,
		UpdatedBy = @updated_by,
		UpdatedDT = GetDate()
	WHERE mpid = @mpid
		and mpid not in (select mpid from [Profile.Data].[Publication.DSpace.MPID])
		and mpid not in (select mpid from [Profile.Data].[Publication.ISI.MPID])


	IF @@ROWCOUNT > 0
	BEGIN

		DECLARE @SQL NVARCHAR(MAX)

		---------------------------------------------------
		-- Update the InformationResource Entity
		---------------------------------------------------
	
		-- Get publication information
	
		CREATE TABLE #Publications
		(
			PMID INT NULL ,
			MPID NVARCHAR(50) NULL ,
			EntityDate DATETIME NULL ,
			Authors NVARCHAR(4000) NULL,
			Reference VARCHAR(MAX) NULL ,
			Source VARCHAR(25) NULL ,
			URL VARCHAR(1000) NULL ,
			Title VARCHAR(4000) NULL
		)

		INSERT  INTO #Publications
				( MPID ,
				  EntityDate ,
				  Authors,
				  Reference ,
				  Source ,
				  URL ,
				  Title
				)
				SELECT  MPID ,
						EntityDate ,
						Authors = REPLACE(authors, CHAR(11), '') ,
						Reference = REPLACE(--authors +
											(CASE WHEN IsNull(article,'') <> '' THEN article + '. ' ELSE '' END)
											+ (CASE WHEN IsNull(pub,'') <> '' THEN pub + '. ' ELSE '' END)
											+ y
											+ CASE WHEN y <> ''
														AND vip <> '' THEN '; '
												   ELSE ''
											  END + vip
											+ CASE WHEN y <> ''
														OR vip <> '' THEN '.'
												   ELSE ''
											  END, CHAR(11), '') ,
						Source = 'Custom' ,
						URL = url,
						Title = left((case when IsNull(article,'')<>'' then article when IsNull(pub,'')<>'' then pub else 'Untitled Publication' end),4000)
				FROM    ( SELECT    MPID ,
									EntityDate ,
									url ,
									authors = CASE WHEN authors = '' THEN ''
												   WHEN RIGHT(authors, 1) = '.'
												   THEN LEFT(authors,
															 LEN(authors) - 1)
												   ELSE authors
											  END ,
									article = CASE WHEN article = '' THEN ''
												   WHEN RIGHT(article, 1) = '.'
												   THEN LEFT(article,
															 LEN(article) - 1)
												   ELSE article
											  END ,
									pub = CASE WHEN pub = '' THEN ''
											   WHEN RIGHT(pub, 1) = '.'
											   THEN LEFT(pub, LEN(pub) - 1)
											   ELSE pub
										  END ,
									y ,
									vip
						  FROM      ( SELECT    MPG.mpid ,
												EntityDate = MPG.publicationdt ,
												authors = CASE WHEN RTRIM(LTRIM(COALESCE(MPG.authors,
																  ''))) = ''
															   THEN ''
															   WHEN RIGHT(COALESCE(MPG.authors,
																  ''), 1) = '.'
																THEN  COALESCE([Profile.Data].[fnPublication.MyPub.HighlightAuthors] (MPG.authors, p.FirstName, p.MiddleName, p.LastName),
																  '') + ' '
															   ELSE COALESCE([Profile.Data].[fnPublication.MyPub.HighlightAuthors] (MPG.authors, p.FirstName, p.MiddleName, p.LastName),
																  '') + '. '
														  END ,
												url = CASE WHEN COALESCE(MPG.url,
																  '') <> ''
																AND LEFT(COALESCE(MPG.url,
																  ''), 4) = 'http'
														   THEN MPG.url
														   WHEN COALESCE(MPG.url,
																  '') <> ''
														   THEN 'http://' + MPG.url
														   ELSE ''
													  END ,
												article = LTRIM(RTRIM(COALESCE(MPG.articletitle,
																  ''))) ,
												pub = LTRIM(RTRIM(COALESCE(MPG.pubtitle,
																  ''))) ,
												y = CASE WHEN MPG.publicationdt > '1/1/1901'
														 THEN CONVERT(VARCHAR(50), YEAR(MPG.publicationdt))
														 ELSE ''
													END ,
												vip = COALESCE(MPG.volnum, '')
												+ CASE WHEN COALESCE(MPG.issuepub,
																  '') <> ''
													   THEN '(' + MPG.issuepub
															+ ')'
													   ELSE ''
												  END
												+ CASE WHEN ( COALESCE(MPG.paginationpub,
																  '') <> '' )
															AND ( COALESCE(MPG.volnum,
																  '')
																  + COALESCE(MPG.issuepub,
																  '') <> '' )
													   THEN ':'
													   ELSE ''
												  END + COALESCE(MPG.paginationpub,
																 '')
									  FROM      [Profile.Data].[Publication.MyPub.General] MPG
									  join [Profile.Data].Person p on MPG.PersonID = p.PersonID
									  WHERE MPID = @mpid
									) T0
						) T0

		-- Update the entity record
		DECLARE @EntityID INT		
		UPDATE e
			SET e.EntityDate = p.EntityDate,
				e.Authors = p.Authors,
				e.Reference = p.Reference,
				e.Source = p.Source,
				e.URL = p.URL,
				@EntityID = e.EntityID
			FROM #publications p, [Profile.Data].[Publication.Entity.InformationResource] e
			WHERE p.MPID = e.MPID

		-- Update the RDF
		IF @EntityID IS NOT NULL
		BEGIN
			SELECT @SQL = ''
			SELECT @SQL = @SQL + 'EXEC [RDF.Stage].ProcessDataMap @DataMapID = '
								+CAST(DataMapID AS VARCHAR(50))
								+', @InternalIdIn = '
								+'''' + CAST(@EntityID AS VARCHAR(50)) + ''''
								+', @TurnOffIndexing=0, @SaveLog=0; '
				FROM [Ontology.].DataMap
				WHERE Class = 'http://vivoweb.org/ontology/core#InformationResource'
					AND NetworkProperty IS NULL
					AND Property IN (
										'http://www.w3.org/2000/01/rdf-schema#label',
										'http://profiles.catalyst.harvard.edu/ontology/prns#informationResourceReference',
										'http://profiles.catalyst.harvard.edu/ontology/prns#publicationDate',
										'http://profiles.catalyst.harvard.edu/ontology/prns#year'
									)
			EXEC sp_executesql @SQL
		END

		---------------------------------------------------
		-- Update the Authorship Entity
		---------------------------------------------------

		IF (@EntityID IS NOT NULL)
		BEGIN

			CREATE TABLE #Authorship
			(
				EntityDate DATETIME NULL ,
				authorRank INT NULL,
				numberOfAuthors INT NULL,
				authorNameAsListed VARCHAR(255) NULL,
				AuthorWeight FLOAT NULL,
				AuthorPosition VARCHAR(1) NULL,
				PubYear INT NULL ,
				YearWeight FLOAT NULL ,
				PersonID INT NULL ,
				InformationResourceID INT NULL,
				PMID INT NULL,
				IsActive BIT
			)

			INSERT INTO #Authorship (EntityDate, PersonID, InformationResourceID, PMID, IsActive)
				SELECT e.EntityDate, i.PersonID, e.EntityID, null PMID, 1 IsActive
					FROM [Profile.Data].[Publication.Entity.InformationResource] e,
						[Profile.Data].[Publication.Person.Include] i
					WHERE (e.MPID = i.MPID) and (e.MPID = @mpid) and (e.PMID is null)
		 
			UPDATE #authorship
				SET authorWeight = 0.5,
					authorPosition = 'U',
					PubYear = year(EntityDate),
					YearWeight = (case when EntityDate is null then 0.5
														when year(EntityDate) <= 1901 then 0.5
														else power(cast(0.5 as float),cast(datediff(d,EntityDate,GetDate()) as float)/365.25/10)
														end)

			-- Update the entity record
			SELECT @EntityID = NULL
			UPDATE e
				SET e.EntityDate = a.EntityDate,
					e.authorRank = a.authorRank,
					e.numberOfAuthors = a.numberOfAuthors,
					e.authorNameAsListed = a.authorNameAsListed,
					e.authorWeight = a.authorWeight,
					e.authorPosition = a.authorPosition,
					e.PubYear = a.PubYear,
					e.YearWeight = a.YearWeight,
					@EntityID = EntityID
				FROM #authorship a, [Profile.Data].[Publication.Entity.Authorship] e
				WHERE a.PersonID = e.PersonID and a.InformationResourceID = e.InformationResourceID

			-- Update the RDF
			/*
			IF @EntityID IS NOT NULL
			BEGIN
				SELECT @SQL = ''
				SELECT @SQL = @SQL + 'EXEC [RDF.Stage].ProcessDataMap @DataMapID = '
									+CAST(DataMapID AS VARCHAR(50))
									+', @InternalIdIn = '
									+'''' + CAST(@EntityID AS VARCHAR(50)) + ''''
									+', @TurnOffIndexing=0, @SaveLog=0; '
					FROM [Ontology.].DataMap
					WHERE Class = 'http://vivoweb.org/ontology/core#Authorship'
						AND NetworkProperty IS NULL
						AND Property IN (
											'http://www.w3.org/2000/01/rdf-schema#label',
											'http://profiles.catalyst.harvard.edu/ontology/prns#authorPosition',
											'http://profiles.catalyst.harvard.edu/ontology/prns#authorPositionWeight',
											'http://profiles.catalyst.harvard.edu/ontology/prns#authorshipWeight',
											'http://profiles.catalyst.harvard.edu/ontology/prns#numberOfAuthors',
											'http://vivoweb.org/ontology/core#authorRank'
										)
				EXEC sp_executesql @SQL
			END
			*/

		END

	END
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.MyPub.AddPublication]
	@PersonID INT,
	@HMS_PUB_CATEGORY nvarchar(60) = '',
	@PUB_TITLE nvarchar(2000) = '',
	@ARTICLE_TITLE nvarchar(2000) = '',
	@CONF_EDITORS nvarchar(2000) = '',
	@CONF_LOC nvarchar(2000) = '',
	@EDITION nvarchar(30) = '',
	@PLACE_OF_PUB nvarchar(60) = '',
	@VOL_NUM nvarchar(30) = '',
	@PART_VOL_PUB nvarchar(15) = '',
	@ISSUE_PUB nvarchar(30) = '',
	@PAGINATION_PUB nvarchar(30) = '',
	@ADDITIONAL_INFO nvarchar(2000) = '',
	@PUBLISHER nvarchar(255) = '',
	@CONF_NM nvarchar(2000) = '',
	@CONF_DTS nvarchar(60) = '',
	@REPT_NUMBER nvarchar(35) = '',
	@CONTRACT_NUM nvarchar(35) = '',
	@DISS_UNIV_NM nvarchar(2000) = '',
	@NEWSPAPER_COL nvarchar(15) = '',
	@NEWSPAPER_SECT nvarchar(15) = '',
	@PUBLICATION_DT smalldatetime = '',
	@ABSTRACT varchar(max) = '',
	@AUTHORS varchar(max) = '',
	@URL varchar(1000) = '',
	@created_by varchar(50) = ''
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	 
	DECLARE @mpid nvarchar(50)
	SET @mpid = cast(NewID() as nvarchar(50))

	DECLARE @pubid nvarchar(50)
	SET @pubid = cast(NewID() as nvarchar(50))
	BEGIN TRY
	BEGIN TRANSACTION

		INSERT INTO [Profile.Data].[Publication.MyPub.General]
		        (
			mpid,
			PersonID,
			HmsPubCategory,
			PubTitle,
			ArticleTitle,
			ConfEditors,
			ConfLoc,
			EDITION,
			PlaceOfPub,
			VolNum,
			PartVolPub,
			IssuePub,
			PaginationPub,
			AdditionalInfo,
			Publisher,
			ConfNm,
			ConfDts,
			ReptNumber,
			ContractNum,
			DissUnivNM,
			NewspaperCol,
			NewspaperSect,
			PublicationDT,
			ABSTRACT,
			AUTHORS,
			URL,
			CreatedBy,
			CreatedDT,
			UpdatedBy,
			UpdatedDT
		) VALUES (
			@mpid,
			@PersonID,
			@HMS_PUB_CATEGORY,
			@PUB_TITLE,
			@ARTICLE_TITLE,
			@CONF_EDITORS,
			@CONF_LOC,
			@EDITION,
			@PLACE_OF_PUB,
			@VOL_NUM,
			@PART_VOL_PUB,
			@ISSUE_PUB,
			@PAGINATION_PUB,
			@ADDITIONAL_INFO,
			@PUBLISHER,
			@CONF_NM,
			@CONF_DTS,
			@REPT_NUMBER,
			@CONTRACT_NUM,
			@DISS_UNIV_NM,
	@NEWSPAPER_COL,
			@NEWSPAPER_SECT,
			@PUBLICATION_DT,
			@ABSTRACT,
			@AUTHORS,
			@URL,
			@created_by,
			GetDate(),
			@created_by,
			GetDate()
		)

		INSERT INTO [Profile.Data].[Publication.Person.Include]
		        ( PubID, PersonID,   MPID )
	 
			VALUES (@pubid, @PersonID, @mpid)

		INSERT INTO [Profile.Data].[Publication.Person.Add]
		        ( PubID, PersonID,   MPID )
			VALUES (@pubid, @PersonID, @mpid)

	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=1
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure  [Profile.Data].[Publication.Pubmed.AddPubMedXML] ( 					 @pmid INT,
																			   @pubmedxml XML)
AS
BEGIN
	SET NOCOUNT ON;	
	 
	-- Parse Load Publication XML
	BEGIN TRY 	 
	
	IF ISNULL(CAST(@pubmedxml AS NVARCHAR(MAX)),'')='' 
		BEGIN
			DELETE FROM [Profile.Data].[Publication.PubMed.Disambiguation] WHERE pmid = @pmid AND NOT EXISTS (SELECT 1 FROM [Profile.Data].[Publication.Person.Add]  pa WHERE pa.pmid = @pmid)
			RETURN
		END
 
		BEGIN TRAN
			-- Remove existing pmid record
			DELETE FROM [Profile.Data].[Publication.PubMed.AllXML] WHERE pmid = @pmid
		
			-- Add Pub Med XML	
			INSERT INTO [Profile.Data].[Publication.PubMed.AllXML](pmid,X) VALUES(@pmid,CAST(@pubmedxml AS XML))		
			
			-- Parse Pub Med XML
			--EXEC [Profile.Data].[Publication.Pubmed.ParsePubMedXML] 	 @pmid		
		 
		COMMIT
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
 
		-- Raise an error with the details of the exception
		SELECT @ErrMsg = '[Profile.Data].[Publication.Pubmed.AddPubMedXML] FAILED for PMID: ' + cast(@PMID as varchar(50)) + ' WITH : ' + ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()
 
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
			 
	END CATCH				
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- =============================================
-- Author:		<Author,,Name>
-- Create date: <Create Date,,>
-- Description:	<Description,,>
-- =============================================
CREATE procedure [Profile.Cache].[Publication.PubMed.UpdateAuthorPosition]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	  /* 
		drop table cache_pm_author_position
		create table dbo.cache_pm_author_position (
			PersonID int not null,
			pmid int not null,
			AuthorPosition char(1),
			AuthorWeight float,
			PubDate datetime,
			PubYear int,
			YearWeight float
		)
		alter table cache_pm_author_position add primary key (PersonID, pmid)
	*/
 
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER,@rows BIGINT 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
 
	select distinct i.pmid, p.personid, p.lastname, p.firstname, '' middlename,
			left(p.lastname,1) ln, left(p.firstname,1) fn, left('',1) mn
		into #pmid_person_name
		from [Profile.Data].[Publication.Person.Include] i, [Profile.Cache].Person p
		where i.personid = p.personid and i.pmid is not null
	create unique clustered index idx_pu on #pmid_person_name(pmid,personid)
 
	select distinct pmid, personid, pmpubsauthorid
		into #authorid_personid
		from (
			select a.pmid, a.PmPubsAuthorID, p.personid, dense_rank() over (partition by a.pmid, p.personid order by 
				(case when a.lastname = p.lastname and (a.forename like p.firstname + left(p.middlename,1) + '%') then 1
					when a.lastname = p.lastname and (a.forename like p.firstname + '%') and len(p.firstname) > 1 then 2
					when a.lastname = p.lastname and a.initials = p.fn+p.mn then 3
					when a.lastname = p.lastname and left(a.initials,1) = p.fn then 4
					when a.lastname = p.lastname then 5
					else 6 end) ) k
			from [Profile.Data].[Publication.PubMed.Author] a inner join #pmid_person_name p 
				on a.pmid = p.pmid and a.validyn = 'Y' and left(a.lastname,1) = p.ln
		) t
		where k = 1
	create unique clustered index idx_ap on #authorid_personid(pmid, personid, pmpubsauthorid)
 
	select pmid, min(pmpubsauthorid) a, max(pmpubsauthorid) b, count(*) numberOfAuthors
		into #pmid_authorid_range
		from [Profile.Data].[Publication.PubMed.Author]
		group by pmid
	create unique clustered index idx_p on #pmid_authorid_range(pmid)
 
	select PersonID, pmid, a AuthorPosition, 
			(case when a in ('F','L','S') then 1.00
				when a in ('M') then 0.25
				else 0.50 end) AuthorWeight,
			pmpubsauthorid,
			cast(null as int) authorRank,
			cast(null as int) numberOfAuthors,
			cast(null as varchar(255)) authorNameAsListed
		into #cache_author_position
		from (
			select pmid, personid, a, pmpubsauthorid, row_number() over (partition by pmid, personid order by k, pmpubsauthorid) k
			from (
				select a.pmid, a.personid,
						(case when a.pmpubsauthorid = r.a then 'F'
							when a.pmpubsauthorid = r.b then 'L'
							else 'M'
							end) a,
						(case when a.pmpubsauthorid = r.a then 1
							when a.pmpubsauthorid = r.b then 2
							else 3
							end) k,
						a.pmpubsauthorid
					from #authorid_personid a, #pmid_authorid_range r
					where a.pmid = r.pmid and r.b <> r.a
				union all
				select p.pmid, p.personid, 'S' a, 0 k, r.a pmpubsauthorid
					from #pmid_person_name p, #pmid_authorid_range r
					where p.pmid = r.pmid and r.a = r.b
				union all
				select pmid, personid, 'U' a, 9 k, null pmpubsauthorid
					from #pmid_person_name
			) t
		) t
		where k = 1
	create clustered index idx_pmid on #cache_author_position(pmid)
	create nonclustered index idx_pmpubsauthorid on #cache_author_position(pmpubsauthorid)
 
	update a
		set a.numberOfAuthors = r.numberOfAuthors
		from #cache_author_position a, #pmid_authorid_range r
		where a.pmid = r.pmid
 
	select pmpubsauthorid, 
			isnull(LastName,'') 
			+ (case when isnull(LastName,'')<>'' and (isnull(ForeName,'')+isnull(Suffix,''))<>'' then ', ' else '' end)
			+ isnull(ForeName,'')
			+ (case when isnull(ForeName,'')<>'' and isnull(Suffix,'')<>'' then ' ' else '' end)
			+ isnull(Suffix,'') authorNameAsListed,
			row_number() over (partition by pmid order by pmpubsauthorid) authorRank
		into #pmpubsauthorid_authorRank
		from [Profile.Data].[Publication.PubMed.Author]
	create unique clustered index idx_p on #pmpubsauthorid_authorRank(pmpubsauthorid)
 
	update a
		set a.authorRank = r.authorRank, a.authorNameAsListed = r.authorNameAsListed
		from #cache_author_position a, #pmpubsauthorid_authorRank r
		where a.pmpubsauthorid = r.pmpubsauthorid
 
	select PersonID, a.pmid, AuthorPosition, AuthorWeight, g.PubDate, year(g.PubDate) PubYear,
			(case when g.PubDate = '1900-01-01 00:00:00.000' then 0.5
				else power(cast(0.5 as float),cast(datediff(d,g.PubDate,GetDate()) as float)/365.25/10)
				end) YearWeight,
			authorRank, numberOfAuthors, authorNameAsListed
		into #cache_pm_author_position
		from #cache_author_position a, [Profile.Data].[Publication.PubMed.General] g
		where a.pmid = g.pmid
	update #cache_pm_author_position
		set PubYear = Year(GetDate()), YearWeight = 1
		where YearWeight > 1
 
	BEGIN TRY
		BEGIN TRAN
			TRUNCATE TABLE [Profile.Cache].[Publication.PubMed.AuthorPosition]
			INSERT INTO [Profile.Cache].[Publication.PubMed.AuthorPosition] (PersonID, pmid, AuthorPosition, AuthorWeight, PubDate, PubYear, YearWeight, authorRank, numberOfAuthors, authorNameAsListed)
				SELECT PersonID, pmid, AuthorPosition, AuthorWeight, PubDate, PubYear, YearWeight, authorRank, numberOfAuthors, authorNameAsListed
				FROM #cache_pm_author_position
			SELECT @rows = @@ROWCOUNT
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate =@date,@error = 1,@insert_new_record=0
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate =@date,@ProcessedRows = @rows,@insert_new_record=0
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
-- Stored Procedure

CREATE procedure [Profile.Data].[Publication.PubMed.GetAllPMIDs] (@GetOnlyNewXML BIT=0 )
AS
BEGIN
	SET NOCOUNT ON;	


	BEGIN TRY
		IF @GetOnlyNewXML = 1 
		-- ONLY GET XML FOR NEW Publications
			BEGIN
				SELECT distinct pmid
				  FROM [Profile.Data].[Publication.PubMed.Disambiguation]
				 WHERE pmid NOT IN(SELECT PMID FROM [Profile.Data].[Publication.PubMed.General])
				   AND pmid IS NOT NULL AND pmid not in (select pmid from [Profile.Data].[Publication.PubMed.DisambiguationExclude])
			END
		ELSE 
		-- FULL REFRESH
			BEGIN
				SELECT pmid
				  FROM [Profile.Data].[Publication.PubMed.Disambiguation]
				 WHERE pmid IS NOT NULL AND pmid not in (select pmid from [Profile.Data].[Publication.PubMed.DisambiguationExclude]) 
				 UNION   
				SELECT pmid
				  FROM [Profile.Data].[Publication.Person.Include]
				 WHERE pmid IS NOT NULL AND pmid not in (select pmid from [Profile.Data].[Publication.PubMed.DisambiguationExclude]) 
			END 

	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK

		-- Raise an error with the details of the exception
		SELECT @ErrMsg = 'FAILED WITH : ' + ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()

		RAISERROR(@ErrMsg, @ErrSeverity, 1)

	END CATCH				
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[Concept.Mesh.UpdateCountTree]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
	DECLARE @proc VARCHAR(200)
	SELECT @proc = OBJECT_NAME(@@PROCID)
	DECLARE @date DATETIME,@auditid UNIQUEIDENTIFIER, @rows int
	SELECT @date=GETDATE() 
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
 
 
	select m.meshheader,
			count(*) num_publications,
			count(distinct a.personid) num_faculty,
			cast(0 as float) weight,
			sum( (case when m.majortopicyn = 'Y' then 1 else 0.25 end) * a.authorweight * a.yearweight ) rawweight
		into #cache_mesh_count
		from [Profile.Cache].[Publication.PubMed.AuthorPosition] a, [Profile.Data].[vwPublication.Pubmed.Mesh.Descriptor] m
		where a.pmid = m.pmid
		group by m.meshheader
	update #cache_mesh_count set weight = 10/sqrt(100 + rawweight)
	create unique clustered index idx_m on #cache_mesh_count(meshheader)
 
 
	SELECT *
		INTO #m
		FROM (
			SELECT m.treenumber mesh_code,
				m.descriptorname meshheader,
				COALESCE(c.numpublications,0) num_publications,
				COALESCE(c.numfaculty,0) num_faculty,
				COALESCE(c.weight,0) weight
			FROM [Profile.Data].[Concept.Mesh.TreeTop] m
				LEFT JOIN [Profile.Cache].[Concept.Mesh.Count] c
				ON m.descriptorname = c.meshheader
		) t
	CREATE UNIQUE CLUSTERED INDEX idx_pk ON #m (mesh_code)
 
	SELECT *,
				 (SELECT SUM(num_publications)
						FROM #m n
					 WHERE n.mesh_code LIKE m.mesh_code + '%') tot_publications,
				 (SELECT SUM(weight)
						FROM #m n
					 WHERE n.mesh_code LIKE m.mesh_code + '%') tot_weight
		INTO #n
		FROM #m m
	CREATE UNIQUE CLUSTERED INDEX idx_pk ON #n (mesh_code)
 
 
	BEGIN TRY
		BEGIN TRAN
			TRUNCATE TABLE [Profile.Cache].[Concept.Mesh.Count]
			INSERT INTO [Profile.Cache].[Concept.Mesh.Count](meshheader, numpublications, numfaculty, weight, rawweight)
				SELECT meshheader, num_publications, num_faculty, weight, rawweight
				FROM #cache_mesh_count
			TRUNCATE TABLE [Profile.Cache].[Concept.Mesh.Tree]
			INSERT INTO [Profile.Cache].[Concept.Mesh.Tree](meshcode, meshheader, numpublications, numfaculty, weight, totpublications, totweight)
				SELECT mesh_code, meshheader, num_publications, num_faculty, weight, tot_publications, tot_weight
				FROM #n
			SELECT @rows = @@ROWCOUNT
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=0
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName ='Concept.Mesh.UpdateCountTree',@ProcessEndDate=@date,@ProcessedRows = @rows,@insert_new_record=0
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Concept.Mesh.GetPublications]
	@NodeID BIGINT,
	@ListType varchar(50) = NULL,
	@LastDate datetime = '1/1/1900'
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @DescriptorName NVARCHAR(255)
 	SELECT @DescriptorName = d.DescriptorName
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n,
			[Profile.Data].[Concept.Mesh.Descriptor] d
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
			AND m.InternalID = d.DescriptorUI

	if @ListType = 'Newest' or @ListType IS NULL
	begin

		select *
		from (
			select top 10 g.pmid, g.pubdate, [Profile.Cache].[fnPublication.Pubmed.General2Reference](g.pmid, ArticleDay, ArticleMonth, ArticleYear, ArticleTitle, Authors, AuthorListCompleteYN, Issue, JournalDay, JournalMonth, JournalYear, MedlineDate, MedlinePgn, MedlineTA, Volume, 0) reference
			from [Profile.Data].[Publication.PubMed.General] g, (
				select m.pmid, max(MajorTopicYN) MajorTopicYN
				from [Profile.Data].[Publication.Person.Include] i, [Profile.Data].[Publication.PubMed.Mesh] m
				where i.pmid = m.pmid and i.pmid is not null and m.descriptorname = @DescriptorName
				group by m.pmid
			) m
			where g.pmid = m.pmid
			order by g.pubdate desc
		) t
		order by pubdate desc

	end

	if @ListType = 'Oldest' or @ListType IS NULL
	begin

		select *
		from (
			select top 10 g.pmid, g.pubdate, [Profile.Cache].[fnPublication.Pubmed.General2Reference](g.pmid, ArticleDay, ArticleMonth, ArticleYear, ArticleTitle, Authors, AuthorListCompleteYN, Issue, JournalDay, JournalMonth, JournalYear, MedlineDate, MedlinePgn, MedlineTA, Volume, 0) reference
			from [Profile.Data].[Publication.PubMed.General] g, (
				select m.pmid, max(MajorTopicYN) MajorTopicYN
				from [Profile.Data].[Publication.Person.Include] i, [Profile.Data].[Publication.PubMed.Mesh] m
				where i.pmid = m.pmid and i.pmid is not null and m.descriptorname = @DescriptorName
				group by m.pmid
			) m
			where g.pmid = m.pmid --and g.pubdate < @LastDate
			order by g.pubdate
		) t
		order by pubdate

	end


	if @ListType = 'Cited' or @ListType IS NULL
	begin

		;with pm_citation_count as (
			select pmid, 0 n
			from [Profile.Data].[Publication.PubMed.General]
		)
		select *
		from (
			select top 10 g.pmid, g.pubdate, c.n, [Profile.Cache].[fnPublication.Pubmed.General2Reference](g.pmid, ArticleDay, ArticleMonth, ArticleYear, ArticleTitle, Authors, AuthorListCompleteYN, Issue, JournalDay, JournalMonth, JournalYear, MedlineDate, MedlinePgn, MedlineTA, Volume, 0) reference
			from [Profile.Data].[Publication.PubMed.General] g, (
				select m.pmid, max(MajorTopicYN) MajorTopicYN
				from [Profile.Data].[Publication.Person.Include] i, [Profile.Data].[Publication.PubMed.Mesh] m
				where i.pmid = m.pmid and i.pmid is not null and m.descriptorname = @DescriptorName
				group by m.pmid
			) m, pm_citation_count c
			where g.pmid = m.pmid and m.pmid = c.pmid
			order by c.n desc, g.pubdate desc
		) t
		order by n desc, pubdate desc

	end

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Framework.].[ChangeBaseURI]
	@oldBaseURI varchar(1000),
	@newBaseURI varchar(1000)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
    /* 
 
	EXAMPLE:
 
	exec [Framework.].[ChangeBaseURI]	@oldBaseURI = 'http://connects.catalyst.harvard.edu/profiles/profile/',
						@newBaseURI = 'http://dev.connects.catalyst.harvard.edu/profiles/profile/'
 
	*/
 
	UPDATE [Framework.].[Parameter]
		SET Value = @newBaseURI
		WHERE ParameterID = 'baseURI'
 
	UPDATE [RDF.].[Node]
		SET Value = @newBaseURI + substring(value,len(@oldBaseURI)+1,len(value)),
			ValueHash = [RDF.].[fnValueHash](Language,DataType,@newBaseURI + substring(value,len(@oldBaseURI)+1,len(value)))
		WHERE Value LIKE @oldBaseURI + '%'
 
	UPDATE m
		SET m.ValueHash = n.ValueHash
		FROM [RDF.Stage].InternalNodeMap m, [RDF.].[Node] n
		WHERE m.NodeID = n.NodeID
 
	EXEC [Search.Cache].[Public.UpdateCache]

	EXEC [Search.Cache].[Private.UpdateCache]

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Ontology.].[AddProperty]
	@OWL nvarchar(100),
	@PropertyURI varchar(400),
	@PropertyName varchar(max),
	@ObjectType bit,
	@PropertyGroupURI varchar(400) = null,
	@SortOrder int = null,
	@ClassURI varchar(400) = null,
	@NetworkPropertyURI varchar(400) = null,
	@IsDetail bit = null,
	@Limit int = null,
	@IncludeDescription bit = null,
	@IncludeNetwork bit = null,
	@SearchWeight float = null,
	@CustomDisplay bit = null,
	@CustomEdit bit = null,
	@ViewSecurityGroup bigint = null,
	@EditSecurityGroup bigint = null,
	@EditPermissionsSecurityGroup bigint = null,
	@EditExistingSecurityGroup bigint = null,
	@EditAddNewSecurityGroup bigint = null,
	@EditAddExistingSecurityGroup bigint = null,
	@EditDeleteSecurityGroup bigint = null,
	@MinCardinality int = null,
	@MaxCardinality int = null,
	@CustomEditModule xml = null,
	@ReSortClassProperty bit = 1
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;


	---------------------------------------------------
	-- [Ontology.Import].[Triple]
	---------------------------------------------------

	DECLARE @LoadRDF BIT
	SELECT @LoadRDF = 0

	-- Get Graph
	DECLARE @Graph BIGINT
	SELECT @Graph = (SELECT Graph FROM [Ontology.Import].[OWL] WHERE Name = @OWL)

	-- Insert Type record
	IF NOT EXISTS (SELECT *
					FROM [Ontology.Import].[Triple]
					WHERE OWL = @OWL and Subject = @PropertyURI and Predicate = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
	BEGIN
		INSERT INTO [Ontology.Import].[Triple] (OWL, Graph, Subject, Predicate, Object)
			SELECT @OWL, @Graph, @PropertyURI,
				'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
				(CASE WHEN @ObjectType = 1 THEN 'http://www.w3.org/2002/07/owl#DatatypeProperty'
						ELSE 'http://www.w3.org/2002/07/owl#ObjectProperty' END)
		SELECT @LoadRDF = 1
	END
	
	-- Insert Label record
	IF NOT EXISTS (SELECT *
					FROM [Ontology.Import].[Triple]
					WHERE OWL = @OWL and Subject = @PropertyURI and Predicate = 'http://www.w3.org/2000/01/rdf-schema#label')
	BEGIN
		INSERT INTO [Ontology.Import].[Triple] (OWL, Graph, Subject, Predicate, Object)
			SELECT @OWL, @Graph, @PropertyURI,
				'http://www.w3.org/2000/01/rdf-schema#label',
				@PropertyName
		SELECT @LoadRDF = 1
	END

	-- Load RDF
	IF @LoadRDF = 1
	BEGIN
		EXEC [RDF.Stage].[LoadTriplesFromOntology] @OWL = @OWL, @Truncate = 1
		EXEC [RDF.Stage].[ProcessTriples]
	END
	
	---------------------------------------------------
	-- [Ontology.].[PropertyGroupProperty]
	---------------------------------------------------

	IF NOT EXISTS (SELECT * FROM [Ontology.].PropertyGroupProperty WHERE PropertyURI = @PropertyURI)
	BEGIN
	
		-- Validate the PropertyGroupURI
		SELECT @PropertyGroupURI = IsNull((SELECT TOP 1 PropertyGroupURI 
											FROM [Ontology.].PropertyGroup
											WHERE PropertyGroupURI = @PropertyGroupURI
												AND @PropertyGroupURI IS NOT NULL
											),'http://profiles.catalyst.harvard.edu/ontology/prns#PropertyGroupOverview')
		
		-- Validate the SortOrder
		DECLARE @MaxSortOrder INT
		SELECT @MaxSortOrder = IsNull((SELECT MAX(SortOrder)
										FROM [Ontology.].PropertyGroupProperty
										WHERE PropertyGroupURI = @PropertyGroupURI),0)
		SELECT @SortOrder = (CASE WHEN @SortOrder IS NULL THEN @MaxSortOrder+1
									WHEN @SortOrder > @MaxSortOrder THEN @MaxSortOrder+1
									ELSE @SortOrder END)

		-- Shift SortOrder of existing records
		UPDATE [Ontology.].PropertyGroupProperty
			SET SortOrder = SortOrder + 1
			WHERE PropertyGroupURI = @PropertyGroupURI AND SortOrder >= @SortOrder
		
		-- Insert new property
		INSERT INTO [Ontology.].PropertyGroupProperty (PropertyGroupURI, PropertyURI, SortOrder, _NumberOfNodes)
			SELECT @PropertyGroupURI, @PropertyURI, @SortOrder, 0

	END

	---------------------------------------------------
	-- [Ontology.].[ClassProperty]
	---------------------------------------------------

	IF (@ClassURI IS NOT NULL) AND NOT EXISTS (
		SELECT *
		FROM [Ontology.].[ClassProperty]
		WHERE Class = @ClassURI AND Property = @PropertyURI
			AND ( (NetworkProperty IS NULL AND @NetworkPropertyURI IS NULL) OR (NetworkProperty = @NetworkPropertyURI) )
	)
	BEGIN

		-- Get the ClassPropertyID	
		DECLARE @ClassPropertyID INT
		SELECT @ClassPropertyID = IsNull((SELECT MAX(ClassPropertyID)
											FROM [Ontology.].ClassProperty),0)+1
		-- Insert the new property
		INSERT INTO [Ontology.].[ClassProperty] (
				ClassPropertyID,
				Class, NetworkProperty, Property,
				IsDetail, Limit, IncludeDescription, IncludeNetwork, SearchWeight,
				CustomDisplay, CustomEdit, ViewSecurityGroup,
				EditSecurityGroup, EditPermissionsSecurityGroup, EditExistingSecurityGroup, EditAddNewSecurityGroup, EditAddExistingSecurityGroup, EditDeleteSecurityGroup,
				MinCardinality, MaxCardinality, CustomEditModule,
				_NumberOfNodes, _NumberOfTriples		
			)
			SELECT	@ClassPropertyID,
					@ClassURI, @NetworkPropertyURI, @PropertyURI,
					IsNull(@IsDetail,1), @Limit, IsNull(@IncludeDescription,0), IsNull(@IncludeNetwork,0),
					IsNull(@SearchWeight,(CASE WHEN @ObjectType = 0 THEN 0 ELSE 0.5 END)),
					IsNull(@CustomDisplay,0), IsNull(@CustomEdit,0), IsNull(@ViewSecurityGroup,-1),
					IsNull(@EditSecurityGroup,-40),
					Coalesce(@EditPermissionsSecurityGroup,@EditSecurityGroup,-40),
					Coalesce(@EditExistingSecurityGroup,@EditSecurityGroup,-40),
					Coalesce(@EditAddNewSecurityGroup,@EditSecurityGroup,-40),
					Coalesce(@EditAddExistingSecurityGroup,@EditSecurityGroup,-40),
					Coalesce(@EditDeleteSecurityGroup,@EditSecurityGroup,-40),
					IsNull(@MinCardinality,0),
					@MaxCardinality,
					@CustomEditModule,
					0, 0

		-- Re-sort the table
		IF @ReSortClassProperty = 1
		BEGIN
			update x
				set x.ClassPropertyID = y.k
				from [Ontology.].ClassProperty x, (
					select *, row_number() over (order by (case when NetworkProperty is null then 0 else 1 end), Class, NetworkProperty, IsDetail, IncludeNetwork, Property) k
						from [Ontology.].ClassProperty
				) y
				where x.Class = y.Class and x.Property = y.Property
					and ((x.NetworkProperty is null and y.NetworkProperty is null) or (x.NetworkProperty = y.NetworkProperty))

					
			update x 
				set x._ClassPropertyID = b.ClassPropertyID 
				from [Ontology.].ClassPropertyCustom x join [Ontology.].ClassProperty b
					on x.Class=b.Class and x.Property=b.Property
					and ((x.NetworkProperty is null and b.NetworkProperty is null) or (x.NetworkProperty = b.NetworkProperty))
		END
	END

	---------------------------------------------------
	-- Update Derived Fields
	---------------------------------------------------

	EXEC [Ontology.].UpdateDerivedFields
	
	
	/*
	
	-- Example
	exec [Ontology.].AddProperty
		@OWL = 'PRNS_1.0',
		@PropertyURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#emailEncrypted',
		@PropertyName = 'email encrypted',
		@ObjectType = 1,
		@PropertyGroupURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#PropertyGroupAddress',
		@SortOrder = 20,
		@ClassURI = 'http://xmlns.com/foaf/0.1/Person',
		@NetworkPropertyURI = null,
		@IsDetail = 0,
		@SearchWeight = 0,
		@CustomDisplay = 1,
		@CustomEdit = 1

	*/
	
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [RDF.].[DeleteNode]
	@NodeID bigint = NULL,
	@NodeURI varchar(400) = NULL,
	@DeleteType tinyint = 1,
	@SessionID uniqueidentifier = NULL,
	-- Output variables
	@Error bit = NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
	
	SELECT @Error = 0
	
	SELECT @NodeID = NULL WHERE @NodeID = 0
 
	IF (@NodeID IS NULL) AND (@NodeURI IS NOT NULL)
		SELECT @NodeID = [RDF.].fnURI2NodeID(@NodeURI)
 
	IF (@NodeID IS NOT NULL)
	BEGIN TRY
	BEGIN TRANSACTION
	    
		IF @DeleteType = 0 -- True delete
		BEGIN
			EXEC [RDF.].[DeleteTriple] @DeleteType = @DeleteType, @SessionID = @SessionID, @SubjectID = @NodeID
			EXEC [RDF.].[DeleteTriple] @DeleteType = @DeleteType, @SessionID = @SessionID, @PredicateID = @NodeID
			EXEC [RDF.].[DeleteTriple] @DeleteType = @DeleteType, @SessionID = @SessionID, @ObjectID = @NodeID
			DELETE
				FROM [RDF.Stage].[InternalNodeMap]
				WHERE NodeID = @NodeID
			DELETE
				FROM [RDF.].[Node]
				WHERE NodeID = @NodeID
		END
 
		IF @DeleteType = 1 -- Change security groups
		BEGIN
			UPDATE [RDF.].[Node]
				SET ViewSecurityGroup = 0, EditSecurityGroup = -50
				WHERE NodeID = @NodeID
		END
  
	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=0
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[CustomViewAuthorInAuthorship.GetList]
	@NodeID bigint = NULL,
	@SessionID uniqueidentifier = NULL
AS
BEGIN

	DECLARE @SecurityGroupID BIGINT, @HasSpecialViewAccess BIT
	EXEC [RDF.Security].GetSessionSecurityGroup @SessionID, @SecurityGroupID OUTPUT, @HasSpecialViewAccess OUTPUT
	CREATE TABLE #SecurityGroupNodes (SecurityGroupNode BIGINT PRIMARY KEY)
	INSERT INTO #SecurityGroupNodes (SecurityGroupNode) EXEC [RDF.Security].GetSessionSecurityGroupNodes @SessionID, @NodeID


	declare @AuthorInAuthorship bigint
	select @AuthorInAuthorship = [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#authorInAuthorship') 
	declare @LinkedInformationResource bigint
	select @LinkedInformationResource = [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#linkedInformationResource') 


	select i.NodeID, p.EntityID, i.Value rdf_about, p.EntityName rdfs_label, 
		isnull(e.AuthorsString, p.Authors) + p.Reference prns_informationResourceReference, p.EntityDate prns_publicationDate,
		year(p.EntityDate) prns_year, p.pmid bibo_pmid, p.pmcid vivo_pmcid, p.doi bibo_doi, p.mpid prns_mpid, p.URL vivo_webpage, 
		isnull(b.PMCCitations, -1) as PMCCitations, isnull(Fields, '') as Fields, isnull(TranslationHumans , 0) as TranslationHumans, isnull(TranslationAnimals , 0) as TranslationAnimals, 
		isnull(TranslationCells , 0) as TranslationCells, isnull(TranslationPublicHealth , 0) as TranslationPublicHealth, isnull(TranslationClinicalTrial , 0) as TranslationClinicalTrial
	from [RDF.].[Triple] t
		inner join [RDF.].[Node] a
			on t.subject = @NodeID and t.predicate = @AuthorInAuthorship
				and t.object = a.NodeID
				and ((t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
				and ((a.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (a.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (a.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
		inner join [RDF.].[Node] i
			on t.object = i.NodeID
				and ((i.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (i.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (i.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
		inner join [RDF.Stage].[InternalNodeMap] m
			on i.NodeID = m.NodeID
		inner join [Profile.Data].[Publication.Entity.Authorship] e
			on m.InternalID = e.EntityID
		inner join [Profile.Data].[Publication.Entity.InformationResource] p
			on e.InformationResourceID = p.EntityID
		left join [Profile.Data].[Publication.Pubmed.Bibliometrics] b on p.PMID = b.PMID
	order by p.EntityDate desc

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[Concept.Mesh.UpdatePersonPublication]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
	DECLARE @proc VARCHAR(200)
	SELECT @proc = OBJECT_NAME(@@PROCID)
	DECLARE @date DATETIME,@auditid UNIQUEIDENTIFIER, @rows int
	SELECT @date=GETDATE() 
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
 
	SELECT *, (case when majortopicyn='Y' then 1.0 else 0.25 end) TopicWeight 
		INTO #pm_pub_mesh 
		FROM [Profile.Data].[vwPublication.Pubmed.Mesh.Descriptor]
	CREATE UNIQUE CLUSTERED INDEX idx_pm on #pm_pub_mesh(pmid, meshheader)
 
	SELECT m.MeshHeader, a.PersonID, a.PMID, c.NumPublications NumPubsAll, 1 NumPubsThis,
			m.TopicWeight, a.AuthorWeight, a.YearWeight, c.Weight UniquenessWeight,
			m.TopicWeight * a.AuthorWeight * a.YearWeight * c.Weight MeshWeight,
			a.AuthorPosition, a.PubYear, c.NumFaculty NumPeopleAll, a.PubDate
		INTO #cache_pub_mesh
		FROM #pm_pub_mesh m, [Profile.Cache].[Publication.PubMed.AuthorPosition] a, [Profile.Cache].[Concept.Mesh.Count] c
		WHERE a.pmid = m.pmid and m.meshheader = c.meshheader
 
	BEGIN TRY
		BEGIN TRAN
			TRUNCATE TABLE [Profile.Cache].[Concept.Mesh.PersonPublication]
			INSERT INTO [Profile.Cache].[Concept.Mesh.PersonPublication] (MeshHeader, PersonID, PMID, NumPubsAll, NumPubsThis, TopicWeight, AuthorWeight, YearWeight, UniquenessWeight, MeshWeight, AuthorPosition, PubYear, NumPeopleAll, PubDate)
				SELECT MeshHeader, PersonID, PMID, NumPubsAll, NumPubsThis, TopicWeight, AuthorWeight, YearWeight, UniquenessWeight, MeshWeight, AuthorPosition, PubYear, NumPeopleAll, PubDate
				FROM #cache_pub_mesh
			SELECT @rows = @@ROWCOUNT
		COMMIT
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=0
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName ='usp_cache_pub_mesh',@ProcessEndDate=@date,@ProcessedRows = @rows,@insert_new_record=0
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Edit.Module].[CustomEditAuthorInAuthorship.GetList]
	@NodeID bigint = NULL,
	@SessionID uniqueidentifier = NULL
AS
BEGIN

	DECLARE @PersonID INT
 
	SELECT @PersonID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
 
	SELECT r.Reference, (CASE WHEN r.PMID IS NOT NULL THEN 1 ELSE 0 END) FromPubMed, i.PubID, r.PMID, r.MPID, NULL Category, r.URL, r.EntityDate PubDate, r.EntityID, r.Source, r.IsActive, i.PersonID
		FROM [Profile.Data].[Publication.Person.Include] i
			INNER JOIN [Profile.Data].[Publication.Entity.InformationResource] r
				ON i.PMID = r.PMID AND i.PMID IS NOT NULL
				AND i.PersonID = @PersonID
	UNION ALL
	SELECT r.Reference, (CASE WHEN r.PMID IS NOT NULL THEN 1 ELSE 0 END) FromPubMed, i.PubID, r.PMID, r.MPID, g.HmsPubCategory Category, r.URL, r.EntityDate PubDate, r.EntityID, r.Source, r.IsActive, i.PersonID
		FROM [Profile.Data].[Publication.Person.Include] i
			INNER JOIN [Profile.Data].[Publication.Entity.InformationResource] r
				ON i.MPID = r.MPID AND i.PMID IS NULL AND i.MPID IS NOT NULL
				AND i.PersonID = @PersonID
			INNER JOIN [Profile.Data].[Publication.MyPub.General] g
				ON i.MPID = g.MPID
	ORDER BY EntityDate DESC, EntityID

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[NetworkTimeline.Person.CoAuthorOf.GetData]
	@NodeID BIGINT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @PersonID INT
 	SELECT @PersonID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
 
 	DECLARE @baseURI NVARCHAR(400)
	SELECT @baseURI = value FROM [Framework.].Parameter WHERE ParameterID = 'baseURI'

	;with e as (
		select top 20 s.PersonID1, s.PersonID2, s.n PublicationCount, 
			year(s.FirstPubDate) FirstPublicationYear, year(s.LastPubDate) LastPublicationYear, 
			p.DisplayName DisplayName2, ltrim(rtrim(p.FirstName+' '+p.LastName)) FirstLast2, s.w OverallWeight
		from [Profile.Cache].[SNA.Coauthor] s, [Profile.Cache].[Person] p
		where personid1 = @PersonID and personid2 = p.personid
		order by w desc, personid2
	), f as (
		select e.*, g.pubdate
		from [Profile.Data].[Publication.Person.Include] a, 
			[Profile.Data].[Publication.Person.Include] b, 
			[Profile.Data].[Publication.PubMed.General] g,
			e
		where a.personid = e.personid1 and b.personid = e.personid2 and a.pmid = b.pmid and a.pmid = g.pmid
			and g.pubdate > '1/1/1900'
	), g as (
		select min(year(pubdate))-1 a, max(year(pubdate))+1 b,
			cast(cast('1/1/'+cast(min(year(pubdate))-1 as varchar(10)) as datetime) as float) f,
			cast(cast('1/1/'+cast(max(year(pubdate))+1 as varchar(10)) as datetime) as float) g
		from f
	), h as (
		select f.*, (cast(pubdate as float)-f)/(g-f) x, a, b, f, g
		from f, g
	), i as (
		select personid2, min(x) MinX, max(x) MaxX, avg(x) AvgX
		from h
		group by personid2
	)
	select h.*, MinX, MaxX, AvgX, h.FirstLast2 label, (select count(distinct personid2) from i) n,
		@baseURI + cast(m.NodeID as varchar(50)) ObjectURI
	from h, i, [RDF.Stage].[InternalNodeMap] m
	where h.personid2 = i.personid2 and cast(i.personid2 as varchar(50)) = m.InternalID
		and m.Class = 'http://xmlns.com/foaf/0.1/Person' and m.InternalType = 'Person'
	order by AvgX, firstpublicationyear, lastpublicationyear, personid2, pubdate

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [RDF.].[GetStoreNode]
	-- Cat0
	@ExistingNodeID bigint = null,
	-- Cat1
	@Value nvarchar(max) = null,
	@Language nvarchar(255) = null,
	@DataType nvarchar(255) = null,
	@ObjectType bit = null,
	-- Cat2
	@Class nvarchar(400) = null,
	@InternalType nvarchar(100) = null,
	@InternalID nvarchar(100) = null,
	-- Cat3
	@TripleID bigint = null,
	-- Cat5, Cat6
	@StartTime nvarchar(100) = null,
	@EndTime nvarchar(100) = null,
	@TimePrecision nvarchar(100) = null,
	-- Cat7
	@DefaultURI bit = null,
	-- Cat8
	@EntityClassID bigint = null,
	@EntityClassURI varchar(400) = null,
	@Label nvarchar(max) = null,
	@ForceNewEntity bit = 0,
	-- Cat9
	@SubjectID bigint = null,
	@PredicateID bigint = null,
	@SortOrder int = null,
	-- Attributes
	@ViewSecurityGroup bigint = null,
	@EditSecurityGroup bigint = null,
	-- Security
	@SessionID uniqueidentifier = NULL,
	-- Output variables
	@Error bit = NULL OUTPUT,
	@NodeID bigint = NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	/* 
	The node can be defined in different ways:
		Cat 0: ExistingNodeID (a NodeID from [RDF.].Node)
		Cat 1: Value, Language, DataType, ObjectType (standard RDF literal [ObjectType=1], or just Value if URI [ObjectType=0])
		Cat 2: NodeType (primary VIVO type, http://xmlns.com/foaf/0.1/Person), InternalType (Profiles10 type, such as "Person"), InternalID (personID=32213)
		Cat 3: TripleID (from [RDF.].Triple -- a reitification)
		Cat 5: StartTime, EndTime, TimePrecision (VIVO's DateTimeInterval, DateTimeValue, and DateTimeValuePrecision classes)
		Cat 6: StartTime, TimePrecision (VIVO's DateTimeValue, and DateTimeValuePrecision classes)
		Cat 7: The default URI: baseURI+NodeID
		Cat 8: New entity with class (by node ID or URI) and label; ForceNewEntity=1 always creates a new node
		Cat 9: The object node of a triple given the SubjectID node, PredicateID node, and the triple sort order
	*/

	SELECT @Error = 0

	SELECT @ExistingNodeID = NULL WHERE @ExistingNodeID = 0
	SELECT @TripleID = NULL WHERE @TripleID = 0

 	IF (@EntityClassID IS NULL) AND (@EntityClassURI IS NOT NULL)
		SELECT @EntityClassID = [RDF.].fnURI2NodeID(@EntityClassURI)

	-- Determine the category
	DECLARE @Category INT
	SELECT @Category = (
		CASE
			WHEN (@ExistingNodeID IS NOT NULL) THEN 0
			WHEN (@Value IS NOT NULL) THEN 1
			WHEN ((@Class IS NOT NULL) AND (@InternalType IS NOT NULL) AND (@InternalID IS NOT NULL)) THEN 2
			WHEN (@TripleID IS NOT NULL) THEN 3
			WHEN ((@StartTime IS NOT NULL) AND (@EndTime IS NOT NULL) AND (@TimePrecision IS NOT NULL)) THEN 5
			WHEN ((@StartTime IS NOT NULL) AND (@TimePrecision IS NOT NULL)) THEN 6
			WHEN (@DefaultURI = 1) THEN 7
			WHEN ((@EntityClassID IS NOT NULL) AND (IsNull(@Label,'')<>'')) THEN 8
			WHEN ((@SubjectID IS NOT NULL) AND (@PredicateID IS NOT NULL) AND (@SortOrder IS NOT NULL)) THEN 9
			ELSE NULL END)

	IF @Category IS NULL
	BEGIN
		SELECT @Error = 1
		RETURN
	END

	-- Determine if the node already exists
	SELECT @NodeID = (CASE
		WHEN @Category = 0 THEN (
				SELECT NodeID
				FROM [RDF.].[Node]
				WHERE NodeID = @ExistingNodeID
			)
		WHEN @Category = 1 THEN (
				SELECT NodeID
				FROM [RDF.].[Node]
				WHERE ValueHash = [RDF.].[fnValueHash](@Language,@DataType,@Value)
			)
		WHEN @Category = 2 THEN (
				SELECT NodeID
				FROM [RDF.Stage].InternalNodeMap
				WHERE Class = @Class AND InternalType = @InternalType AND InternalID = @InternalID
			)
		WHEN @Category = 8 THEN (
				SELECT NodeID
				FROM [RDF.].Triple t, [RDF.].Triple v, [RDF.].Node n
				WHERE t.subject = v.subject
					AND t.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
					AND t.object = @EntityClassID
					AND v.predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')
					AND v.object = n.NodeID
					AND n.ValueHash = [RDF.].[fnValueHash](null,null,@Label)
					AND @ForceNewEntity = 0
			)
		WHEN @Category = 9 THEN (
				SELECT t.Object
				FROM [RDF.].[Triple] t
				WHERE t.subject = @SubjectID
					AND t.predicate = @PredicateID
					AND t.SortOrder = @SortOrder
			)
		ELSE NULL END)

	-- Update attributes of an existing node
	IF (@NodeID IS NOT NULL) AND (IsNull(@ViewSecurityGroup,@EditSecurityGroup) IS NOT NULL)
	BEGIN
		UPDATE [RDF.].Node
			SET ViewSecurityGroup = IsNull(@ViewSecurityGroup,ViewSecurityGroup),
				EditSecurityGroup = IsNull(@EditSecurityGroup,EditSecurityGroup)
			WHERE NodeID = @NodeID
	END

	-- Check that if a new node is needed, then all attributes are defined
	IF (@NodeID IS NULL)
	BEGIN
		SELECT	@ViewSecurityGroup = IsNull(@ViewSecurityGroup,-1),
				@EditSecurityGroup = IsNull(@EditSecurityGroup,-40)
		SELECT	@ObjectType = (CASE WHEN @Value LIKE 'http://%' or @Value LIKE 'https://%' THEN 0 ELSE 1 END)
			WHERE (@Category=1 AND @ObjectType IS NULL)
	END

	-- Create a new node if needed
	IF (@NodeID IS NULL)	
	BEGIN
		BEGIN TRY 
		BEGIN TRANSACTION

		-- Lookup the base URI
		DECLARE @baseURI NVARCHAR(400)
		SELECT @baseURI = Value FROM [Framework.].Parameter WHERE ParameterID = 'baseURI'

		-- Create node based on category
		IF @Category = 1
			BEGIN
				INSERT INTO [RDF.].[Node] (ViewSecurityGroup, EditSecurityGroup, Language, DataType, Value, ObjectType, ValueHash)
					SELECT @ViewSecurityGroup, @EditSecurityGroup, @Language, @DataType, @Value, @ObjectType,
						[RDF.].[fnValueHash](@Language,@DataType,@Value)
				SET @NodeID = @@IDENTITY
			END
		IF @Category = 2
			BEGIN
				-- Create the InternalNodeMap record
				DECLARE @InternalNodeMapID BIGINT
				INSERT INTO [RDF.Stage].[InternalNodeMap] (InternalType, InternalID, Class, Status, InternalHash)
					SELECT @InternalType, @InternalID, @Class, 4, 
						[RDF.].fnValueHash(null,null,@Class+'^^'+@InternalType+'^^'+@InternalID)
				SET @InternalNodeMapID = @@IDENTITY
				-- Create the Node
				INSERT INTO [RDF.].[Node] (ViewSecurityGroup, EditSecurityGroup, InternalNodeMapID, ObjectType, Value, ValueHash)
					SELECT @ViewSecurityGroup, @EditSecurityGroup, @InternalNodeMapID, 0,
						'#INM'+cast(@InternalNodeMapID as nvarchar(50)),
						[RDF.].fnValueHash(null,null,'#INM'+cast(@InternalNodeMapID as nvarchar(50)))
				SET @NodeID = @@IDENTITY
				-- Update the InternalNodeMap, given the NodeID
				UPDATE [RDF.Stage].[InternalNodeMap]
					SET NodeID = @NodeID, Status = 3,
						ValueHash = [RDF.].fnValueHash(null,null,@baseURI+cast(@NodeID as nvarchar(50)))
					WHERE InternalNodeMapID = @InternalNodeMapID
				-- Update the Node, given the NodeID
				UPDATE [RDF.].[Node]
					SET Value = @baseURI+cast(@NodeID as nvarchar(50)),
						ValueHash = [RDF.].fnValueHash(null,null,@baseURI+cast(@NodeID as nvarchar(50)))
					WHERE NodeID = @NodeID
			END
		IF @Category = 7
			BEGIN
				-- Create the Node
				DECLARE @TempValue varchar(50)
				SELECT @TempValue = '#NODE'+cast(NewID() as varchar(50))
				INSERT INTO [RDF.].[Node] (ViewSecurityGroup, EditSecurityGroup, Value, ObjectType, ValueHash)
					SELECT @ViewSecurityGroup, @EditSecurityGroup, @TempValue, 0, [RDF.].[fnValueHash](NULL,NULL,@TempValue)
				SET @NodeID = @@IDENTITY
				-- Update the Node, given the NodeID
				UPDATE [RDF.].[Node]
					SET Value = @baseURI+cast(@NodeID as nvarchar(50)),
						ValueHash = [RDF.].fnValueHash(null,null,@baseURI+cast(@NodeID as nvarchar(50)))
					WHERE NodeID = @NodeID
			END
		IF @Category = 8
			BEGIN
				-- Create the new node
				EXEC [RDF.].GetStoreNode	@DefaultURI = 1,
											@ViewSecurityGroup = @ViewSecurityGroup,
											@EditSecurityGroup = @EditSecurityGroup,
											@SessionID = @SessionID,
											@Error = @Error OUTPUT,
											@NodeID = @NodeID OUTPUT
				IF @Error = 1
				BEGIN
					RETURN
				END
				-- Convert URIs to NodeIDs
				DECLARE @TypeID BIGINT
				DECLARE @LabelID BIGINT
				DECLARE @ClassID BIGINT
				DECLARE @SubClassID BIGINT
				SELECT	@TypeID = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
						@LabelID = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label'),
						@ClassID = [RDF.].fnURI2NodeID('http://www.w3.org/2002/07/owl#Class'),
						@SubClassID = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#subClassOf')
				-- Add class(es) to new node
				DECLARE @TempClassID BIGINT
				SELECT @TempClassID = @EntityClassID
				WHILE (@TempClassID IS NOT NULL)
				BEGIN
					EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
												@PredicateID = @TypeID,
												@ObjectID = @TempClassID,
												@ViewSecurityGroup = -1,
												@Weight = 1,
												@SessionID = @SessionID,
												@Error = @Error OUTPUT
					IF @Error = 1
					BEGIN
						RETURN
					END
					-- Determine if there is a parent class
					SELECT @TempClassID = (
							SELECT TOP 1 t.object
							FROM [RDF.].Triple t, [RDF.].Triple c
							WHERE t.subject = @TempClassID
								AND t.predicate = @SubClassID
								AND c.subject = t.object
								AND c.predicate = @TypeID
								AND c.object = @ClassID
								AND NOT EXISTS (
									SELECT *
									FROM [RDF.].Triple v
									WHERE v.subject = @NodeID
										AND v.predicate = @TypeID
										AND v.object = t.object
								)
						)
				END
				-- Get node ID for label
				DECLARE @LabelNodeID BIGINT
				EXEC [RDF.].GetStoreNode	@Value = @Label,
											@ObjectType = 1,
											@ViewSecurityGroup = -1,
											@EditSecurityGroup = -40,
											@SessionID = @SessionID,
											@Error = @Error OUTPUT,
											@NodeID = @LabelNodeID OUTPUT
				IF @Error = 1
				BEGIN
					RETURN
				END
				-- Add label to new node
				EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
											@PredicateID = @LabelID,
											@ObjectID = @LabelNodeID,
											@ViewSecurityGroup = -1,
											@Weight = 1,
											@SortOrder = 1,
											@SessionID = @SessionID,
											@Error = @Error OUTPUT
				IF @Error = 1
				BEGIN
					RETURN
				END
			END
		IF @Category = 9
			BEGIN
				-- We can't create a new node in this case, so throw an error
				SELECT @Error = 1
			END

		COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK

		-- Raise an error with the details of the exception
		SELECT @ErrMsg =  ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()

		RAISERROR(@ErrMsg, @ErrSeverity, 1)

	END CATCH		
	END

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [RDF.].[GetDataRDF]
	@subject BIGINT=NULL,
	@predicate BIGINT=NULL,
	@object BIGINT=NULL,
	@offset BIGINT=NULL,
	@limit BIGINT=NULL,
	@showDetails BIT=1,
	@expand BIT=1,
	@SessionID UNIQUEIDENTIFIER=NULL,
	@NodeListXML XML=NULL,
	@ExpandRDFListXML XML=NULL,
	@returnXML BIT=1,
	@returnXMLasStr BIT=0,
	@dataStr NVARCHAR (MAX)=NULL OUTPUT,
	@dataStrDataType NVARCHAR (255)=NULL OUTPUT,
	@dataStrLanguage NVARCHAR (255)=NULL OUTPUT,
	@RDF XML=NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	/*

	This stored procedure returns the data for a node in RDF format.

	Input parameters:
		@subject		The NodeID whose RDF should be returned.
		@predicate		The predicate NodeID for a network.
		@object			The object NodeID for a connection.
		@offset			Pagination - The first object node to return.
		@limit			Pagination - The number of object nodes to return.
		@showDetails	If 1, then additional properties will be returned.
		@expand			If 1, then object properties will be expanded.
		@SessionID		The SessionID of the user requesting the data.

	There are two ways to call this procedure. By default, @returnXML = 1,
	and the RDF is returned as XML. When @returnXML = 0, the data is instead
	returned as the strings @dataStr, @dataStrDataType, and @dataStrLanguage.
	This second method of calling this procedure is used by other procedures
	and is generally not called directly by the website.

	The RDF returned by this procedure is not equivalent to what is
	returned by SPARQL. This procedure applies security rules, expands
	nodes as defined by [Ontology.].[RDFExpand], and calculates network
	information on-the-fly.

	*/

	--declare @debugLogID int
	--insert into [RDF.].[GetDataRDF.DebugLog] (subject,predicate,object,offset,limit,showDetails,expand,SessionID,StartDate)
	--	select @subject,@predicate,@object,@offset,@limit,@showDetails,@expand,@SessionID,GetDate()
	--select @debugLogID = @@IDENTITY
	--insert into [RDF.].[GetDataRDF.DebugLog.ExpandRDFListXML] (LogID, ExpandRDFListXML)
	--	select @debugLogID, @ExpandRDFListXML

	
	declare @d datetime

	declare @baseURI nvarchar(400)
	select @baseURI = value from [Framework.].Parameter where ParameterID = 'baseURI'

	select @subject = null where @subject = 0
	select @predicate = null where @predicate = 0
	select @object = null where @object = 0
		
	declare @firstURI nvarchar(400)
	select @firstURI = @baseURI+cast(@subject as varchar(50))

	declare @firstValue nvarchar(400)
	select @firstValue = null
	
	declare @typeID bigint
	select @typeID = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')

	declare @labelID bigint
	select @labelID = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')	

	declare @validURI bit
	select @validURI = 1
	
	declare @includePredicates bit
	select @includePredicates = 1

	--*******************************************************************************************
	--*******************************************************************************************
	-- Define temp tables
	--*******************************************************************************************
	--*******************************************************************************************

	/*
		drop table #subjects
		drop table #types
		drop table #expand
		drop table #properties
		drop table #connections
	*/

	create table #subjects (
		subject bigint primary key,
		showDetail bit,
		expanded bit,
		uri nvarchar(400)
	)
	
	create table #types (
		subject bigint not null,
		object bigint not null,
		predicate bigint,
		showDetail bit,
		uri nvarchar(400)
	)
	create unique clustered index idx_sop on #types (subject,object,predicate)

	create table #expand (
		subject bigint not null,
		predicate bigint not null,
		uri nvarchar(400),
		property nvarchar(400),
		tagName nvarchar(1000),
		propertyLabel nvarchar(400),
		IsDetail bit,
		limit bigint,
		showStats bit,
		showSummary bit
	)
	alter table #expand add primary key (subject,predicate)

	create table #properties (
		uri nvarchar(400),
		subject bigint,
		predicate bigint,
		object bigint,
		showSummary bit,
		property nvarchar(400),
		tagName nvarchar(1000),
		propertyLabel nvarchar(400),
		Language nvarchar(255),
		DataType nvarchar(255),
		Value nvarchar(max),
		ObjectType bit,
		SortOrder int
	)

	create table #connections (
		subject bigint,
		subjectURI nvarchar(400),
		predicate bigint,
		predicateURI nvarchar(400),
		object bigint,
		Language nvarchar(255),
		DataType nvarchar(255),
		Value nvarchar(max),
		ObjectType bit,
		SortOrder int,
		Weight float,
		Reitification bigint,
		ReitificationURI nvarchar(400),
		connectionURI nvarchar(400)
	)
	
	create table #ClassPropertyCustom (
		ClassPropertyID int primary key,
		IncludeProperty bit,
		Limit int,
		IncludeNetwork bit,
		IncludeDescription bit,
		IsDetail bit
	)

	--*******************************************************************************************
	--*******************************************************************************************
	-- Setup variables used for security
	--*******************************************************************************************
	--*******************************************************************************************

	DECLARE @SecurityGroupID BIGINT, @HasSpecialViewAccess BIT, @HasSecurityGroupNodes BIT
	EXEC [RDF.Security].GetSessionSecurityGroup @SessionID, @SecurityGroupID OUTPUT, @HasSpecialViewAccess OUTPUT
	CREATE TABLE #SecurityGroupNodes (SecurityGroupNode BIGINT PRIMARY KEY)
	INSERT INTO #SecurityGroupNodes (SecurityGroupNode) EXEC [RDF.Security].GetSessionSecurityGroupNodes @SessionID, @Subject
	SELECT @HasSecurityGroupNodes = (CASE WHEN EXISTS (SELECT * FROM #SecurityGroupNodes) THEN 1 ELSE 0 END)


	--*******************************************************************************************
	--*******************************************************************************************
	-- Check if user has access to the URI
	--*******************************************************************************************
	--*******************************************************************************************

	if @subject is not null
		select @validURI = 0
			where not exists (
				select *
				from [RDF.].Node
				where NodeID = @subject
					and ( (ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) )
			)

	if @predicate is not null
		select @validURI = 0
			where not exists (
				select *
				from [RDF.].Node
				where NodeID = @predicate and ObjectType = 0
					and ( (ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) )
			)

	if @object is not null
		select @validURI = 0
			where not exists (
				select *
				from [RDF.].Node
				where NodeID = @object and ObjectType = 0
					and ( (ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) )
			)


	--*******************************************************************************************
	--*******************************************************************************************
	-- Get subject information when it is a literal
	--*******************************************************************************************
	--*******************************************************************************************

	select @dataStr = Value, @dataStrDataType = DataType, @dataStrLanguage = Language
		from [RDF.].Node
		where NodeID = @subject and ObjectType = 1
			and ( (ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) )


	--*******************************************************************************************
	--*******************************************************************************************
	-- Seed temp tables
	--*******************************************************************************************
	--*******************************************************************************************

	---------------------------------------------------------------------------------------------
	-- Profile [seed with the subject(s)]
	---------------------------------------------------------------------------------------------
	if (@subject is not null) and (@predicate is null) and (@object is null)
	begin
		insert into #subjects(subject,showDetail,expanded,URI)
			select NodeID, @showDetails, 0, Value
				from [RDF.].Node
				where NodeID = @subject
					and ((ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
		select @firstValue = URI
			from #subjects s, [RDF.].Node n
			where s.subject = @subject
				and s.subject = n.NodeID and n.ObjectType = 0
	end
	if (@NodeListXML is not null)
	begin
		insert into #subjects(subject,showDetail,expanded,URI)
			select n.NodeID, t.ShowDetails, 0, n.Value
			from [RDF.].Node n, (
				select NodeID, MAX(ShowDetails) ShowDetails
				from (
					select x.value('@ID','bigint') NodeID, IsNull(x.value('@ShowDetails','tinyint'),0) ShowDetails
					from @NodeListXML.nodes('//Node') as N(x)
				) t
				group by NodeID
				having NodeID not in (select subject from #subjects)
			) t
			where n.NodeID = t.NodeID and n.ObjectType = 0
	end
	
	---------------------------------------------------------------------------------------------
	-- Get all connections
	---------------------------------------------------------------------------------------------
	insert into #connections (subject, subjectURI, predicate, predicateURI, object, Language, DataType, Value, ObjectType, SortOrder, Weight, Reitification, ReitificationURI, connectionURI)
		select	s.NodeID subject, s.value subjectURI, 
				p.NodeID predicate, p.value predicateURI,
				t.object, o.Language, o.DataType, o.Value, o.ObjectType,
				t.SortOrder, t.Weight, 
				r.NodeID Reitification, r.Value ReitificationURI,
				@baseURI+cast(@subject as varchar(50))+'/'+cast(@predicate as varchar(50))+'/'+cast(object as varchar(50)) connectionURI
			from [RDF.].Triple t
				inner join [RDF.].Node s
					on t.subject = s.NodeID
				inner join [RDF.].Node p
					on t.predicate = p.NodeID
				inner join [RDF.].Node o
					on t.object = o.NodeID
				left join [RDF.].Node r
					on t.reitification = r.NodeID
						and t.reitification is not null
						and ((r.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (r.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (r.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
			where @subject is not null and @predicate is not null
				and s.NodeID = @subject 
				and p.NodeID = @predicate 
				and o.NodeID = IsNull(@object,o.NodeID)
				and ((t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
				and ((s.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (s.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (s.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
				and ((p.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (p.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (p.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
				and ((o.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (o.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (o.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))

	-- Make sure there are connections
	if (@subject is not null) and (@predicate is not null)
		select @validURI = 0
		where not exists (select * from #connections)

	---------------------------------------------------------------------------------------------
	-- Network [seed with network statistics and connections]
	---------------------------------------------------------------------------------------------
	if (@subject is not null) and (@predicate is not null) and (@object is null)
	begin
		select @firstURI = @baseURI+cast(@subject as varchar(50))+'/'+cast(@predicate as varchar(50))
		-- Basic network properties
		;with networkProperties as (
			select 1 n, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' property, 'rdf:type' tagName, 'type' propertyLabel, 0 ObjectType
			union all select 2, 'http://profiles.catalyst.harvard.edu/ontology/prns#numberOfConnections', 'prns:numberOfConnections', 'number of connections', 1
			union all select 3, 'http://profiles.catalyst.harvard.edu/ontology/prns#maxWeight', 'prns:maxWeight', 'maximum connection weight', 1
			union all select 4, 'http://profiles.catalyst.harvard.edu/ontology/prns#minWeight', 'prns:minWeight', 'minimum connection weight', 1
			union all select 5, 'http://profiles.catalyst.harvard.edu/ontology/prns#predicateNode', 'prns:predicateNode', 'predicate node', 0
			union all select 6, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate', 'rdf:predicate', 'predicate', 0
			union all select 7, 'http://www.w3.org/2000/01/rdf-schema#label', 'rdfs:label', 'label', 1
			union all select 8, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#subject', 'rdf:subject', 'subject', 0
		), networkStats as (
			select	cast(isnull(count(*),0) as varchar(50)) numberOfConnections,
					cast(isnull(max(Weight),1) as varchar(50)) maxWeight,
					cast(isnull(min(Weight),1) as varchar(50)) minWeight,
					max(predicateURI) predicateURI
				from #connections
		), subjectLabel as (
			select IsNull(Max(o.Value),'') Label
			from [RDF.].Triple t, [RDF.].Node o
			where t.subject = @subject
				and t.predicate = @labelID
				and t.object = o.NodeID
				and ((t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
				and ((o.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (o.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (o.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
		)
		insert into #properties (uri,predicate,property,tagName,propertyLabel,Value,ObjectType,SortOrder)
			select	@firstURI,
					[RDF.].fnURI2NodeID(p.property), p.property, p.tagName, p.propertyLabel,
					(case p.n when 1 then 'http://profiles.catalyst.harvard.edu/ontology/prns#Network'
								when 2 then n.numberOfConnections
								when 3 then n.maxWeight
								when 4 then n.minWeight
								when 5 then @baseURI+cast(@predicate as varchar(50))
								when 6 then n.predicateURI
								when 7 then l.Label
								when 8 then @baseURI+cast(@subject as varchar(50))
								end),
					p.ObjectType,
					1
				from networkStats n, networkProperties p, subjectLabel l
		-- Limit the number of connections if the subject is not a person or a group
		select @limit = 10
			where (@limit is null) 
				and not exists (
					select *
					from [rdf.].[triple]
					where subject = @subject
						and predicate = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
						and object in ( [RDF.].fnURI2NodeID('http://xmlns.com/foaf/0.1/Person') , [RDF.].fnURI2NodeID('http://xmlns.com/foaf/0.1/Group') )
				)
		-- Remove connections not within offset-limit window
		delete from #connections
			where (SortOrder < 1+IsNull(@offset,0)) or (SortOrder > IsNull(@limit,SortOrder) + (case when IsNull(@offset,0)<1 then 0 else @offset end))
		-- Add hasConnection properties
		insert into #properties (uri,predicate,property,tagName,propertyLabel,Value,ObjectType,SortOrder)
			select	@baseURI+cast(@subject as varchar(50))+'/'+cast(@predicate as varchar(50)),
					[RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#hasConnection'), 
					'http://profiles.catalyst.harvard.edu/ontology/prns#hasConnection', 'prns:hasConnection', 'has connection',
					connectionURI,
					0,
					SortOrder
				from #connections
	end

	---------------------------------------------------------------------------------------------
	-- Connection [seed with connection]
	---------------------------------------------------------------------------------------------
	if (@subject is not null) and (@predicate is not null) and (@object is not null)
	begin
		select @firstURI = @baseURI+cast(@subject as varchar(50))+'/'+cast(@predicate as varchar(50))+'/'+cast(@object as varchar(50))
	end

	---------------------------------------------------------------------------------------------
	-- Expanded Connections [seed with statistics, subject, object, and connectionDetails]
	---------------------------------------------------------------------------------------------
	if (@expand = 1 or @object is not null) and exists (select * from #connections)
	begin
		-- Connection statistics
		;with connectionProperties as (
			select 1 n, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' property, 'rdf:type' tagName, 'type' propertyLabel, 0 ObjectType
			union all select 2, 'http://profiles.catalyst.harvard.edu/ontology/prns#connectionWeight', 'prns:connectionWeight', 'connection weight', 1
			union all select 3, 'http://profiles.catalyst.harvard.edu/ontology/prns#sortOrder', 'prns:sortOrder', 'sort order', 1
			union all select 4, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#object', 'rdf:object', 'object', 0
			union all select 5, 'http://profiles.catalyst.harvard.edu/ontology/prns#hasConnectionDetails', 'prns:hasConnectionDetails', 'connection details', 0
			union all select 6, 'http://profiles.catalyst.harvard.edu/ontology/prns#predicateNode', 'prns:predicateNode', 'predicate node', 0
			union all select 7, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate', 'rdf:predicate', 'predicate', 0
			union all select 8, 'http://www.w3.org/2000/01/rdf-schema#label', 'rdfs:label', 'label', 1
			union all select 9, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#subject', 'rdf:subject', 'subject', 0
			union all select 10, 'http://profiles.catalyst.harvard.edu/ontology/prns#connectionInNetwork', 'prns:connectionInNetwork', 'connection in network', 0
		)
		insert into #properties (uri,predicate,property,tagName,propertyLabel,Value,ObjectType,SortOrder)
			select	connectionURI,
					[RDF.].fnURI2NodeID(p.property), p.property, p.tagName, p.propertyLabel,
					(case p.n	when 1 then 'http://profiles.catalyst.harvard.edu/ontology/prns#Connection'
								when 2 then cast(c.Weight as varchar(50))
								when 3 then cast(c.SortOrder as varchar(50))
								when 4 then c.value
								when 5 then c.ReitificationURI
								when 6 then @baseURI+cast(@predicate as varchar(50))
								when 7 then c.predicateURI
								when 8 then l.value
								when 9 then c.subjectURI
								when 10 then c.subjectURI+'/'+cast(@predicate as varchar(50))
								end),
					(case p.n when 4 then c.ObjectType else p.ObjectType end),
					1
				from #connections c, connectionProperties p
					left outer join (
						select o.value
							from [RDF.].Triple t, [RDF.].Node o
							where t.subject = @subject 
								and t.predicate = @labelID
								and t.object = o.NodeID
								and ((t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
								and ((o.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (o.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (o.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
					) l on p.n = 8
				where (p.n < 5) 
					or (p.n = 5 and c.ReitificationURI is not null)
					or (p.n > 5 and @object is not null)
		if (@expand = 1)
		begin
			-- Connection subject
			insert into #subjects (subject, showDetail, expanded, URI)
				select NodeID, 0, 0, Value
					from [RDF.].Node
					where NodeID = @subject
			-- Connection objects
			insert into #subjects (subject, showDetail, expanded, URI)
				select object, 0, 0, value
					from #connections
					where ObjectType = 0 and object not in (select subject from #subjects)
			-- Connection details (reitifications)
			insert into #subjects (subject, showDetail, expanded, URI)
				select Reitification, 0, 0, ReitificationURI
					from #connections
					where Reitification is not null and Reitification not in (select subject from #subjects)
		end
	end

	--*******************************************************************************************
	--*******************************************************************************************
	-- Get property values
	--*******************************************************************************************
	--*******************************************************************************************

	-- Get custom settings to override the [Ontology.].[ClassProperty] default values
	insert into #ClassPropertyCustom (ClassPropertyID, IncludeProperty, Limit, IncludeNetwork, IncludeDescription, IsDetail)
		select p.ClassPropertyID, t.IncludeProperty, t.Limit, t.IncludeNetwork, t.IncludeDescription, t.IsDetail
			from [Ontology.].[ClassProperty] p
				inner join (
					select	x.value('@Class','varchar(400)') Class,
							x.value('@NetworkProperty','varchar(400)') NetworkProperty,
							x.value('@Property','varchar(400)') Property,
							(case x.value('@IncludeProperty','varchar(5)') when 'true' then 1 when 'false' then 0 else null end) IncludeProperty,
							x.value('@Limit','int') Limit,
							(case x.value('@IncludeNetwork','varchar(5)') when 'true' then 1 when 'false' then 0 else null end) IncludeNetwork,
							(case x.value('@IncludeDescription','varchar(5)') when 'true' then 1 when 'false' then 0 else null end) IncludeDescription,
							(case x.value('@IsDetail','varchar(5)') when 'true' then 1 when 'false' then 0 else null end) IsDetail
					from @ExpandRDFListXML.nodes('//ExpandRDF') as R(x)
				) t
				on p.Class=t.Class and p.Property=t.Property
					and ((p.NetworkProperty is null and t.NetworkProperty is null) or (p.NetworkProperty = t.NetworkProperty))

	declare @ClassPropertyCustomTypeID int
	select @ClassPropertyCustomTypeID = ClassPropertyCustomTypeID from (select x.value('@ClassPropertyCustomTypeID', 'int') ClassPropertyCustomTypeID from @ExpandRDFListXML.nodes('//ExpandRDFOptions') as R(x)) t
	insert into #ClassPropertyCustom (ClassPropertyID, IncludeProperty, Limit, IncludeNetwork, IncludeDescription, IsDetail)
		select _ClassPropertyID, IncludeProperty, Limit, IncludeNetwork, IncludeDescription, IsDetail from [Ontology.].[ClassPropertyCustom]
		where ClassPropertyCustomTypeID=@ClassPropertyCustomTypeID and _ClassPropertyID not in (select ClassPropertyID from #ClassPropertyCustom)

	if exists (select 1 from (select (case x.value('@ExpandPredicates', 'varchar(5)') when 'false' then 0 else 1 end) ExpandPredicates from @ExpandRDFListXML.nodes('//ExpandRDFOptions') as R(x)) t
		where t.ExpandPredicates = 0) begin set @includePredicates = 0 end

	-- Get properties and loop if objects need to be expanded
	declare @numLoops int
	declare @maxLoops int
	declare @actualLoops int
	declare @NewSubjects int
	select @numLoops = 0, @maxLoops = 10, @actualLoops = 0
	while (@numLoops < @maxLoops)
	begin
		-- Get the types of each subject that hasn't been expanded
		truncate table #types
		insert into #types(subject,object,predicate,showDetail,uri)
			select s.subject, t.object, null, s.showDetail, s.uri
				from #subjects s 
					inner join [RDF.].Triple t on s.subject = t.subject 
						and t.predicate = @typeID 
					inner join [RDF.].Node n on t.object = n.NodeID
						and ((n.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (n.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (1 = CASE WHEN @HasSecurityGroupNodes = 0 THEN 0 WHEN n.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes) THEN 1 ELSE 0 END))
						and ((t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (1 = CASE WHEN @HasSecurityGroupNodes = 0 THEN 0 WHEN t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes) THEN 1 ELSE 0 END))
				where s.expanded = 0				   
		-- Get the subject types of each reitification that hasn't been expanded
		insert into #types(subject,object,predicate,showDetail,uri)
		select distinct s.subject, t.object, r.predicate, s.showDetail, s.uri
			from #subjects s 
				inner join [RDF.].Triple r on s.subject = r.reitification
				inner join [RDF.].Triple t on r.subject = t.subject 
					and t.predicate = @typeID 
				inner join [RDF.].Node n on t.object = n.NodeID
					and ((n.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (n.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (1 = CASE WHEN @HasSecurityGroupNodes = 0 THEN 0 WHEN n.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes) THEN 1 ELSE 0 END))
					and ((t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (1 = CASE WHEN @HasSecurityGroupNodes = 0 THEN 0 WHEN t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes) THEN 1 ELSE 0 END))
					and ((r.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (r.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (1 = CASE WHEN @HasSecurityGroupNodes = 0 THEN 0 WHEN r.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes) THEN 1 ELSE 0 END))
			where s.expanded = 0
		-- Get the items that should be expanded
		truncate table #expand
		insert into #expand(subject, predicate, uri, property, tagName, propertyLabel, IsDetail, limit, showStats, showSummary)
			select p.subject, o._PropertyNode, max(p.uri) uri, o.property, o._TagName, o._PropertyLabel, min(o.IsDetail*1) IsDetail, 
					(case when min(IsNull(c.IsDetail, o.IsDetail)*1) = 0 then max(case when IsNull(c.IsDetail, o.IsDetail)=0 then IsNull(c.limit,o.limit) else null end) else max(IsNull(c.limit,o.limit)) end) limit,
					(case when min(IsNull(c.IsDetail, o.IsDetail)*1) = 0 then max(case when IsNull(c.IsDetail, o.IsDetail)=0 then IsNull(c.IncludeNetwork,o.IncludeNetwork)*1 else 0 end) else max(IsNull(c.IncludeNetwork,o.IncludeNetwork)*1) end) showStats,
					(case when min(IsNull(c.IsDetail, o.IsDetail)*1) = 0 then max(case when IsNull(c.IsDetail, o.IsDetail)=0 then IsNull(c.IncludeDescription,o.IncludeDescription)*1 else 0 end) else max(IsNull(c.IncludeDescription,o.IncludeDescription)*1) end) showSummary
				from #types p
					inner join [Ontology.].ClassProperty o
						on p.object = o._ClassNode 
						and ((p.predicate is null and o._NetworkPropertyNode is null) or (p.predicate = o._NetworkPropertyNode))
					left outer join #ClassPropertyCustom c
						on o.ClassPropertyID = c.ClassPropertyID
				where IsNull(c.IncludeProperty,1) = 1
				and IsNull(c.IsDetail, o.IsDetail) <= showDetail
				group by p.subject, o.property, o._PropertyNode, o._TagName, o._PropertyLabel
		-- Get the values for each property that should be expanded
		insert into #properties (uri,subject,predicate,object,showSummary,property,tagName,propertyLabel,Language,DataType,Value,ObjectType,SortOrder)
			select e.uri, e.subject, t.predicate, t.object, e.showSummary,
					e.property, e.tagName, e.propertyLabel, 
					o.Language, o.DataType, o.Value, o.ObjectType, t.SortOrder
			from #expand e
				inner join [RDF.].Triple t
					on t.subject = e.subject and t.predicate = e.predicate
						and (e.limit is null or t.sortorder <= e.limit)
						and ((t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (1 = CASE WHEN @HasSecurityGroupNodes = 0 THEN 0 WHEN t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes) THEN 1 ELSE 0 END))
				inner join [RDF.].Node p
					on t.predicate = p.NodeID
						and ((p.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (p.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (1 = CASE WHEN @HasSecurityGroupNodes = 0 THEN 0 WHEN p.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes) THEN 1 ELSE 0 END))
				inner join [RDF.].Node o
					on t.object = o.NodeID
						and ((o.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (o.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (1 = CASE WHEN @HasSecurityGroupNodes = 0 THEN 0 WHEN o.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes) THEN 1 ELSE 0 END))
		-- Get network properties
		if (@numLoops = 0)
		begin
			-- Calculate network statistics
			select e.uri, e.subject, t.predicate, e.property, e.tagName, e.PropertyLabel, 
					cast(isnull(count(*),0) as varchar(50)) numberOfConnections,
					cast(isnull(max(t.Weight),1) as varchar(50)) maxWeight,
					cast(isnull(min(t.Weight),1) as varchar(50)) minWeight,
					@baseURI+cast(e.subject as varchar(50))+'/'+cast(t.predicate as varchar(50)) networkURI
				into #networks
				from #expand e
					inner join [RDF.].Triple t
						on t.subject = e.subject and t.predicate = e.predicate
							and (e.showStats = 1)
							and ((t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (1 = CASE WHEN @HasSecurityGroupNodes = 0 THEN 0 WHEN t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes) THEN 1 ELSE 0 END))
					inner join [RDF.].Node p
						on t.predicate = p.NodeID
							and ((p.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (p.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (1 = CASE WHEN @HasSecurityGroupNodes = 0 THEN 0 WHEN p.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes) THEN 1 ELSE 0 END))
					inner join [RDF.].Node o
						on t.object = o.NodeID
							and ((o.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (o.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (1 = CASE WHEN @HasSecurityGroupNodes = 0 THEN 0 WHEN o.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes) THEN 1 ELSE 0 END))
				group by e.uri, e.subject, t.predicate, e.property, e.tagName, e.PropertyLabel
			-- Create properties from network statistics
			;with networkProperties as (
				select 1 n, 'http://profiles.catalyst.harvard.edu/ontology/prns#hasNetwork' property, 'prns:hasNetwork' tagName, 'has network' propertyLabel, 0 ObjectType
				union all select 2, 'http://profiles.catalyst.harvard.edu/ontology/prns#numberOfConnections', 'prns:numberOfConnections', 'number of connections', 1
				union all select 3, 'http://profiles.catalyst.harvard.edu/ontology/prns#maxWeight', 'prns:maxWeight', 'maximum connection weight', 1
				union all select 4, 'http://profiles.catalyst.harvard.edu/ontology/prns#minWeight', 'prns:minWeight', 'minimum connection weight', 1
				union all select 5, 'http://profiles.catalyst.harvard.edu/ontology/prns#predicateNode', 'prns:predicateNode', 'predicate node', 0
				union all select 6, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate', 'rdf:predicate', 'predicate', 0
				union all select 7, 'http://www.w3.org/2000/01/rdf-schema#label', 'rdfs:label', 'label', 1
				union all select 8, 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type', 'rdf:type', 'type', 0
			)
			insert into #properties (uri,subject,predicate,property,tagName,propertyLabel,Value,ObjectType,SortOrder)
				select	(case p.n when 1 then n.uri else n.networkURI end),
						(case p.n when 1 then subject else null end),
						[RDF.].fnURI2NodeID(p.property), p.property, p.tagName, p.propertyLabel,
						(case p.n when 1 then n.networkURI 
									when 2 then n.numberOfConnections
									when 3 then n.maxWeight
									when 4 then n.minWeight
									when 5 then @baseURI+cast(n.predicate as varchar(50))
									when 6 then n.property
									when 7 then n.PropertyLabel
									when 8 then 'http://profiles.catalyst.harvard.edu/ontology/prns#Network'
									end),
						p.ObjectType,
						1
					from #networks n, networkProperties p
					where p.n = 1 or @expand = 1
		end
		-- Mark that all previous subjects have been expanded
		update #subjects set expanded = 1 where expanded = 0
		-- See if there are any new subjects that need to be expanded
		insert into #subjects(subject,showDetail,expanded,uri)
			select distinct object, 0, 0, value
				from #properties
				where showSummary = 1
					and ObjectType = 0
					and object not in (select subject from #subjects)
		select @NewSubjects = @@ROWCOUNT
		if(@includePredicates = 1)
		begin		
			insert into #subjects(subject,showDetail,expanded,uri)
				select distinct predicate, 0, 0, property
					from #properties
					where predicate is not null
						and predicate not in (select subject from #subjects)
			select @NewSubjects = @NewSubjects + @@ROWCOUNT
		end
		-- If no subjects need to be expanded, then we are done
		if @NewSubjects = 0
			select @numLoops = @maxLoops
		select @numLoops = @numLoops + 1 + @maxLoops * (1 - @expand)
		select @actualLoops = @actualLoops + 1
	end
	-- Add tagName as a property of DatatypeProperty and ObjectProperty classes
	insert into #properties (uri, subject, showSummary, property, tagName, propertyLabel, Value, ObjectType, SortOrder)
		select p.uri, p.subject, 0, 'http://profiles.catalyst.harvard.edu/ontology/prns#tagName', 'prns:tagName', 'tag name', 
				n.prefix+':'+substring(p.uri,len(n.uri)+1,len(p.uri)), 1, 1
			from #properties p, [Ontology.].Namespace n
			where p.property = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
				and p.value in ('http://www.w3.org/2002/07/owl#DatatypeProperty','http://www.w3.org/2002/07/owl#ObjectProperty')
				and p.uri like n.uri+'%'
	--select @actualLoops
	--select * from #properties order by (case when uri = @firstURI then 0 else 1 end), uri, tagName, value


	--*******************************************************************************************
	--*******************************************************************************************
	-- Handle the special case where a local node is storing a copy of an external URI
	--*******************************************************************************************
	--*******************************************************************************************

	if (@firstValue IS NOT NULL) AND (@firstValue <> @firstURI)
		insert into #properties (uri, subject, predicate, object, 
				showSummary, property, 
				tagName, propertyLabel, 
				Language, DataType, Value, ObjectType, SortOrder
			)
			select @firstURI uri, @subject subject, predicate, object, 
					showSummary, property, 
					tagName, propertyLabel, 
					Language, DataType, Value, ObjectType, 1 SortOrder
				from #properties
				where uri = @firstValue
					and not exists (select * from #properties where uri = @firstURI)
			union all
			select @firstURI uri, @subject subject, null predicate, null object, 
					0 showSummary, 'http://www.w3.org/2002/07/owl#sameAs' property,
					'owl:sameAs' tagName, 'same as' propertyLabel, 
					null Language, null DataType, @firstValue Value, 0 ObjectType, 1 SortOrder

	--*******************************************************************************************
	--*******************************************************************************************
	-- Generate an XML string from the node properties table
	--*******************************************************************************************
	--*******************************************************************************************

	declare @description nvarchar(max)
	select @description = ''
	-- sort the tags
	select *, 
			row_number() over (partition by uri order by i) j, 
			row_number() over (partition by uri order by i desc) k 
		into #propertiesSorted
		from (
			select *, row_number() over (order by (case when uri = @firstURI then 0 else 1 end), uri, tagName, SortOrder, value) i
				from #properties
		) t
	create unique clustered index idx_i on #propertiesSorted(i)
	-- handle special xml characters in the uri and value strings
	update #propertiesSorted
		set uri = replace(replace(replace(uri,'&','&amp;'),'<','&lt;'),'>','&gt;')
		where uri like '%[&<>]%'
	update #propertiesSorted
		set value = replace(replace(replace(value,'&','&amp;'),'<','&lt;'),'>','&gt;')
		where value like '%[&<>]%'
	-- concatenate the tags
	select @description = (
			select (case when j=1 then '<rdf:Description rdf:about="' + uri + '">' else '' end)
					+'<'+tagName
					+(case when ObjectType = 0 then ' rdf:resource="'+value+'"/>' else '>'+value+'</'+tagName+'>' end)
					+(case when k=1 then '</rdf:Description>' else '' end)
			from #propertiesSorted
			order by i
			for xml path(''), type
		).value('(./text())[1]','nvarchar(max)')
	-- default description if none exists
	if (@description IS NULL) OR (@validURI = 0)
		select @description = '<rdf:Description rdf:about="' + @firstURI + '"'
			+IsNull(' xml:lang="'+@dataStrLanguage+'"','')
			+IsNull(' rdf:datatype="'+@dataStrDataType+'"','')
			+IsNull(' >'+replace(replace(replace(@dataStr,'&','&amp;'),'<','&lt;'),'>','&gt;')+'</rdf:Description>',' />')


	--*******************************************************************************************
	--*******************************************************************************************
	-- Return as a string or as XML
	--*******************************************************************************************
	--*******************************************************************************************

	select @dataStr = IsNull(@dataStr,@description)

	declare @x as nvarchar(max)
	select @x = '<rdf:RDF'
	select @x = @x + ' xmlns:'+Prefix+'="'+URI+'"' 
		from [Ontology.].Namespace
	select @x = @x + ' >' + @description + '</rdf:RDF>'

	if @returnXML = 1 and @returnXMLasStr = 0
		select cast(replace(@x,char(13),'&#13;') as xml) RDF

	if @returnXML = 1 and @returnXMLasStr = 1
		select @x RDF

	--update [RDF.].[GetDataRDF.DebugLog]
	--	set DurationMS = DATEDIFF(ms,StartDate,GetDate())
	--	where LogiD = @debugLogID

	/*	
		declare @d datetime
		select @d = getdate()
		select datediff(ms,@d,getdate())
	*/
		
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [RDF.].[GetPresentationXML]
@subject BIGINT=NULL, @predicate BIGINT=NULL, @object BIGINT=NULL, @subjectType BIGINT=NULL, @objectType BIGINT=NULL, @SessionID UNIQUEIDENTIFIER=NULL, @EditMode BIT=0, @returnXML BIT=1, @PresentationXML XML=NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	declare @typeID bigint
	select @typeID = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')

	select @subject = null where @subject = 0
	select @predicate = null where @predicate = 0
	select @object = null where @object = 0

	declare @SecurityGroupListXML xml
	select @SecurityGroupListXML = NULL

	declare @NetworkNode bigint
	declare @ConnectionNode bigint
	select	@NetworkNode = [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#Network'),
			@ConnectionNode = [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#Connection')


	-------------------------------------------------------------------------------
	-- Determine the PresentationType (P = profile, N = network, C = connection)
	-------------------------------------------------------------------------------

	declare @PresentationType char(1)
	select @PresentationType = (case when IsNull(@object,@objectType) is not null AND @predicate is not null AND IsNull(@subject,@subjectType) is not null then 'C'
									when @predicate is not null AND IsNull(@subject,@subjectType) is not null then 'N'
									when IsNull(@subject,@subjectType) is not null then 'P'
									else NULL end)

	-------------------------------------------------------------------------------
	-- Determine whether the user can edit this profile
	-------------------------------------------------------------------------------

	DECLARE @CanEdit BIT
	SELECT @CanEdit = 0
	DECLARE @SecurityGroupID BIGINT, @HasSpecialViewAccess BIT, @HasSpecialEditAccess BIT
	EXEC [RDF.Security].GetSessionSecurityGroup @SessionID, @SecurityGroupID OUTPUT, @HasSpecialViewAccess OUTPUT, @HasSpecialEditAccess OUTPUT
	CREATE TABLE #SecurityGroupNodes (SecurityGroupNode BIGINT PRIMARY KEY)
	IF (@PresentationType = 'P') AND (@SessionID IS NOT NULL)
	BEGIN
		-- Get SecurityGroup nodes
		INSERT INTO #SecurityGroupNodes (SecurityGroupNode) EXEC [RDF.Security].GetSessionSecurityGroupNodes @SessionID, @Subject
		SELECT @CanEdit = 1
			FROM [RDF.].Node
			WHERE NodeID = @subject
				AND ( (EditSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (EditSecurityGroup > 0 AND @HasSpecialEditAccess = 1) OR (EditSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) )
		-- Get names/descriptions of different SecurityGroups
		IF @CanEdit = 1 AND @EditMode = 1
		BEGIN
			;WITH a AS (
				SELECT 1 x, m.NodeID SecurityGroupID, 'Only Me' Label, 'Only me and special authorized users who manage this website.' Description
					FROM [User.Session].[Session] s, [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
					WHERE s.SessionID = @SessionID AND s.UserID IS NOT NULL
						AND m.InternalID = s.UserID AND m.Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#User' AND m.InternalType = 'User'
						AND n.NodeID = @Subject AND n.EditSecurityGroup = m.NodeID 
			), b AS (
				SELECT 2 x, n.EditSecurityGroup SecurityGroupID, 'Owner' Label, 'Only ' + IsNull(Max(o.Value),'') + ' and special authorized users who manage this website.' Description
					FROM [RDF.].Node n, [RDF.].Triple t, [RDF.].Node o, [RDF.Stage].[InternalNodeMap] m
					WHERE n.NodeID = @Subject AND n.EditSecurityGroup > 0
						AND n.EditSecurityGroup NOT IN (SELECT SecurityGroupID FROM a)
						AND n.NodeID = m.NodeID
						AND m.Class = 'http://xmlns.com/foaf/0.1/Person'
						AND t.Subject = n.NodeID 
						AND t.Predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label') 
						AND t.Object = o.NodeID
						AND ( (n.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (n.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (n.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) )
						AND ( (t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) )
						AND ( (o.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (o.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (o.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) )
					GROUP BY n.EditSecurityGroup
			), c AS (
				SELECT 3 x, n.EditSecurityGroup SecurityGroupID, 'Owner' Label, 'Only managers of this profile and special authorized users who manage this website.' Description
					FROM [RDF.].Node n
					WHERE n.NodeID = @Subject AND n.EditSecurityGroup > 0
						AND n.EditSecurityGroup NOT IN (SELECT SecurityGroupID FROM a UNION SELECT SecurityGroupID FROM b)
					GROUP BY n.EditSecurityGroup
			), d AS (
				SELECT 4 x, SecurityGroupID, Label, Description
					FROM [RDF.Security].[Group]
					WHERE SecurityGroupID between @SecurityGroupID and -1
				UNION ALL SELECT * FROM a
				UNION ALL SELECT * FROM b
				UNION ALL SELECT * FROM c
			)
			SELECT @SecurityGroupListXML = (
				SELECT	SecurityGroupID "@ID",
						Label "@Label",
						Description "@Description"
					FROM d
					ORDER BY x, SecurityGroupID
					FOR XML PATH('SecurityGroup'), TYPE
			)
		END
	END

	-------------------------------------------------------------------------------
	-- Get the PresentationID based on type
	-------------------------------------------------------------------------------

	declare @PresentationID int
	select @PresentationID = (
			select top 1 PresentationID
				from [Ontology.Presentation].[XML]
				where type = (case when @EditMode = 1 then 'E' else IsNull(@PresentationType,'P') end)
					AND	(_SubjectNode IS NULL
							OR _SubjectNode = @subjectType
							OR _SubjectNode IN (select object from [RDF.].Triple where @subject is not null and subject=@subject and predicate=@typeID)
						)
					AND	(_PredicateNode IS NULL
							OR _PredicateNode = @predicate
						)
					AND	(_ObjectNode IS NULL
							OR _ObjectNode = @objectType
							OR _ObjectNode IN (select object from [RDF.].Triple where @object is not null and subject=@object and predicate=@typeID)
						)
				order by	(case when _ObjectNode is null then 1 else 0 end),
							(case when _PredicateNode is null then 1 else 0 end),
							(case when _SubjectNode is null then 1 else 0 end),
							PresentationID
		)

	-------------------------------------------------------------------------------
	-- Get the PropertyListXML based on type
	-------------------------------------------------------------------------------

	declare @PropertyListXML xml
	if @EditMode = 0
	begin
		-- View properties
		select @PropertyListXML = (
			select PropertyGroupURI "@URI", _PropertyGroupLabel "@Label", SortOrder "@SortOrder", x.query('.')
			from (
				select PropertyGroupURI, _PropertyGroupLabel, SortOrder,
				(
					select	a.URI "@URI", 
							a.TagName "@TagName", 
							a.Label "@Label", 
							p.SortOrder "@SortOrder",
							(case when a.CustomDisplay = 1 then 'true' else 'false' end) "@CustomDisplay",
							cast(a.CustomDisplayModule as xml)
					from [ontology.].PropertyGroupProperty p, (
						select NodeID,
							max(URI) URI, 
							max(TagName) TagName, 
							max(Label) Label,
							max(CustomDisplay) CustomDisplay,
							max(CustomDisplayModule) CustomDisplayModule
						from (
								select
									c._PropertyNode NodeID,
									c.Property URI,
									c._TagName TagName,
									c._PropertyLabel Label,
									cast(c.CustomDisplay as tinyint) CustomDisplay,
									IsNull(cast(c.CustomDisplayModule as nvarchar(max)),cast(p.CustomDisplayModule as nvarchar(max))) CustomDisplayModule
								from [Ontology.].ClassProperty c
									left outer join [Ontology.].PropertyGroupProperty p
									on c.Property = p.PropertyURI
								where c._ClassNode in (
									select object 
										from [RDF.].Triple 
										where subject=@subject and predicate=@typeID and @predicate is null and @object is null
									union all
									select @NetworkNode
										where @subject is not null and @predicate is not null and @object is null
									union all
									select @ConnectionNode
										where @subject is not null and @predicate is not null and @object is not null
								)
								and 1 = (case	when c._NetworkPropertyNode is null and @predicate is null then 1
												when c._NetworkPropertyNode is null and @predicate is not null and @object is null and c._ClassNode = @NetworkNode then 1
												when c._NetworkPropertyNode is null and @predicate is not null and @object is not null and c._ClassNode = @ConnectionNode then 1
												when c._NetworkPropertyNode = @predicate and @object is not null then 1
												else 0 end)
							) t
						group by NodeID
					) a
					where p._PropertyNode = a.NodeID and p._PropertyGroupNode = g._PropertyGroupNode
					order by p.SortOrder
					for xml path('Property'), type
				) x
				from [ontology.].PropertyGroup g
			) t
			where x is not null
			order by SortOrder
			for xml path('PropertyGroup'), type
		)
	end
	else
	begin
		-- Edit properties
		select @PropertyListXML = (
			select PropertyGroupURI "@URI", _PropertyGroupLabel "@Label", SortOrder "@SortOrder", x.query('.')
			from (
				select PropertyGroupURI, _PropertyGroupLabel, SortOrder,
				(
					select	a.URI "@URI", 
							a.TagName "@TagName", 
							a.Label "@Label", 
							p.SortOrder "@SortOrder",
							IsNull(s.ViewSecurityGroup,a.ViewSecurityGroup) "@ViewSecurityGroup",
							(case when a.CustomEdit = 1 then 'true' else 'false' end) "@CustomEdit",
							(case when a.EditPermissions = 1 then 'true' else 'false' end) "@EditPermissions",
							(case when a.EditExisting = 1 then 'true' else 'false' end) "@EditExisting",
							(case when a.EditAddNew = 1 then 'true' else 'false' end) "@EditAddNew",
							(case when a.EditAddExisting = 1 then 'true' else 'false' end) "@EditAddExisting",
							(case when a.EditDelete = 1 then 'true' else 'false' end) "@EditDelete",
							a.MinCardinality "@MinCardinality",
							a.MaxCardinality "@MaxCardinality",
							a.ObjectType "@ObjectType",
							(case when a.HasDataFeed = 1 then 'true' else 'false' end) "@HasDataFeed",
							cast(a.CustomEditModule as xml)
					from [ontology.].PropertyGroupProperty p inner join (
						select NodeID,
							max(URI) URI, 
							max(TagName) TagName, 
							max(Label) Label,
							max(ViewSecurityGroup) ViewSecurityGroup,
							max(CustomEdit) CustomEdit,
							max(EditPermissions) EditPermissions,
							max(EditExisting) EditExisting,
							max(EditAddNew) EditAddNew,
							max(EditAddExisting) EditAddExisting,
							max(EditDelete) EditDelete,
							min(MinCardinality) MinCardinality,
							max(MaxCardinality) MaxCardinality,
							max(cast(ObjectType as tinyint)) ObjectType,
							max(HasDataFeed) HasDataFeed,
							max(CustomEditModule) CustomEditModule
						from (
								select
									c._PropertyNode NodeID,
									c.Property URI,
									c._TagName TagName,
									c._PropertyLabel Label,
									c.ViewSecurityGroup,
									cast(c.CustomEdit as tinyint) CustomEdit,
									(case when ( (EditPermissionsSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (EditPermissionsSecurityGroup > 0 AND @HasSpecialEditAccess = 1) OR (EditPermissionsSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) ) then 1 else 0 end) EditPermissions,
									(case when ( (EditExistingSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (EditExistingSecurityGroup > 0 AND @HasSpecialEditAccess = 1) OR (EditExistingSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) ) then 1 else 0 end) EditExisting,
									(case when ( (EditAddNewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (EditAddNewSecurityGroup > 0 AND @HasSpecialEditAccess = 1) OR (EditAddNewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) ) then 1 else 0 end) EditAddNew,
									(case when ( (EditAddExistingSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (EditAddExistingSecurityGroup > 0 AND @HasSpecialEditAccess = 1) OR (EditAddExistingSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) ) then 1 else 0 end) EditAddExisting,
									(case when ( (EditDeleteSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (EditDeleteSecurityGroup > 0 AND @HasSpecialEditAccess = 1) OR (EditDeleteSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) ) then 1 else 0 end) EditDelete,
									c.MinCardinality,
									c.MaxCardinality,
									c._ObjectType ObjectType,
									(case when d._PropertyNode is null then 0 else 1 end) HasDataFeed,
									IsNull(cast(c.CustomEditModule as nvarchar(max)),cast(p.CustomEditModule as nvarchar(max))) CustomEditModule
								from [Ontology.].ClassProperty c
									left outer join (
										select distinct _ClassNode, _PropertyNode
										from [Ontology.].DataMap
										where NetworkProperty is null and _ClassNode is not null and _PropertyNode is not null and IsAutoFeed = 1
									) d
										on c._ClassNode = d._ClassNode and c._PropertyNode = d._PropertyNode
									left outer join [Ontology.].PropertyGroupProperty p
										on c.Property = p.PropertyURI
								where c._ClassNode in (
									select object 
										from [RDF.].Triple 
										where subject=@subject and predicate=@typeID and @predicate is null and @object is null
								)
								and c.Property is not null
								and c.NetworkProperty is null
								and ( (EditSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (EditSecurityGroup > 0 AND @HasSpecialEditAccess = 1) OR (EditSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) )
							) t
						group by NodeID
					) a
					on p._PropertyNode = a.NodeID and p._PropertyGroupNode = g._PropertyGroupNode
					left outer join [RDF.Security].NodeProperty s
					on s.NodeID = @subject and s.Property = p._PropertyNode 
					order by p.SortOrder
					for xml path('Property'), type
				) x
				from [ontology.].PropertyGroup g
			) t
			where x is not null
			order by SortOrder
			for xml path('PropertyGroup'), type
		)
	end	

	-------------------------------------------------------------------------------
	-- Combine the PresentationXML with property information
	-------------------------------------------------------------------------------

	select @PresentationXML = (
		select
			PresentationXML.value('Presentation[1]/@PresentationClass[1]','varchar(max)') "@PresentationClass",
			PresentationXML.value('Presentation[1]/PageOptions[1]/@Columns[1]','varchar(max)') "PageOptions/@Columns",
			(case when @CanEdit = 1 then 'true' else NULL end) "PageOptions/@CanEdit",
			(case when @CanEdit = 1 then 'true' else NULL end) "CanEdit",
			PresentationXML.query('Presentation[1]/WindowName[1]'),
			PresentationXML.query('Presentation[1]/PageColumns[1]'),
			PresentationXML.query('Presentation[1]/PageTitle[1]'),
			PresentationXML.query('Presentation[1]/PageBackLinkName[1]'),
			PresentationXML.query('Presentation[1]/PageBackLinkURL[1]'),
			PresentationXML.query('Presentation[1]/PageSubTitle[1]'),
			PresentationXML.query('Presentation[1]/PageDescription[1]'),
			PresentationXML.query('Presentation[1]/PanelTabType[1]'),
			PresentationXML.query('Presentation[1]/PanelList[1]'),
			PresentationXML.query('Presentation[1]/ExpandRDFList[1]'),
			@PropertyListXML "PropertyList",
			@SecurityGroupListXML "SecurityGroupList"
		from [Ontology.Presentation].[XML]
		where presentationid = @PresentationID
		for xml path('Presentation'), type
	)
	
	if @returnXML = 1
		select @PresentationXML PresentationXML

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [RDF.].[GetPropertyRangeList]
	@PropertyID BIGINT = NULL,
	@PropertyURI VARCHAR(400) = NULL,
	@returnTable BIT = 0,
	@returnXML BIT = 1,
	@PropertyRangeListXML XML = NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF (@PropertyURI IS NULL) AND (@PropertyID IS NOT NULL)
		SELECT @PropertyURI = Value
			FROM [RDF.].Node
			WHERE NodeID = @PropertyID

	declare @LabelID bigint
	declare @SubClassOfID bigint
	select	@LabelID = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label'),
			@SubClassOfID = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#subClassOf')

	create table #range (
		ClassID bigint primary key,
		ClassURI varchar(400),
		Label varchar(400),
		Depth int,
		SortOrder float,
	)
	
	insert into #range (ClassID, Label, Depth, SortOrder)
		select p.ValueNode, n.Value, 0, row_number() over (order by n.Value)
			from [ontology.].vwPropertyTall p, [RDF.].Triple t, [RDF.].Node n
			where p.property = @PropertyURI
				and p.predicate = 'http://www.w3.org/2000/01/rdf-schema#range'
				and t.subject = p.ValueNode
				and t.predicate = @LabelID
				and t.object = n.NodeID

	declare @done bit
	select @done = 0
	while @done = 0
	begin
		insert into #range (ClassID, Label, Depth, SortOrder)
			select t.subject, left(n.Value,400), r.depth+1,
					r.SortOrder + power(cast(0.001 as float),r.depth+1)*(row_number() over (partition by r.classid order by n.value))
				from #range r, [RDF.].Triple t, [RDF.].Triple v, [RDF.].Node n
				where t.object = r.ClassID
					and t.predicate = @SubClassOfID
					and t.subject = v.subject
					and v.predicate = @LabelID
					and v.object = n.NodeID
					and t.subject not in (select ClassID from #range)
		if @@ROWCOUNT = 0
			select @done = 1
	end
	
	update r
		set r.ClassURI = n.Value
		from #range r, [RDF.].Node n
		where r.ClassID = n.NodeID

	if @returnTable = 1
		select * 
		from #range
		order by sortorder

	select @PropertyRangeListXML = (
			select (
					select	ClassID "@ClassID",
							ClassURI "@ClassURI",
							Depth "@Depth",
							Label "@Label"
						from #range
						order by SortOrder
						for xml path('PropertyRange'), type
				) "PropertyRangeList"
			for xml path(''), type
		)

	if @PropertyRangeListXML is null or (cast(@PropertyRangeListXML as nvarchar(max)) = '')
		select @PropertyRangeListXML = cast('<PropertyRangeList />' as xml)
	
	if @returnXML = 1
		select @PropertyRangeListXML PropertyRangeList

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[NetworkMap.GetSimilarPeople]
	@NodeID BIGINT,
	@show_connections BIT=0,
	@SessionID UNIQUEIDENTIFIER=NULL
AS
BEGIN
 
 
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET nocount  ON;
 
 
 
	DECLARE @PersonID INT
 
	SELECT @PersonID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
 
 
	DECLARE  @f  TABLE(
		personid INT,
		internalldapusername NVARCHAR(50),
		display_name NVARCHAR(255),
		latitude FLOAT,
		longitude FLOAT,
		address1 NVARCHAR(1000),
		address2 NVARCHAR(1000),
		URI VARCHAR(400)
	)
 
	INSERT INTO @f
						 (personid, 
							display_name,
							latitude,
							longitude,
							address1,
							address2)
	SELECT p.personid, 
				 p.displayname,
				 l.latitude,
				 l.longitude,
				 CASE WHEN p.addressstring LIKE '%,%' THEN LEFT(p.addressstring,CHARINDEX(',',p.addressstring) - 1)ELSE p.addressstring END  address1,
				 REPLACE(SUBSTRING(p.addressstring,CHARINDEX(',',p.addressstring) + 1,
													 LEN(p.addressstring)),', USA','') address2
		FROM [Profile.Cache].Person p,  
				 (SELECT @PersonID personid,
								 0         latitude
					UNION ALL
					SELECT SimilarPersonID, 0 FROM [Profile.Cache].[Person.SimilarPerson] WHERE PersonID = @PersonID
					--SELECT *
					--FROM fn_GetTopSimilarPeople(@PersonID) s
					) t,
				[Profile.Cache].Person l  
	 WHERE p.personid = t.personid
		 AND p.personid = l.personid 
		 AND l.latitude IS NOT NULL
		 AND l.longitude IS NOT NULL
	 ORDER BY latitude DESC,
				 p.lastname,
				 p.firstname
 
 
	UPDATE @f
		SET URI = p.Value + cast(m.NodeID as varchar(50))
		FROM @f, [RDF.Stage].InternalNodeMap m, [Framework.].Parameter p
		WHERE p.ParameterID = 'baseURI' AND m.InternalHash = [RDF.].fnValueHash(null,null,'http://xmlns.com/foaf/0.1/Person^^Person^^'+cast(PersonID as  varchar(50)))
 
	DELETE FROM @f WHERE URI IS NULL
 
 
	IF @show_connections = 0
	BEGIN
		SELECT personid,
					 internalldapusername,
					 display_name,
					 latitude,
					 longitude,
					 address1,
					 address2,
					 uri
			FROM @f
		 ORDER BY address1,
					 address2,
					 display_name
	END
	ELSE
	BEGIN
		SELECT DISTINCT a.latitude        x1,
						a.longitude        y1,
						d.latitude        x2,
						d.longitude        y2,
						a.personid a,
						d.personid b,
						(CASE 
							 WHEN a.personid = @PersonID
										 OR d.personid= @PersonID THEN 1
							 ELSE 0
						 END) is_person,
						a.URI u1,
						d.URI u2
			FROM @f a,
					 [Profile.Data].[Publication.Person.Include] b,
					 [Profile.Data].[Publication.Person.Include] c,
					 @f d
		 WHERE a.personid = b.personid
			 AND b.pmid = c.pmid
			 AND b.personid < c.personid
			 AND c.personid = d.personid
	END
		
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Module].[NetworkMap.GetCoauthors]
	@NodeID BIGINT,
	@which INT=0,
	@SessionID UNIQUEIDENTIFIER=NULL
AS
BEGIN
 
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET nocount  ON;
 
 
	DECLARE @PersonID INT
 
	SELECT @PersonID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
 
	DECLARE  @f  TABLE(
		PersonID INT,
		display_name NVARCHAR(255),
		latitude FLOAT,
		longitude FLOAT,
		address1 NVARCHAR(1000),
		address2 NVARCHAR(1000),
		URI VARCHAR(400)
	)
 
	INSERT INTO @f (	PersonID,
						display_name,
						latitude,
						longitude,
						address1,
						address2
					)
		SELECT	p.PersonID,
				p.displayname,
				l.latitude,
				l.longitude,
				CASE WHEN p.addressstring like '%,%' THEN LEFT(p.addressstring,CHARINDEX(',',p.addressstring) - 1)ELSE P.addressstring END address1,
				CASE WHEN p.addressstring like '%,%' THEN REPLACE(SUBSTRING(p.addressstring,CHARINDEX(',',p.addressstring) + 1,LEN(p.addressstring)),', USA','') ELSE p.addressstring END address2
		FROM [Profile.Data].vwperson p,
				(SELECT DISTINCT PersonID
					FROM  [Profile.Data].[Publication.Person.Include]
					WHERE pmid IN (SELECT pmid
										FROM [Profile.Data].[Publication.Person.Include]
										WHERE PersonID = @PersonID
											AND pmid IS NOT NULL
									)
				) t,
				[Profile.Data].vwperson l
		 WHERE p.PersonID = t.PersonID
			 AND p.PersonID = l.PersonID
			 AND l.latitude IS NOT NULL
			 AND l.longitude IS NOT NULL
		 ORDER BY p.lastname, p.firstname
 
	UPDATE @f
		SET URI = p.Value + cast(m.NodeID as varchar(50))
		FROM @f, [RDF.Stage].InternalNodeMap m, [Framework.].Parameter p
		WHERE p.ParameterID = 'baseURI' AND m.InternalHash = [RDF.].fnValueHash(null,null,'http://xmlns.com/foaf/0.1/Person^^Person^^'+cast(PersonID as varchar(50)))
 
	DELETE FROM @f WHERE URI IS NULL
 
	IF (SELECT COUNT(*) FROM @f) = 1
		IF (SELECT personid from @f)=@PersonID
			DELETE FROM @f
 
 
	IF @which = 0
	BEGIN
		SELECT PersonID, 
			display_name,
			latitude,
			longitude,
			address1,
			address2,
			URI
		FROM @f
		ORDER BY address1,
			address2,
			display_name
	END
	ELSE
	BEGIN
		SELECT DISTINCT	a.latitude	x1,
						a.longitude	y1,
						d.latitude	x2,
						d.longitude	y2,
						a.PersonID	a,
						d.PersonID	b,
						(CASE 
							 WHEN a.PersonID = @PersonID
								OR d.PersonID = @PersonID THEN 1
							 ELSE 0
						 END) is_person,
						a.URI u1,
						d.URI u2
			FROM @f a,
					 [Profile.Data].[Publication.Person.Include] b,
					 [Profile.Data].[Publication.Person.Include] c,
					 @f d
		 WHERE a.PersonID = b.PersonID
			 AND b.pmid = c.pmid
			 AND b.PersonID < c.PersonID
			 AND c.PersonID = d.PersonID
	END
		
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[NetworkAuthorshipTimeline.Person.GetData]
	@NodeID BIGINT,
	@ShowAuthorPosition BIT = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @PersonID INT
 	SELECT @PersonID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
 
    -- Insert statements for procedure here
	declare @gc varchar(max)

	declare @y table (
		y int,
		A int,
		B int,
		C int,
		T int
	)

	insert into @y (y,A,B,C,T)
		select n.n y, coalesce(t.A,0) A, coalesce(t.B,0) B, coalesce(t.C,0) C, coalesce(t.T,0) T
		from [Utility.Math].[N] left outer join (
			select (case when y < 1970 then 1970 else y end) y,
				sum(case when r in ('F','S') then 1 else 0 end) A,
				sum(case when r not in ('F','S','L') then 1 else 0 end) B,
				sum(case when r in ('L') then 1 else 0 end) C,
				count(*) T
			from (
				select coalesce(p.AuthorPosition,'U') r, year(coalesce(p.pubdate,m.publicationdt,'1/1/1970')) y
				from [Profile.Data].[Publication.Person.Include] a
					left outer join [Profile.Cache].[Publication.PubMed.AuthorPosition] p on a.pmid = p.pmid and p.personid = a.personid
					left outer join [Profile.Data].[Publication.MyPub.General] m on a.mpid = m.mpid
				where a.personid = @PersonID
			) t
			group by y
		) t on n.n = t.y
		where n.n between year(getdate())-30 and year(getdate())

	declare @x int

	--select @x = max(A+B+C)
	--	from @y

	select @x = max(T)
		from @y

	if coalesce(@x,0) > 0
	begin
		declare @v varchar(1000)
		declare @z int
		declare @k int
		declare @i int

		set @z = power(10,floor(log(@x)/log(10)))
		set @k = floor(@x/@z)
		if @x > @z*@k
			select @k = @k + 1
		if @k > 5
			select @k = floor(@k/2.0+0.5), @z = @z*2

		set @v = ''
		set @i = 0
		while @i <= @k
		begin
			set @v = @v + '|' + cast(@z*@i as varchar(50))
			set @i = @i + 1
		end
		set @v = '|0|'+cast(@x as varchar(50))
		--set @v = '|0|50|100'

		declare @h varchar(1000)
		set @h = ''
		select @h = @h + '|' + (case when y % 2 = 1 then '' else ''''+right(cast(y as varchar(50)),2) end)
			from @y
			order by y 

		declare @w float
		--set @w = @k*@z
		set @w = @x

		declare @c varchar(50)
		declare @d varchar(max)
		set @d = ''

		if @ShowAuthorPosition = 0
		begin
			select @d = @d + cast(floor(0.5 + 100*T/@w) as varchar(50)) + ','
				from @y
				order by y
			set @d = left(@d,len(@d)-1)

			--set @c = 'AC1B30'
			set @c = '80B1D3'
			set @gc = '//chart.googleapis.com/chart?chs=595x100&chf=bg,s,ffffff|c,s,ffffff&chxt=x,y&chxl=0:' + @h + '|1:' + @v + '&cht=bvs&chd=t:' + @d + '&chdl=Publications&chco='+@c+'&chbh=10'
		end
		else
		begin
			select @d = @d + cast(floor(0.5 + 100*A/@w) as varchar(50)) + ','
				from @y
				order by y
			set @d = left(@d,len(@d)-1) + '|'
			select @d = @d + cast(floor(0.5 + 100*B/@w) as varchar(50)) + ','
				from @y
				order by y
			set @d = left(@d,len(@d)-1) + '|'
			select @d = @d + cast(floor(0.5 + 100*C/@w) as varchar(50)) + ','
				from @y
				order by y
			set @d = left(@d,len(@d)-1)

			set @c = 'FB8072,B3DE69,80B1D3'
			set @gc = '//chart.googleapis.com/chart?chs=595x100&chf=bg,s,ffffff|c,s,ffffff&chxt=x,y&chxl=0:' + @h + '|1:' + @v + '&cht=bvs&chd=t:' + @d + '&chdl=First+Author|Middle or Unkown|Last+Author&chco='+@c+'&chbh=10'
		end
		
		declare @asText varchar(max)
		set @asText = '<table style="width:592px"><tr><th>Year</th><th>Publications</th></tr>'
		select @asText = @asText + '<tr><td style="text-align:center;">' + cast(y as varchar(50)) + '</td><td style="text-align:center;">' + cast(t as varchar(50)) + '</td></tr>'
			from @y
			where t > 0
			order by y 
		select @asText = @asText + '</table>'
		
			declare @alt varchar(max)
		select @alt = 'Bar chart showing ' + cast(sum(t) as varchar(50))+ ' publications over ' + cast(count(*) as varchar(50)) + ' distinct years, with a maximum of ' + cast(@x as varchar(50)) + ' publications in ' from @y where t > 0
		select @alt = @alt + cast(y as varchar(50)) + ' and '
			from @y
			where t = @x
			order by y 
		select @alt = left(@alt, len(@alt) - 4)


		select @gc gc, @alt alt, @asText asText --, @w w
	end

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Person.AddPhoto]
	@PersonID INT,
	@Photo VARBINARY(MAX)=NULL,
	@PhotoLink NVARCHAR(MAX)=NULL
AS
BEGIN
	
	SET NOCOUNT ON;

	-- Only one custom photo per user, so replace any existing custom photos

	IF EXISTS (SELECT 1 FROM [Profile.Data].[Person.Photo] WHERE PersonID = @personid)
		BEGIN 
			UPDATE [Profile.Data].[Person.Photo] SET photo = @photo, PhotoLink = @PhotoLink WHERE PersonID = @personid 
		END
	ELSE 
		BEGIN 
			INSERT INTO [Profile.Data].[Person.Photo](PersonID ,Photo,PhotoLink) VALUES(@PersonID,@Photo,@PhotoLink)
		END 
	
	DECLARE @NodeID BIGINT
	DECLARE @URI VARCHAR(400)
	DECLARE @URINodeID BIGINT
	SELECT @NodeID = PersonNodeID, @URI = URI
		FROM [Profile.Data].[vwPerson.Photo]
		WHERE PersonID = @PersonID
	IF (@NodeID IS NOT NULL AND @URI IS NOT NULL)
		BEGIN
			EXEC [RDF.].[GetStoreNode] @Value = @URI, @NodeID = @URINodeID OUTPUT
			IF (@URINodeID IS NOT NULL)
				EXEC [RDF.].[GetStoreTriple]	@SubjectID = @NodeID,
												@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#mainImage',
												@ObjectID = @URINodeID
		END
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Search.].[ParseSearchString]
	@SearchString VARCHAR(500) = NULL,
	@NumberOfPhrases INT = 0 OUTPUT,
	@CombinedSearchString VARCHAR(8000) = '' OUTPUT,
	@SearchString1 VARCHAR(8000) = NULL OUTPUT,
	@SearchString2 VARCHAR(8000) = NULL OUTPUT,
	@SearchString3 VARCHAR(8000) = NULL OUTPUT,
	@SearchPhraseXML XML = NULL OUTPUT,
	@SearchPhraseFormsXML XML = NULL OUTPUT,
	@ProcessTime INT = 0 OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
		-- interfering with SELECT statements.
		SET NOCOUNT ON;

	-- Start timer
	declare @d datetime
	select @d = GetDate()


	-- Remove bad characters
	declare @SearchStringNormalized varchar(max)
	select @SearchStringNormalized = ''
	declare @StringPos int
	select @StringPos = 1
	declare @InQuotes tinyint
	select @InQuotes = 0
	declare @Char char(1)
	while @StringPos <= len(@SearchString)
	begin
		select @Char = substring(@SearchString,@StringPos,1)
		select @InQuotes = 1 - @InQuotes where @Char = '"'
		if @Char like '[0-9A-Za-z]'
			select @SearchStringNormalized = @SearchStringNormalized + @Char
		else if @Char = '"'
			select @SearchStringNormalized = @SearchStringNormalized + ' '
		else if right(@SearchStringNormalized,1) not in (' ','_')
			select @SearchStringNormalized = @SearchStringNormalized + (case when @InQuotes = 1 then '_' else ' ' end)
		select @StringPos = @StringPos + 1
	end
	select @SearchStringNormalized = replace(@SearchStringNormalized,'  ',' ')
	select @SearchStringNormalized = ' ' + ltrim(rtrim(replace(replace(' '+@SearchStringNormalized+' ',' _',' '),'_ ',' '))) + ' |'


	-- Find phrase positions
	declare @PhraseBreakPositions table (z int, n int, m int, i int)
	;with a as (
		select n.n, row_number() over (order by n.n) - 1 i
			from [Utility.Math].N n
			where n.n between 1 and len(@SearchStringNormalized) and substring(@SearchStringNormalized,n.n,1) = ' '
	), b as (
		select count(*)-1 j from a
	)
	insert into @PhraseBreakPositions
		select n.n z, a.n, a.i m, row_number() over (partition by n.n order by a.n) i
			from a, b, [Utility.Math].N n
			where n.n < Power(2,b.j-1)
				and 1 = (case when a.i=0 then 1 when a.i=b.j then 1 when Power(2,a.i-1) & n.n > 0 then 1 else 0 end)
	select @SearchStringNormalized = replace(@SearchStringNormalized,'_',' ')


	-- Extract phrases
	declare @TempPhraseList table (i int, w varchar(max), x int) 
	;with d as (
		select c.*, substring(@SearchStringNormalized,c.n+1,d.n-c.n-1) w, d.m-c.m l
			from @PhraseBreakPositions c, @PhraseBreakPositions d
			where c.z=d.z and c.i=d.i-1
	), e as (
		select d.*, IsNull(t.x,0) x
		from d outer apply (select top 1 1 x from [Utility.NLP].Thesaurus t where d.w = t.TermName) t
	), f as (
		select top 1 z
		from e
		group by z 
		order by sum(l*l*x) desc, z desc
	)
	insert into @TempPhraseList
		select row_number() over (order by e.i) i, e.w, e.x
			from e, f
			where e.z = f.z
				and e.w not in (select word from [Utility.NLP].StopWord where scope = 0)
				and e.w <> ''
	declare @PhraseList table (PhraseID int, Phrase varchar(max), ThesaurusMatch bit, Forms varchar(max))
	insert into @PhraseList (PhraseID, Phrase, ThesaurusMatch, Forms)
		select i, w, x, (case when x = 0 then '"'+[Utility.NLP].fnPorterAlgorithm(p.w)+'*"'
						else substring(cast( (
									select distinct ' OR "'+v.TermName+'"'
										from [Utility.NLP].Thesaurus t, [Utility.NLP].Thesaurus v
										where p.w=t.TermName and t.Source=v.Source and t.ConceptID=v.ConceptID
										for xml path(''), type
								) as varchar(max)),5,999999)
						end)
		from @TempPhraseList p
	select @NumberOfPhrases = (select max(PhraseID) from @PhraseList)
	select @SearchStringNormalized = substring(@SearchStringNormalized,2,len(@SearchStringNormalized)-3)

	-- Create a combined string for fulltext search
	/*
	select @CombinedSearchString = 
			(case when @NumberOfPhrases = 0 then ''
				when @NumberOfPhrases = 1 then
					'"'+@SearchStringNormalized+'" OR ' + (select Forms from @PhraseList)
				else
					'"'+@SearchStringNormalized+'"'
					+ ' OR '
					--+ '(' + replace(@SearchStringNormalized,' ',' NEAR ') + ')'
					+ '(' + substring(cast((select ' NEAR '+Phrase from @PhraseList order by PhraseID for xml path(''), type) as varchar(max)),7,999999) + ')'
					+ ' OR '
					+ '(' + substring(cast((select ' AND ('+Forms+')' from @PhraseList order by PhraseID for xml path(''), type) as varchar(max)),6,999999) + ')'
				end)
	*/
	if @NumberOfPhrases = 0
		select @SearchString1 = NULL, @SearchString2 = NULL, @SearchString3 = NULL
	if @NumberOfPhrases = 1
		select	@SearchString1 = '"'+@SearchStringNormalized+'"', 
				@SearchString2 = (select Forms from @PhraseList),
				@SearchString3 = NULL
	if @NumberOfPhrases > 1
		select	@SearchString1 = '"'+@SearchStringNormalized+'"', 
				@SearchString2 = '(' + substring(cast((select ' NEAR "'+Phrase+'"' from @PhraseList order by PhraseID for xml path(''), type) as varchar(max)),7,999999) + ')',
				@SearchString3 = '(' + substring(cast((select ' AND ('+Forms+')' from @PhraseList order by PhraseID for xml path(''), type) as varchar(max)),6,999999) + ')'
	select @CombinedSearchString = IsNull(@SearchString1,'') + IsNull(' OR '+@SearchString2,'') + IsNull(' OR '+@SearchString3,'')
	
	-- Create an XML message listing the parsed phrases
	select @SearchPhraseXML =		(select
										(select PhraseID "SearchPhrase/@ID", 
											(case when ThesaurusMatch='1' then 'true' else 'false' end) "SearchPhrase/@ThesaurusMatch",
											Phrase "SearchPhrase"
										from @PhraseList
										order by PhraseID
										for xml path(''), type) "SearchPhraseList"
									for xml path(''), type)
	select @SearchPhraseFormsXML =	(select
										(select PhraseID "SearchPhrase/@ID", 
											(case when ThesaurusMatch='1' then 'true' else 'false' end) "SearchPhrase/@ThesaurusMatch",
											Forms "SearchPhrase/@Forms",
											Phrase "SearchPhrase"
										from @PhraseList
										order by PhraseID
										for xml path(''), type) "SearchPhraseList"
									for xml path(''), type)

					
	-- End timer
	select @ProcessTime = datediff(ms,@d,GetDate())

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [User.Session].[CreateSession]
    @RequestIP VARCHAR(16),
    @UserAgent VARCHAR(500) = NULL,
    @UserID VARCHAR(200) = NULL,
	@SessionPersonNodeID BIGINT = NULL OUTPUT,
	@SessionPersonURI VARCHAR(400) = NULL OUTPUT,
	@SecurityGroupID BIGINT = NULL OUTPUT
AS 
BEGIN
 
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON ;

	-- See if there is a PersonID associated with the user	
	DECLARE @PersonID INT
	IF @UserID IS NOT NULL
		SELECT @PersonID = PersonID
			FROM [User.Account].[User]
			WHERE UserID = @UserID

	-- Get the NodeID and URI of the PersonID
	IF EXISTS (SELECT 1 FROM [Profile.Data].Person WHERE PersonID = @PersonID AND IsActive = 1)
	BEGIN
		SELECT @SessionPersonNodeID = m.NodeID, @SessionPersonURI = p.Value + CAST(m.NodeID AS VARCHAR(50))
			FROM [RDF.Stage].InternalNodeMap m, [Framework.].[Parameter] p
			WHERE m.InternalID = @PersonID
				AND m.InternalType = 'person'
				AND m.Class = 'http://xmlns.com/foaf/0.1/Person'
				AND p.ParameterID = 'baseURI'
	END


	-- Create a SessionID
    DECLARE @SessionID UNIQUEIDENTIFIER
	SELECT @SessionID = NEWID()
 
	-- Create the Session table record
	INSERT INTO [User.Session].Session
		(	SessionID,
			CreateDate,
			LastUsedDate,
			LoginDate,
			LogoutDate,
			RequestIP,
			UserID,
			UserNode,
			PersonID,
			UserAgent,
			IsBot
		)
        SELECT  @SessionID ,
                GETDATE() ,
                GETDATE() ,
                CASE WHEN @UserID IS NULL THEN NULL
                        ELSE GETDATE()
                END ,
                NULL ,
                @RequestIP ,
                @UserID ,
				(SELECT NodeID FROM [User.Account].[User] WHERE UserID = @UserID AND @UserID IS NOT NULL),
                @PersonID,
                @UserAgent,
                0
                    
    -- Check if bot
	DECLARE @IsBot BIT
	SELECT @IsBot = 0
	SELECT @IsBot = 1
		WHERE @UserAgent IS NOT NULL AND EXISTS (SELECT * FROM [User.Session].[Bot] WHERE @UserAgent LIKE UserAgent)
	If (@IsBot = 1)
		UPDATE [User.Session].Session
			SET IsBot = 1
			WHERE SessionID = @SessionID

	-- Create a node if not a bot
	If (@IsBot = 0)
	BEGIN

		-- Get the BaseURI
		DECLARE @baseURI NVARCHAR(400)
		SELECT @baseURI = Value FROM [Framework.].Parameter WHERE ParameterID = 'baseURI'

		-- Create the Node
		DECLARE @NodeID BIGINT
		DECLARE @NodeIDTable TABLE (nodeId BIGINT)
		DECLARE @TempValue varchar(50)
		SELECT @TempValue = '#NODE'+cast(NewID() as varchar(50))
		INSERT INTO [RDF.].[Node] (ViewSecurityGroup, EditSecurityGroup, Value, ObjectType, ValueHash)
			  OUTPUT Inserted.NodeID INTO @NodeIDTable
			  select 0, -50, @TempValue, 0,
					[RDF.].[fnValueHash](NULL,NULL,@TempValue)
		SELECT @NodeID = nodeId from @NodeIDTable
		UPDATE [RDF.].[Node]
			SET ViewSecurityGroup = @NodeID,
				Value = @baseURI+cast(@NodeID as nvarchar(50)),
				ValueHash = [RDF.].fnValueHash(null,null,@baseURI+cast(@NodeID as nvarchar(50)))
			WHERE NodeID = @NodeID

		-- Add properties to the node
		DECLARE @Error INT
		DECLARE @TypeID BIGINT
		DECLARE @SessionClass BIGINT
		DECLARE @TripleID BIGINT
		SELECT	@TypeID = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
				@SessionClass = [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#Session')
		EXEC [RDF.].[GetStoreTriple]	@SubjectID = @NodeID,
										@PredicateID = @TypeID,
										@ObjectID = @SessionClass,
										@ViewSecurityGroup = @NodeID,
										@Weight = 1,
										@SortOrder = 1,
										@SessionID = @SessionID,
										@Error = @Error OUTPUT,
										@TripleID = @TripleID OUTPUT

		-- If no error, then assign the NodeID to the session
		IF (@Error = 0)
		BEGIN
			-- Update the Session record with the NodeID
			UPDATE [User.Session].Session
				SET NodeID = @NodeID
				WHERE SessionID = @SessionID
		END
	END

	-- Get the security group of the session
	EXEC [RDF.Security].[GetSessionSecurityGroup] @SessionID = @SessionID, @SecurityGroupID = @SecurityGroupID OUTPUT

    SELECT *, @SecurityGroupID SecurityGroupID
		FROM [User.Session].[Session]
		WHERE SessionID = @SessionID AND @SessionID IS NOT NULL
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [User.Session].[DeleteOldSessionRDF]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	-- Get a list of nodes for sessions last used more than 7 days ago
	CREATE TABLE #s (
		NodeID BIGINT PRIMARY KEY
	)
	INSERT INTO #s (NodeID)
		SELECT DISTINCT NodeID
			FROM (
				SELECT TOP 1000000 NodeID
					FROM [User.Session].[Session] WITH (NOLOCK)
					WHERE NodeID IS NOT NULL
						AND NodeID IN (SELECT NodeID FROM [RDF.].[Node] WITH (NOLOCK))
						AND DateDiff(dd,LastUsedDate,GetDate()) >= 7
			) t

	-- Get a list of the triples associated with those nodes
	CREATE TABLE #t (
		TripleID BIGINT PRIMARY KEY
	)
	INSERT INTO #t (TripleID)
		SELECT t.TripleID
			FROM [RDF.].[Triple] t WITH (NOLOCK), #s s
			WHERE t.subject = s.NodeID

	-- Delete the triples
	DELETE t
		FROM [RDF.].[Triple] t, #t s
		WHERE t.TripleID = s.TripleID

	-- Turn off real-time indexing
	--ALTER FULLTEXT INDEX ON [RDF.].Node SET CHANGE_TRACKING OFF 
	
	-- Delete the nodes
	DELETE n
		FROM [RDF.].[Node] n, #s s
		WHERE n.NodeID = s.NodeID

	-- Turn on real-time indexing
	--ALTER FULLTEXT INDEX ON [RDF.].Node SET CHANGE_TRACKING AUTO;
	-- Kick off population FT Catalog and index
	--ALTER FULLTEXT INDEX ON [RDF.].Node START FULL POPULATION 


	/*

	SELECT *
		FROM [User.Session].[Session] WITH (NOLOCK)
		WHERE NodeID IS NOT NULL
			AND NodeID IN (SELECT NodeID FROM [RDF.].[Node] WITH (NOLOCK))
			AND DateDiff(hh,LastUsedDate,GetDate()) >= 24
			--AND ((LogoutDate IS NOT NULL) OR (DateDiff(hh,LastUsedDate,GetDate()) >= 24))

	SELECT *
		FROM [RDF.].[Triple] t, #s s
		WHERE t.subject = s.NodeID

	SELECT *
		FROM [RDF.].[Node] n, #s s
		WHERE n.NodeID = s.NodeID

	*/

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Edit.Module].[CustomEditAwardOrHonor.StoreItem]
@ExistingAwardReceiptID BIGINT=NULL, @ExistingAwardReceiptURI VARCHAR (400)=NULL, @awardOrHonorForID BIGINT=NULL, @awardOrHonorForURI BIGINT=NULL, @label VARCHAR (MAX), @awardConferredBy VARCHAR (MAX)=NULL, @startDate VARCHAR (MAX)=NULL, @endDate VARCHAR (MAX)=NULL, @SessionID UNIQUEIDENTIFIER=NULL, @Error BIT=NULL OUTPUT, @NodeID BIGINT=NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	/*
	
	This stored procedure either creates or updates an
	AwardReceipt. In both cases a label is required.
	Nodes can be specified either by ID or URI.
	
	*/
	
	SELECT @Error = 0

	-------------------------------------------------
	-- Validate and prepare variables
	-------------------------------------------------
	
	-- Convert URIs to NodeIDs
 	IF (@ExistingAwardReceiptID IS NULL) AND (@ExistingAwardReceiptURI IS NOT NULL)
		SELECT @ExistingAwardReceiptID = [RDF.].fnURI2NodeID(@ExistingAwardReceiptURI)
 	IF (@awardOrHonorForID IS NULL) AND (@awardOrHonorForURI IS NOT NULL)
		SELECT @awardOrHonorForID = [RDF.].fnURI2NodeID(@awardOrHonorForURI)

	-- Check that some operation will be performed
	IF ((@ExistingAwardReceiptID IS NULL) AND (@awardOrHonorForID IS NULL)) OR (IsNull(@label,'') = '')
	BEGIN
		SELECT @Error = 1
		RETURN
	END

	-- Convert properties to NodeIDs
	DECLARE @awardConferredByNodeID BIGINT
	DECLARE @startDateNodeID BIGINT
	DECLARE @endDateNodeID BIGINT
	
	SELECT @awardConferredByNodeID = NULL, @startDateNodeID = NULL, @endDateNodeID = NULL
	
	IF IsNull(@awardConferredBy,'')<>''
		EXEC [RDF.].GetStoreNode @Value = @awardConferredBy, @Language = NULL, @DataType = NULL,
			@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @awardConferredByNodeID OUTPUT
	IF IsNull(@startDate,'')<>''
		EXEC [RDF.].GetStoreNode @Value = @startDate, @Language = NULL, @DataType = NULL,
			@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @startDateNodeID OUTPUT
	IF IsNull(@endDate,'')<>''
		EXEC [RDF.].GetStoreNode @Value = @endDate, @Language = NULL, @DataType = NULL,
			@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @endDateNodeID OUTPUT

	-------------------------------------------------
	-- Handle required nodes and properties
	-------------------------------------------------

	-- Get an AwardReceipt with just a label
	IF (@ExistingAwardReceiptID IS NOT NULL)
	BEGIN
		-- The AwardReceipt NodeID is the ExistingAwardReceipt
		SELECT @NodeID = @ExistingAwardReceiptID
		-- Delete any existing properties
		EXEC [RDF.].DeleteTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#awardConferredBy',
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		EXEC [RDF.].DeleteTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#startDate',
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		EXEC [RDF.].DeleteTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#endDate',
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		EXEC [RDF.].DeleteTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://www.w3.org/2000/01/rdf-schema#label',
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		-- Add the label
		DECLARE @labelNodeID BIGINT
		EXEC [RDF.].GetStoreNode	@Value = @label, 
									@Language = NULL,
									@DataType = NULL,
									@SessionID = @SessionID, 
									@Error = @Error OUTPUT, 
									@NodeID = @labelNodeID OUTPUT
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://www.w3.org/2000/01/rdf-schema#label',
									@ObjectID = @labelNodeID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
	END
	ELSE
	BEGIN
		-- Create a new AwardReceipt
		EXEC [RDF.].GetStoreNode	@EntityClassURI = 'http://vivoweb.org/ontology/core#AwardReceipt',
									@Label = @label,
									@ForceNewEntity = 1,
									@SessionID = @SessionID, 
									@Error = @Error OUTPUT, 
									@NodeID = @NodeID OUTPUT
		-- Link the AwardReceipt to the awardOrHonorFor
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://vivoweb.org/ontology/core#awardOrHonorFor',
									@ObjectID = @awardOrHonorForID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		-- Link the awardOrHonorFor to the AwardReceipt
		EXEC [RDF.].GetStoreTriple	@SubjectID = @awardOrHonorForID,
									@PredicateURI = 'http://vivoweb.org/ontology/core#awardOrHonor',
									@ObjectID = @NodeID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
	END

	-------------------------------------------------
	-- Handle optional properties
	-------------------------------------------------

	-- Add optional properties to the AwardReceipt
	IF (@NodeID IS NOT NULL) AND (@Error = 0)
	BEGIN
		IF @awardConferredByNodeID IS NOT NULL
			EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
										@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#awardConferredBy',
										@ObjectID = @awardConferredByNodeID,
										@SessionID = @SessionID,
										@Error = @Error OUTPUT
		IF @startDateNodeID IS NOT NULL
			EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
										@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#startDate',
										@ObjectID = @startDateNodeID,
										@SessionID = @SessionID,
										@Error = @Error OUTPUT
		IF @endDateNodeID IS NOT NULL
			EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
										@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#endDate',
										@ObjectID = @endDateNodeID,
										@SessionID = @SessionID,
										@Error = @Error OUTPUT
	END

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Ontology.].[CleanUp]
	@Action varchar(100) = NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- This stored procedure contains code to help developers manage
	-- content in several ontology tables.
	
	-------------------------------------------------------------
	-- View the contents of the tables
	-------------------------------------------------------------

	if @Action = 'ShowTables'
	begin
		select * from [Ontology.].ClassGroup
		select * from [Ontology.].ClassGroupClass
		select * from [Ontology.].ClassProperty
		select * from [Ontology.].DataMap
		select * from [Ontology.].Namespace
		select * from [Ontology.].PropertyGroup
		select * from [Ontology.].PropertyGroupProperty
		select * from [Ontology.Import].[Triple]
		select * from [Ontology.Import].OWL
		select * from [Ontology.Presentation].General
	end
	
	-------------------------------------------------------------
	-- Insert missing records, use default values
	-------------------------------------------------------------

	if @Action = 'AddMissingRecords'
	begin

		insert into [Ontology.].ClassProperty (ClassPropertyID, Class, NetworkProperty, Property, IsDetail, Limit, IncludeDescription, IncludeNetwork, SearchWeight, CustomDisplay, CustomEdit, ViewSecurityGroup, EditSecurityGroup, EditPermissionsSecurityGroup, EditExistingSecurityGroup, EditAddNewSecurityGroup, EditAddExistingSecurityGroup, EditDeleteSecurityGroup, MinCardinality, MaxCardinality, CustomEditModule)
			select ClassPropertyID, Class, NetworkProperty, Property, IsDetail, Limit, IncludeDescription, IncludeNetwork, SearchWeight, CustomDisplay, CustomEdit, ViewSecurityGroup, EditSecurityGroup, EditPermissionsSecurityGroup, EditExistingSecurityGroup, EditAddNewSecurityGroup, EditAddExistingSecurityGroup, EditDeleteSecurityGroup, MinCardinality, MaxCardinality, CustomEditModule
				from [Ontology.].vwMissingClassProperty

		insert into [Ontology.].PropertyGroupProperty (PropertyGroupURI, PropertyURI, SortOrder)
			select PropertyGroupURI, PropertyURI, SortOrder
				from [Ontology.].vwMissingPropertyGroupProperty

	end

	-------------------------------------------------------------
	-- Update IDs using the default sort order
	-------------------------------------------------------------

	if @Action = 'UpdateIDs'
	begin
		
		update x
			set x.ClassPropertyID = y.k
			from [Ontology.].ClassProperty x, (
				select *, row_number() over (order by (case when NetworkProperty is null then 0 else 1 end), Class, NetworkProperty, IsDetail, IncludeNetwork, Property) k
					from [Ontology.].ClassProperty
			) y
			where x.Class = y.Class and x.Property = y.Property
				and ((x.NetworkProperty is null and y.NetworkProperty is null) or (x.NetworkProperty = y.NetworkProperty))

		update x
			set x.DataMapID = y.k
			from [Ontology.].DataMap x, (
				select *, row_number() over (order by	(case when Property is null then 0 when NetworkProperty is null then 1 else 2 end), 
														(case when Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#User' then 0 else 1 end), 
														Class,
														(case when NetworkProperty = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' then 0 when NetworkProperty = 'http://www.w3.org/2000/01/rdf-schema#label' then 1 else 2 end),
														NetworkProperty, 
														(case when Property = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' then 0 when Property = 'http://www.w3.org/2000/01/rdf-schema#label' then 1 else 2 end),
														MapTable,
														Property
														) k
					from [Ontology.].DataMap
			) y
			where x.Class = y.Class and x.sInternalType = y.sInternalType
				and ((x.Property is null and y.Property is null) or (x.Property = y.Property))
				and ((x.NetworkProperty is null and y.NetworkProperty is null) or (x.NetworkProperty = y.NetworkProperty))

		update x
			set x.PresentationID = y.k
			from [Ontology.Presentation].General x, (
				select *, row_number() over (order by	(case when Type = 'E' then 1 else 0 end), 
														Subject,
														(case Type when 'P' then 1 when 'N' then 2 else 3 end),
														Predicate, Object
														) k
					from [Ontology.Presentation].General
			) y
			where x.Type = y.Type
				and ((x.Subject is null and y.Subject is null) or (x.Subject = y.Subject))
				and ((x.Predicate is null and y.Predicate is null) or (x.Predicate = y.Predicate))
				and ((x.Object is null and y.Object is null) or (x.Object = y.Object))	

		update x 
			set x.JobID = y.k 
			from [Framework.].Job x, (
				select *, ROW_NUMBER() over (order by JobGroup, Step) k 
					from [Framework.].Job
			) y
			where x.JobGroup = y.JobGroup and x.Step = y.Step
			
		update x 
			set x._ClassPropertyID = b.ClassPropertyID 
			from [Ontology.].ClassPropertyCustom x join [Ontology.].ClassProperty b
				on x.Class=b.Class and x.Property=b.Property
				and ((x.NetworkProperty is null and b.NetworkProperty is null) or (x.NetworkProperty = b.NetworkProperty))
	end

	-------------------------------------------------------------
	-- Update derived and calculated fields
	-------------------------------------------------------------

	if @Action = 'UpdateFields'
	begin
		exec [Ontology.].UpdateDerivedFields
		exec [Ontology.].UpdateCounts
	end
    
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Import].[Beta.LoadData] (@SourceDBName varchar(max))
AS BEGIN
	 
	SET NOCOUNT ON;
 
	   /* 
 
	This stored procedure imports a subset of data from a Profiles RNS Beta
	instance into the Profiles RNS 1.0 Extended Schema tables. 
 
	Input parameters:
		@SourceDBName				source db to pull beta data from.		  
 
	Test Call:
		[Utility.Application].[uspImportBetaData] resnav_people_hmsopen
		
	*/
	DECLARE @sql NVARCHAR(MAX) 
	
	-- Toggle off fkey constraints
	ALTER TABLE [Profile.Data].[Person.FilterRelationship]  NOCHECK CONSTRAINT FK_person_type_relationships_person
	ALTER TABLE [Profile.Data].[Person.FilterRelationship]  NOCHECK CONSTRAINT FK_person_type_relationships_person_types	
	ALTER TABLE [Profile.Data].[Publication.Person.Include]  NOCHECK CONSTRAINT FK_publications_include_pm_pubs_general
	ALTER TABLE [Profile.Data].[Publication.MyPub.General]  NOCHECK CONSTRAINT FK_my_pubs_general_person
	ALTER TABLE [Profile.Data].[Publication.Person.Include]  NOCHECK CONSTRAINT FK_publications_include_person
	ALTER TABLE [Profile.Data].[Publication.Person.Include]  NOCHECK CONSTRAINT FK_publications_include_my_pubs_general 
	ALTER TABLE [Profile.Data].[Publication.PubMed.Accession]  NOCHECK CONSTRAINT  FK_pm_pubs_accessions_pm_pubs_general
	ALTER TABLE [Profile.Data].[Publication.PubMed.Author]  NOCHECK CONSTRAINT  FK_pm_pubs_authors_pm_pubs_general
	ALTER TABLE [Profile.Data].[Publication.PubMed.Chemical]  NOCHECK CONSTRAINT  FK_pm_pubs_chemicals_pm_pubs_general
	ALTER TABLE [Profile.Data].[Publication.PubMed.Databank]  NOCHECK CONSTRAINT  FK_pm_pubs_databanks_pm_pubs_general
	ALTER TABLE [Profile.Data].[Publication.PubMed.Grant]  NOCHECK CONSTRAINT FK_pm_pubs_grants_pm_pubs_general
	
	-- [profile.data].[Organization.Department] 
	TRUNCATE TABLE [profile.data].[Organization.Department]
	SET IDENTITY_INSERT [profile.data].[Organization.Department] ON 
	SELECT @sql = 'SELECT DepartmentID,DepartmentName,Visible FROM '+ @SourceDBName + '.dbo.department'
	INSERT INTO [profile.data].[Organization.Department](DepartmentID,DepartmentName,Visible)
	EXEC sp_executesql @sql
	SET IDENTITY_INSERT [profile.data].[Organization.Department] OFF	
	
	--[profile.data].[Organization.Division]dbo.division
	TRUNCATE TABLE [profile.data].[Organization.division]
	SET IDENTITY_INSERT [profile.data].[Organization.Division] ON 
	SELECT @sql = 'SELECT DivisionID,DivisionName FROM '+ @SourceDBName + '.dbo.Division'
	INSERT INTO [profile.data].[Organization.Division](DivisionID,DivisionName)
	EXEC sp_executesql @sql	
	SET IDENTITY_INSERT [profile.data].[Organization.Division] OFF	
	
	--[profile.data].[Organization.Institution]dbo.institution
	TRUNCATE TABLE [profile.data].[Organization.institution]
	SET IDENTITY_INSERT [profile.data].[Organization.institution] ON 
	SELECT @sql = 'SELECT institutionID,institutionName,InstitutionAbbreviation FROM '+ @SourceDBName + '.dbo.institution'
	INSERT INTO [profile.data].[Organization.institution](institutionID,institutionName,InstitutionAbbreviation)
	EXEC sp_executesql @sql	
	SET IDENTITY_INSERT [profile.data].[Organization.institution] OFF	
	
	--	[profile.data].[concept.mesh.descriptor]dbo.mesh_descriptors institution
	TRUNCATE TABLE [profile.data].[concept.mesh.descriptor]
	SELECT @sql = 'SELECT DescriptorUI,DescriptorName FROM '+ @SourceDBName + '.dbo.mesh_descriptors'
	INSERT INTO [profile.data].[concept.mesh.descriptor](DescriptorUI,DescriptorName )
	EXEC sp_executesql @sql	 	
	
	--	[profile.data].[concept.mesh.tree]dbo.mesh_tree
	TRUNCATE TABLE [profile.data].[concept.mesh.tree]
	SELECT @sql = 'SELECT DescriptorUI,TreeNumber FROM '+ @SourceDBName + '.dbo.mesh_tree'
	INSERT INTO [profile.data].[concept.mesh.tree](DescriptorUI,TreeNumber )
	EXEC sp_executesql @sql	 
	
	--	[profile.data].[concept.mesh.SemanticGroup]dbo.mesh_semantic_groups
	TRUNCATE TABLE [profile.data].[concept.mesh.SemanticGroup]
	SELECT @sql = 'SELECT DescriptorUI,SemanticGroupUI,SemanticGroupName FROM '+ @SourceDBName + '.dbo.mesh_semantic_groups'
	INSERT INTO [profile.data].[concept.mesh.SemanticGroup](DescriptorUI,SemanticGroupUI,SemanticGroupName  )
	EXEC sp_executesql @sql	 	
	
	--  [profile.cache].[Publication.PubMed.AuthorPosition], dbo.cache_pm_author_position
	TRUNCATE TABLE [profile.cache].[Publication.PubMed.AuthorPosition]
	SELECT @sql =  'SELECT [PersonID],[PMID],[AuthorPosition],[AuthorWeight],[PubDate],[PubYear],[YearWeight] FROM '+ @SourceDBName + '.dbo.cache_pm_author_position'
	INSERT INTO [profile.cache].[Publication.PubMed.AuthorPosition]([PersonID],[PMID],[AuthorPosition],[AuthorWeight],[PubDate],[PubYear],[YearWeight]  )
	EXEC sp_executesql @sql	 
	 
	--	[Profile.Data].[Person]dbo.person
	DELETE FROM [profile.Data].[Person]
	SET IDENTITY_INSERT [profile.data].[Person] ON 
	SELECT @sql = 'SELECT p.[PersonID],p.[UserID],[FirstName],[LastName],[MiddleName],[DisplayName],[Suffix],p.[IsActive],[EmailAddr],[Phone],[Fax],[AddressLine1],[AddressLine2],[AddressLine3],[AddressLine4],[City],[State],[Zip],[Building],[Floor],[Room],[AddressString],[Latitude],[Longitude],[GeoScore],pa.[FacultyRankID],p.[InternalUsername],isnull([Visible], 1) FROM '+ @SourceDBName + '.dbo.person p'
	+ ' left join ' + @SourceDBName + '.dbo.person_affiliations pa on p.PersonID = pa.PersonID and PA.IsPrimary = 1'
	INSERT INTO [profile.data].[Person]([PersonID],[UserID],[FirstName],[LastName],[MiddleName],[DisplayName],[Suffix],[IsActive],[EmailAddr],[Phone],[Fax],[AddressLine1],[AddressLine2],[AddressLine3],[AddressLine4],[City],[State],[Zip],[Building],[Floor],[Room],[AddressString],[Latitude],[Longitude],[GeoScore],[FacultyRankID],[InternalUsername],[Visible]  )
	EXEC sp_executesql @sql	 
	SET IDENTITY_INSERT [profile.data].[Person] OFF 		
	
	--	[Profile.Data].[Person.FilterRelationship]dbo.person_filter_relationships
	TRUNCATE TABLE [profile.Data].[Person.FilterRelationship] 
	SELECT @sql = 'SELECT [PersonID],[PersonFilterid] FROM '+ @SourceDBName + '.dbo.person_filter_relationships'
	INSERT INTO [profile.data].[Person.FilterRelationship]([PersonID],[PersonFilterid] )
	EXEC sp_executesql @sql	   
	
	--	[Profile.Data].[Person.Filter]dbo.person_filters
	SET IDENTITY_INSERT [profile.data].[Person.Filter] ON 
	DELETE FROM [profile.Data].[Person.Filter] 
	SELECT @sql = 'SELECT [PersonFilterID],[PersonFilter],[PersonFilterCategory],[PersonFilterSort] FROM '+ @SourceDBName + '.dbo.person_filters'
	INSERT INTO [profile.data].[Person.Filter]([PersonFilterID],[PersonFilter],[PersonFilterCategory],[PersonFilterSort] )
	EXEC sp_executesql @sql	   
	SET IDENTITY_INSERT [profile.data].[Person.Filter] OFF 
		
	--	[profile.data].[Person.Affiliation]dbo.person_affiliations
	SET IDENTITY_INSERT [profile.data].[Person.Affiliation] ON 
	TRUNCATE TABLE [profile.Data].[Person.Affiliation] 
	SELECT @sql = 'SELECT [PersonAffiliationID],[PersonID],[SortOrder],[IsActive],[IsPrimary],[InstitutionID],[DepartmentID],[DivisionID],[Title],[EmailAddress],[FacultyRankID] 
					FROM '+ @SourceDBName + '.dbo.person_affiliations a
						LEFT OUTER JOIN '+ @SourceDBName + '.dbo.institution_fullname i ON a.[InstitutionFullnameID] = i.[InstitutionFullnameID] 
						LEFT OUTER JOIN '+ @SourceDBName + '.dbo.department_fullname d ON a.[DepartmentFullNameID] = d.[DepartmentFullNameID]
						LEFT OUTER JOIN '+ @SourceDBName + '.dbo.division_fullname v ON a.[DivisionFullnameID] = v.[DivisionFullnameID]'
	INSERT INTO [profile.data].[Person.Affiliation]([PersonAffiliationID],[PersonID],[SortOrder],[IsActive],[IsPrimary],[InstitutionID],[DepartmentID],[DivisionID],[Title],[EmailAddress],[FacultyRankID] )
	EXEC sp_executesql @sql	   
	SET IDENTITY_INSERT [profile.data].[Person.Affiliation] OFF 	
	
	--	[Profile.Data].[Person.Award]dbo.awards 
	TRUNCATE TABLE [profile.Import].[Beta.Award] 
	SELECT @sql = 'SELECT [AwardID],[PersonID],[Yr],[Yr2],[AwardNM],[AwardingInst] FROM '+ @SourceDBName + '.dbo.awards'
	INSERT INTO [profile.Import].[Beta.Award]([AwardID],[PersonID],[Yr],[Yr2],[AwardNM],[AwardingInst] )
	EXEC sp_executesql @sql	    
	
	--	[Profile.Data].[Person.FacultyRank]dbo.faculty_rank
	SET IDENTITY_INSERT [profile.Data].[Person.FacultyRank] ON 
	TRUNCATE TABLE [profile.Data].[Person.FacultyRank] 
	SELECT @sql = 'SELECT DISTINCT [facultyrankid],[FacultyRank],[FacultyRankSort],[Visible] FROM '+ @SourceDBName + '.dbo. faculty_rank'
	INSERT INTO [profile.data].[Person.FacultyRank]([facultyrankid],[FacultyRank],[FacultyRankSort],[Visible] )
	EXEC sp_executesql @sql	   
	SET IDENTITY_INSERT [profile.Data].[Person.FacultyRank] OFF 
	
	--	[profile.data].[person.narrative]dbo.narratives  
	TRUNCATE TABLE [profile.Import].[Beta.Narrative] 
	SELECT @sql = 'SELECT [PersonID],[NarrativeMain] FROM '+ @SourceDBName + '.dbo.narratives'
	INSERT INTO [profile.Import].[Beta.Narrative]([PersonID],[NarrativeMain] )
	EXEC sp_executesql @sql	    	
	
	--	[Profile.Cache].[SNA.Coauthor]dbo.sna_coauthors 
	TRUNCATE TABLE [Profile.Cache].[SNA.Coauthor]
	SELECT @sql = 'SELECT [PersonID1],[PersonID2],[i],[j],[w],[FirstPubDate],[LastPubDate],[n] FROM '+ @SourceDBName + '.dbo.sna_coauthors'
	INSERT INTO [Profile.Cache].[SNA.Coauthor]([PersonID1],[PersonID2],[i],[j],[w],[FirstPubDate],[LastPubDate],[n] )
	EXEC sp_executesql @sql	    
	
	--	[profile.cache].[Concept.Mesh.Count]dbo.cache_mesh_count
	TRUNCATE TABLE [Profile.Cache].[Concept.Mesh.Count]
	SELECT @sql = 'SELECT[MeshHeader],[NumPublications],[NumFaculty],[Weight],[RawWeight] FROM '+ @SourceDBName + '.dbo.cache_mesh_count'
	INSERT INTO [Profile.Cache].[Concept.Mesh.Count]([MeshHeader],[NumPublications],[NumFaculty],[Weight],[RawWeight] )
	EXEC sp_executesql @sql	    
	 
	--	[Profile.Cache].[Person.PhysicalNeighbor]dbo.cache_physical_neighbors
	TRUNCATE TABLE [Profile.Cache].[Person.PhysicalNeighbor]
	SELECT @sql = 'SELECT[PersonID],[NeighborID],[Distance],[DisplayName],[MyNeighbors] FROM '+ @SourceDBName + '.dbo.cache_physical_neighbors'
	INSERT INTO [Profile.Cache].[Person.PhysicalNeighbor]([PersonID],[NeighborID],[Distance],[DisplayName],[MyNeighbors])
	EXEC sp_executesql @sql	    
	
	--	[Profile.Cache].[Person.SimilarPerson]dbo.cache_similar_people
	TRUNCATE TABLE [Profile.Cache].[Person.SimilarPerson]
	SELECT @sql = 'SELECT[PersonID],[SimilarPersonID],[Weight],[CoAuthor] FROM '+ @SourceDBName + '.dbo.cache_similar_people'
	INSERT INTO [Profile.Cache].[Person.SimilarPerson]([PersonID],[SimilarPersonID],[Weight],[CoAuthor])
	EXEC sp_executesql @sql	    
	
	--	[Profile.Cache].[Concept.Mesh.Person]dbo.cache_user_mesh
	TRUNCATE TABLE [Profile.Cache].[Concept.Mesh.Person]
	SELECT @sql = 'SELECT[PersonID],[MeshHeader],[NumPubsAll],[NumPubsThis],[Weight],[FirstPublicationYear],[LastPublicationYear],[MaxAuthorWeight],[WeightCategory]FROM '+ @SourceDBName + '.dbo.cache_user_mesh'
	INSERT INTO [Profile.Cache].[Concept.Mesh.Person]([PersonID],[MeshHeader],[NumPubsAll],[NumPubsThis],[Weight],[FirstPublicationYear],[LastPublicationYear],[MaxAuthorWeight],[WeightCategory])
	EXEC sp_executesql @sql	    
	
	--	[Profile.Data].[Publication.PubMed.General]dbo.pm_pubs_general
	DELETE FROM [Profile.Data].[Publication.PubMed.General]
	SELECT @sql = 'SELECT[PMID],[Owner],[Status],[PubModel],[Volume],[Issue],[MedlineDate],[JournalYear],[JournalMonth],[JournalDay],[JournalTitle],[ISOAbbreviation],[MedlineTA],[ArticleTitle],[MedlinePgn],[AbstractText],[ArticleDateType],[ArticleYear],[ArticleMonth],[ArticleDay],[Affiliation],[AuthorListCompleteYN],[GrantListCompleteYN],[PubDate],[Authors]FROM '+ @SourceDBName + '.dbo.pm_pubs_general'
	INSERT INTO [Profile.Data].[Publication.PubMed.General]([PMID],[Owner],[Status],[PubModel],[Volume],[Issue],[MedlineDate],[JournalYear],[JournalMonth],[JournalDay],[JournalTitle],[ISOAbbreviation],[MedlineTA],[ArticleTitle],[MedlinePgn],[AbstractText],[ArticleDateType],[ArticleYear],[ArticleMonth],[ArticleDay],[Affiliation],[AuthorListCompleteYN],[GrantListCompleteYN],[PubDate],[Authors])
	EXEC sp_executesql @sql	    
	
	--	[Profile.Data].[Publication.MyPub.General]dbo.my_pubs_general
	DELETE FROM [Profile.Data].[Publication.MyPub.General]
	SELECT @sql = 'SELECT[MPID],[PersonID],[PMID],[HmsPubCategory],[NlmPubCategory],[PubTitle],[ArticleTitle],[ArticleType],[ConfEditors],[ConfLoc],[EDITION],[PlaceOfPub],[VolNum],[PartVolPub],[IssuePub],[PaginationPub],[AdditionalInfo],[Publisher],[SecondaryAuthors],[ConfNm],[ConfDTs],[ReptNumber],[ContractNum],[DissUnivNm],[NewspaperCol],[NewspaperSect],[PublicationDT],[Abstract],[Authors],[URL],[CreatedDT],[CreatedBy],[UpdatedDT],[UpdatedBy] FROM '+ @SourceDBName + '.dbo.my_pubs_general'
	INSERT INTO [Profile.Data].[Publication.MyPub.General]([MPID],[PersonID],[PMID],[HmsPubCategory],[NlmPubCategory],[PubTitle],[ArticleTitle],[ArticleType],[ConfEditors],[ConfLoc],[EDITION],[PlaceOfPub],[VolNum],[PartVolPub],[IssuePub],[PaginationPub],[AdditionalInfo],[Publisher],[SecondaryAuthors],[ConfNm],[ConfDTs],[ReptNumber],[ContractNum],[DissUnivNm],[NewspaperCol],[NewspaperSect],[PublicationDT],[Abstract],[Authors],[URL],[CreatedDT],[CreatedBy],[UpdatedDT],[UpdatedBy] )
	EXEC sp_executesql @sql	    
	
	--	[Profile.Data].[Publication.PubMed.Mesh]
	DELETE FROM [Profile.Data].[Publication.PubMed.Mesh]
	SELECT @sql = 'SELECT [PMID],[descriptorname],[QualifierName],[MajorTopicYN] FROM '+ @SourceDBName + '.dbo.pm_pubs_mesh'
	INSERT INTO [Profile.Data].[Publication.PubMed.Mesh]( [PMID],[descriptorname],[QualifierName],[MajorTopicYN])
	EXEC sp_executesql @sql	 
	
	-- [Profile.Data].[Publication.PubMed.Accession]
	DELETE FROM [Profile.Data].[Publication.PubMed.Accession]
	SELECT @sql = 'SELECT [PMID],[DataBankName],[AccessionNumber]  FROM '+ @SourceDBName + '.dbo.pm_pubs_accessions'
	INSERT INTO [Profile.Data].[Publication.PubMed.accession]([PMID],[DataBankName],[AccessionNumber])
	EXEC sp_executesql @sql	 
	
	--1 [Profile.Data].[Publication.PubMed.Author]
	DELETE FROM [Profile.Data].[Publication.PubMed.Author]
	SELECT @sql = 'SELECT [PMID],[ValidYN],[LastName],FirstName,ForeName,Suffix,Initials,Affiliation  FROM '+ @SourceDBName + '.dbo.pm_pubs_authors'
	INSERT INTO [Profile.Data].[Publication.PubMed.Author]([PMID],[ValidYN],[LastName],FirstName,ForeName,Suffix,Initials,Affiliation)
	EXEC sp_executesql @sql	 
	
	 
	--1 [Profile.Data].[Publication.PubMed.Chemical]
	DELETE FROM [Profile.Data].[Publication.PubMed.Chemical]
	SELECT @sql = 'SELECT [PMID],NameOfSubstance  FROM '+ @SourceDBName + '.dbo.pm_pubs_chemicals'
	INSERT INTO [Profile.Data].[Publication.PubMed.Chemical]([PMID],NameOfSubstance)
	EXEC sp_executesql @sql	 
	
	 
	-- [Profile.Data].[Publication.PubMed.Databank]
	DELETE FROM [Profile.Data].[Publication.PubMed.Databank]
	SELECT @sql = 'SELECT [PMID],DataBankName  FROM '+ @SourceDBName + '.dbo.pm_pubs_databanks'
	INSERT INTO [Profile.Data].[Publication.PubMed.Databank]([PMID],DataBankName)
	EXEC sp_executesql @sql	 
	
	 
	--[Profile.Data].[Publication.PubMed.Grant]
	DELETE FROM [Profile.Data].[Publication.PubMed.Grant]
	SELECT @sql = 'SELECT [PMID],GrantID,Acronym,Agency  FROM '+ @SourceDBName + '.dbo.pm_pubs_grants'
	INSERT INTO [Profile.Data].[Publication.PubMed.Grant]([PMID],GrantID,Acronym,Agency )
	EXEC sp_executesql @sql	
	
	--[Profile.Data].[Publication.PubMed.Investigator]
	DELETE FROM [Profile.Data].[Publication.PubMed.Investigator]
	SELECT @sql = 'SELECT [PMID],[LastName],FirstName,ForeName,Suffix,Initials,Affiliation FROM '+ @SourceDBName + '.dbo.pm_pubs_investigators'
	INSERT INTO [Profile.Data].[Publication.PubMed.Investigator]([PMID],[LastName],FirstName,ForeName,Suffix,Initials,Affiliation)
	EXEC sp_executesql @sql	
	
	--[Profile.Data].[Publication.PubMed.Keyword]
	DELETE FROM [Profile.Data].[Publication.PubMed.Keyword]
	SELECT @sql = 'SELECT PMID, Keyword,MajorTopicYN  FROM '+ @SourceDBName + '.dbo.pm_pubs_keywords'
	INSERT INTO [Profile.Data].[Publication.PubMed.Keyword](PMID, Keyword,MajorTopicYN )
	EXEC sp_executesql @sql	 
	
	--	[Profile.Data].[Publication.Person.Include]dbo.publications_include
	TRUNCATE TABLE [Profile.Data].[Publication.Person.Include]
	SELECT @sql = 'SELECT[PubID],[PersonID],[PMID],[MPID] FROM '+ @SourceDBName + '.dbo.publications_include'
	INSERT INTO [Profile.Data].[Publication.Person.Include]([PubID],[PersonID],[PMID],[MPID])
	EXEC sp_executesql @sql	    
	
	--	[Profile.Data].[Publication.Person.Add]dbo.publications_add
	TRUNCATE TABLE [Profile.Data].[Publication.Person.Add]
	SELECT @sql = 'SELECT[PubID],[PersonID],[PMID],[MPID] FROM '+ @SourceDBName + '.dbo.publications_add'
	INSERT INTO [Profile.Data].[Publication.Person.Add]([PubID],[PersonID],[PMID],[MPID])
	EXEC sp_executesql @sql	   
	
	--	[Profile.Data].[Publication.Person.Exclude]dbo.publications_Exclude
	TRUNCATE TABLE [Profile.Data].[Publication.Person.Exclude]
	SELECT @sql = 'SELECT[PubID],[PersonID],[PMID],[MPID] FROM '+ @SourceDBName + '.dbo.publications_Exclude'
	INSERT INTO [Profile.Data].[Publication.Person.Exclude]([PubID],[PersonID],[PMID],[MPID])
	EXEC sp_executesql @sql	   
	
	--	[Profile.Data].[Publication.PubMed.AllXML]dbo.pm_all_xml
	TRUNCATE TABLE [Profile.Data].[Publication.PubMed.AllXML]
	SELECT @sql = 'SELECT pmid,x,parsedt FROM '+ @SourceDBName + '.dbo.pm_all_xml'
	INSERT INTO [Profile.Data].[Publication.PubMed.AllXML]([PMID],x,parsedt)
	EXEC sp_executesql @sql	   
	 
	--	[User.Account].[User]dbo.[user]
	SET IDENTITY_INSERT [User.Account].[User] ON 
	DELETE FROM [User.Account].[User]
	SELECT @sql = 'SELECT[UserID],EmailAddr,[PersonID],[IsActive],[CanBeProxy],[FirstName],[LastName],[DisplayName],[InstitutionFullName],[DepartmentFullName],[DivisionFullName],[UserName],[Password],[CreateDate],[ApplicationName],[Comment],[IsApproved],[IsOnline],[InternalUserName] FROM '+ @SourceDBName + '.dbo.[user] '
	INSERT INTO [User.Account].[User]([UserID],EmailAddr,[PersonID],[IsActive],[CanBeProxy],[FirstName],[LastName],[DisplayName],[Institution],[Department],[Division],[UserName],[Password],[CreateDate],[ApplicationName],[Comment],[IsApproved],[IsOnline],[InternalUserName])
	EXEC sp_executesql @sql	    
	SET IDENTITY_INSERT [User.Account].[User] OFF  
 
	--  [User.Account].DefaultProxy
	DELETE FROM [User.Account].DefaultProxy
	SELECT @sql = 'SELECT proxy, institution,department,NULL, case when ishidden=''Y'' then 0 else 1 end	FROM  '+ @SourceDBName + '.dbo.[proxies_default]  '
	INSERT INTO [User.Account].DefaultProxy
	        ( UserID ,
	          ProxyForInstitution ,
	          ProxyForDepartment ,
	          ProxyForDivision ,
	          IsVisible
	        )
	EXEC sp_executesql @sql	 
	
	-- [User.Account].DesignatedProxy 
	DELETE FROM [User.Account].DesignatedProxy 
	SELECT @sql = 'select  Proxy, PersonID FROM  '+ @SourceDBName + '.dbo.[proxies_designated]  '
	INSERT INTO [User.Account].DesignatedProxy ( UserID, ProxyForUserID )
	EXEC sp_executesql @sql 
	
	-- [User.Account].Relationship 
	DELETE FROM [User.Account].Relationship
	SELECT @sql = 'select UserID, personid,RelationshipType FROM  '+ @SourceDBName + '.dbo.[user_relationships]  '
	INSERT INTO [User.Account].Relationship ( UserID, personid,RelationshipType )
	EXEC sp_executesql @sql 
	 
	-- [Profile.Import].[Beta.DisplayPreference]
	TRUNCATE TABLE [Profile.Import].[Beta.DisplayPreference]
	SELECT @sql = 'select PersonID,ShowPhoto,ShowPublications,ShowAwards,ShowNarrative,ShowAddress,ShowEmail,ShowPhone,ShowFax,PhotoPreference FROM  '+ @SourceDBName + '.dbo.[display_prefs]  '
	INSERT INTO [Profile.Import].[Beta.DisplayPreference] (PersonID,ShowPhoto,ShowPublications,ShowAwards,ShowNarrative,ShowAddress,ShowEmail,ShowPhone,ShowFax,PhotoPreference )
	EXEC sp_executesql @sql 			
	
	-- [Profile.Data].[Person.Photo]
	TRUNCATE TABLE [Profile.Data].[Person.Photo]
	SELECT @sql = 'select PersonID,Photo,PhotoLink  FROM  '+ @SourceDBName + '.dbo.[photo]  '
	INSERT INTO [Profile.Data].[Person.Photo] (PersonID,Photo,PhotoLink )
	EXEC sp_executesql @sql 	
		
			 
	--  [Profile.Cache].[Concept.Mesh.SimilarConcept]
	TRUNCATE TABLE [Profile.Cache].[Concept.Mesh.SimilarConcept]
	SELECT @sql = 'SELECT meshheader, sortorder, similarconcept, weight FROM  '+ @SourceDBName + '.dbo.[cache_similar_concepts]  '
	INSERT INTO [Profile.Cache].[Concept.Mesh.SimilarConcept] (meshheader, sortorder, similarconcept, weight)
	EXEC sp_executesql @sql 
	
	-- [Profile.Cache].[SNA.Coauthor.Distance]
	TRUNCATE TABLE [Profile.Cache].[SNA.Coauthor.Distance]
	SELECT @sql = 'SELECT PersonID1,PersonID2,Distance,NumPaths FROM '+ @SourceDBName + '.dbo.sna_distance'
	INSERT INTO [Profile.Cache].[SNA.Coauthor.Distance] (PersonID1,PersonID2,Distance,NumPaths)
	EXEC sp_executesql @sql  
	
	-- [Profile.Cache].[SNA.Coauthor.Reach]
	TRUNCATE TABLE [Profile.Cache].[SNA.Coauthor.Reach]
	SELECT @sql = 'SELECT PersonID,Distance,NumPeople FROM '+ @SourceDBName + '.dbo.sna_reach'
	INSERT INTO [Profile.Cache].[SNA.Coauthor.Reach] (PersonID,Distance,NumPeople)
	EXEC sp_executesql @sql  
	
	-- [Profile.Cache].[SNA.Coauthor.Betweenness]
	TRUNCATE TABLE [Profile.Cache].[SNA.Coauthor.Betweenness]
	SELECT @sql = 'SELECT personid,i,b FROM '+ @SourceDBName + '.dbo.sna_betweenness'	
	INSERT INTO [Profile.Cache].[SNA.Coauthor.Betweenness] (personid,i,b)
	EXEC sp_executesql @sql 
				
  	-- [Profile.Data].[Publication.PubMed.DisambiguationAffiliation] 		
	truncate table [Profile.Data].[Publication.PubMed.DisambiguationAffiliation]
	SELECT @sql = 'SELECT affiliation FROM '+ @SourceDBName + '.dbo.disambiguation_pm_affiliations'	
	INSERT INTO [Profile.Data].[Publication.PubMed.DisambiguationAffiliation] (affiliation)
	EXEC sp_executesql @sql 		
	 
	-- Toggle off fkey constraints
	ALTER TABLE [Profile.Data].[Person.FilterRelationship]  CHECK CONSTRAINT FK_person_type_relationships_person
	ALTER TABLE [Profile.Data].[Person.FilterRelationship]  CHECK CONSTRAINT FK_person_type_relationships_person_types	
	ALTER TABLE [Profile.Data].[Publication.Person.Include]  CHECK CONSTRAINT FK_publications_include_pm_pubs_general
	ALTER TABLE [Profile.Data].[Publication.MyPub.General]  CHECK CONSTRAINT FK_my_pubs_general_person
	ALTER TABLE [Profile.Data].[Publication.Person.Include]  CHECK CONSTRAINT FK_publications_include_person
	ALTER TABLE [Profile.Data].[Publication.Person.Include]  CHECK CONSTRAINT FK_publications_include_my_pubs_general 
	ALTER TABLE [Profile.Data].[Publication.PubMed.Accession]  CHECK CONSTRAINT  FK_pm_pubs_accessions_pm_pubs_general
	ALTER TABLE [Profile.Data].[Publication.PubMed.Author]  CHECK CONSTRAINT  FK_pm_pubs_authors_pm_pubs_general
	ALTER TABLE [Profile.Data].[Publication.PubMed.Chemical]  CHECK CONSTRAINT  FK_pm_pubs_chemicals_pm_pubs_general
	ALTER TABLE [Profile.Data].[Publication.PubMed.Databank]   CHECK CONSTRAINT  FK_pm_pubs_databanks_pm_pubs_general
	ALTER TABLE [Profile.Data].[Publication.PubMed.Grant]  CHECK CONSTRAINT FK_pm_pubs_grants_pm_pubs_general
	
	-- Popluate [Publication.Entity.Authorship] and [Publication.Entity.InformationResource] tables
	EXEC [Profile.Data].[Publication.Entity.UpdateEntity]
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.Pubmed.LoadDisambiguationResults]
AS
BEGIN
BEGIN TRY  
BEGIN TRAN
 
-- Remove orphaned pubs
DECLARE @deletedPMIDTable TABLE (PersonID int, PMID int)
DELETE FROM [Profile.Data].[Publication.Person.Include]
OUTPUT deleted.PersonID, deleted.PMID into @deletedPMIDTable
	  WHERE NOT EXISTS (SELECT *
						  FROM [Profile.Data].[Publication.PubMed.Disambiguation] p
						 WHERE p.personid = [Profile.Data].[Publication.Person.Include].personid
						   AND p.pmid = [Profile.Data].[Publication.Person.Include].pmid)
		AND mpid IS NULL
INSERT INTO [Framework.].[Log.Activity] (userId, personId, methodName, property, privacyCode, param1, param2) 
SELECT 0, PersonID, '[Profile.Data].[Publication.Pubmed.LoadDisambiguationResults]', null, null, 'Delete PMID', PMID FROM @deletedPMIDTable

-- Add Added Pubs
insert into [Profile.Data].[Publication.Person.Include](pubid,PersonID,pmid,mpid)
select a.PubID, a.PersonID, a.PMID, a.MPID from [Profile.Data].[Publication.Person.Add] a
	left join [Profile.Data].[Publication.Person.Include] i
	on a.PersonID = i.PersonID
	and isnull(a.PMID, -1) = isnull(i.PMID, -1)
	and isnull(a.mpid, '') = isnull(i.mpid, '')
	where i.personid is null
	and (a.pmid is null or a.PMID in (select pmid from [Profile.Data].[Publication.PubMed.General]))
	and (a.mpid is null or a.MPID in (select mpid from [Profile.Data].[Publication.MyPub.General]))
		
--Move in new pubs
DECLARE @addedPMIDTable TABLE (PersonID int, PMID int)
INSERT INTO [Profile.Data].[Publication.Person.Include]
OUTPUT inserted.PersonID, inserted.PMID into @addedPMIDTable
SELECT	 NEWID(),
		 personid,
		 pmid,
		 NULL
  FROM [Profile.Data].[Publication.PubMed.Disambiguation] d
 WHERE NOT EXISTS (SELECT *
					 FROM  [Profile.Data].[Publication.Person.Include] p
					WHERE p.personid = d.personid
					  AND p.pmid = d.pmid)
  AND EXISTS (SELECT 1 FROM [Profile.Data].[Publication.PubMed.General] g where g.pmid = d.pmid)					  
 INSERT INTO [Framework.].[Log.Activity] (userId, personId, methodName, property, privacyCode, param1, param2) 
SELECT 0, PersonID, '[Profile.Data].[Publication.Pubmed.LoadDisambiguationResults]', null, null, 'Add PMID', PMID FROM @addedPMIDTable	  
 
COMMIT
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
 
		-- Raise an error with the details of the exception
		SELECT @ErrMsg =  ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()
 
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
			 
	END CATCH		
 
-- Popluate [Publication.Entity.Authorship] and [Publication.Entity.InformationResource] tables
	EXEC [Profile.Data].[Publication.Entity.UpdateEntity]
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.Pubmed.AddPublication] 
	@UserID INT,
	@pmid int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
	if exists (select * from [Profile.Data].[Publication.PubMed.AllXML] where pmid = @pmid)
	begin
 
		declare @ParseDate datetime
		set @ParseDate = (select coalesce(ParseDT,'1/1/1900') from [Profile.Data].[Publication.PubMed.AllXML] where pmid = @pmid)
		if (@ParseDate < '1/1/2000')
		begin
			exec [Profile.Data].[Publication.Pubmed.ParsePubMedXML] 
			 @pmid
		end
 BEGIN TRY 
		BEGIN TRANSACTION
 
			if not exists (select * from [Profile.Data].[Publication.Person.Include] where PersonID = @UserID and pmid = @pmid)
			begin
 
				declare @pubid uniqueidentifier
				declare @mpid varchar(50)
 
				set @mpid = null
 
				set @pubid = (select top 1 pubid from [Profile.Data].[Publication.Person.Exclude] where PersonID = @UserID and pmid = @pmid)
				if @pubid is not null
					begin
						set @mpid = (select mpid from [Profile.Data].[Publication.Person.Exclude] where pubid = @pubid)
						delete from [Profile.Data].[Publication.Person.Exclude] where pubid = @pubid
					end
				else
					begin
						set @pubid = (select newid())
					end
 
				insert into [Profile.Data].[Publication.Person.Include](pubid,PersonID,pmid,mpid)
					values (@pubid,@UserID,@pmid,@mpid)
 
				insert into [Profile.Data].[Publication.Person.Add](pubid,PersonID,pmid,mpid)
					values (@pubid,@UserID,@pmid,@mpid)
 
				EXEC  [Profile.Data].[Publication.Pubmed.AddOneAuthorPosition] @PersonID = @UserID, @pmid = @pmid
 
				-- Popluate [Publication.Entity.Authorship] and [Publication.Entity.InformationResource] tables
				EXEC [Profile.Data].[Publication.Entity.UpdateEntityOnePerson]@UserID
				
			end
 
		COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
 
		-- Raise an error with the details of the exception
		SELECT @ErrMsg =  ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()
 
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
			 
	END CATCH		
 
	END
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.GetPersonPublications] 
	-- Add the parameters for the stored procedure here
	@UserID INT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
SELECT *
  FROM [Profile.Data].[fnPublication.Person.GetPublications](@UserID)
 
 
	--ORDER BY publication_dt, publications
 
 
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Search.Cache].[Public.GetNodes]
	@SearchOptions XML,
	@SessionID UNIQUEIDENTIFIER = NULL,
	@NoRDF BIT =0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
		-- interfering with SELECT statements.
		SET NOCOUNT ON;

	/*
	
	EXEC [Search.].[GetNodes] @SearchOptions = '
	<SearchOptions>
		<MatchOptions>
			<SearchString ExactMatch="false">options for "lung cancer" treatment</SearchString>
			<ClassURI>http://xmlns.com/foaf/0.1/Person</ClassURI>
			<SearchFiltersList>
				<SearchFilter Property="http://xmlns.com/foaf/0.1/lastName" MatchType="Left">Smit</SearchFilter>
			</SearchFiltersList>
		</MatchOptions>
		<OutputOptions>
			<Offset>0</Offset>
			<Limit>5</Limit>
			<SortByList>
				<SortBy IsDesc="1" Property="http://xmlns.com/foaf/0.1/firstName" />
				<SortBy IsDesc="0" Property="http://xmlns.com/foaf/0.1/lastName" />
			</SortByList>
		</OutputOptions>	
	</SearchOptions>
	'
		
	*/

	declare @MatchOptions xml
	declare @OutputOptions xml
	declare @SearchString varchar(500)
	declare @ClassGroupURI varchar(400)
	declare @ClassURI varchar(400)
	declare @SearchFiltersXML xml
	declare @offset bigint
	declare @limit bigint
	declare @SortByXML xml
	declare @DoExpandedSearch bit
	
	select	@MatchOptions = @SearchOptions.query('SearchOptions[1]/MatchOptions[1]'),
			@OutputOptions = @SearchOptions.query('SearchOptions[1]/OutputOptions[1]')
	
	select	@SearchString = @MatchOptions.value('MatchOptions[1]/SearchString[1]','varchar(500)'),
			@DoExpandedSearch = (case when @MatchOptions.value('MatchOptions[1]/SearchString[1]/@ExactMatch','varchar(50)') = 'true' then 0 else 1 end),
			@ClassGroupURI = @MatchOptions.value('MatchOptions[1]/ClassGroupURI[1]','varchar(400)'),
			@ClassURI = @MatchOptions.value('MatchOptions[1]/ClassURI[1]','varchar(400)'),
			@SearchFiltersXML = @MatchOptions.query('MatchOptions[1]/SearchFiltersList[1]'),
			@offset = @OutputOptions.value('OutputOptions[1]/Offset[1]','bigint'),
			@limit = @OutputOptions.value('OutputOptions[1]/Limit[1]','bigint'),
			@SortByXML = @OutputOptions.query('OutputOptions[1]/SortByList[1]')

	declare @baseURI nvarchar(400)
	select @baseURI = value from [Framework.].Parameter where ParameterID = 'baseURI'

	declare @d datetime
	select @d = GetDate()
	
	declare @IsBot bit
	if @SessionID is not null
		select @IsBot = IsBot
			from [User.Session].[Session]
			where SessionID = @SessionID
	select @IsBot = IsNull(@IsBot,0)

	select @limit = 100
		where (@limit is null) or (@limit > 100)
	
	declare @SearchHistoryQueryID int
	insert into [Search.].[History.Query] (StartDate, SessionID, IsBot, SearchOptions)
		select GetDate(), @SessionID, @IsBot, @SearchOptions
	select @SearchHistoryQueryID = @@IDENTITY

	-------------------------------------------------------
	-- Parse search string and convert to fulltext query
	-------------------------------------------------------
/*
	declare @NumberOfPhrases INT
	declare @CombinedSearchString VARCHAR(8000)
	declare @SearchPhraseXML XML
	declare @SearchPhraseFormsXML XML
	declare @ParseProcessTime INT

	EXEC [Search.].[ParseSearchString]	@SearchString = @SearchString,
										@NumberOfPhrases = @NumberOfPhrases OUTPUT,
										@CombinedSearchString = @CombinedSearchString OUTPUT,
										@SearchPhraseXML = @SearchPhraseXML OUTPUT,
										@SearchPhraseFormsXML = @SearchPhraseFormsXML OUTPUT,
										@ProcessTime = @ParseProcessTime OUTPUT

*/

	declare @NumberOfPhrases INT
	declare @CombinedSearchString VARCHAR(8000)
	declare @SearchString1 VARCHAR(8000)
	declare @SearchString2 VARCHAR(8000)
	declare @SearchString3 VARCHAR(8000)
	declare @SearchPhraseXML XML
	declare @SearchPhraseFormsXML XML
	declare @ParseProcessTime INT

	EXEC [Search.].[ParseSearchString]	@SearchString = @SearchString,
										@NumberOfPhrases = @NumberOfPhrases OUTPUT,
										@CombinedSearchString = @CombinedSearchString OUTPUT,
										@SearchString1 = @SearchString1 OUTPUT,
										@SearchString2 = @SearchString2 OUTPUT,
										@SearchString3 = @SearchString3 OUTPUT,
										@SearchPhraseXML = @SearchPhraseXML OUTPUT,
										@SearchPhraseFormsXML = @SearchPhraseFormsXML OUTPUT,
										@ProcessTime = @ParseProcessTime OUTPUT


	declare @PhraseList table (PhraseID int, Phrase varchar(max), ThesaurusMatch bit, Forms varchar(max))
	insert into @PhraseList (PhraseID, Phrase, ThesaurusMatch, Forms)
	select	x.value('@ID','INT'),
			x.value('.','VARCHAR(MAX)'),
			x.value('@ThesaurusMatch','BIT'),
			x.value('@Forms','VARCHAR(MAX)')
		from @SearchPhraseFormsXML.nodes('//SearchPhrase') as p(x)

	--SELECT @NumberOfPhrases, @CombinedSearchString, @SearchPhraseXML, @SearchPhraseFormsXML, @ParseProcessTime, @SearchString1, @SearchString2, @SearchString3
	--SELECT * FROM @PhraseList
	--select datediff(ms,@d,GetDate())


	-------------------------------------------------------
	-- Parse search filters
	-------------------------------------------------------

	create table #SearchFilters (
		SearchFilterID int identity(0,1) primary key,
		IsExclude bit,
		PropertyURI varchar(400),
		PropertyURI2 varchar(400),
		MatchType varchar(100),
		Value varchar(750),
		Predicate bigint,
		Predicate2 bigint
	)
	
	insert into #SearchFilters (IsExclude, PropertyURI, PropertyURI2, MatchType, Value, Predicate, Predicate2)	
		select t.IsExclude, t.PropertyURI, t.PropertyURI2, t.MatchType, t.Value,
				--left(t.Value,750)+(case when t.MatchType='Left' then '%' else '' end),
				t.Predicate, t.Predicate2
			from (
				select IsNull(IsExclude,0) IsExclude, PropertyURI, PropertyURI2, MatchType, Value,
					[RDF.].fnURI2NodeID(PropertyURI) Predicate,
					[RDF.].fnURI2NodeID(PropertyURI2) Predicate2
				from (
					select distinct S.x.value('@IsExclude','bit') IsExclude,
							S.x.value('@Property','varchar(400)') PropertyURI,
							S.x.value('@Property2','varchar(400)') PropertyURI2,
							S.x.value('@MatchType','varchar(100)') MatchType,
							--S.x.value('.','nvarchar(max)') Value
							(case when cast(S.x.query('./*') as nvarchar(max)) <> '' then cast(S.x.query('./*') as nvarchar(max)) else S.x.value('.','nvarchar(max)') end) Value
					from @SearchFiltersXML.nodes('//SearchFilter') as S(x)
				) t
			) t
			where t.Value IS NOT NULL and t.Value <> ''
			
	declare @NumberOfIncludeFilters int
	select @NumberOfIncludeFilters = IsNull((select count(*) from #SearchFilters where IsExclude=0),0)

	-------------------------------------------------------
	-- Parse sort by options
	-------------------------------------------------------

	create table #SortBy (
		SortByID int identity(1,1) primary key,
		IsDesc bit,
		PropertyURI varchar(400),
		PropertyURI2 varchar(400),
		PropertyURI3 varchar(400),
		Predicate bigint,
		Predicate2 bigint,
		Predicate3 bigint
	)
	
	insert into #SortBy (IsDesc, PropertyURI, PropertyURI2, PropertyURI3, Predicate, Predicate2, Predicate3)	
		select IsNull(IsDesc,0), PropertyURI, PropertyURI2, PropertyURI3,
				[RDF.].fnURI2NodeID(PropertyURI) Predicate,
				[RDF.].fnURI2NodeID(PropertyURI2) Predicate2,
				[RDF.].fnURI2NodeID(PropertyURI3) Predicate3
			from (
				select S.x.value('@IsDesc','bit') IsDesc,
						S.x.value('@Property','varchar(400)') PropertyURI,
						S.x.value('@Property2','varchar(400)') PropertyURI2,
						S.x.value('@Property3','varchar(400)') PropertyURI3
				from @SortByXML.nodes('//SortBy') as S(x)
			) t

	-------------------------------------------------------
	-- Get initial list of matching nodes (before filters)
	-------------------------------------------------------

	create table #FullNodeMatch (
		NodeID bigint not null,
		Paths bigint,
		Weight float
	)

	if @CombinedSearchString <> ''
	begin

		-- Get nodes that match separate phrases
		create table #PhraseNodeMatch (
			PhraseID int not null,
			NodeID bigint not null,
			Paths bigint,
			Weight float
		)
		if (@NumberOfPhrases > 1) and (@DoExpandedSearch = 1)
		begin
			declare @PhraseSearchString varchar(8000)
			declare @loop int
			select @loop = 1
			while @loop <= @NumberOfPhrases
			begin
				select @PhraseSearchString = Forms
					from @PhraseList
					where PhraseID = @loop
				select * into #NodeRankTemp from containstable ([RDF.].[vwLiteral], value, @PhraseSearchString, 100000)
				alter table #NodeRankTemp add primary key ([Key])
				insert into #PhraseNodeMatch (PhraseID, NodeID, Paths, Weight)
					select @loop, s.NodeID, count(*) Paths, 1-exp(sum(log(case when s.Weight*(m.[Rank]*0.000999+0.001) > 0.999999 then 0.000001 else 1-s.Weight*(m.[Rank]*0.000999+0.001) end))) Weight
						from #NodeRankTemp m
							inner loop join [Search.Cache].[Public.NodeMap] s
								on s.MatchedByNodeID = m.[Key]
						group by s.NodeID
				drop table #NodeRankTemp
				select @loop = @loop + 1
			end
			--create clustered index idx_n on #PhraseNodeMatch(NodeID)
		end

		-- Get nodes that match the combined search string
		create table #TempMatchNodes (
			NodeID bigint,
			MatchedByNodeID bigint,
			Distance int,
			Paths int,
			Weight float,
			mWeight float
		)
		-- Run each search string
		if @SearchString1 <> ''
				select * into #CombinedSearch1 from containstable ([RDF.].[vwLiteral], value, @SearchString1, 100000) t
		if @SearchString2 <> ''
				select * into #CombinedSearch2 from containstable ([RDF.].[vwLiteral], value, @SearchString2, 100000) t
		if @SearchString3 <> ''
				select * into #CombinedSearch3 from containstable ([RDF.].[vwLiteral], value, @SearchString3, 100000) t
		-- Combine each search string
		create table #CombinedSearch ([key] bigint primary key, [rank] int)
		if IsNull(@SearchString1,'') <> '' and IsNull(@SearchString2,'') = '' and IsNull(@SearchString3,'') = ''
			insert into #CombinedSearch select [key], max([rank]) [rank] from #CombinedSearch1 t group by [key]
		if IsNull(@SearchString1,'') <> '' and IsNull(@SearchString2,'') <> '' and IsNull(@SearchString3,'') = ''
			insert into #CombinedSearch select [key], max([rank]) [rank] from (select * from #CombinedSearch1 union all select * from #CombinedSearch2) t group by [key]
		if IsNull(@SearchString1,'') <> '' and IsNull(@SearchString2,'') <> '' and IsNull(@SearchString3,'') <> ''
			insert into #CombinedSearch select [key], max([rank]) [rank] from (select * from #CombinedSearch1 union all select * from #CombinedSearch2 union all select * from #CombinedSearch3) t group by [key]
		-- Get the TempMatchNodes
		insert into #TempMatchNodes (NodeID, MatchedByNodeID, Distance, Paths, Weight, mWeight)
			select s.*, m.[Rank]*0.000999+0.001 mWeight
				from #CombinedSearch m
					inner loop join [Search.Cache].[Public.NodeMap] s
						on s.MatchedByNodeID = m.[key]
		-- Delete temp tables
		if @SearchString1 <> ''
				drop table #CombinedSearch1
		if @SearchString2 <> ''
				drop table #CombinedSearch2
		if @SearchString3 <> ''
				drop table #CombinedSearch3
		drop table #CombinedSearch

		-- Get nodes that match either all phrases or the combined search string
		insert into #FullNodeMatch (NodeID, Paths, Weight)
			select IsNull(a.NodeID,b.NodeID) NodeID, IsNull(a.Paths,b.Paths) Paths,
					(case when a.weight is null or b.weight is null then IsNull(a.Weight,b.Weight) else 1-(1-a.Weight)*(1-b.Weight) end) Weight
				from (
					select NodeID, exp(sum(log(Paths))) Paths, exp(sum(log(Weight))) Weight
						from #PhraseNodeMatch
						group by NodeID
						having count(*) = @NumberOfPhrases
				) a full outer join (
					select NodeID, count(*) Paths, 1-exp(sum(log(case when Weight*mWeight > 0.999999 then 0.000001 else 1-Weight*mWeight end))) Weight
						from #TempMatchNodes
						group by NodeID
				) b on a.NodeID = b.NodeID
		--select 'Text Matches Found', datediff(ms,@d,getdate())
	end
	else if (@NumberOfIncludeFilters > 0)
	begin
		insert into #FullNodeMatch (NodeID, Paths, Weight)
			select t1.Subject, 1, 1
				from #SearchFilters f
					inner join [RDF.].Triple t1
						on f.Predicate is not null
							and t1.Predicate = f.Predicate 
							and t1.ViewSecurityGroup = -1
					left outer join [Search.Cache].[Public.NodePrefix] n1
						on n1.NodeID = t1.Object
					left outer join [RDF.].Triple t2
						on f.Predicate2 is not null
							and t2.Subject = n1.NodeID
							and t2.Predicate = f.Predicate2
							and t2.ViewSecurityGroup = -1
					left outer join [Search.Cache].[Public.NodePrefix] n2
						on n2.NodeID = t2.Object
				where f.IsExclude = 0
					and 1 = (case	when (f.Predicate2 is not null) then
										(case	when f.MatchType = 'Left' then
													(case when n2.Prefix like f.Value+'%' then 1 else 0 end)
												when f.MatchType = 'In' then
													(case when n2.Prefix in (select r.x.value('.','varchar(max)') v from (select cast(f.Value as xml) x) t cross apply x.nodes('//Item') as r(x)) then 1 else 0 end)
												else
													(case when n2.Prefix = f.Value then 1 else 0 end)
												end)
									else
										(case	when f.MatchType = 'Left' then
													(case when n1.Prefix like f.Value+'%' then 1 else 0 end)
												when f.MatchType = 'In' then
													(case when n1.Prefix in (select r.x.value('.','varchar(max)') v from (select cast(f.Value as xml) x) t cross apply x.nodes('//Item') as r(x)) then 1 else 0 end)
												else
													(case when n1.Prefix = f.Value then 1 else 0 end)
												end)
									end)
					--and (case when f.Predicate2 is not null then n2.Prefix else n1.Prefix end)
					--	like f.Value
				group by t1.Subject
				having count(distinct f.SearchFilterID) = @NumberOfIncludeFilters
		delete from #SearchFilters where IsExclude = 0
		select @NumberOfIncludeFilters = 0
	end
	else if (IsNull(@ClassGroupURI,'') <> '' or IsNull(@ClassURI,'') <> '')
	begin
		insert into #FullNodeMatch (NodeID, Paths, Weight)
			select distinct n.NodeID, 1, 1
				from [Search.Cache].[Public.NodeClass] n, [Ontology.].ClassGroupClass c
				where n.Class = c._ClassNode
					and ((@ClassGroupURI is null) or (c.ClassGroupURI = @ClassGroupURI))
					and ((@ClassURI is null) or (c.ClassURI = @ClassURI))
		select @ClassGroupURI = null, @ClassURI = null
	end

	-------------------------------------------------------
	-- Run the actual search
	-------------------------------------------------------
	create table #Node (
		SortOrder bigint identity(0,1) primary key,
		NodeID bigint,
		Paths bigint,
		Weight float
	)

	insert into #Node (NodeID, Paths, Weight)
		select s.NodeID, s.Paths, s.Weight
			from #FullNodeMatch s
				inner join [Search.Cache].[Public.NodeSummary] n on
					s.NodeID = n.NodeID
					and ( IsNull(@ClassGroupURI,@ClassURI) is null or s.NodeID in (
							select NodeID
								from [Search.Cache].[Public.NodeClass] x, [Ontology.].ClassGroupClass c
								where x.Class = c._ClassNode
									and c.ClassGroupURI = IsNull(@ClassGroupURI,c.ClassGroupURI)
									and c.ClassURI = IsNull(@ClassURI,c.ClassURI)
						) )
					and ( @NumberOfIncludeFilters =
							(select count(distinct f.SearchFilterID)
								from #SearchFilters f
									inner join [RDF.].Triple t1
										on f.Predicate is not null
											and t1.Subject = s.NodeID
											and t1.Predicate = f.Predicate 
											and t1.ViewSecurityGroup = -1
									left outer join [Search.Cache].[Public.NodePrefix] n1
										on n1.NodeID = t1.Object
									left outer join [RDF.].Triple t2
										on f.Predicate2 is not null
											and t2.Subject = n1.NodeID
											and t2.Predicate = f.Predicate2
											and t2.ViewSecurityGroup = -1
									left outer join [Search.Cache].[Public.NodePrefix] n2
										on n2.NodeID = t2.Object
								where f.IsExclude = 0
									and 1 = (case	when (f.Predicate2 is not null) then
														(case	when f.MatchType = 'Left' then
																	(case when n2.Prefix like f.Value+'%' then 1 else 0 end)
																when f.MatchType = 'In' then
																	(case when n2.Prefix in (select r.x.value('.','varchar(max)') v from (select cast(f.Value as xml) x) t cross apply x.nodes('//Item') as r(x)) then 1 else 0 end)
																else
																	(case when n2.Prefix = f.Value then 1 else 0 end)
																end)
													else
														(case	when f.MatchType = 'Left' then
																	(case when n1.Prefix like f.Value+'%' then 1 else 0 end)
																when f.MatchType = 'In' then
																	(case when n1.Prefix in (select r.x.value('.','varchar(max)') v from (select cast(f.Value as xml) x) t cross apply x.nodes('//Item') as r(x)) then 1 else 0 end)
																else
																	(case when n1.Prefix = f.Value then 1 else 0 end)
																end)
													end)
									--and (case when f.Predicate2 is not null then n2.Prefix else n1.Prefix end)
									--	like f.Value
							)
						)
					and not exists (
							select *
								from #SearchFilters f
									inner join [RDF.].Triple t1
										on f.Predicate is not null
											and t1.Subject = s.NodeID
											and t1.Predicate = f.Predicate 
											and t1.ViewSecurityGroup = -1
									left outer join [Search.Cache].[Public.NodePrefix] n1
										on n1.NodeID = t1.Object
									left outer join [RDF.].Triple t2
										on f.Predicate2 is not null
											and t2.Subject = n1.NodeID
											and t2.Predicate = f.Predicate2
											and t2.ViewSecurityGroup = -1
									left outer join [Search.Cache].[Public.NodePrefix] n2
										on n2.NodeID = t2.Object
								where f.IsExclude = 1
									and 1 = (case	when (f.Predicate2 is not null) then
														(case	when f.MatchType = 'Left' then
																	(case when n2.Prefix like f.Value+'%' then 1 else 0 end)
																when f.MatchType = 'In' then
																	(case when n2.Prefix in (select r.x.value('.','varchar(max)') v from (select cast(f.Value as xml) x) t cross apply x.nodes('//Item') as r(x)) then 1 else 0 end)
																else
																	(case when n2.Prefix = f.Value then 1 else 0 end)
																end)
													else
														(case	when f.MatchType = 'Left' then
																	(case when n1.Prefix like f.Value+'%' then 1 else 0 end)
																when f.MatchType = 'In' then
																	(case when n1.Prefix in (select r.x.value('.','varchar(max)') v from (select cast(f.Value as xml) x) t cross apply x.nodes('//Item') as r(x)) then 1 else 0 end)
																else
																	(case when n1.Prefix = f.Value then 1 else 0 end)
																end)
													end)
									--and (case when f.Predicate2 is not null then n2.Prefix else n1.Prefix end)
									--	like f.Value
						)
				outer apply (
					select	max(case when SortByID=1 then AscSortBy else null end) AscSortBy1,
							max(case when SortByID=2 then AscSortBy else null end) AscSortBy2,
							max(case when SortByID=3 then AscSortBy else null end) AscSortBy3,
							max(case when SortByID=1 then DescSortBy else null end) DescSortBy1,
							max(case when SortByID=2 then DescSortBy else null end) DescSortBy2,
							max(case when SortByID=3 then DescSortBy else null end) DescSortBy3
						from (
							select	SortByID,
									(case when f.IsDesc = 1 then null
											when f.Predicate3 is not null then n3.Value
											when f.Predicate2 is not null then n2.Value
											else n1.Value end) AscSortBy,
									(case when f.IsDesc = 0 then null
											when f.Predicate3 is not null then n3.Value
											when f.Predicate2 is not null then n2.Value
											else n1.Value end) DescSortBy
								from #SortBy f
									inner join [RDF.].Triple t1
										on f.Predicate is not null
											and t1.Subject = s.NodeID
											and t1.Predicate = f.Predicate 
											and t1.ViewSecurityGroup = -1
									left outer join [RDF.].Node n1
										on n1.NodeID = t1.Object
											and n1.ViewSecurityGroup = -1
									left outer join [RDF.].Triple t2
										on f.Predicate2 is not null
											and t2.Subject = n1.NodeID
											and t2.Predicate = f.Predicate2
											and t2.ViewSecurityGroup = -1
									left outer join [RDF.].Node n2
										on n2.NodeID = t2.Object
											and n2.ViewSecurityGroup = -1
									left outer join [RDF.].Triple t3
										on f.Predicate3 is not null
											and t3.Subject = n2.NodeID
											and t3.Predicate = f.Predicate3
											and t3.ViewSecurityGroup = -1
									left outer join [RDF.].Node n3
										on n3.NodeID = t3.Object
											and n3.ViewSecurityGroup = -1
							) t
					) o
			order by	(case when o.AscSortBy1 is null then 1 else 0 end),
						o.AscSortBy1,
						(case when o.DescSortBy1 is null then 1 else 0 end),
						o.DescSortBy1 desc,
						(case when o.AscSortBy2 is null then 1 else 0 end),
						o.AscSortBy2,
						(case when o.DescSortBy2 is null then 1 else 0 end),
						o.DescSortBy2 desc,
						(case when o.AscSortBy3 is null then 1 else 0 end),
						o.AscSortBy3,
						(case when o.DescSortBy3 is null then 1 else 0 end),
						o.DescSortBy3 desc,
						s.Weight desc,
						n.ShortLabel,
						n.NodeID

	if @NoRDF = 1
	BEGIN
		SELECT * FROM #Node
		return 
	END
	--select 'Search Nodes Found', datediff(ms,@d,GetDate())

	-------------------------------------------------------
	-- Get network counts
	-------------------------------------------------------

	declare @NumberOfConnections as bigint
	declare @MaxWeight as float
	declare @MinWeight as float

	select @NumberOfConnections = count(*), @MaxWeight = max(Weight), @MinWeight = min(Weight) 
		from #Node

	-------------------------------------------------------
	-- Get matching class groups and classes
	-------------------------------------------------------

	declare @MatchesClassGroups nvarchar(max)

/*
	select c.ClassGroupURI, c.ClassURI, n.NodeID
		into #NodeClass
		from #Node n, [Search.Cache].[Public.NodeClass] s, [Ontology.].ClassGroupClass c
		where n.NodeID = s.NodeID and s.Class = c._ClassNode
*/

	select n.NodeID, s.Class
		into #NodeClassTemp
		from #Node n
			inner join [Search.Cache].[Public.NodeClass] s
				on n.NodeID = s.NodeID
	select c.ClassGroupURI, c.ClassURI, n.NodeID
		into #NodeClass
		from #NodeClassTemp n
			inner join [Ontology.].ClassGroupClass c
				on n.Class = c._ClassNode

	;with a as (
		select ClassGroupURI, count(distinct NodeID) NumberOfNodes
			from #NodeClass s
			group by ClassGroupURI
	), b as (
		select ClassGroupURI, ClassURI, count(distinct NodeID) NumberOfNodes
			from #NodeClass s
			group by ClassGroupURI, ClassURI
	)
	select @MatchesClassGroups = replace(cast((
			select	g.ClassGroupURI "@rdf_.._resource", 
				g._ClassGroupLabel "rdfs_.._label",
				'http://www.w3.org/2001/XMLSchema#int' "prns_.._numberOfConnections/@rdf_.._datatype",
				a.NumberOfNodes "prns_.._numberOfConnections",
				g.SortOrder "prns_.._sortOrder",
				(
					select	c.ClassURI "@rdf_.._resource",
							c._ClassLabel "rdfs_.._label",
							'http://www.w3.org/2001/XMLSchema#int' "prns_.._numberOfConnections/@rdf_.._datatype",
							b.NumberOfNodes "prns_.._numberOfConnections",
							c.SortOrder "prns_.._sortOrder"
						from b, [Ontology.].ClassGroupClass c
						where b.ClassGroupURI = c.ClassGroupURI and b.ClassURI = c.ClassURI
							and c.ClassGroupURI = g.ClassGroupURI
						order by c.SortOrder
						for xml path('prns_.._matchesClass'), type
				)
			from a, [Ontology.].ClassGroup g
			where a.ClassGroupURI = g.ClassGroupURI and g.IsVisible = 1
			order by g.SortOrder
			for xml path('prns_.._matchesClassGroup'), type
		) as nvarchar(max)),'_.._',':')

	-------------------------------------------------------
	-- Get RDF of search results objects
	-------------------------------------------------------

	declare @ObjectNodesRDF nvarchar(max)

	if @NumberOfConnections > 0
	begin
		/*
			-- Alternative methods that uses GetDataRDF to get the RDF
			declare @NodeListXML xml
			select @NodeListXML = (
					select (
							select NodeID "@ID"
							from #Node
							where SortOrder >= IsNull(@offset,0) and SortOrder < IsNull(IsNull(@offset,0)+@limit,SortOrder+1)
							order by SortOrder
							for xml path('Node'), type
							)
					for xml path('NodeList'), type
				)
			exec [RDF.].GetDataRDF @NodeListXML = @NodeListXML, @expand = 1, @showDetails = 0, @returnXML = 0, @dataStr = @ObjectNodesRDF OUTPUT
		*/
		create table #OutputNodes (
			NodeID bigint primary key,
			k int
		)
		insert into #OutputNodes (NodeID,k)
			SELECT DISTINCT  NodeID,0
			from #Node
			where SortOrder >= IsNull(@offset,0) and SortOrder < IsNull(IsNull(@offset,0)+@limit,SortOrder+1)
		declare @k int
		select @k = 0
		while @k < 10
		begin
			insert into #OutputNodes (NodeID,k)
				select distinct e.ExpandNodeID, @k+1
				from #OutputNodes o, [Search.Cache].[Public.NodeExpand] e
				where o.k = @k and o.NodeID = e.NodeID
					and e.ExpandNodeID not in (select NodeID from #OutputNodes)
			if @@ROWCOUNT = 0
				select @k = 10
			else
				select @k = @k + 1
		end
		select @ObjectNodesRDF = replace(replace(cast((
				select r.RDF + ''
				from #OutputNodes n, [Search.Cache].[Public.NodeRDF] r
				where n.NodeID = r.NodeID
				order by n.NodeID
				for xml path(''), type
			) as nvarchar(max)),'_TAGLT_','<'),'_TAGGT_','>')
	end


	-------------------------------------------------------
	-- Form search results RDF
	-------------------------------------------------------

	declare @results nvarchar(max)

	select @results = ''
			+'<rdf:Description rdf:nodeID="SearchResults">'
			+'<rdf:type rdf:resource="http://profiles.catalyst.harvard.edu/ontology/prns#Network" />'
			+'<rdfs:label>Search Results</rdfs:label>'
			+'<prns:numberOfConnections rdf:datatype="http://www.w3.org/2001/XMLSchema#int">'+cast(IsNull(@NumberOfConnections,0) as nvarchar(50))+'</prns:numberOfConnections>'
			+'<prns:offset rdf:datatype="http://www.w3.org/2001/XMLSchema#int"' + IsNull('>'+cast(@offset as nvarchar(50))+'</prns:offset>',' />')
			+'<prns:limit rdf:datatype="http://www.w3.org/2001/XMLSchema#int"' + IsNull('>'+cast(@limit as nvarchar(50))+'</prns:limit>',' />')
			+'<prns:maxWeight rdf:datatype="http://www.w3.org/2001/XMLSchema#float"' + IsNull('>'+cast(@MaxWeight as nvarchar(50))+'</prns:maxWeight>',' />')
			+'<prns:minWeight rdf:datatype="http://www.w3.org/2001/XMLSchema#float"' + IsNull('>'+cast(@MinWeight as nvarchar(50))+'</prns:minWeight>',' />')
			+'<vivo:overview rdf:parseType="Literal">'
			+IsNull(cast(@SearchOptions as nvarchar(max)),'')
			+'<SearchDetails>'+IsNull(cast(@SearchPhraseXML as nvarchar(max)),'')+'</SearchDetails>'
			+IsNull('<prns:matchesClassGroupsList>'+@MatchesClassGroups+'</prns:matchesClassGroupsList>','')
			+'</vivo:overview>'
			+IsNull((select replace(replace(cast((
					select '_TAGLT_prns:hasConnection rdf:nodeID="C'+cast(SortOrder as nvarchar(50))+'" /_TAGGT_'
					from #Node
					where SortOrder >= IsNull(@offset,0) and SortOrder < IsNull(IsNull(@offset,0)+@limit,SortOrder+1)
					order by SortOrder
					for xml path(''), type
				) as nvarchar(max)),'_TAGLT_','<'),'_TAGGT_','>')),'')
			+'</rdf:Description>'
			+IsNull((select replace(replace(cast((
					select ''
						+'_TAGLT_rdf:Description rdf:nodeID="C'+cast(x.SortOrder as nvarchar(50))+'"_TAGGT_'
						+'_TAGLT_prns:connectionWeight_TAGGT_'+cast(x.Weight as nvarchar(50))+'_TAGLT_/prns:connectionWeight_TAGGT_'
						+'_TAGLT_prns:sortOrder_TAGGT_'+cast(x.SortOrder as nvarchar(50))+'_TAGLT_/prns:sortOrder_TAGGT_'
						+'_TAGLT_rdf:object rdf:resource="'+replace(n.Value,'"','')+'"/_TAGGT_'
						+'_TAGLT_rdf:type rdf:resource="http://profiles.catalyst.harvard.edu/ontology/prns#Connection" /_TAGGT_'
						+'_TAGLT_rdfs:label_TAGGT_'+(case when s.ShortLabel<>'' then ltrim(rtrim(s.ShortLabel)) else 'Untitled' end)+'_TAGLT_/rdfs:label_TAGGT_'
						+IsNull(+'_TAGLT_vivo:overview_TAGGT_'+s.ClassName+'_TAGLT_/vivo:overview_TAGGT_','')
						+'_TAGLT_/rdf:Description_TAGGT_'
					from #Node x, [RDF.].Node n, [Search.Cache].[Public.NodeSummary] s
					where x.SortOrder >= IsNull(@offset,0) and x.SortOrder < IsNull(IsNull(@offset,0)+@limit,x.SortOrder+1)
						and x.NodeID = n.NodeID
						and x.NodeID = s.NodeID
					order by x.SortOrder
					for xml path(''), type
				) as nvarchar(max)),'_TAGLT_','<'),'_TAGGT_','>')),'')
			+IsNull(@ObjectNodesRDF,'')

	declare @x as varchar(max)
	select @x = '<rdf:RDF'
	select @x = @x + ' xmlns:'+Prefix+'="'+URI+'"' 
		from [Ontology.].Namespace
	select @x = @x + ' >' + @results + '</rdf:RDF>'
	select cast(@x as xml) RDF


	-------------------------------------------------------
	-- Log results
	-------------------------------------------------------

	update [Search.].[History.Query]
		set EndDate = GetDate(),
			DurationMS = datediff(ms,StartDate,GetDate()),
			NumberOfConnections = IsNull(@NumberOfConnections,0)
		where SearchHistoryQueryID = @SearchHistoryQueryID
	
	insert into [Search.].[History.Phrase] (SearchHistoryQueryID, PhraseID, ThesaurusMatch, Phrase, EndDate, IsBot, NumberOfConnections)
		select	@SearchHistoryQueryID,
				PhraseID,
				ThesaurusMatch,
				Phrase,
				GetDate(),
				@IsBot,
				IsNull(@NumberOfConnections,0)
			from @PhraseList

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Search.Cache].[Public.GetConnection]
	@SearchOptions XML,
	@NodeID BIGINT = NULL,
	@NodeURI VARCHAR(400) = NULL,
	@SessionID UNIQUEIDENTIFIER = NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- start timer
	declare @d datetime
	select @d = GetDate()

	-- get the NodeID
	IF (@NodeID IS NULL) AND (@NodeURI IS NOT NULL)
		SELECT @NodeID = [RDF.].fnURI2NodeID(@NodeURI)
	IF @NodeID IS NULL
		RETURN
	SELECT @NodeURI = Value
		FROM [RDF.].Node
		WHERE NodeID = @NodeID

	-- get the search string
	declare @SearchString varchar(500)
	declare @DoExpandedSearch bit
	select	@SearchString = @SearchOptions.value('SearchOptions[1]/MatchOptions[1]/SearchString[1]','varchar(500)'),
			@DoExpandedSearch = (case when @SearchOptions.value('SearchOptions[1]/MatchOptions[1]/SearchString[1]/@ExactMatch','varchar(50)') = 'true' then 0 else 1 end)

	if @SearchString is null
		RETURN

	-- set constants
	declare @baseURI nvarchar(400)
	declare @typeID bigint
	declare @labelID bigint
	select @baseURI = value from [Framework.].Parameter where ParameterID = 'baseURI'
	select @typeID = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
	select @labelID = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')

	-------------------------------------------------------
	-- Parse search string and convert to fulltext query
	-------------------------------------------------------
	
	declare @NumberOfPhrases INT
	declare @CombinedSearchString VARCHAR(8000)
	declare @SearchPhraseXML XML
	declare @SearchPhraseFormsXML XML
	declare @ParseProcessTime INT

		
	EXEC [Search.].[ParseSearchString]	@SearchString = @SearchString,
										@NumberOfPhrases = @NumberOfPhrases OUTPUT,
										@CombinedSearchString = @CombinedSearchString OUTPUT,
										@SearchPhraseXML = @SearchPhraseXML OUTPUT,
										@SearchPhraseFormsXML = @SearchPhraseFormsXML OUTPUT,
										@ProcessTime = @ParseProcessTime OUTPUT

	declare @PhraseList table (PhraseID int, Phrase varchar(max), ThesaurusMatch bit, Forms varchar(max))
	insert into @PhraseList (PhraseID, Phrase, ThesaurusMatch, Forms)
	select	x.value('@ID','INT'),
			x.value('.','VARCHAR(MAX)'),
			x.value('@ThesaurusMatch','BIT'),
			x.value('@Forms','VARCHAR(MAX)')
		from @SearchPhraseFormsXML.nodes('//SearchPhrase') as p(x)


	-------------------------------------------------------
	-- Find matching nodes connected to NodeID
	-------------------------------------------------------

	-- Get nodes that match separate phrases
	create table #PhraseNodeMap (
		PhraseID int not null,
		NodeID bigint not null,
		MatchedByNodeID bigint not null,
		Distance int,
		Paths int,
		MapWeight float,
		TextWeight float,
		Weight float
	)
	if (@DoExpandedSearch = 1)
	begin
		declare @PhraseSearchString varchar(8000)
		declare @loop int
		select @loop = 1
		while @loop <= @NumberOfPhrases
		begin
			select @PhraseSearchString = Forms
				from @PhraseList
				where PhraseID = @loop
			insert into #PhraseNodeMap (PhraseID, NodeID, MatchedByNodeID, Distance, Paths, MapWeight, TextWeight, Weight)
				select @loop, s.NodeID, s.MatchedByNodeID, s.Distance, s.Paths, s.Weight, m.Weight,
						(case when s.Weight*m.Weight > 0.999999 then 0.999999 else s.Weight*m.Weight end) Weight
					from [Search.Cache].[Public.NodeMap] s, (
						select [Key] NodeID, [Rank]*0.000999+0.001 Weight
							from Containstable ([RDF.].[vwLiteral], value, @PhraseSearchString) n
					) m
					where s.MatchedByNodeID = m.NodeID and s.NodeID = @NodeID
			select @loop = @loop + 1
		end
	end
	else
	begin
		insert into #PhraseNodeMap (PhraseID, NodeID, MatchedByNodeID, Distance, Paths, MapWeight, TextWeight, Weight)
			select 1, s.NodeID, s.MatchedByNodeID, s.Distance, s.Paths, s.Weight, m.Weight,
					(case when s.Weight*m.Weight > 0.999999 then 0.999999 else s.Weight*m.Weight end) Weight
				from [Search.Cache].[Public.NodeMap] s, (
					select [Key] NodeID, [Rank]*0.000999+0.001 Weight
						from Containstable ([RDF.].[vwLiteral], value, @CombinedSearchString) n
				) m
				where s.MatchedByNodeID = m.NodeID and s.NodeID = @NodeID
	end

	-------------------------------------------------------
	-- Get details on the matches
	-------------------------------------------------------
	
	SELECT *
		INTO #m
		FROM (
			SELECT 1 DirectMatch, NodeID, NodeID MiddleNodeID, MatchedByNodeID, 
					COUNT(DISTINCT PhraseID) Phrases, 1-exp(sum(log(1-Weight))) Weight
				FROM #PhraseNodeMap
				WHERE Distance = 1
				GROUP BY NodeID, MatchedByNodeID
			UNION ALL
			SELECT 0 DirectMatch, d.NodeID, y.NodeID MiddleNodeID, d.MatchedByNodeID,
					COUNT(DISTINCT d.PhraseID) Phrases, 1-exp(sum(log(1-d.Weight))) Weight
				FROM #PhraseNodeMap d
					INNER JOIN [Search.Cache].[Public.NodeMap] x
						ON x.NodeID = d.NodeID
							AND x.Distance = d.Distance - 1
					INNER JOIN [Search.Cache].[Public.NodeMap] y
						ON y.NodeID = x.MatchedByNodeID
							AND y.MatchedByNodeID = d.MatchedByNodeID
							AND y.Distance = 1
				WHERE d.Distance > 1
				GROUP BY d.NodeID, d.MatchedByNodeID, y.NodeID
		) t

	SELECT *
		INTO #w
		FROM (
			SELECT DISTINCT m.DirectMatch, m.NodeID, m.MiddleNodeID, m.MatchedByNodeID, m.Phrases, m.Weight,
				p._PropertyLabel PropertyLabel, p._PropertyNode PropertyNode
			FROM #m m
				INNER JOIN [Search.Cache].[Public.NodeClass] c
					ON c.NodeID = m.MiddleNodeID
				INNER JOIN [Ontology.].[ClassProperty] p
					ON p._ClassNode = c.Class
						AND p._NetworkPropertyNode IS NULL
						AND p.SearchWeight > 0
				INNER JOIN [RDF.].Triple t
					ON t.subject = m.MiddleNodeID
						AND t.predicate = p._PropertyNode
						AND t.object = m.MatchedByNodeID
		) t

	SELECT w.DirectMatch, w.Phrases, w.Weight,
			n.NodeID, n.Value URI, c.ShortLabel Label, c.ClassName, 
			w.PropertyLabel Predicate, 
			w.MatchedByNodeID, o.value Value
		INTO #MatchDetails
		FROM #w w
			INNER JOIN [RDF.].Node n
				ON n.NodeID = w.MiddleNodeID
			INNER JOIN [Search.Cache].[Public.NodeSummary] c
				ON c.NodeID = w.MiddleNodeID
			INNER JOIN [RDF.].Node o
				ON o.NodeID = w.MatchedByNodeID

	UPDATE #MatchDetails
		SET Weight = (CASE WHEN Weight > 0.999999 THEN 999999 WHEN Weight < 0.000001 THEN 0.000001 ELSE Weight END)

	-------------------------------------------------------
	-- Build ConnectionDetailsXML
	-------------------------------------------------------

	DECLARE @ConnectionDetailsXML XML
	
	;WITH a AS (
		SELECT DirectMatch, NodeID, URI, Label, ClassName, 
				COUNT(*) NumberOfProperties, 1-exp(sum(log(1-Weight))) Weight,
				(
					SELECT	p.Predicate "Name",
							p.Phrases "NumberOfPhrases",
							p.Weight "Weight",
							p.Value "Value",
							(
								SELECT r.Phrase "MatchedPhrase"
								FROM #PhraseNodeMap q, @PhraseList r
								WHERE q.MatchedByNodeID = p.MatchedByNodeID
									AND r.PhraseID = q.PhraseID
								ORDER BY r.PhraseID
								FOR XML PATH(''), TYPE
							) "MatchedPhraseList"
						FROM #MatchDetails p
						WHERE p.DirectMatch = m.DirectMatch
							AND p.NodeID = m.NodeID
						ORDER BY p.Predicate
						FOR XML PATH('Property'), TYPE
				) PropertyList
			FROM #MatchDetails m
			GROUP BY DirectMatch, NodeID, URI, Label, ClassName
	)
	SELECT @ConnectionDetailsXML = (
		SELECT	(
					SELECT	NodeID "NodeID",
							URI "URI",
							Label "Label",
							ClassName "ClassName",
							NumberOfProperties "NumberOfProperties",
							Weight "Weight",
							PropertyList "PropertyList"
					FROM a
					WHERE DirectMatch = 1
					FOR XML PATH('Match'), TYPE
				) "DirectMatchList",
				(
					SELECT	NodeID "NodeID",
							URI "URI",
							Label "Label",
							ClassName "ClassName",
							NumberOfProperties "NumberOfProperties",
							Weight "Weight",
							PropertyList "PropertyList"
					FROM a
					WHERE DirectMatch = 0
					FOR XML PATH('Match'), TYPE
				) "IndirectMatchList"				
		FOR XML PATH(''), TYPE
	)
	
	--SELECT @ConnectionDetailsXML ConnectionDetails
	--SELECT * FROM #PhraseNodeMap

	-------------------------------------------------------
	-- Get RDF of the NodeID
	-------------------------------------------------------

	DECLARE @ObjectNodeRDF NVARCHAR(MAX)
	
	EXEC [RDF.].GetDataRDF	@subject = @NodeID,
							@showDetails = 0,
							@expand = 0,
							@SessionID = @SessionID,
							@returnXML = 0,
							@dataStr = @ObjectNodeRDF OUTPUT


	-------------------------------------------------------
	-- Form search results details RDF
	-------------------------------------------------------

	DECLARE @results NVARCHAR(MAX)

	SELECT @results = ''
			+'<rdf:Description rdf:nodeID="SearchResultsDetails">'
			+'<rdf:type rdf:resource="http://profiles.catalyst.harvard.edu/ontology/prns#Connection" />'
			+'<prns:connectionInNetwork rdf:NodeID="SearchResults" />'
			--+'<prns:connectionWeight>0.37744</prns:connectionWeight>'
			+'<prns:hasConnectionDetails rdf:NodeID="ConnectionDetails" />'
			+'<rdf:object rdf:resource="'+@NodeURI+'" />'
			+'<rdfs:label>Search Results Details</rdfs:label>'
			+'</rdf:Description>'
			+'<rdf:Description rdf:nodeID="SearchResults">'
			+'<rdf:type rdf:resource="http://profiles.catalyst.harvard.edu/ontology/prns#Network" />'
			+'<rdfs:label>Search Results</rdfs:label>'
			+'<vivo:overview rdf:parseType="Literal">'
			+CAST(@SearchOptions AS NVARCHAR(MAX))
			+IsNull('<SearchDetails>'+CAST(@SearchPhraseXML AS NVARCHAR(MAX))+'</SearchDetails>','')
			+'</vivo:overview>'
			+'<prns:hasConnection rdf:nodeID="SearchResultsDetails" />'
			+'</rdf:Description>'
			+IsNull(@ObjectNodeRDF,'')
			+'<rdf:Description rdf:NodeID="ConnectionDetails">'
			+'<rdf:type rdf:resource="http://profiles.catalyst.harvard.edu/ontology/prns#ConnectionDetails" />'
			+'<vivo:overview rdf:parseType="Literal">'
			+CAST(@ConnectionDetailsXML AS NVARCHAR(MAX))
			+'</vivo:overview>'
			+'</rdf:Description> '

	declare @x as varchar(max)
	select @x = '<rdf:RDF'
	select @x = @x + ' xmlns:'+Prefix+'="'+URI+'"' 
		from [Ontology.].Namespace
	select @x = @x + ' >' + @results + '</rdf:RDF>'
	select cast(@x as xml) RDF

/*


	EXEC [Search.].[GetNodes] @SearchOptions = '
	<SearchOptions>
		<MatchOptions>
			<SearchString ExactMatch="false">options for "lung cancer" treatment</SearchString>
			<ClassURI>http://xmlns.com/foaf/0.1/Person</ClassURI>
		</MatchOptions>
		<OutputOptions>
			<Offset>0</Offset>
			<Limit>5</Limit>
		</OutputOptions>	
	</SearchOptions>
	'

	EXEC [Search.].[GetConnection] @SearchOptions = '
	<SearchOptions>
		<MatchOptions>
			<SearchString ExactMatch="false">options for "lung cancer" treatment</SearchString>
			<ClassURI>http://xmlns.com/foaf/0.1/Person</ClassURI>
		</MatchOptions>
		<OutputOptions>
			<Offset>0</Offset>
			<Limit>5</Limit>
		</OutputOptions>	
	</SearchOptions>
	', @NodeURI = 'http://localhost:55956/profile/1069731'


*/

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Search.Cache].[Private.GetNodes]
	@SearchOptions XML,
	@SessionID UNIQUEIDENTIFIER=NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
		-- interfering with SELECT statements.
		SET NOCOUNT ON;

	/*
	
	EXEC [Search.Cache].[Private.GetNodes] @SearchOptions = '
	<SearchOptions>
		<MatchOptions>
			<SearchString ExactMatch="false">options for "lung cancer" treatment</SearchString>
			<ClassURI>http://xmlns.com/foaf/0.1/Person</ClassURI>
			<SearchFiltersList>
				<SearchFilter Property="http://xmlns.com/foaf/0.1/lastName" MatchType="Left">Smit</SearchFilter>
			</SearchFiltersList>
		</MatchOptions>
		<OutputOptions>
			<Offset>0</Offset>
			<Limit>5</Limit>
			<SortByList>
				<SortBy IsDesc="1" Property="http://xmlns.com/foaf/0.1/firstName" />
				<SortBy IsDesc="0" Property="http://xmlns.com/foaf/0.1/lastName" />
			</SortByList>
		</OutputOptions>	
	</SearchOptions>
	'
		
	*/

	declare @MatchOptions xml
	declare @OutputOptions xml
	declare @SearchString varchar(500)
	declare @ClassGroupURI varchar(400)
	declare @ClassURI varchar(400)
	declare @SearchFiltersXML xml
	declare @offset bigint
	declare @limit bigint
	declare @SortByXML xml
	declare @DoExpandedSearch bit
	
	select	@MatchOptions = @SearchOptions.query('SearchOptions[1]/MatchOptions[1]'),
			@OutputOptions = @SearchOptions.query('SearchOptions[1]/OutputOptions[1]')
	
	select	@SearchString = @MatchOptions.value('MatchOptions[1]/SearchString[1]','varchar(500)'),
			@DoExpandedSearch = (case when @MatchOptions.value('MatchOptions[1]/SearchString[1]/@ExactMatch','varchar(50)') = 'true' then 0 else 1 end),
			@ClassGroupURI = @MatchOptions.value('MatchOptions[1]/ClassGroupURI[1]','varchar(400)'),
			@ClassURI = @MatchOptions.value('MatchOptions[1]/ClassURI[1]','varchar(400)'),
			@SearchFiltersXML = @MatchOptions.query('MatchOptions[1]/SearchFiltersList[1]'),
			@offset = @OutputOptions.value('OutputOptions[1]/Offset[1]','bigint'),
			@limit = @OutputOptions.value('OutputOptions[1]/Limit[1]','bigint'),
			@SortByXML = @OutputOptions.query('OutputOptions[1]/SortByList[1]')

	declare @baseURI nvarchar(400)
	select @baseURI = value from [Framework.].Parameter where ParameterID = 'baseURI'

	declare @d datetime
	select @d = GetDate()
	

	-------------------------------------------------------
	-- Parse search string and convert to fulltext query
	-------------------------------------------------------

	declare @NumberOfPhrases INT
	declare @CombinedSearchString VARCHAR(8000)
	declare @SearchString1 VARCHAR(8000)
	declare @SearchString2 VARCHAR(8000)
	declare @SearchString3 VARCHAR(8000)
	declare @SearchPhraseXML XML
	declare @SearchPhraseFormsXML XML
	declare @ParseProcessTime INT

	EXEC [Search.].[ParseSearchString]	@SearchString = @SearchString,
										@NumberOfPhrases = @NumberOfPhrases OUTPUT,
										@CombinedSearchString = @CombinedSearchString OUTPUT,
										@SearchString1 = @SearchString1 OUTPUT,
										@SearchString2 = @SearchString2 OUTPUT,
										@SearchString3 = @SearchString3 OUTPUT,
										@SearchPhraseXML = @SearchPhraseXML OUTPUT,
										@SearchPhraseFormsXML = @SearchPhraseFormsXML OUTPUT,
										@ProcessTime = @ParseProcessTime OUTPUT

	declare @PhraseList table (PhraseID int, Phrase varchar(max), ThesaurusMatch bit, Forms varchar(max))
	insert into @PhraseList (PhraseID, Phrase, ThesaurusMatch, Forms)
	select	x.value('@ID','INT'),
			x.value('.','VARCHAR(MAX)'),
			x.value('@ThesaurusMatch','BIT'),
			x.value('@Forms','VARCHAR(MAX)')
		from @SearchPhraseFormsXML.nodes('//SearchPhrase') as p(x)

	--SELECT @NumberOfPhrases, @CombinedSearchString, @SearchPhraseXML, @SearchPhraseFormsXML, @ParseProcessTime, @SearchString1, @SearchString2, @SearchString3
	--SELECT * FROM @PhraseList
	--select datediff(ms,@d,GetDate())


	-------------------------------------------------------
	-- Parse search filters
	-------------------------------------------------------

	create table #SearchFilters (
		SearchFilterID int identity(0,1) primary key,
		IsExclude bit,
		PropertyURI varchar(400),
		PropertyURI2 varchar(400),
		MatchType varchar(100),
		Value nvarchar(max),
		Predicate bigint,
		Predicate2 bigint
	)
	
	insert into #SearchFilters (IsExclude, PropertyURI, PropertyURI2, MatchType, Value, Predicate, Predicate2)	
		select t.IsExclude, t.PropertyURI, t.PropertyURI2, t.MatchType, t.Value,
				--left(t.Value,750)+(case when t.MatchType='Left' then '%' else '' end),
				t.Predicate, t.Predicate2
			from (
				select IsNull(IsExclude,0) IsExclude, PropertyURI, PropertyURI2, MatchType, Value,
					[RDF.].fnURI2NodeID(PropertyURI) Predicate,
					[RDF.].fnURI2NodeID(PropertyURI2) Predicate2
				from (
					select distinct S.x.value('@IsExclude','bit') IsExclude,
							S.x.value('@Property','varchar(400)') PropertyURI,
							S.x.value('@Property2','varchar(400)') PropertyURI2,
							S.x.value('@MatchType','varchar(100)') MatchType,
							--S.x.value('.','nvarchar(max)') Value
							--cast(S.x.query('./*') as nvarchar(max)) Value
							(case when cast(S.x.query('./*') as nvarchar(max)) <> '' then cast(S.x.query('./*') as nvarchar(max)) else S.x.value('.','nvarchar(max)') end) Value
					from @SearchFiltersXML.nodes('//SearchFilter') as S(x)
				) t
			) t
			where t.Value IS NOT NULL and t.Value <> ''
			
	declare @NumberOfIncludeFilters int
	select @NumberOfIncludeFilters = IsNull((select count(*) from #SearchFilters where IsExclude=0),0)

	-------------------------------------------------------
	-- Parse sort by options
	-------------------------------------------------------

	create table #SortBy (
		SortByID int identity(1,1) primary key,
		IsDesc bit,
		PropertyURI varchar(400),
		PropertyURI2 varchar(400),
		PropertyURI3 varchar(400),
		Predicate bigint,
		Predicate2 bigint,
		Predicate3 bigint
	)
	
	insert into #SortBy (IsDesc, PropertyURI, PropertyURI2, PropertyURI3, Predicate, Predicate2, Predicate3)	
		select IsNull(IsDesc,0), PropertyURI, PropertyURI2, PropertyURI3,
				[RDF.].fnURI2NodeID(PropertyURI) Predicate,
				[RDF.].fnURI2NodeID(PropertyURI2) Predicate2,
				[RDF.].fnURI2NodeID(PropertyURI3) Predicate3
			from (
				select S.x.value('@IsDesc','bit') IsDesc,
						S.x.value('@Property','varchar(400)') PropertyURI,
						S.x.value('@Property2','varchar(400)') PropertyURI2,
						S.x.value('@Property3','varchar(400)') PropertyURI3
				from @SortByXML.nodes('//SortBy') as S(x)
			) t

	-------------------------------------------------------
	-- Get initial list of matching nodes (before filters)
	-------------------------------------------------------

	create table #FullNodeMatch (
		NodeID bigint not null,
		Paths bigint,
		Weight float
	)

	if @CombinedSearchString <> ''
	begin

		-- Get nodes that match separate phrases
		create table #PhraseNodeMatch (
			PhraseID int not null,
			NodeID bigint not null,
			Paths bigint,
			Weight float
		)
		if (@NumberOfPhrases > 1) and (@DoExpandedSearch = 1)
		begin
			declare @PhraseSearchString varchar(8000)
			declare @loop int
			select @loop = 1
			while @loop <= @NumberOfPhrases
			begin
				select @PhraseSearchString = Forms
					from @PhraseList
					where PhraseID = @loop
				select * into #NodeRankTemp from containstable ([RDF.].[vwLiteral], value, @PhraseSearchString, 100000)
				alter table #NodeRankTemp add primary key ([Key])
				insert into #PhraseNodeMatch (PhraseID, NodeID, Paths, Weight)
					select @loop, s.NodeID, count(*) Paths, 1-exp(sum(log(case when s.Weight*(m.[Rank]*0.000999+0.001) > 0.999999 then 0.000001 else 1-s.Weight*(m.[Rank]*0.000999+0.001) end))) Weight
						from #NodeRankTemp m
							inner loop join [Search.Cache].[Private.NodeMap] s
								on s.MatchedByNodeID = m.[Key]
						group by s.NodeID
				drop table #NodeRankTemp
				select @loop = @loop + 1
			end
			--create clustered index idx_n on #PhraseNodeMatch(NodeID)
		end

		-- Get nodes that match the combined search string
		create table #TempMatchNodes (
			NodeID bigint,
			MatchedByNodeID bigint,
			Distance int,
			Paths int,
			Weight float,
			mWeight float
		)
		-- Run each search string
		if @SearchString1 <> ''
				select * into #CombinedSearch1 from containstable ([RDF.].[vwLiteral], value, @SearchString1, 100000) t
		if @SearchString2 <> ''
				select * into #CombinedSearch2 from containstable ([RDF.].[vwLiteral], value, @SearchString2, 100000) t
		if @SearchString3 <> ''
				select * into #CombinedSearch3 from containstable ([RDF.].[vwLiteral], value, @SearchString3, 100000) t
		-- Combine each search string
		create table #CombinedSearch ([key] bigint primary key, [rank] int)
		if IsNull(@SearchString1,'') <> '' and IsNull(@SearchString2,'') = '' and IsNull(@SearchString3,'') = ''
			insert into #CombinedSearch select [key], max([rank]) [rank] from #CombinedSearch1 t group by [key]
		if IsNull(@SearchString1,'') <> '' and IsNull(@SearchString2,'') <> '' and IsNull(@SearchString3,'') = ''
			insert into #CombinedSearch select [key], max([rank]) [rank] from (select * from #CombinedSearch1 union all select * from #CombinedSearch2) t group by [key]
		if IsNull(@SearchString1,'') <> '' and IsNull(@SearchString2,'') <> '' and IsNull(@SearchString3,'') <> ''
			insert into #CombinedSearch select [key], max([rank]) [rank] from (select * from #CombinedSearch1 union all select * from #CombinedSearch2 union all select * from #CombinedSearch3) t group by [key]
		-- Get the TempMatchNodes
		insert into #TempMatchNodes (NodeID, MatchedByNodeID, Distance, Paths, Weight, mWeight)
			select s.*, m.[Rank]*0.000999+0.001 mWeight
				from #CombinedSearch m
					inner loop join [Search.Cache].[Private.NodeMap] s
						on s.MatchedByNodeID = m.[key]
		-- Delete temp tables
		if @SearchString1 <> ''
				drop table #CombinedSearch1
		if @SearchString2 <> ''
				drop table #CombinedSearch2
		if @SearchString3 <> ''
				drop table #CombinedSearch3
		drop table #CombinedSearch

		-- Get nodes that match either all phrases or the combined search string
		insert into #FullNodeMatch (NodeID, Paths, Weight)
			select IsNull(a.NodeID,b.NodeID) NodeID, IsNull(a.Paths,b.Paths) Paths,
					(case when a.weight is null or b.weight is null then IsNull(a.Weight,b.Weight) else 1-(1-a.Weight)*(1-b.Weight) end) Weight
				from (
					select NodeID, exp(sum(log(Paths))) Paths, exp(sum(log(Weight))) Weight
						from #PhraseNodeMatch
						group by NodeID
						having count(*) = @NumberOfPhrases
				) a full outer join (
					select NodeID, count(*) Paths, 1-exp(sum(log(case when Weight*mWeight > 0.999999 then 0.000001 else 1-Weight*mWeight end))) Weight
						from #TempMatchNodes
						group by NodeID
				) b on a.NodeID = b.NodeID
		--select 'Text Matches Found', datediff(ms,@d,getdate())
	end
	else if (@NumberOfIncludeFilters > 0)
	begin
		insert into #FullNodeMatch (NodeID, Paths, Weight)
			select t1.Subject, 1, 1
				from #SearchFilters f
					inner join [RDF.].Triple t1
						on f.Predicate is not null
							and t1.Predicate = f.Predicate 
							and t1.ViewSecurityGroup between -30 and -1
					left outer join [Search.Cache].[Private.NodePrefix] n1
						on n1.NodeID = t1.Object
					left outer join [RDF.].Triple t2
						on f.Predicate2 is not null
							and t2.Subject = n1.NodeID
							and t2.Predicate = f.Predicate2
							and t2.ViewSecurityGroup between -30 and -1
					left outer join [Search.Cache].[Private.NodePrefix] n2
						on n2.NodeID = t2.Object
				where f.IsExclude = 0
					and 1 = (case	when (f.Predicate2 is not null) then
										(case	when f.MatchType = 'Left' then
													(case when n2.Prefix like f.Value+'%' then 1 else 0 end)
												when f.MatchType = 'In' then
													(case when n2.Prefix in (select r.x.value('.','varchar(max)') v from (select cast(f.Value as xml) x) t cross apply x.nodes('//Item') as r(x)) then 1 else 0 end)
												else
													(case when n2.Prefix = f.Value then 1 else 0 end)
												end)
									else
										(case	when f.MatchType = 'Left' then
													(case when n1.Prefix like f.Value+'%' then 1 else 0 end)
												when f.MatchType = 'In' then
													(case when n1.Prefix in (select r.x.value('.','varchar(max)') v from (select cast(f.Value as xml) x) t cross apply x.nodes('//Item') as r(x)) then 1 else 0 end)
												else
													(case when n1.Prefix = f.Value then 1 else 0 end)
												end)
									end)
					--and (case when f.Predicate2 is not null then n2.Prefix else n1.Prefix end)
					--	like f.Value
				group by t1.Subject
				having count(distinct f.SearchFilterID) = @NumberOfIncludeFilters
		delete from #SearchFilters where IsExclude = 0
		select @NumberOfIncludeFilters = 0
	end
	else if (IsNull(@ClassGroupURI,'') <> '' or IsNull(@ClassURI,'') <> '')
	begin
		insert into #FullNodeMatch (NodeID, Paths, Weight)
			select distinct n.NodeID, 1, 1
				from [Search.Cache].[Private.NodeClass] n, [Ontology.].ClassGroupClass c
				where n.Class = c._ClassNode
					and ((@ClassGroupURI is null) or (c.ClassGroupURI = @ClassGroupURI))
					and ((@ClassURI is null) or (c.ClassURI = @ClassURI))
		select @ClassGroupURI = null, @ClassURI = null
	end

	-------------------------------------------------------
	-- Run the actual search
	-------------------------------------------------------
	create table #Node (
		SortOrder bigint identity(0,1) primary key,
		NodeID bigint,
		Paths bigint,
		Weight float
	)

	insert into #Node (NodeID, Paths, Weight)
		select s.NodeID, s.Paths, s.Weight
			from #FullNodeMatch s
				inner join [Search.Cache].[Private.NodeSummary] n on
					s.NodeID = n.NodeID
					and ( IsNull(@ClassGroupURI,@ClassURI) is null or s.NodeID in (
							select NodeID
								from [Search.Cache].[Private.NodeClass] x, [Ontology.].ClassGroupClass c
								where x.Class = c._ClassNode
									and c.ClassGroupURI = IsNull(@ClassGroupURI,c.ClassGroupURI)
									and c.ClassURI = IsNull(@ClassURI,c.ClassURI)
						) )
					and ( @NumberOfIncludeFilters =
							(select count(distinct f.SearchFilterID)
								from #SearchFilters f
									inner join [RDF.].Triple t1
										on f.Predicate is not null
											and t1.Subject = s.NodeID
											and t1.Predicate = f.Predicate 
											and t1.ViewSecurityGroup between -30 and -1
									left outer join [Search.Cache].[Private.NodePrefix] n1
										on n1.NodeID = t1.Object
									left outer join [RDF.].Triple t2
										on f.Predicate2 is not null
											and t2.Subject = n1.NodeID
											and t2.Predicate = f.Predicate2
											and t2.ViewSecurityGroup between -30 and -1
									left outer join [Search.Cache].[Private.NodePrefix] n2
										on n2.NodeID = t2.Object
								where f.IsExclude = 0
									and 1 = (case	when (f.Predicate2 is not null) then
														(case	when f.MatchType = 'Left' then
																	(case when n2.Prefix like f.Value+'%' then 1 else 0 end)
																when f.MatchType = 'In' then
																	(case when n2.Prefix in (select r.x.value('.','varchar(max)') v from (select cast(f.Value as xml) x) t cross apply x.nodes('//Item') as r(x)) then 1 else 0 end)
																else
																	(case when n2.Prefix = f.Value then 1 else 0 end)
																end)
													else
														(case	when f.MatchType = 'Left' then
																	(case when n1.Prefix like f.Value+'%' then 1 else 0 end)
																when f.MatchType = 'In' then
																	(case when n1.Prefix in (select r.x.value('.','varchar(max)') v from (select cast(f.Value as xml) x) t cross apply x.nodes('//Item') as r(x)) then 1 else 0 end)
																else
																	(case when n1.Prefix = f.Value then 1 else 0 end)
																end)
													end)
									--and (case when f.Predicate2 is not null then n2.Prefix else n1.Prefix end)
									--	like f.Value
							)
						)
					and not exists (
							select *
								from #SearchFilters f
									inner join [RDF.].Triple t1
										on f.Predicate is not null
											and t1.Subject = s.NodeID
											and t1.Predicate = f.Predicate 
											and t1.ViewSecurityGroup between -30 and -1
									left outer join [Search.Cache].[Private.NodePrefix] n1
										on n1.NodeID = t1.Object
									left outer join [RDF.].Triple t2
										on f.Predicate2 is not null
											and t2.Subject = n1.NodeID
											and t2.Predicate = f.Predicate2
											and t2.ViewSecurityGroup between -30 and -1
									left outer join [Search.Cache].[Private.NodePrefix] n2
										on n2.NodeID = t2.Object
								where f.IsExclude = 1
									and 1 = (case	when (f.Predicate2 is not null) then
														(case	when f.MatchType = 'Left' then
																	(case when n2.Prefix like f.Value+'%' then 1 else 0 end)
																when f.MatchType = 'In' then
																	(case when n2.Prefix in (select r.x.value('.','varchar(max)') v from (select cast(f.Value as xml) x) t cross apply x.nodes('//Item') as r(x)) then 1 else 0 end)
																else
																	(case when n2.Prefix = f.Value then 1 else 0 end)
																end)
													else
														(case	when f.MatchType = 'Left' then
																	(case when n1.Prefix like f.Value+'%' then 1 else 0 end)
																when f.MatchType = 'In' then
																	(case when n1.Prefix in (select r.x.value('.','varchar(max)') v from (select cast(f.Value as xml) x) t cross apply x.nodes('//Item') as r(x)) then 1 else 0 end)
																else
																	(case when n1.Prefix = f.Value then 1 else 0 end)
																end)
													end)
									--and (case when f.Predicate2 is not null then n2.Prefix else n1.Prefix end)
									--	like f.Value
						)
				outer apply (
					select	max(case when SortByID=1 then AscSortBy else null end) AscSortBy1,
							max(case when SortByID=2 then AscSortBy else null end) AscSortBy2,
							max(case when SortByID=3 then AscSortBy else null end) AscSortBy3,
							max(case when SortByID=1 then DescSortBy else null end) DescSortBy1,
							max(case when SortByID=2 then DescSortBy else null end) DescSortBy2,
							max(case when SortByID=3 then DescSortBy else null end) DescSortBy3
						from (
							select	SortByID,
									(case when f.IsDesc = 1 then null
											when f.Predicate3 is not null then n3.Value
											when f.Predicate2 is not null then n2.Value
											else n1.Value end) AscSortBy,
									(case when f.IsDesc = 0 then null
											when f.Predicate3 is not null then n3.Value
											when f.Predicate2 is not null then n2.Value
											else n1.Value end) DescSortBy
								from #SortBy f
									inner join [RDF.].Triple t1
										on f.Predicate is not null
											and t1.Subject = s.NodeID
											and t1.Predicate = f.Predicate 
											and t1.ViewSecurityGroup between -30 and -1
									left outer join [RDF.].Node n1
										on n1.NodeID = t1.Object
											and n1.ViewSecurityGroup between -30 and -1
									left outer join [RDF.].Triple t2
										on f.Predicate2 is not null
											and t2.Subject = n1.NodeID
											and t2.Predicate = f.Predicate2
											and t2.ViewSecurityGroup between -30 and -1
									left outer join [RDF.].Node n2
										on n2.NodeID = t2.Object
											and n2.ViewSecurityGroup between -30 and -1
									left outer join [RDF.].Triple t3
										on f.Predicate3 is not null
											and t3.Subject = n2.NodeID
											and t3.Predicate = f.Predicate3
											and t3.ViewSecurityGroup between -30 and -1
									left outer join [RDF.].Node n3
										on n3.NodeID = t3.Object
											and n3.ViewSecurityGroup between -30 and -1
							) t
					) o
			order by	(case when o.AscSortBy1 is null then 1 else 0 end),
						o.AscSortBy1,
						(case when o.DescSortBy1 is null then 1 else 0 end),
						o.DescSortBy1 desc,
						(case when o.AscSortBy2 is null then 1 else 0 end),
						o.AscSortBy2,
						(case when o.DescSortBy2 is null then 1 else 0 end),
						o.DescSortBy2 desc,
						(case when o.AscSortBy3 is null then 1 else 0 end),
						o.AscSortBy3,
						(case when o.DescSortBy3 is null then 1 else 0 end),
						o.DescSortBy3 desc,
						s.Weight desc,
						n.ShortLabel,
						n.NodeID


	--select 'Search Nodes Found', datediff(ms,@d,GetDate())

	-------------------------------------------------------
	-- Get network counts
	-------------------------------------------------------

	declare @NumberOfConnections as bigint
	declare @MaxWeight as float
	declare @MinWeight as float

	select @NumberOfConnections = count(*), @MaxWeight = max(Weight), @MinWeight = min(Weight) 
		from #Node

	-------------------------------------------------------
	-- Get matching class groups and classes
	-------------------------------------------------------

	declare @MatchesClassGroups nvarchar(max)

	select n.NodeID, s.Class
		into #NodeClassTemp
		from #Node n
			inner join [Search.Cache].[Private.NodeClass] s
				on n.NodeID = s.NodeID
	select c.ClassGroupURI, c.ClassURI, n.NodeID
		into #NodeClass
		from #NodeClassTemp n
			inner join [Ontology.].ClassGroupClass c
				on n.Class = c._ClassNode

	;with a as (
		select ClassGroupURI, count(distinct NodeID) NumberOfNodes
			from #NodeClass s
			group by ClassGroupURI
	), b as (
		select ClassGroupURI, ClassURI, count(distinct NodeID) NumberOfNodes
			from #NodeClass s
			group by ClassGroupURI, ClassURI
	)
	select @MatchesClassGroups = replace(cast((
			select	g.ClassGroupURI "@rdf_.._resource", 
				g._ClassGroupLabel "rdfs_.._label",
				'http://www.w3.org/2001/XMLSchema#int' "prns_.._numberOfConnections/@rdf_.._datatype",
				a.NumberOfNodes "prns_.._numberOfConnections",
				g.SortOrder "prns_.._sortOrder",
				(
					select	c.ClassURI "@rdf_.._resource",
							c._ClassLabel "rdfs_.._label",
							'http://www.w3.org/2001/XMLSchema#int' "prns_.._numberOfConnections/@rdf_.._datatype",
							b.NumberOfNodes "prns_.._numberOfConnections",
							c.SortOrder "prns_.._sortOrder"
						from b, [Ontology.].ClassGroupClass c
						where b.ClassGroupURI = c.ClassGroupURI and b.ClassURI = c.ClassURI
							and c.ClassGroupURI = g.ClassGroupURI
						order by c.SortOrder
						for xml path('prns_.._matchesClass'), type
				)
			from a, [Ontology.].ClassGroup g
			where a.ClassGroupURI = g.ClassGroupURI and g.IsVisible = 1
			order by g.SortOrder
			for xml path('prns_.._matchesClassGroup'), type
		) as nvarchar(max)),'_.._',':')

	-------------------------------------------------------
	-- Get RDF of search results objects
	-------------------------------------------------------

	declare @ObjectNodesRDF nvarchar(max)

	if @NumberOfConnections > 0
	begin
		/*
			-- Alternative methods that uses GetDataRDF to get the RDF
			declare @NodeListXML xml
			select @NodeListXML = (
					select (
							select NodeID "@ID"
							from #Node
							where SortOrder >= IsNull(@offset,0) and SortOrder < IsNull(IsNull(@offset,0)+@limit,SortOrder+1)
							order by SortOrder
							for xml path('Node'), type
							)
					for xml path('NodeList'), type
				)
			exec [RDF.].GetDataRDF @NodeListXML = @NodeListXML, @expand = 1, @showDetails = 0, @returnXML = 0, @dataStr = @ObjectNodesRDF OUTPUT
		*/
		create table #OutputNodes (
			NodeID bigint primary key,
			k int
		)
		insert into #OutputNodes (NodeID,k)
			select DISTINCT NodeID,0
			from #Node
			where SortOrder >= IsNull(@offset,0) and SortOrder < IsNull(IsNull(@offset,0)+@limit,SortOrder+1)
		declare @k int
		select @k = 0
		while @k < 10
		begin
			insert into #OutputNodes (NodeID,k)
				select distinct e.ExpandNodeID, @k+1
				from #OutputNodes o, [Search.Cache].[Private.NodeExpand] e
				where o.k = @k and o.NodeID = e.NodeID
					and e.ExpandNodeID not in (select NodeID from #OutputNodes)
			if @@ROWCOUNT = 0
				select @k = 10
			else
				select @k = @k + 1
		end
		select @ObjectNodesRDF = replace(replace(cast((
				select r.RDF + ''
				from #OutputNodes n, [Search.Cache].[Private.NodeRDF] r
				where n.NodeID = r.NodeID
				order by n.NodeID
				for xml path(''), type
			) as nvarchar(max)),'_TAGLT_','<'),'_TAGGT_','>')
	end


	-------------------------------------------------------
	-- Form search results RDF
	-------------------------------------------------------

	declare @results nvarchar(max)

	select @results = ''
			+'<rdf:Description rdf:nodeID="SearchResults">'
			+'<rdf:type rdf:resource="http://profiles.catalyst.harvard.edu/ontology/prns#Network" />'
			+'<rdfs:label>Search Results</rdfs:label>'
			+'<prns:numberOfConnections rdf:datatype="http://www.w3.org/2001/XMLSchema#int">'+cast(IsNull(@NumberOfConnections,0) as nvarchar(50))+'</prns:numberOfConnections>'
			+'<prns:offset rdf:datatype="http://www.w3.org/2001/XMLSchema#int"' + IsNull('>'+cast(@offset as nvarchar(50))+'</prns:offset>',' />')
			+'<prns:limit rdf:datatype="http://www.w3.org/2001/XMLSchema#int"' + IsNull('>'+cast(@limit as nvarchar(50))+'</prns:limit>',' />')
			+'<prns:maxWeight rdf:datatype="http://www.w3.org/2001/XMLSchema#float"' + IsNull('>'+cast(@MaxWeight as nvarchar(50))+'</prns:maxWeight>',' />')
			+'<prns:minWeight rdf:datatype="http://www.w3.org/2001/XMLSchema#float"' + IsNull('>'+cast(@MinWeight as nvarchar(50))+'</prns:minWeight>',' />')
			+'<vivo:overview rdf:parseType="Literal">'
			+IsNull(cast(@SearchOptions as nvarchar(max)),'')
			+'<SearchDetails>'+IsNull(cast(@SearchPhraseXML as nvarchar(max)),'')+'</SearchDetails>'
			+IsNull('<prns:matchesClassGroupsList>'+@MatchesClassGroups+'</prns:matchesClassGroupsList>','')
			+'</vivo:overview>'
			+IsNull((select replace(replace(cast((
					select '_TAGLT_prns:hasConnection rdf:nodeID="C'+cast(SortOrder as nvarchar(50))+'" /_TAGGT_'
					from #Node
					where SortOrder >= IsNull(@offset,0) and SortOrder < IsNull(IsNull(@offset,0)+@limit,SortOrder+1)
					order by SortOrder
					for xml path(''), type
				) as nvarchar(max)),'_TAGLT_','<'),'_TAGGT_','>')),'')
			+'</rdf:Description>'
			+IsNull((select replace(replace(cast((
					select ''
						+'_TAGLT_rdf:Description rdf:nodeID="C'+cast(x.SortOrder as nvarchar(50))+'"_TAGGT_'
						+'_TAGLT_prns:connectionWeight_TAGGT_'+cast(x.Weight as nvarchar(50))+'_TAGLT_/prns:connectionWeight_TAGGT_'
						+'_TAGLT_prns:sortOrder_TAGGT_'+cast(x.SortOrder as nvarchar(50))+'_TAGLT_/prns:sortOrder_TAGGT_'
						+'_TAGLT_rdf:object rdf:resource="'+replace(n.Value,'"','')+'"/_TAGGT_'
						+'_TAGLT_rdf:type rdf:resource="http://profiles.catalyst.harvard.edu/ontology/prns#Connection" /_TAGGT_'
						+'_TAGLT_rdfs:label_TAGGT_'+(case when s.ShortLabel<>'' then ltrim(rtrim(s.ShortLabel)) else 'Untitled' end)+'_TAGLT_/rdfs:label_TAGGT_'
						+IsNull(+'_TAGLT_vivo:overview_TAGGT_'+s.ClassName+'_TAGLT_/vivo:overview_TAGGT_','')
						+'_TAGLT_/rdf:Description_TAGGT_'
					from #Node x, [RDF.].Node n, [Search.Cache].[Private.NodeSummary] s
					where x.SortOrder >= IsNull(@offset,0) and x.SortOrder < IsNull(IsNull(@offset,0)+@limit,x.SortOrder+1)
						and x.NodeID = n.NodeID
						and x.NodeID = s.NodeID
					order by x.SortOrder
					for xml path(''), type
				) as nvarchar(max)),'_TAGLT_','<'),'_TAGGT_','>')),'')
			+IsNull(@ObjectNodesRDF,'')

	declare @x as varchar(max)
	select @x = '<rdf:RDF'
	select @x = @x + ' xmlns:'+Prefix+'="'+URI+'"' 
		from [Ontology.].Namespace
	select @x = @x + ' >' + @results + '</rdf:RDF>'
	select cast(@x as xml) RDF


END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Search.Cache].[Private.GetConnection]
	@SearchOptions XML,
	@NodeID BIGINT = NULL,
	@NodeURI VARCHAR(400) = NULL,
	@SessionID UNIQUEIDENTIFIER = NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- start timer
	declare @d datetime
	select @d = GetDate()

	-- get the NodeID
	IF (@NodeID IS NULL) AND (@NodeURI IS NOT NULL)
		SELECT @NodeID = [RDF.].fnURI2NodeID(@NodeURI)
	IF @NodeID IS NULL
		RETURN
	SELECT @NodeURI = Value
		FROM [RDF.].Node
		WHERE NodeID = @NodeID

	-- get the search string
	declare @SearchString varchar(500)
	declare @DoExpandedSearch bit
	select	@SearchString = @SearchOptions.value('SearchOptions[1]/MatchOptions[1]/SearchString[1]','varchar(500)'),
			@DoExpandedSearch = (case when @SearchOptions.value('SearchOptions[1]/MatchOptions[1]/SearchString[1]/@ExactMatch','varchar(50)') = 'true' then 0 else 1 end)

	if @SearchString is null
		RETURN

	-- set constants
	declare @baseURI nvarchar(400)
	declare @typeID bigint
	declare @labelID bigint
	select @baseURI = value from [Framework.].Parameter where ParameterID = 'baseURI'
	select @typeID = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
	select @labelID = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')

	-------------------------------------------------------
	-- Parse search string and convert to fulltext query
	-------------------------------------------------------
	
	declare @NumberOfPhrases INT
	declare @CombinedSearchString VARCHAR(8000)
	declare @SearchPhraseXML XML
	declare @SearchPhraseFormsXML XML
	declare @ParseProcessTime INT

		
	EXEC [Search.].[ParseSearchString]	@SearchString = @SearchString,
										@NumberOfPhrases = @NumberOfPhrases OUTPUT,
										@CombinedSearchString = @CombinedSearchString OUTPUT,
										@SearchPhraseXML = @SearchPhraseXML OUTPUT,
										@SearchPhraseFormsXML = @SearchPhraseFormsXML OUTPUT,
										@ProcessTime = @ParseProcessTime OUTPUT

	declare @PhraseList table (PhraseID int, Phrase varchar(max), ThesaurusMatch bit, Forms varchar(max))
	insert into @PhraseList (PhraseID, Phrase, ThesaurusMatch, Forms)
	select	x.value('@ID','INT'),
			x.value('.','VARCHAR(MAX)'),
			x.value('@ThesaurusMatch','BIT'),
			x.value('@Forms','VARCHAR(MAX)')
		from @SearchPhraseFormsXML.nodes('//SearchPhrase') as p(x)


	-------------------------------------------------------
	-- Find matching nodes connected to NodeID
	-------------------------------------------------------


	-- Get nodes that match separate phrases
	create table #PhraseNodeMap (
		PhraseID int not null,
		NodeID bigint not null,
		MatchedByNodeID bigint not null,
		Distance int,
		Paths int,
		MapWeight float,
		TextWeight float,
		Weight float
	)
	if (@DoExpandedSearch = 1)
	begin
		declare @PhraseSearchString varchar(8000)
		declare @loop int
		select @loop = 1
		while @loop <= @NumberOfPhrases
		begin
			select @PhraseSearchString = Forms
				from @PhraseList
				where PhraseID = @loop
			insert into #PhraseNodeMap (PhraseID, NodeID, MatchedByNodeID, Distance, Paths, MapWeight, TextWeight, Weight)
				select @loop, s.NodeID, s.MatchedByNodeID, s.Distance, s.Paths, s.Weight, m.Weight,
						(case when s.Weight*m.Weight > 0.999999 then 0.999999 else s.Weight*m.Weight end) Weight
					from [Search.Cache].[Private.NodeMap] s, (
						select [Key] NodeID, [Rank]*0.000999+0.001 Weight
							from Containstable ([RDF.].[vwLiteral], value, @PhraseSearchString) n
					) m
					where s.MatchedByNodeID = m.NodeID and s.NodeID = @NodeID
			select @loop = @loop + 1
		end
	end
	else
	begin
		insert into #PhraseNodeMap (PhraseID, NodeID, MatchedByNodeID, Distance, Paths, MapWeight, TextWeight, Weight)
			select 1, s.NodeID, s.MatchedByNodeID, s.Distance, s.Paths, s.Weight, m.Weight,
					(case when s.Weight*m.Weight > 0.999999 then 0.999999 else s.Weight*m.Weight end) Weight
				from [Search.Cache].[Private.NodeMap] s, (
					select [Key] NodeID, [Rank]*0.000999+0.001 Weight
						from Containstable ([RDF.].[vwLiteral], value, @CombinedSearchString) n
				) m
				where s.MatchedByNodeID = m.NodeID and s.NodeID = @NodeID
	end


	-------------------------------------------------------
	-- Get details on the matches
	-------------------------------------------------------
	
	SELECT *
		INTO #m
		FROM (
			SELECT 1 DirectMatch, NodeID, NodeID MiddleNodeID, MatchedByNodeID, 
					COUNT(DISTINCT PhraseID) Phrases, 1-exp(sum(log(1-Weight))) Weight
				FROM #PhraseNodeMap
				WHERE Distance = 1
				GROUP BY NodeID, MatchedByNodeID
			UNION ALL
			SELECT 0 DirectMatch, d.NodeID, y.NodeID MiddleNodeID, d.MatchedByNodeID,
					COUNT(DISTINCT d.PhraseID) Phrases, 1-exp(sum(log(1-d.Weight))) Weight
				FROM #PhraseNodeMap d
					INNER JOIN [Search.Cache].[Private.NodeMap] x
						ON x.NodeID = d.NodeID
							AND x.Distance = d.Distance - 1
					INNER JOIN [Search.Cache].[Private.NodeMap] y
						ON y.NodeID = x.MatchedByNodeID
							AND y.MatchedByNodeID = d.MatchedByNodeID
							AND y.Distance = 1
				WHERE d.Distance > 1
				GROUP BY d.NodeID, d.MatchedByNodeID, y.NodeID
		) t

	SELECT *
		INTO #w
		FROM (
			SELECT DISTINCT m.DirectMatch, m.NodeID, m.MiddleNodeID, m.MatchedByNodeID, m.Phrases, m.Weight,
				p._PropertyLabel PropertyLabel, p._PropertyNode PropertyNode
			FROM #m m
				INNER JOIN [Search.Cache].[Private.NodeClass] c
					ON c.NodeID = m.MiddleNodeID
				INNER JOIN [Ontology.].[ClassProperty] p
					ON p._ClassNode = c.Class
						AND p._NetworkPropertyNode IS NULL
						AND p.SearchWeight > 0
				INNER JOIN [RDF.].Triple t
					ON t.subject = m.MiddleNodeID
						AND t.predicate = p._PropertyNode
						AND t.object = m.MatchedByNodeID
		) t

	SELECT w.DirectMatch, w.Phrases, w.Weight,
			n.NodeID, n.Value URI, c.ShortLabel Label, c.ClassName, 
			w.PropertyLabel Predicate, 
			w.MatchedByNodeID, o.value Value
		INTO #MatchDetails
		FROM #w w
			INNER JOIN [RDF.].Node n
				ON n.NodeID = w.MiddleNodeID
			INNER JOIN [Search.Cache].[Private.NodeSummary] c
				ON c.NodeID = w.MiddleNodeID
			INNER JOIN [RDF.].Node o
				ON o.NodeID = w.MatchedByNodeID

	UPDATE #MatchDetails
		SET Weight = (CASE WHEN Weight > 0.999999 THEN 999999 WHEN Weight < 0.000001 THEN 0.000001 ELSE Weight END)

	-------------------------------------------------------
	-- Build ConnectionDetailsXML
	-------------------------------------------------------

	DECLARE @ConnectionDetailsXML XML
	
	;WITH a AS (
		SELECT DirectMatch, NodeID, URI, Label, ClassName, 
				COUNT(*) NumberOfProperties, 1-exp(sum(log(1-Weight))) Weight,
				(
					SELECT	p.Predicate "Name",
							p.Phrases "NumberOfPhrases",
							p.Weight "Weight",
							p.Value "Value",
							(
								SELECT r.Phrase "MatchedPhrase"
								FROM #PhraseNodeMap q, @PhraseList r
								WHERE q.MatchedByNodeID = p.MatchedByNodeID
									AND r.PhraseID = q.PhraseID
								ORDER BY r.PhraseID
								FOR XML PATH(''), TYPE
							) "MatchedPhraseList"
						FROM #MatchDetails p
						WHERE p.DirectMatch = m.DirectMatch
							AND p.NodeID = m.NodeID
						ORDER BY p.Predicate
						FOR XML PATH('Property'), TYPE
				) PropertyList
			FROM #MatchDetails m
			GROUP BY DirectMatch, NodeID, URI, Label, ClassName
	)
	SELECT @ConnectionDetailsXML = (
		SELECT	(
					SELECT	NodeID "NodeID",
							URI "URI",
							Label "Label",
							ClassName "ClassName",
							NumberOfProperties "NumberOfProperties",
							Weight "Weight",
							PropertyList "PropertyList"
					FROM a
					WHERE DirectMatch = 1
					FOR XML PATH('Match'), TYPE
				) "DirectMatchList",
				(
					SELECT	NodeID "NodeID",
							URI "URI",
							Label "Label",
							ClassName "ClassName",
							NumberOfProperties "NumberOfProperties",
							Weight "Weight",
							PropertyList "PropertyList"
					FROM a
					WHERE DirectMatch = 0
					FOR XML PATH('Match'), TYPE
				) "IndirectMatchList"				
		FOR XML PATH(''), TYPE
	)
	
	--SELECT @ConnectionDetailsXML ConnectionDetails
	--SELECT * FROM #PhraseNodeMap


	-------------------------------------------------------
	-- Get RDF of the NodeID
	-------------------------------------------------------

	DECLARE @ObjectNodeRDF NVARCHAR(MAX)
	
	EXEC [RDF.].GetDataRDF	@subject = @NodeID,
							@showDetails = 0,
							@expand = 0,
							@SessionID = @SessionID,
							@returnXML = 0,
							@dataStr = @ObjectNodeRDF OUTPUT


	-------------------------------------------------------
	-- Form search results details RDF
	-------------------------------------------------------

	DECLARE @results NVARCHAR(MAX)

	SELECT @results = ''
			+'<rdf:Description rdf:nodeID="SearchResultsDetails">'
			+'<rdf:type rdf:resource="http://profiles.catalyst.harvard.edu/ontology/prns#Connection" />'
			+'<prns:connectionInNetwork rdf:NodeID="SearchResults" />'
			--+'<prns:connectionWeight>0.37744</prns:connectionWeight>'
			+'<prns:hasConnectionDetails rdf:NodeID="ConnectionDetails" />'
			+'<rdf:object rdf:resource="'+@NodeURI+'" />'
			+'<rdfs:label>Search Results Details</rdfs:label>'
			+'</rdf:Description>'
			+'<rdf:Description rdf:nodeID="SearchResults">'
			+'<rdf:type rdf:resource="http://profiles.catalyst.harvard.edu/ontology/prns#Network" />'
			+'<rdfs:label>Search Results</rdfs:label>'
			+'<vivo:overview rdf:parseType="Literal">'
			+CAST(@SearchOptions AS NVARCHAR(MAX))
			+IsNull('<SearchDetails>'+CAST(@SearchPhraseXML AS NVARCHAR(MAX))+'</SearchDetails>','')
			+'</vivo:overview>'
			+'<prns:hasConnection rdf:nodeID="SearchResultsDetails" />'
			+'</rdf:Description>'
			+IsNull(@ObjectNodeRDF,'')
			+'<rdf:Description rdf:NodeID="ConnectionDetails">'
			+'<rdf:type rdf:resource="http://profiles.catalyst.harvard.edu/ontology/prns#ConnectionDetails" />'
			+'<vivo:overview rdf:parseType="Literal">'
			+CAST(@ConnectionDetailsXML AS NVARCHAR(MAX))
			+'</vivo:overview>'
			+'</rdf:Description> '

	declare @x as varchar(max)
	select @x = '<rdf:RDF'
	select @x = @x + ' xmlns:'+Prefix+'="'+URI+'"' 
		from [Ontology.].Namespace
	select @x = @x + ' >' + @results + '</rdf:RDF>'
	select cast(@x as xml) RDF


END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Cache].[Concept.Mesh.UpdateWord2MeshAll]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
 
DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER,@rows BIGINT 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessStartDate=@date,@insert_new_record=1
 
 
 
	select distinct nref.value('.','varchar(max)') word, m mesh_header 
		into #cwm
		from (
			select m, cast(replace(
				'<x><w>'+replace(v,' ','</w><w>')+'</w></x>',
				'<w></w>','') as xml) x
			from (select m, 
				replace(
				replace(
				replace(
				replace(
				replace(
				replace(m,
					nchar(11),' '),
					',',' '),
					'-',' '),
					'&','&amp;'),
					'<','&lt;'),
					'>','&gt;') v 
				from (
					select distinct DescriptorName m from [Profile.Data].[Concept.Mesh.Descriptor]
				) t
			) t
		) t
		cross apply x.nodes('//w') as R(nref)
 
	select distinct word, TermName mesh_term, DescriptorName as mesh_header, 0 num_words
		into #cwm3
		from [Profile.Data].[Concept.Mesh.Term]
			cross apply [Utility.NLP].fnNormalizeSplitStem(termname)
	create nonclustered index idx_ht on #cwm3(mesh_header, mesh_term)
	update c
		set c.num_words = t.n
		from #cwm3 c, (
			select mesh_header, mesh_term, count(*) n
			from #cwm3
			group by mesh_header, mesh_term
		) t
		where c.mesh_header = t.mesh_header and c.mesh_term = t.mesh_term
 
	select distinct word, mesh_header
		into #cwm2
		from #cwm3
 BEGIN TRY
	begin transaction
 
		delete FROM [Profile.Cache].[Concept.Mesh.Word2meshAll]
		insert into [Profile.Cache].[Concept.Mesh.Word2meshAll] (word, mesh_header)
			select word, mesh_header from #cwm
 
		delete from [Profile.Cache].[Concept.Mesh.Word2mesh2All]
		insert into [Profile.Cache].[Concept.Mesh.Word2mesh2All] (word, mesh_header)
			select word, mesh_header from #cwm2
 
		delete from [Profile.Cache].[Concept.Mesh.Word2Mesh3All]
		insert into [Profile.Cache].[Concept.Mesh.Word2Mesh3All] (word, mesh_term, mesh_header, num_words)
			select word, mesh_term, mesh_header, num_words from #cwm3
 
	commit transaction
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate =@date,@error = 1,@insert_new_record=0
		-- Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
 
	SELECT @date=GETDATE()
	EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate =@date,@ProcessedRows = @rows,@insert_new_record=0
 
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Search.].[LookupNodes]
	@SearchOptions XML,
	@SessionID UNIQUEIDENTIFIER = NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	/********************************************************************
	
	This procedure provides secure, real-time search for editing and
	administrative functions. It gets called in the same way as the
	main GetNodes search procedure, but it has several differences:
	
	1) All nodes, including non-public nodes, are searched. The
		user's SessionID determines which non-public nodes are
		returned.
	2) No cache tables are used. Changes to Nodes and Triples are
		immediately available to this procedure. Though, there could
		be a delay caused by the time it takes fulltext search indexes
		to be updated.
	3) Only node labels (not the full content of a profile) are 
		searched. As a result, fewer nodes are matched by a search
		string.
	4) There are fewer search options. In particular, class group,
		search filters, and sort options are not supported.
	5) Data is returned as XML, not RDF.
	
	Below are examples:

	-- Return all people named "Smith"
	EXEC [Search.].[LookupNodes] @SearchOptions = '
		<SearchOptions>
			<MatchOptions>
				<SearchString>Smith</SearchString>
				<ClassURI>http://xmlns.com/foaf/0.1/Person</ClassURI>
			</MatchOptions>
			<OutputOptions>
				<Offset>0</Offset>
				<Limit>5</Limit>
			</OutputOptions>	
		</SearchOptions>
		'

	-- Return publications about "lung cancer"
	EXEC [Search.].[LookupNodes] @SearchOptions = '
		<SearchOptions>
			<MatchOptions>
				<SearchString>lung cancer</SearchString>
				<ClassURI>http://purl.org/ontology/bibo/AcademicArticle</ClassURI>
			</MatchOptions>
			<OutputOptions>
				<Offset>5</Offset>
				<Limit>10</Limit>
			</OutputOptions>	
		</SearchOptions>
		'

	-- Return all departments
	EXEC [Search.].[LookupNodes] @SearchOptions = '
		<SearchOptions>
			<MatchOptions>
				<ClassURI>http://vivoweb.org/ontology/core#Department</ClassURI>
			</MatchOptions>
			<OutputOptions>
				<Offset>0</Offset>
				<Limit>25</Limit>
			</OutputOptions>	
		</SearchOptions>
		'

	********************************************************************/

	-- start timer
	declare @d datetime
	select @d = GetDate()

	-- declare variables
	declare @MatchOptions xml
	declare @OutputOptions xml
	declare @SearchString varchar(500)
	declare @ClassURI varchar(400)
	declare @offset bigint
	declare @limit bigint
	declare @baseURI nvarchar(400)
	declare @typeID bigint
	declare @labelID bigint
	declare @classID bigint
	declare @CombinedSearchString VARCHAR(8000)

	-- set constants
	select @baseURI = value from [Framework.].Parameter where ParameterID = 'baseURI'
	select @typeID = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
	select @labelID = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')

	-- parse input
	select	@MatchOptions = @SearchOptions.query('SearchOptions[1]/MatchOptions[1]'),
			@OutputOptions = @SearchOptions.query('SearchOptions[1]/OutputOptions[1]')
	select	@SearchString = @MatchOptions.value('MatchOptions[1]/SearchString[1]','varchar(500)'),
			@ClassURI = @MatchOptions.value('MatchOptions[1]/ClassURI[1]','varchar(400)'),
			@offset = @OutputOptions.value('OutputOptions[1]/Offset[1]','bigint'),
			@limit = @OutputOptions.value('OutputOptions[1]/Limit[1]','bigint')
	if @ClassURI is not null
		select @classID = [RDF.].fnURI2NodeID(@ClassURI)
	if @SearchString is not null
		EXEC [Search.].[ParseSearchString]	@SearchString = @SearchString,
											@CombinedSearchString = @CombinedSearchString OUTPUT

	-- get security information
	DECLARE @SecurityGroupID BIGINT, @HasSpecialViewAccess BIT
	EXEC [RDF.Security].GetSessionSecurityGroup @SessionID, @SecurityGroupID OUTPUT, @HasSpecialViewAccess OUTPUT
	CREATE TABLE #SecurityGroupNodes (SecurityGroupNode BIGINT PRIMARY KEY)
	INSERT INTO #SecurityGroupNodes (SecurityGroupNode) EXEC [RDF.Security].GetSessionSecurityGroupNodes @SessionID


	-- get a list of possible classes
	create table #c (ClassNode bigint primary key, TreeDepth int, ClassName varchar(400))
	insert into #c (ClassNode, TreeDepth, ClassName)
		select _ClassNode, _TreeDepth, _ClassName
		from [Ontology.].ClassTreeDepth
		where _ClassNode = IsNull(@classID,_ClassNode)

	
	-- CASE 1: A search string was provided
	IF IsNull(@CombinedSearchString,'') <> ''
	BEGIN
		;with a as (
			select NodeID, Label, ClassName, URI, ConnectionWeight,
					row_number() over (order by Label, NodeID) SortOrder
				from (
					select (case when len(m.Value)>500 then left(m.Value,497)+'...' else m.Value end) Label, 
						n.NodeID, n.value URI, c.ClassName ClassName, x.[Rank]*0.001 ConnectionWeight,
						row_number() over (partition by n.NodeID order by c.TreeDepth desc) k
					from Containstable ([RDF.].[vwLiteral], value, @CombinedSearchString) x
						inner join [RDF.].Node m -- text node
							on x.[Key] = m.NodeID
								and ((m.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (m.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (m.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
						inner join [RDF.].Triple t -- match label
							on t.object = m.NodeID
								and t.predicate = @labelID
								and ((t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
						inner join [RDF.].Node n -- match node
							on n.NodeID = t.subject
								and ((n.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (n.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (n.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
						inner join [RDF.].Triple v -- class
							on v.subject = n.NodeID
								and v.predicate = @typeID
								and ((v.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (v.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (v.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
						inner join #c c -- class name
							on c.ClassNode = v.object
				) t
				where k = 1
		)
		select (
				select	@SearchString "SearchString",
						@ClassURI "ClassURI",
						@offset "offset",
						@limit "limit",
						(select count(*) from a) "NumberOfConnections",
						(
							select	SortOrder "Connection/@SortOrder",
									NodeID "Connection/@NodeID",
									ClassName "Connection/@ClassName", 
									URI "Connection/@URI",
									ConnectionWeight "Connection/@ConnectionWeight",
									Label "Connection"
							from a
							where SortOrder >= (IsNull(@offset,0) + 1) AND SortOrder <= (IsNull(@offset,0) + IsNull(@limit,SortOrder))
							order by SortOrder
							for xml path(''), type
						) "Network"
					for xml path('SearchResults'), type
			) SearchResults
	END


	-- CASE 2: A Class, but no search string, was provided
	IF (IsNull(@CombinedSearchString,'') = '') AND (@classID IS NOT NULL)
	BEGIN
		;with a as (
			select NodeID, Label, ClassName, URI, 1 ConnectionWeight,
					row_number() over (order by Label, NodeID) SortOrder
				from (
					select (case when len(m.Value)>500 then left(m.Value,497)+'...' else m.Value end) Label, 
						n.NodeID, n.value URI, c.ClassName ClassName,
						row_number() over (partition by n.NodeID order by m.NodeID desc) k
					from #c c
						inner join [RDF.].Triple v -- class
							on v.object = c.ClassNode
								and v.predicate = @typeID
								and ((v.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (v.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (v.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
						inner join [RDF.].Node n -- match node
							on n.NodeID = v.subject
								and ((n.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (n.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (n.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
						inner join [RDF.].Triple t -- match label
							on t.subject = n.NodeID
								and t.predicate = @labelID
								and ((t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
						inner join [RDF.].Node m -- text node
							on m.NodeID = t.object
								and ((m.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (m.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (m.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
				) t
				where k = 1
		)
		select (
				select	@SearchString "SearchString",
						@ClassURI "ClassURI",
						@offset "offset",
						@limit "limit",
						(select count(*) from a) "NumberOfConnections",
						(
							select	SortOrder "Connection/@SortOrder",
									NodeID "Connection/@NodeID",
									ClassName "Connection/@ClassName", 
									URI "Connection/@URI",
									ConnectionWeight "Connection/@ConnectionWeight",
									Label "Connection"
							from a
							where SortOrder >= (IsNull(@offset,0) + 1) AND SortOrder <= (IsNull(@offset,0) + IsNull(@limit,SortOrder))
							order by SortOrder
							for xml path(''), type
						) "Network"
					for xml path('SearchResults'), type
			) SearchResults	
	END


END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Search.].[GetNodes]
	@SearchOptions XML,
	@SessionID UNIQUEIDENTIFIER = NULL,
	@Lookup BIT = 0,
	@UseCache VARCHAR(50) = 'Public',
	@NoRDF BIT =0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	/*
	
	EXEC [Search.].[GetNodes] @SearchOptions = '
	<SearchOptions>
		<MatchOptions>
			<SearchString ExactMatch="false">options for "lung cancer" treatment</SearchString>
			<ClassURI>http://xmlns.com/foaf/0.1/Person</ClassURI>
			<SearchFiltersList>
				<SearchFilter Property="http://xmlns.com/foaf/0.1/lastName" MatchType="Left">Smit</SearchFilter>
			</SearchFiltersList>
		</MatchOptions>
		<OutputOptions>
			<Offset>0</Offset>
			<Limit>5</Limit>
			<SortByList>
				<SortBy IsDesc="1" Property="http://xmlns.com/foaf/0.1/firstName" />
				<SortBy IsDesc="0" Property="http://xmlns.com/foaf/0.1/lastName" />
			</SortByList>
		</OutputOptions>	
	</SearchOptions>
	'
		
	*/
	
	-- Select either a lookup or a full search
	IF @Lookup = 1
	BEGIN
		-- Run a lookup
		EXEC [Search.].[LookupNodes] @SearchOptions = @SearchOptions, @SessionID = @SessionID
	END
	ELSE
	BEGIN
		-- Run a full search
		-- Determine the cache type if set to auto
		IF IsNull(@UseCache,'Auto') IN ('','Auto')
		BEGIN
			DECLARE @SecurityGroupID BIGINT, @HasSpecialViewAccess BIT
			EXEC [RDF.Security].GetSessionSecurityGroup @SessionID, @SecurityGroupID OUTPUT, @HasSpecialViewAccess OUTPUT
			SELECT @UseCache = (CASE WHEN @SecurityGroupID <= -30 THEN 'Private' ELSE 'Public' END)
		END
		-- Run the search based on the cache type
		IF @UseCache = 'Public'
			EXEC [Search.Cache].[Public.GetNodes] @SearchOptions = @SearchOptions, @SessionID = @SessionID, @NoRDF=@NoRDF
		ELSE IF @UseCache = 'Private'
			EXEC [Search.Cache].[Private.GetNodes] @SearchOptions = @SearchOptions, @SessionID = @SessionID
	END

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Search.].[GetConnection]
	@SearchOptions XML,
	@NodeID BIGINT = NULL,
	@NodeURI VARCHAR(400) = NULL,
	@SessionID UNIQUEIDENTIFIER = NULL,
	@UseCache VARCHAR(50) = 'Public'
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Determine the cache type if set to auto
	IF IsNull(@UseCache,'Auto') IN ('','Auto')
	BEGIN
		DECLARE @SecurityGroupID BIGINT, @HasSpecialViewAccess BIT
		EXEC [RDF.Security].GetSessionSecurityGroup @SessionID, @SecurityGroupID OUTPUT, @HasSpecialViewAccess OUTPUT
		SELECT @UseCache = (CASE WHEN @SecurityGroupID <= -30 THEN 'Private' ELSE 'Public' END)
	END

	-- Get connection based on the cache type
	IF @UseCache = 'Public'
		EXEC [Search.Cache].[Public.GetConnection] @SearchOptions = @SearchOptions, @NodeID = @NodeID, @NodeURI = @NodeURI, @SessionID = @SessionID
	ELSE IF @UseCache = 'Private'
		EXEC [Search.Cache].[Private.GetConnection] @SearchOptions = @SearchOptions, @NodeID = @NodeID, @NodeURI = @NodeURI, @SessionID = @SessionID

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORNG.].[AddAppToOntology](@AppID INT, 
										   @EditView nvarchar(100) = 'home',
										   @EditOptParams nvarchar(255) = '{''hide_titlebar'':1}', --'{''gadget_class'':''ORNGToggleGadget'', ''start_closed'':0, ''hideShow'':1, ''closed_width'':700}',
										   @ProfileView nvarchar(100) = 'profile',
										   @ProfileOptParams nvarchar(255) = '{''hide_titlebar'':1}',
										   @SessionID UNIQUEIDENTIFIER=NULL, 
										   @Error BIT=NULL OUTPUT, 
										   @NodeID BIGINT=NULL OUTPUT)
As
BEGIN
	SET NOCOUNT ON
		-- Cat2
		DECLARE @InternalType nvarchar(100) -- lookup from import.twitter
		DECLARE @Name nvarchar(255)
		DECLARE @URL nvarchar(255)
		DECLARE @LabelNodeID BIGINT
		DECLARE @ApplicationIdNodeID BIGINT
		DECLARE @ApplicationURLNodeID BIGINT
		DECLARE @DataMapID int
		DECLARE @TableName nvarchar(255)
		DECLARE @ClassPropertyName nvarchar(255)
		DECLARE @ClassPropertyLabel nvarchar(255)
		DECLARE @CustomDisplayModule XML
		DECLARE @CustomEditModule XML
		DECLARE @Enabled bit
		
		SELECT @InternalType = n.value FROM [rdf.].[Triple] t JOIN [rdf.].Node n ON t.[Object] = n.NodeID 
			WHERE t.[Subject] = [RDF.].fnURI2NodeID('http://orng.info/ontology/orng#Application')
			and t.Predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')
		SELECT @Name = REPLACE(RTRIM(RIGHT(url, CHARINDEX('/', REVERSE(url)) - 1)), '.xml', '')
			FROM [ORNG.].[Apps] WHERE AppID = @AppID 
		SELECT @URL = url FROM [ORNG.].[Apps] WHERE AppID = @AppID
		SELECT @Enabled = Enabled FROM [ORNG.].[Apps] WHERE AppID = @AppID
			
		-- Add the Nodes for the application, its Id and URL
		EXEC [RDF.].GetStoreNode	@Class = 'http://orng.info/ontology/orng#Application',
									@InternalType = @InternalType,
									@InternalID = @Name,
									@SessionID = @SessionID, 
									@Error = @Error OUTPUT, 
									@NodeID = @NodeID OUTPUT		
		EXEC [RDF.].GetStoreNode @Value = @Name, @Language = NULL, @DataType = NULL,
			@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @LabelNodeID OUTPUT	
		EXEC [RDF.].GetStoreNode @Value = @AppID, @Language = NULL, @DataType = NULL,
			@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @ApplicationIdNodeID OUTPUT	
		EXEC [RDF.].GetStoreNode @Value = @URL, @Language = NULL, @DataType = NULL,
			@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @ApplicationURLNodeID OUTPUT	
		-- Add the Type
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
									@ObjectURI = 'http://orng.info/ontology/orng#Application',
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		-- Add the Label
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://www.w3.org/2000/01/rdf-schema#label',
									@ObjectID = @LabelNodeID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		-- Add the triples for the application, we assume label and class are already wired
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://orng.info/ontology/orng#applicationId',
									@ObjectID = @ApplicationIdNodeID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://orng.info/ontology/orng#applicationURL',
									@ObjectID = @ApplicationURLNodeID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT																																
		
		-- create a custom property to associate an instance of this application to a person
		SET @ClassPropertyName = 'http://orng.info/ontology/orng#has' + @Name
		SELECT @ClassPropertyLabel = Name
			FROM [ORNG.].[Apps] WHERE AppID = @AppID 
		SET @CustomEditModule = cast(N'<Module ID="EditPersonalGadget">
					<ParamList>
					  <Param Name="AppId">' + cast(@AppID as varchar) + '</Param>
					  <Param Name="Label">' + @ClassPropertyLabel + '</Param>
					  <Param Name="View">' + @EditView + '</Param>
					  <Param Name="OptParams">' + @EditOptParams + '</Param>
					</ParamList>
				  </Module>' as XML)
		SET @CustomDisplayModule = cast(N'<Module ID="ViewPersonalGadget">
					<ParamList>
					  <Param Name="AppId">' + cast(@AppID as varchar) + '</Param>
					  <Param Name="Label">' + @ClassPropertyLabel + '</Param>
					  <Param Name="View">' + @ProfileView + '</Param>
					  <Param Name="OptParams">' + @ProfileOptParams + '</Param>
					</ParamList>
				  </Module>' as XML)				
		EXEC [Ontology.].[AddProperty]	@OWL = 'ORNG_1.0', 
										@PropertyURI = @ClassPropertyName,
										@PropertyName = @ClassPropertyLabel,
										@ObjectType = 0,
										@PropertyGroupURI = 'http://orng.info/ontology/orng#PropertyGroupORNGApplications', 
										@ClassURI = 'http://xmlns.com/foaf/0.1/Person',
										@IsDetail = 0,
										@IncludeDescription = 0
		IF (@Enabled = 1)
		BEGIN								
			UPDATE [Ontology.].[ClassProperty] set EditExistingSecurityGroup = -20, IsDetail = 0, IncludeDescription = 0,
					CustomEdit = 1, CustomEditModule = @CustomEditModule,
					CustomDisplay = 1, CustomDisplayModule = @CustomDisplayModule,
					EditSecurityGroup = -20, EditPermissionsSecurityGroup = -20, -- was -20's
					EditAddNewSecurityGroup = -20, EditAddExistingSecurityGroup = -20, EditDeleteSecurityGroup = -20 
				WHERE property = @ClassPropertyName;
		END
		ELSE IF (@Enabled = 0)
		BEGIN								
			UPDATE [Ontology.].[ClassProperty] set EditExistingSecurityGroup = -50, IsDetail = 0, IncludeDescription = 0,
					CustomEdit = 1, CustomEditModule = @CustomEditModule,
					CustomDisplay = 1, CustomDisplayModule = @CustomDisplayModule,
					EditSecurityGroup = -50, EditPermissionsSecurityGroup = -50, -- was -20's
					EditAddNewSecurityGroup = -50, EditAddExistingSecurityGroup = -50, EditDeleteSecurityGroup = -50,
					ViewSecurityGroup = -50
				WHERE property = @ClassPropertyName;
		END
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORNG.].[AddAppToPerson]
@SubjectID BIGINT=NULL, @SubjectURI nvarchar(255)=NULL, @AppID INT, @SessionID UNIQUEIDENTIFIER=NULL, @Error BIT=NULL OUTPUT, @NodeID BIGINT=NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	-- Cat2
	DECLARE @InternalType nvarchar(100) -- lookup from import.twitter
	DECLARE @InternalID nvarchar(100) -- lookpup personid and add appID
	DECLARE @PersonID INT
	DECLARE @PersonName nvarchar(255)
	DECLARE @Label nvarchar(255)
	DECLARE @LabelID BIGINT
	DECLARE @AppName NVARCHAR(100)
	DECLARE @ApplicationNodeID BIGINT
	DECLARE @PredicateURI nvarchar(255) -- this could be passed in for some situations
	DECLARE @PERSON_FILTER_ID INT
	
	IF (@SubjectID IS NULL)
		SET @SubjectID = [RDF.].fnURI2NodeID(@SubjectURI)
	
	SELECT @InternalType = [Object] FROM [Ontology.Import].[Triple] 
		WHERE [Subject] = 'http://orng.info/ontology/orng#ApplicationInstance' AND [Predicate] = 'http://www.w3.org/2000/01/rdf-schema#label'
	
	SELECT @PersonID = cast(InternalID as INT), @InternalID = InternalID + '-' + CAST(@AppID as varchar) FROM [RDF.Stage].[InternalNodeMap]
		WHERE [NodeID] = @SubjectID AND Class = 'http://xmlns.com/foaf/0.1/Person'

	IF (@InternalID is null)
	BEGIN
		SELECT @InternalID = InternalID + '-GROUP-' + CAST(@AppID as varchar) FROM [RDF.Stage].[InternalNodeMap]
			WHERE [NodeID] = @SubjectID AND Class = 'http://xmlns.com/foaf/0.1/Group'
	END
		
	SELECT @PersonName = DisplayName from [Profile.Data].Person WHERE PersonID = @PersonID
	--- this odd label format is required for the DataMap items to work properly!
	SELECT @Label = 'http://orng.info/ontology/orng#ApplicationInstance^^' +
					@InternalType + '^^' + @InternalID
					
					
	-- Convert the AppID to an AppName based on its URL
	SELECT @AppName = REPLACE(RTRIM(RIGHT(url, CHARINDEX('/', REVERSE(url)) - 1)), '.xml', '')
		FROM [ORNG.].[Apps] 
		WHERE AppID = @AppID

	-- STOP, should we test that the PredicateURI is consistent with the AppID?
	SELECT @PredicateURI = 'http://orng.info/ontology/orng#has'+@AppName
				
	SELECT @ApplicationNodeID  = NodeID
		FROM [RDF.Stage].[InternalNodeMap]
		WHERE Class = 'http://orng.info/ontology/orng#Application' AND InternalType = 'ORNG Application'
			AND InternalID = @AppName

		
	----------------------------------------------------------------
	-- Determine if this app has already been added to this person
	----------------------------------------------------------------
	DECLARE @AppInstanceID BIGINT
	SELECT @AppInstanceID = NodeID
		FROM [RDF.Stage].[InternalNodeMap]

		WHERE Class = 'http://orng.info/ontology/orng#ApplicationInstance' 
			AND InternalType = 'ORNG Application Instance'
			AND InternalID = @InternalID
	IF @AppInstanceID IS NOT NULL
	BEGIN
		-- Determine the ViewSecurityGroup
		DECLARE @ViewSecurityGroup BIGINT
		SELECT @ViewSecurityGroup = IsNull(p.ViewSecurityGroup,c.ViewSecurityGroup)
			FROM [Ontology.].ClassProperty c
				LEFT OUTER JOIN [RDF.Security].NodeProperty p
					ON p.Property = c._PropertyNode AND p.NodeID = @SubjectID
			WHERE c.Class = 'http://xmlns.com/foaf/0.1/Person'
				AND c.Property = @PredicateURI
				AND c.NetworkProperty IS NULL

		-- Change the security group of the triple
		EXEC [RDF.].[GetStoreTriple] @SubjectID = @SubjectID, -- bigint
									 @ObjectID = @AppInstanceID, -- bigint
									 @PredicateURI = @PredicateURI, -- varchar(400)
									 @ViewSecurityGroup = @ViewSecurityGroup, -- bigint
									 @SessionID = NULL, -- uniqueidentifier
									 @Error = NULL -- bit

		print 'Weare ready to add person to filter'
		SELECT @PERSON_FILTER_ID = (SELECT PersonFilterID FROM [ORNG.].[Apps]  
			WHERE AppID = @AppID AND PersonFilterID NOT IN (
				SELECT personFilterId FROM [Profile.Data].[Person.FilterRelationship] 
					WHERE PersonID = @PersonID))
		IF (@PERSON_FILTER_ID IS NOT NULL) 
			BEGIN
				INSERT [Profile.Import].[PersonFilterFlag]
					SELECT InternalUserName, PersonFilter FROM [Profile.Data].[Person], [Profile.Data].[Person.Filter]
						WHERE PersonID = @PersonID AND PersonFilterID = @PERSON_FILTER_ID
				INSERT [Profile.Data].[Person.FilterRelationship](PersonID, personFilterId) 
					values (@PersonID, @PERSON_FILTER_ID)
			END

		-- Exit the proc
		RETURN;
	END


	----------------------------------------------------------------
	-- Add the app to the person for the first time
	----------------------------------------------------------------
	SELECT @Error = 0
	BEGIN TRAN
		-- We want Type 2.  Lookup internal type from import.triple, pass in AppID
		EXEC [RDF.].GetStoreNode	@Class = 'http://orng.info/ontology/orng#ApplicationInstance',
									@InternalType = @InternalType,
									@InternalID = @InternalID,
									@SessionID = @SessionID, 
									@Error = @Error OUTPUT, 
									@NodeID = @NodeID OUTPUT
		-- for some reason, this Status in [RDF.Stage].InternalNodeMap is set to 0, not 3.  This causes issues so
		-- we fix
		UPDATE [RDF.Stage].[InternalNodeMap] SET [Status] = 3 WHERE NodeID = @NodeID						
			
		EXEC [RDF.].GetStoreNode @Value = @Label, @Language = NULL, @DataType = NULL,
			@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @LabelID OUTPUT	

		-- Add the Type
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
									@ObjectURI = 'http://orng.info/ontology/orng#ApplicationInstance',
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		-- Add the Label
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://www.w3.org/2000/01/rdf-schema#label',
									@ObjectID = @LabelID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		-- Link the ApplicationInstance to the Application
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://orng.info/ontology/orng#applicationInstanceOfApplication',
									@ObjectID = @ApplicationNodeID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT		
		-- Link the ApplicationInstance to the person
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://orng.info/ontology/orng#applicationInstanceForPerson',
									@ObjectID = @SubjectID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT								
		-- Link the person to the ApplicationInstance
		EXEC [RDF.].GetStoreTriple	@SubjectID = @SubjectID,
									@PredicateURI = @PredicateURI,
									@ObjectID = @NodeID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		
		-- wire in the filter to both the import and live tables
		print 'Weare ready to add person to filter'
		SELECT @PERSON_FILTER_ID = (SELECT PersonFilterID FROM [ORNG.].[Apps]  

			WHERE AppID = @AppID AND PersonFilterID NOT IN (
				SELECT personFilterId FROM [Profile.Data].[Person.FilterRelationship] 
					WHERE PersonID = @PersonID))
		IF (@PERSON_FILTER_ID IS NOT NULL) 
			BEGIN
				INSERT [Profile.Import].[PersonFilterFlag]
					SELECT InternalUserName, PersonFilter FROM [Profile.Data].[Person], [Profile.Data].[Person.Filter]
						WHERE PersonID = @PersonID AND PersonFilterID = @PERSON_FILTER_ID

				INSERT [Profile.Data].[Person.FilterRelationship](PersonID, personFilterId) 
					values (@PersonID, @PERSON_FILTER_ID)
			END
	COMMIT	
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORNG.].[DeleteActivity](@Uri nvarchar(255),@AppID INT, @ActivityID int)
As
BEGIN
	SET NOCOUNT ON
	DECLARE @NodeID bigint
	
	select @NodeID = [RDF.].[fnURI2NodeID](@Uri);	
	DELETE [ORNG.].[Activity] WHERE NodeID = @NodeID AND AppID = @AppID and ActivityID = @ActivityID
END		

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORNG.].[DeleteAppData](@Uri nvarchar(255),@AppID INT, @Keyname nvarchar(255))
As
BEGIN
	SET NOCOUNT ON
	DECLARE @NodeID bigint
	
	SELECT @NodeID = [RDF.].[fnURI2NodeID](@Uri);
	DELETE [ORNG.].[AppData] WHERE NodeID = @NodeID AND AppID = @AppID and Keyname = @Keyname
END		


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORNG.].[InsertActivity](@Uri nvarchar(255),@AppID INT, @ActivityID int, @Activity XML)
As
BEGIN
	SET NOCOUNT ON
	DECLARE @NodeID bigint
	
	select @NodeID = [RDF.].[fnURI2NodeID](@Uri);	
	IF (@ActivityID IS NULL OR @ActivityID < 0)
		INSERT [ORNG.].[Activity] (NodeID, AppID, Activity) values (@NodeID, @AppID, @Activity)
	ELSE 		
		INSERT [ORNG.].[Activity] (ActivityID, NodeID, AppID, Activity) values (@ActivityID, @NodeID, @AppID, @Activity)
END		

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORNG.].[InsertMessage](@MsgID nvarchar(255),@Coll nvarchar(255), @Title nvarchar(255), @Body nvarchar(255),
										@senderUri nvarchar(255), @RecipientUri nvarchar(255))
As
BEGIN
	SET NOCOUNT ON
	DECLARE @SenderNodeID bigint
	DECLARE @RecipientNodeID bigint
	
	select @SenderNodeID = [RDF.].[fnURI2NodeID](@senderUri)
	select @RecipientNodeID = [RDF.].[fnURI2NodeID](@RecipientUri)
	
	INSERT [ORNG.].[Messages]  (MsgID, Coll, Title, Body, SenderNodeID, RecipientNodeID) 
			VALUES (@MsgID, @Coll, @Title, @Body, @SenderNodeID, @RecipientNodeID)
END		

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE  [ORNG.].[ReadActivity](@Uri nvarchar(255),@AppID INT, @ActivityID INT)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @NodeID bigint
	
	select @NodeID = [RDF.].[fnURI2NodeID](@Uri);

	select Activity from [ORNG.].Activity where NodeID = @NodeID AND AppID=@AppID AND ActivityID =@ActivityID
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE  [ORNG.].[ReadAllActivities](@Uri nvarchar(255),@AppID INT)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @NodeID bigint
	
	select @NodeID = [RDF.].[fnURI2NodeID](@Uri);

	IF (@AppID IS NULL)
		select Activity from [ORNG.].Activity where NodeID = @NodeID
	ELSE		
		select Activity from [ORNG.].Activity where NodeID = @NodeID AND AppID=@AppID 
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE  [ORNG.].[ReadAppData](@Uri nvarchar(255),@AppID INT, @Keyname nvarchar(255))
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @NodeID bigint
	
	SELECT @NodeID = [RDF.].[fnURI2NodeID](@Uri);

	SELECT Value from [ORNG.].AppData where AppID=@AppID AND NodeID = @NodeID AND Keyname = @Keyname
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE  [ORNG.].[ReadMessages](@RecipientUri nvarchar(255),@Coll nvarchar(255), @MsgIDs nvarchar(max))
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @RecipientNodeID bigint
	DECLARE @baseURI nvarchar(255)
	DECLARE @sql nvarchar(255)
	
	select @RecipientNodeID = [RDF.].[fnURI2NodeID](@RecipientUri)
	select @baseURI = [Value] FROM [Framework.].[Parameter] WHERE ParameterID = 'baseURI';
	
	SET @sql = 'SELECT MsgID, Coll, Body, Title, ''' + @baseURI  + '''+ SenderNodeID , ''' + @baseURI + '''+ RecipientNodeID ' +
		'FROM [ORNG.].[Messages] WHERE RecipientNodeID = ' + @RecipientNodeID
	IF (@Coll IS NOT NULL)
		SET @sql = @sql + ' AND Coll = ''' + @Coll + '''';
	IF (@MsgIDs IS NOT NULL)
		SET @sql = @sql + ' AND MsgID IN ' + @MsgIDs
		
	EXEC @sql;
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE  [ORNG.].[ReadMessageCollections](@RecipientUri nvarchar(255))
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @RecipientNodeID bigint
	
	select @RecipientNodeID = [RDF.].[fnURI2NodeID](@RecipientUri)

	SELECT DISTINCT Coll	FROM [ORNG.].[Messages] WHERE RecipientNodeID =  @RecipientNodeID
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO


CREATE PROCEDURE  [ORNG.].[ReadPerson](@uri nvarchar(255))
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @nodeid bigint
	
	SELECT @nodeid = [RDF.].[fnURI2NodeID](@uri);

	SELECT * from [ORNG.].[vwPerson] WHERE nodeId = @nodeid
END


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORNG.].[RemoveAppFromOntology](@AppID INT, @SessionID UNIQUEIDENTIFIER=NULL, @Error BIT=NULL OUTPUT, @NodeID BIGINT=NULL OUTPUT)
As
BEGIN
	SET NOCOUNT ON
		DECLARE @Name nvarchar(255)
		DECLARE @PropertyURI nvarchar(255)
		
		SELECT @Name = REPLACE(RTRIM(RIGHT(url, CHARINDEX('/', REVERSE(url)) - 1)), '.xml', '')
			FROM [ORNG.].[Apps] WHERE AppID = @AppID 
		SET @PropertyURI = 'http://orng.info/ontology/orng#has' + @Name				
			
		IF (@PropertyURI IS NOT NULL)
		BEGIN	
			DELETE FROM [Ontology.].[ClassProperty]	WHERE Property = @PropertyURI
			DELETE FROM [Ontology.].[PropertyGroupProperty] WHERE PropertyURI = @PropertyURI
		END

		DECLARE @PropertyNode BIGINT
		SELECT @PropertyNode = _PropertyNode FROM [Ontology.].[ClassProperty] WHERE
			Class = 'http://orng.info/ontology/orng#Application' and 
			Property = 'http://orng.info/ontology/orng#applicationId' --_PropertyNode
		SELECT @NodeID = t.[Subject] FROM [RDF.].Triple t JOIN
			[RDF.].Node n ON t.[Object] = n.nodeid 
			WHERE t.Predicate = @PropertyNode AND n.[Value] = CAST(@AppID as varchar)
		
		IF (@NodeID IS NOT NULL)
		BEGIN
			EXEC [RDF.].DeleteNode @NodeID = @NodeID, @DeleteType = 0								   
		END	
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORNG.].[RemoveAppFromPerson]
@SubjectID BIGINT=NULL, @SubjectURI NVARCHAR(255)=NULL, @AppID INT, @DeleteType tinyint = 1, @SessionID UNIQUEIDENTIFIER=NULL, @Error BIT=NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @ApplicationInstanceNodeID  BIGINT
	DECLARE @TripleID BIGINT
	DECLARE @PersonID INT
	DECLARE @InternalID nvarchar(100)	
	DECLARE @InternalType nvarchar(300)
	DECLARE @PERSON_FILTER_ID INT
	DECLARE @InternalUserName NVARCHAR(50)
	DECLARE @PersonFilter NVARCHAR(50)

	IF (@SubjectID IS NULL)
		SET @SubjectID = [RDF.].fnURI2NodeID(@SubjectURI)
	
	-- Lookup the PersonID
	SELECT @InternalID = InternalID, @InternalType = InternalType
		FROM [RDF.Stage].[InternalNodeMap]
		WHERE NodeID = @SubjectID
	
	IF @InternalType = 'Person'
	BEGIN
		-- Lookup the App Instance's NodeID
		SELECT @ApplicationInstanceNodeID  = NodeID
			FROM [RDF.Stage].[InternalNodeMap]
			WHERE Class = 'http://orng.info/ontology/orng#ApplicationInstance' AND InternalType = 'ORNG Application Instance'
				AND InternalID = @InternalID + '-' + CAST(@AppID AS VARCHAR(50))
	END
	ELSE IF @InternalType = 'Group'
	BEGIN
		-- Lookup the App Instance's NodeID
		SELECT @ApplicationInstanceNodeID  = NodeID
			FROM [RDF.Stage].[InternalNodeMap]
			WHERE Class = 'http://orng.info/ontology/orng#ApplicationInstance' AND InternalType = 'ORNG Application Instance'
				AND InternalID = @InternalID + '-GROUP-' + CAST(@AppID AS VARCHAR(50))
	END
		
	-- there is only ONE link from the person to the application object, so grab it	
	SELECT @TripleID = [TripleID] FROM [RDF.].Triple 
		WHERE [Subject] = @SubjectID
		AND [Object] = @ApplicationInstanceNodeID

	-- now delete it
	BEGIN TRAN

		EXEC [RDF.].DeleteTriple @TripleID = @TripleID, 
								 @SessionID = @SessionID, 
								 @Error = @Error

		IF (@DeleteType = 0) -- true delete, remove the now orphaned application instance
		BEGIN
			EXEC [RDF.].DeleteNode @NodeID = @ApplicationInstanceNodeID, 
							   @DeleteType = @DeleteType,
							   @SessionID = @SessionID, 
							   @Error = @Error OUTPUT
		END							   

		-- remove any filters
		SELECT @PERSON_FILTER_ID = (SELECT PersonFilterID FROM Apps WHERE AppID = @AppID)
		IF (@PERSON_FILTER_ID IS NOT NULL) 
			BEGIN
				SELECT @PersonID = CAST(InternalID AS INT) FROM [RDF.Stage].[InternalNodeMap]
					WHERE [NodeID] = @SubjectID AND Class = 'http://xmlns.com/foaf/0.1/Person'
				IF (@PersonID IS NOT NULL)
					BEGIN
						SELECT @InternalUserName = InternalUserName FROM [Profile.Data].[Person] WHERE PersonID = @PersonID
						SELECT @PersonFilter = PersonFilter FROM [Profile.Data].[Person.Filter] WHERE PersonFilterID = @PERSON_FILTER_ID

						DELETE FROM [Profile.Import].[PersonFilterFlag] WHERE InternalUserName = @InternalUserName AND personfilter = @PersonFilter
						DELETE FROM [Profile.Data].[Person.FilterRelationship] WHERE PersonID = @PersonID AND personFilterId = @PERSON_FILTER_ID
					END
			END
	COMMIT
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORNG.].[UpsertAppData](@Uri nvarchar(255),@AppID INT, @Keyname nvarchar(255),@Value nvarchar(4000))
As
BEGIN
	SET NOCOUNT ON
	DECLARE @NodeID bigint
	
	SELECT @NodeID = [RDF.].[fnURI2NodeID](@Uri);
	IF (SELECT COUNT(*) FROM AppData WHERE NodeID = @NodeID AND AppID = @AppID and Keyname = @Keyname) > 0
		UPDATE [ORNG.].[AppData] set [Value] = @Value, updatedDT = GETDATE() WHERE NodeID = @nodeId AND AppID = @AppID and Keyname = @Keyname
	ELSE
		INSERT [ORNG.].[AppData] (NodeID, AppID, Keyname, [Value]) values (@NodeID, @AppID, @Keyname, @Value)
END		

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
create PROCEDURE [ORCID.].[AffiliationsForORCID.GetList]
	@ProfileDataPersonID bigint = NULL
AS
BEGIN
SELECT        TOP (100) PERCENT NULL AS PersonAffiliationID, [Profile.Data].[Person.Affiliation].PersonAffiliationID AS ProfilesID, 2 AS AffiliationTypeID, 
                         NULL AS PersonID, NULL AS PersonMessageID, NULL AS DecisionID, [Profile.Data].[Organization.Department].DepartmentName, 
                         [Profile.Data].[Person.Affiliation].Title AS RoleTitle, NULL AS StartDate, NULL AS EndDate, 
                         [Profile.Data].[Organization.Institution].InstitutionName AS OrganizationName, [Profile.Data].Person.City, 
                         [Profile.Data].Person.State, 'US' as Country, [ORCID.].[Organization.Institution.Disambiguation].DisambiguationID, 
                         [ORCID.].[Organization.Institution.Disambiguation].DisambiguationSource, [Profile.Data].[Person.Affiliation].SortOrder
FROM            [Profile.Data].Person INNER JOIN
                         [Profile.Data].[Person.Affiliation] ON [Profile.Data].Person.PersonID = [Profile.Data].[Person.Affiliation].PersonID INNER JOIN
                         [Profile.Data].[Organization.Institution] ON [Profile.Data].[Person.Affiliation].InstitutionID = [Profile.Data].[Organization.Institution].InstitutionID LEFT OUTER JOIN
                         [Profile.Data].[Organization.Division] ON [Profile.Data].[Person.Affiliation].DivisionID = [Profile.Data].[Organization.Division].DivisionID LEFT OUTER JOIN
                         [Profile.Data].[Organization.Department] ON [Profile.Data].[Person.Affiliation].DepartmentID = [Profile.Data].[Organization.Department].DepartmentID LEFT OUTER JOIN
						 [ORCID.].[Organization.Institution.Disambiguation] ON [Profile.Data].[Person.Affiliation].InstitutionID = [ORCID.].[Organization.Institution.Disambiguation].InstitutionID

WHERE        ([Profile.Data].Person.PersonID = @ProfileDataPersonID)
ORDER BY [Profile.Data].[Person.Affiliation].SortOrder
End

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [ORCID.].[AuthorInAuthorshipForORCID.GetList]
    @NodeID bigint = NULL,
    @SessionID uniqueidentifier = NULL
AS
BEGIN

    DECLARE @SecurityGroupID BIGINT, @HasSpecialViewAccess BIT
    EXEC [RDF.Security].GetSessionSecurityGroup @SessionID, @SecurityGroupID OUTPUT, @HasSpecialViewAccess OUTPUT
    CREATE TABLE #SecurityGroupNodes (SecurityGroupNode BIGINT PRIMARY KEY)
    INSERT INTO #SecurityGroupNodes (SecurityGroupNode) EXEC [RDF.Security].GetSessionSecurityGroupNodes @SessionID, @NodeID


    declare @AuthorInAuthorship bigint
    select @AuthorInAuthorship = [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#authorInAuthorship') 
    declare @LinkedInformationResource bigint
    select @LinkedInformationResource = [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#linkedInformationResource') 


    select i.NodeID, p.EntityID, i.Value rdf_about, p.EntityName rdfs_label, 
        p.Reference prns_informationResourceReference, p.EntityDate prns_publicationDate,
        year(p.EntityDate) prns_year, p.pmid bibo_pmid, p.mpid prns_mpid, mpg.URL
    from [RDF.].[Triple] t
        inner join [RDF.].[Node] a
            on t.subject = @NodeID and t.predicate = @AuthorInAuthorship
                and t.object = a.NodeID
                and ((t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
                and ((a.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (a.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (a.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
        inner join [RDF.].[Node] i
            on t.object = i.NodeID
                and ((i.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (i.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (i.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
        inner join [RDF.Stage].[InternalNodeMap] m
            on i.NodeID = m.NodeID
        inner join [Profile.Data].[Publication.Entity.Authorship] e
            on m.InternalID = e.EntityID
        inner join [Profile.Data].[Publication.Entity.InformationResource] p
            on e.InformationResourceID = p.EntityID
        left join  [Profile.Data].[Publication.MyPub.General] mpg
            on p.MPID = mpg.MPID
    order by p.EntityDate desc

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_ErrorLogAdd]

    @ErrorLogID  INT =NULL OUTPUT 
    , @InternalUsername  NVARCHAR(11) =NULL
    , @Exception  TEXT 
    , @OccurredOn  SMALLDATETIME 
    , @Processed  BIT 

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3732
 
  
        INSERT INTO [ORCID.].[ErrorLog]
        (
            [InternalUsername]
            , [Exception]
            , [OccurredOn]
            , [Processed]
        )
        (
            SELECT
            @InternalUsername
            , @Exception
            , @OccurredOn
            , @Processed
        )
   
        SET @intReturnVal = @@error
        SET @ErrorLogID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the ErrorLog record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_ErrorLogDelete]
 
    @ErrorLogID  INT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[ErrorLog] WHERE         [ORCID.].[ErrorLog].[ErrorLogID] = @ErrorLogID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the ErrorLog record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_ErrorLogEdit]

    @ErrorLogID  INT =NULL OUTPUT 
    , @InternalUsername  NVARCHAR(11) =NULL
    , @Exception  TEXT 
    , @OccurredOn  SMALLDATETIME 
    , @Processed  BIT 

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3732
 
  
        UPDATE [ORCID.].[ErrorLog]
        SET
            [InternalUsername] = @InternalUsername
            , [Exception] = @Exception
            , [OccurredOn] = @OccurredOn
            , [Processed] = @Processed
        FROM
            [ORCID.].[ErrorLog]
        WHERE
        [ORCID.].[ErrorLog].[ErrorLogID] = @ErrorLogID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the ErrorLog record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_ErrorLogGet]
 
    @ErrorLogID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[ErrorLog].[ErrorLogID]
        , [ORCID.].[ErrorLog].[InternalUsername]
        , [ORCID.].[ErrorLog].[Exception]
        , [ORCID.].[ErrorLog].[OccurredOn]
        , [ORCID.].[ErrorLog].[Processed]
    FROM
        [ORCID.].[ErrorLog]
    WHERE
        [ORCID.].[ErrorLog].[ErrorLogID] = @ErrorLogID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_ErrorLogsGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[ErrorLog].[ErrorLogID]
        , [ORCID.].[ErrorLog].[InternalUsername]
        , [ORCID.].[ErrorLog].[Exception]
        , [ORCID.].[ErrorLog].[OccurredOn]
        , [ORCID.].[ErrorLog].[Processed]
    FROM
        [ORCID.].[ErrorLog]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_FieldLevelAuditTrailAdd]

    @FieldLevelAuditTrailID  BIGINT =NULL OUTPUT 
    , @RecordLevelAuditTrailID  BIGINT 
    , @MetaFieldID  INT 
    , @ValueBefore  VARCHAR(50) =NULL
    , @ValueAfter  VARCHAR(50) =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
 
  
        INSERT INTO [ORCID.].[FieldLevelAuditTrail]
        (
            [RecordLevelAuditTrailID]
            , [MetaFieldID]
            , [ValueBefore]
            , [ValueAfter]
        )
        (
            SELECT
            @RecordLevelAuditTrailID
            , @MetaFieldID
            , @ValueBefore
            , @ValueAfter
        )
   
        SET @intReturnVal = @@error
        SET @FieldLevelAuditTrailID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the FieldLevelAuditTrail record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_FieldLevelAuditTrailDelete]
 
    @FieldLevelAuditTrailID  BIGINT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[FieldLevelAuditTrail] WHERE         [ORCID.].[FieldLevelAuditTrail].[FieldLevelAuditTrailID] = @FieldLevelAuditTrailID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the FieldLevelAuditTrail record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_FieldLevelAuditTrailEdit]

    @FieldLevelAuditTrailID  BIGINT =NULL OUTPUT 
    , @RecordLevelAuditTrailID  BIGINT 
    , @MetaFieldID  INT 
    , @ValueBefore  VARCHAR(50) =NULL
    , @ValueAfter  VARCHAR(50) =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
 
  
        UPDATE [ORCID.].[FieldLevelAuditTrail]
        SET
            [RecordLevelAuditTrailID] = @RecordLevelAuditTrailID
            , [MetaFieldID] = @MetaFieldID
            , [ValueBefore] = @ValueBefore
            , [ValueAfter] = @ValueAfter
        FROM
            [ORCID.].[FieldLevelAuditTrail]
        WHERE
        [ORCID.].[FieldLevelAuditTrail].[FieldLevelAuditTrailID] = @FieldLevelAuditTrailID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the FieldLevelAuditTrail record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_FieldLevelAuditTrailGet]
 
    @FieldLevelAuditTrailID  BIGINT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[FieldLevelAuditTrail].[FieldLevelAuditTrailID]
        , [ORCID.].[FieldLevelAuditTrail].[RecordLevelAuditTrailID]
        , [ORCID.].[FieldLevelAuditTrail].[MetaFieldID]
        , [ORCID.].[FieldLevelAuditTrail].[ValueBefore]
        , [ORCID.].[FieldLevelAuditTrail].[ValueAfter]
    FROM
        [ORCID.].[FieldLevelAuditTrail]
    WHERE
        [ORCID.].[FieldLevelAuditTrail].[FieldLevelAuditTrailID] = @FieldLevelAuditTrailID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_FieldLevelAuditTrailsGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[FieldLevelAuditTrail].[FieldLevelAuditTrailID]
        , [ORCID.].[FieldLevelAuditTrail].[RecordLevelAuditTrailID]
        , [ORCID.].[FieldLevelAuditTrail].[MetaFieldID]
        , [ORCID.].[FieldLevelAuditTrail].[ValueBefore]
        , [ORCID.].[FieldLevelAuditTrail].[ValueAfter]
    FROM
        [ORCID.].[FieldLevelAuditTrail]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_GroupEdit]

    @SecurityGroupID  BIGINT 
    , @Label  VARCHAR(255) 
    , @HasSpecialViewAccess  BIT =NULL
    , @HasSpecialEditAccess  BIT =NULL
    , @Description  VARCHAR(MAX) =NULL
    , @DefaultORCIDDecisionID  INT =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3657
 
  
        UPDATE [ORCID.].[DefaultORCIDDecisionIDMapping]
        SET
            [DefaultORCIDDecisionID] = @DefaultORCIDDecisionID
        WHERE
        [SecurityGroupID] = @SecurityGroupID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the Group record.', 11, 11); 
            RETURN @intReturnVal 
        END


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [ORCID.].[cg2_GroupGet]
 
    @SecurityGroupID  BIGINT 

AS
 
    SELECT TOP 100 PERCENT
        [RDF.Security].[Group].[SecurityGroupID]
        , [RDF.Security].[Group].[Label]
        , [RDF.Security].[Group].[HasSpecialViewAccess]
        , [RDF.Security].[Group].[HasSpecialEditAccess]
        , [RDF.Security].[Group].[Description]
        , [ORCID.].[DefaultORCIDDecisionIDMapping].[DefaultORCIDDecisionID]
    FROM
        [RDF.Security].[Group]
		join [ORCID.].[DefaultORCIDDecisionIDMapping]
		on [RDF.Security].[Group].SecurityGroupID = [ORCID.].[DefaultORCIDDecisionIDMapping].SecurityGroupID
    WHERE
        [RDF.Security].[Group].[SecurityGroupID] = @SecurityGroupID



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [ORCID.].[cg2_GroupsGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [RDF.Security].[Group].[SecurityGroupID]
        , [RDF.Security].[Group].[Label]
        , [RDF.Security].[Group].[HasSpecialViewAccess]
        , [RDF.Security].[Group].[HasSpecialEditAccess]
        , [RDF.Security].[Group].[Description]
        , [ORCID.].[DefaultORCIDDecisionIDMapping].[DefaultORCIDDecisionID]
    FROM
        [RDF.Security].[Group]
		join [ORCID.].[DefaultORCIDDecisionIDMapping]
		on [RDF.Security].[Group].SecurityGroupID = [ORCID.].[DefaultORCIDDecisionIDMapping].SecurityGroupID

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [ORCID.].[cg2_OrganizationDepartmentsGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [Profile.Data].[Organization.Department].[DepartmentID]
        , [Profile.Data].[Organization.Department].[DepartmentName]
        , [Profile.Data].[Organization.Department].[Visible]
    FROM
        [Profile.Data].[Organization.Department]


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_OrganizationDivisionsGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [Profile.Data].[Organization.Division].[DivisionID]
        , [Profile.Data].[Organization.Division].[DivisionName]
    FROM
        [Profile.Data].[Organization.Division]


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [ORCID.].[cg2_OrganizationInstitutionGet]
 
    @InstitutionID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [Profile.Data].[Organization.Institution].[InstitutionID]
        , [Profile.Data].[Organization.Institution].[InstitutionName]
        , [Profile.Data].[Organization.Institution].[InstitutionAbbreviation]
  --      , [Profile.Data].[Organization.Institution].[City]
  --      , [Profile.Data].[Organization.Institution].[State]
  --      , [Profile.Data].[Organization.Institution].[Country]
  --      , [Profile.Data].[Organization.Institution].[RingGoldID]
    FROM
        [Profile.Data].[Organization.Institution]
    WHERE
        [Profile.Data].[Organization.Institution].[InstitutionID] = @InstitutionID



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [ORCID.].[cg2_OrganizationInstitutionsGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [Profile.Data].[Organization.Institution].[InstitutionID]
        , [Profile.Data].[Organization.Institution].[InstitutionName]
        , [Profile.Data].[Organization.Institution].[InstitutionAbbreviation]
    FROM
        [Profile.Data].[Organization.Institution]


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonAdd]

    @PersonID  INT =NULL OUTPUT 
    , @InternalUsername  NVARCHAR(100) 
    , @PersonStatusTypeID  INT 
    , @CreateUnlessOptOut  BIT 
    , @ORCID  VARCHAR(50) =NULL
    , @ORCIDRecorded  SMALLDATETIME =NULL
    , @FirstName  NVARCHAR(150) =NULL
    , @LastName  NVARCHAR(150) =NULL
    , @PublishedName  NVARCHAR(500) =NULL
    , @EmailDecisionID  INT =NULL
    , @EmailAddress  VARCHAR(300) =NULL
    , @AlternateEmailDecisionID  INT =NULL
    , @AgreementAcknowledged  BIT =NULL
    , @Biography  VARCHAR(5000) =NULL
    , @BiographyDecisionID  INT =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3566
 
  
        INSERT INTO [ORCID.].[Person]
        (
            [InternalUsername]
            , [PersonStatusTypeID]
            , [CreateUnlessOptOut]
            , [ORCID]
            , [ORCIDRecorded]
            , [FirstName]
            , [LastName]
            , [PublishedName]
            , [EmailDecisionID]
            , [EmailAddress]
            , [AlternateEmailDecisionID]
            , [AgreementAcknowledged]
            , [Biography]
            , [BiographyDecisionID]
        )
        (
            SELECT
            @InternalUsername
            , @PersonStatusTypeID
            , @CreateUnlessOptOut
            , @ORCID
            , @ORCIDRecorded
            , @FirstName
            , @LastName
            , @PublishedName
            , @EmailDecisionID
            , @EmailAddress
            , @AlternateEmailDecisionID
            , @AgreementAcknowledged
            , @Biography
            , @BiographyDecisionID
        )
   
        SET @intReturnVal = @@error
        SET @PersonID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the Person record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonAffiliationAdd]

    @PersonAffiliationID  INT =NULL OUTPUT 
    , @ProfilesID  INT 
    , @AffiliationTypeID  INT 
    , @PersonID  INT 
    , @PersonMessageID  INT =NULL
    , @DecisionID  INT 
    , @DepartmentName  VARCHAR(4000) =NULL
    , @RoleTitle  VARCHAR(200) =NULL
    , @StartDate  SMALLDATETIME =NULL
    , @EndDate  SMALLDATETIME =NULL
    , @OrganizationName  VARCHAR(4000) 
    , @OrganizationCity  VARCHAR(4000) =NULL
    , @OrganizationRegion  VARCHAR(2) =NULL
    , @OrganizationCountry  VARCHAR(2) =NULL
    , @DisambiguationID  VARCHAR(500) =NULL
    , @DisambiguationSource  VARCHAR(500) =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 4467
 
  
        INSERT INTO [ORCID.].[PersonAffiliation]
        (
            [ProfilesID]
            , [AffiliationTypeID]
            , [PersonID]
            , [PersonMessageID]
            , [DecisionID]
            , [DepartmentName]
            , [RoleTitle]
            , [StartDate]
            , [EndDate]
            , [OrganizationName]
            , [OrganizationCity]
            , [OrganizationRegion]
            , [OrganizationCountry]
            , [DisambiguationID]
            , [DisambiguationSource]
        )
        (
            SELECT
            @ProfilesID
            , @AffiliationTypeID
            , @PersonID
            , @PersonMessageID
            , @DecisionID
            , @DepartmentName
            , @RoleTitle
            , @StartDate
            , @EndDate
            , @OrganizationName
            , @OrganizationCity
            , @OrganizationRegion
            , @OrganizationCountry
            , @DisambiguationID
            , @DisambiguationSource
        )
   
        SET @intReturnVal = @@error
        SET @PersonAffiliationID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the PersonAffiliation record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonAffiliationDelete]
 
    @PersonAffiliationID  INT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[PersonAffiliation] WHERE         [ORCID.].[PersonAffiliation].[PersonAffiliationID] = @PersonAffiliationID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the PersonAffiliation record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonAffiliationEdit]

    @PersonAffiliationID  INT =NULL OUTPUT 
    , @ProfilesID  INT 
    , @AffiliationTypeID  INT 
    , @PersonID  INT 
    , @PersonMessageID  INT =NULL
    , @DecisionID  INT 
    , @DepartmentName  VARCHAR(4000) =NULL
    , @RoleTitle  VARCHAR(200) =NULL
    , @StartDate  SMALLDATETIME =NULL
    , @EndDate  SMALLDATETIME =NULL
    , @OrganizationName  VARCHAR(4000) 
    , @OrganizationCity  VARCHAR(4000) =NULL
    , @OrganizationRegion  VARCHAR(2) =NULL
    , @OrganizationCountry  VARCHAR(2) =NULL
    , @DisambiguationID  VARCHAR(500) =NULL
    , @DisambiguationSource  VARCHAR(500) =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 4467
 
  
        UPDATE [ORCID.].[PersonAffiliation]
        SET
            [ProfilesID] = @ProfilesID
            , [AffiliationTypeID] = @AffiliationTypeID
            , [PersonID] = @PersonID
            , [PersonMessageID] = @PersonMessageID
            , [DecisionID] = @DecisionID
            , [DepartmentName] = @DepartmentName
            , [RoleTitle] = @RoleTitle
            , [StartDate] = @StartDate
            , [EndDate] = @EndDate
            , [OrganizationName] = @OrganizationName
            , [OrganizationCity] = @OrganizationCity
            , [OrganizationRegion] = @OrganizationRegion
            , [OrganizationCountry] = @OrganizationCountry
            , [DisambiguationID] = @DisambiguationID
            , [DisambiguationSource] = @DisambiguationSource
        FROM
            [ORCID.].[PersonAffiliation]
        WHERE
        [ORCID.].[PersonAffiliation].[PersonAffiliationID] = @PersonAffiliationID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the PersonAffiliation record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonAffiliationGet]
 
    @PersonAffiliationID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonAffiliation].[PersonAffiliationID]
        , [ORCID.].[PersonAffiliation].[ProfilesID]
        , [ORCID.].[PersonAffiliation].[AffiliationTypeID]
        , [ORCID.].[PersonAffiliation].[PersonID]
        , [ORCID.].[PersonAffiliation].[PersonMessageID]
        , [ORCID.].[PersonAffiliation].[DecisionID]
        , [ORCID.].[PersonAffiliation].[DepartmentName]
        , [ORCID.].[PersonAffiliation].[RoleTitle]
        , [ORCID.].[PersonAffiliation].[StartDate]
        , [ORCID.].[PersonAffiliation].[EndDate]
        , [ORCID.].[PersonAffiliation].[OrganizationName]
        , [ORCID.].[PersonAffiliation].[OrganizationCity]
        , [ORCID.].[PersonAffiliation].[OrganizationRegion]
        , [ORCID.].[PersonAffiliation].[OrganizationCountry]
        , [ORCID.].[PersonAffiliation].[DisambiguationID]
        , [ORCID.].[PersonAffiliation].[DisambiguationSource]
    FROM
        [ORCID.].[PersonAffiliation]
    WHERE
        [ORCID.].[PersonAffiliation].[PersonAffiliationID] = @PersonAffiliationID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonAffiliationGetByDecisionID]
 
    @DecisionID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonAffiliation].[PersonAffiliationID]
        , [ORCID.].[PersonAffiliation].[ProfilesID]
        , [ORCID.].[PersonAffiliation].[AffiliationTypeID]
        , [ORCID.].[PersonAffiliation].[PersonID]
        , [ORCID.].[PersonAffiliation].[PersonMessageID]
        , [ORCID.].[PersonAffiliation].[DecisionID]
        , [ORCID.].[PersonAffiliation].[DepartmentName]
        , [ORCID.].[PersonAffiliation].[RoleTitle]
        , [ORCID.].[PersonAffiliation].[StartDate]
        , [ORCID.].[PersonAffiliation].[EndDate]
        , [ORCID.].[PersonAffiliation].[OrganizationName]
        , [ORCID.].[PersonAffiliation].[OrganizationCity]
        , [ORCID.].[PersonAffiliation].[OrganizationRegion]
        , [ORCID.].[PersonAffiliation].[OrganizationCountry]
        , [ORCID.].[PersonAffiliation].[DisambiguationID]
        , [ORCID.].[PersonAffiliation].[DisambiguationSource]
    FROM
        [ORCID.].[PersonAffiliation]
    WHERE
        [ORCID.].[PersonAffiliation].[DecisionID] = @DecisionID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonAffiliationGetByPersonID]
 
    @PersonID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonAffiliation].[PersonAffiliationID]
        , [ORCID.].[PersonAffiliation].[ProfilesID]
        , [ORCID.].[PersonAffiliation].[AffiliationTypeID]
        , [ORCID.].[PersonAffiliation].[PersonID]
        , [ORCID.].[PersonAffiliation].[PersonMessageID]
        , [ORCID.].[PersonAffiliation].[DecisionID]
        , [ORCID.].[PersonAffiliation].[DepartmentName]
        , [ORCID.].[PersonAffiliation].[RoleTitle]
        , [ORCID.].[PersonAffiliation].[StartDate]
        , [ORCID.].[PersonAffiliation].[EndDate]
        , [ORCID.].[PersonAffiliation].[OrganizationName]
        , [ORCID.].[PersonAffiliation].[OrganizationCity]
        , [ORCID.].[PersonAffiliation].[OrganizationRegion]
        , [ORCID.].[PersonAffiliation].[OrganizationCountry]
        , [ORCID.].[PersonAffiliation].[DisambiguationID]
        , [ORCID.].[PersonAffiliation].[DisambiguationSource]
    FROM
        [ORCID.].[PersonAffiliation]
    WHERE
        [ORCID.].[PersonAffiliation].[PersonID] = @PersonID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonAffiliationGetByPersonMessageID]
 
    @PersonMessageID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonAffiliation].[PersonAffiliationID]
        , [ORCID.].[PersonAffiliation].[ProfilesID]
        , [ORCID.].[PersonAffiliation].[AffiliationTypeID]
        , [ORCID.].[PersonAffiliation].[PersonID]
        , [ORCID.].[PersonAffiliation].[PersonMessageID]
        , [ORCID.].[PersonAffiliation].[DecisionID]
        , [ORCID.].[PersonAffiliation].[DepartmentName]
        , [ORCID.].[PersonAffiliation].[RoleTitle]
        , [ORCID.].[PersonAffiliation].[StartDate]
        , [ORCID.].[PersonAffiliation].[EndDate]
        , [ORCID.].[PersonAffiliation].[OrganizationName]
        , [ORCID.].[PersonAffiliation].[OrganizationCity]
        , [ORCID.].[PersonAffiliation].[OrganizationRegion]
        , [ORCID.].[PersonAffiliation].[OrganizationCountry]
        , [ORCID.].[PersonAffiliation].[DisambiguationID]
        , [ORCID.].[PersonAffiliation].[DisambiguationSource]
    FROM
        [ORCID.].[PersonAffiliation]
    WHERE
        [ORCID.].[PersonAffiliation].[PersonMessageID] = @PersonMessageID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonAffiliationGetByProfilesIDAndAffiliationTypeID]
 
    @ProfilesID  INT 
    , @AffiliationTypeID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonAffiliation].[PersonAffiliationID]
        , [ORCID.].[PersonAffiliation].[ProfilesID]
        , [ORCID.].[PersonAffiliation].[AffiliationTypeID]
        , [ORCID.].[PersonAffiliation].[PersonID]
        , [ORCID.].[PersonAffiliation].[PersonMessageID]
        , [ORCID.].[PersonAffiliation].[DecisionID]
        , [ORCID.].[PersonAffiliation].[DepartmentName]
        , [ORCID.].[PersonAffiliation].[RoleTitle]
        , [ORCID.].[PersonAffiliation].[StartDate]
        , [ORCID.].[PersonAffiliation].[EndDate]
        , [ORCID.].[PersonAffiliation].[OrganizationName]
        , [ORCID.].[PersonAffiliation].[OrganizationCity]
        , [ORCID.].[PersonAffiliation].[OrganizationRegion]
        , [ORCID.].[PersonAffiliation].[OrganizationCountry]
        , [ORCID.].[PersonAffiliation].[DisambiguationID]
        , [ORCID.].[PersonAffiliation].[DisambiguationSource]
    FROM
        [ORCID.].[PersonAffiliation]
    WHERE
        [ORCID.].[PersonAffiliation].[ProfilesID] = @ProfilesID
        AND [ORCID.].[PersonAffiliation].[AffiliationTypeID] = @AffiliationTypeID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonAffiliationsGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonAffiliation].[PersonAffiliationID]
        , [ORCID.].[PersonAffiliation].[ProfilesID]
        , [ORCID.].[PersonAffiliation].[AffiliationTypeID]
        , [ORCID.].[PersonAffiliation].[PersonID]
        , [ORCID.].[PersonAffiliation].[PersonMessageID]
        , [ORCID.].[PersonAffiliation].[DecisionID]
        , [ORCID.].[PersonAffiliation].[DepartmentName]
        , [ORCID.].[PersonAffiliation].[RoleTitle]
        , [ORCID.].[PersonAffiliation].[StartDate]
        , [ORCID.].[PersonAffiliation].[EndDate]
        , [ORCID.].[PersonAffiliation].[OrganizationName]
        , [ORCID.].[PersonAffiliation].[OrganizationCity]
        , [ORCID.].[PersonAffiliation].[OrganizationRegion]
        , [ORCID.].[PersonAffiliation].[OrganizationCountry]
        , [ORCID.].[PersonAffiliation].[DisambiguationID]
        , [ORCID.].[PersonAffiliation].[DisambiguationSource]
    FROM
        [ORCID.].[PersonAffiliation]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonAlternateEmailAdd]

    @PersonAlternateEmailID  INT =NULL OUTPUT 
    , @PersonID  INT 
    , @EmailAddress  VARCHAR(200) 
    , @PersonMessageID  INT =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3579
 
  
        INSERT INTO [ORCID.].[PersonAlternateEmail]
        (
            [PersonID]
            , [EmailAddress]
            , [PersonMessageID]
        )
        (
            SELECT
            @PersonID
            , @EmailAddress
            , @PersonMessageID
        )
   
        SET @intReturnVal = @@error
        SET @PersonAlternateEmailID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the PersonAlternateEmail record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonAlternateEmailDelete]
 
    @PersonAlternateEmailID  INT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[PersonAlternateEmail] WHERE         [ORCID.].[PersonAlternateEmail].[PersonAlternateEmailID] = @PersonAlternateEmailID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the PersonAlternateEmail record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonAlternateEmailEdit]

    @PersonAlternateEmailID  INT =NULL OUTPUT 
    , @PersonID  INT 
    , @EmailAddress  VARCHAR(200) 
    , @PersonMessageID  INT =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3579
 
  
        UPDATE [ORCID.].[PersonAlternateEmail]
        SET
            [PersonID] = @PersonID
            , [EmailAddress] = @EmailAddress
            , [PersonMessageID] = @PersonMessageID
        FROM
            [ORCID.].[PersonAlternateEmail]
        WHERE
        [ORCID.].[PersonAlternateEmail].[PersonAlternateEmailID] = @PersonAlternateEmailID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the PersonAlternateEmail record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonAlternateEmailGet]
 
    @PersonAlternateEmailID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonAlternateEmail].[PersonAlternateEmailID]
        , [ORCID.].[PersonAlternateEmail].[PersonID]
        , [ORCID.].[PersonAlternateEmail].[EmailAddress]
        , [ORCID.].[PersonAlternateEmail].[PersonMessageID]
    FROM
        [ORCID.].[PersonAlternateEmail]
    WHERE
        [ORCID.].[PersonAlternateEmail].[PersonAlternateEmailID] = @PersonAlternateEmailID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonAlternateEmailGetByPersonID]
 
    @PersonID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonAlternateEmail].[PersonAlternateEmailID]
        , [ORCID.].[PersonAlternateEmail].[PersonID]
        , [ORCID.].[PersonAlternateEmail].[EmailAddress]
        , [ORCID.].[PersonAlternateEmail].[PersonMessageID]
    FROM
        [ORCID.].[PersonAlternateEmail]
    WHERE
        [ORCID.].[PersonAlternateEmail].[PersonID] = @PersonID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonAlternateEmailGetByPersonMessageID]
 
    @PersonMessageID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonAlternateEmail].[PersonAlternateEmailID]
        , [ORCID.].[PersonAlternateEmail].[PersonID]
        , [ORCID.].[PersonAlternateEmail].[EmailAddress]
        , [ORCID.].[PersonAlternateEmail].[PersonMessageID]
    FROM
        [ORCID.].[PersonAlternateEmail]
    WHERE
        [ORCID.].[PersonAlternateEmail].[PersonMessageID] = @PersonMessageID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonAlternateEmailsGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonAlternateEmail].[PersonAlternateEmailID]
        , [ORCID.].[PersonAlternateEmail].[PersonID]
        , [ORCID.].[PersonAlternateEmail].[EmailAddress]
        , [ORCID.].[PersonAlternateEmail].[PersonMessageID]
    FROM
        [ORCID.].[PersonAlternateEmail]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonDelete]
 
    @PersonID  INT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[Person] WHERE         [ORCID.].[Person].[PersonID] = @PersonID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the Person record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonEdit]

    @PersonID  INT =NULL OUTPUT 
    , @InternalUsername  NVARCHAR(100) 
    , @PersonStatusTypeID  INT 
    , @CreateUnlessOptOut  BIT 
    , @ORCID  VARCHAR(50) =NULL
    , @ORCIDRecorded  SMALLDATETIME =NULL
    , @FirstName  NVARCHAR(150) =NULL
    , @LastName  NVARCHAR(150) =NULL
    , @PublishedName  NVARCHAR(500) =NULL
    , @EmailDecisionID  INT =NULL
    , @EmailAddress  VARCHAR(300) =NULL
    , @AlternateEmailDecisionID  INT =NULL
    , @AgreementAcknowledged  BIT =NULL
    , @Biography  VARCHAR(5000) =NULL
    , @BiographyDecisionID  INT =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3566
 
  
        UPDATE [ORCID.].[Person]
        SET
            [InternalUsername] = @InternalUsername
            , [PersonStatusTypeID] = @PersonStatusTypeID
            , [CreateUnlessOptOut] = @CreateUnlessOptOut
            , [ORCID] = @ORCID
            , [ORCIDRecorded] = @ORCIDRecorded
            , [FirstName] = @FirstName
            , [LastName] = @LastName
            , [PublishedName] = @PublishedName
            , [EmailDecisionID] = @EmailDecisionID
            , [EmailAddress] = @EmailAddress
            , [AlternateEmailDecisionID] = @AlternateEmailDecisionID
            , [AgreementAcknowledged] = @AgreementAcknowledged
            , [Biography] = @Biography
            , [BiographyDecisionID] = @BiographyDecisionID
        FROM
            [ORCID.].[Person]
        WHERE
        [ORCID.].[Person].[PersonID] = @PersonID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the Person record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [ORCID.].[cg2_PersonFacultyRankGet]
 
    @FacultyRankID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [Profile.Data].[Person.FacultyRank].[FacultyRankID]
        , [Profile.Data].[Person.FacultyRank].[FacultyRank]
        , [Profile.Data].[Person.FacultyRank].[FacultyRankSort]
        , [Profile.Data].[Person.FacultyRank].[Visible]
    FROM
        [Profile.Data].[Person.FacultyRank]
    WHERE
        [Profile.Data].[Person.FacultyRank].[FacultyRankID] = @FacultyRankID



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonFacultyRanksGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [Profile.Data].[Person.FacultyRank].[FacultyRankID]
        , [Profile.Data].[Person.FacultyRank].[FacultyRank]
        , [Profile.Data].[Person.FacultyRank].[FacultyRankSort]
        , [Profile.Data].[Person.FacultyRank].[Visible]
    FROM
        [Profile.Data].[Person.FacultyRank]


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonGet]
 
    @PersonID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[Person].[PersonID]
        , [ORCID.].[Person].[InternalUsername]
        , [ORCID.].[Person].[PersonStatusTypeID]
        , [ORCID.].[Person].[CreateUnlessOptOut]
        , [ORCID.].[Person].[ORCID]
        , [ORCID.].[Person].[ORCIDRecorded]
        , [ORCID.].[Person].[FirstName]
        , [ORCID.].[Person].[LastName]
        , [ORCID.].[Person].[PublishedName]
        , [ORCID.].[Person].[EmailDecisionID]
        , [ORCID.].[Person].[EmailAddress]
        , [ORCID.].[Person].[AlternateEmailDecisionID]
        , [ORCID.].[Person].[AgreementAcknowledged]
        , [ORCID.].[Person].[Biography]
        , [ORCID.].[Person].[BiographyDecisionID]
    FROM
        [ORCID.].[Person]
    WHERE
        [ORCID.].[Person].[PersonID] = @PersonID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonGetByCreateUnlessOptOut]
 
    @CreateUnlessOptOut  BIT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[Person].[PersonID]
        , [ORCID.].[Person].[InternalUsername]
        , [ORCID.].[Person].[PersonStatusTypeID]
        , [ORCID.].[Person].[CreateUnlessOptOut]
        , [ORCID.].[Person].[ORCID]
        , [ORCID.].[Person].[ORCIDRecorded]
        , [ORCID.].[Person].[FirstName]
        , [ORCID.].[Person].[LastName]
        , [ORCID.].[Person].[PublishedName]
        , [ORCID.].[Person].[EmailDecisionID]
        , [ORCID.].[Person].[EmailAddress]
        , [ORCID.].[Person].[AlternateEmailDecisionID]
        , [ORCID.].[Person].[AgreementAcknowledged]
        , [ORCID.].[Person].[Biography]
        , [ORCID.].[Person].[BiographyDecisionID]
    FROM
        [ORCID.].[Person]
    WHERE
        [ORCID.].[Person].[CreateUnlessOptOut] = @CreateUnlessOptOut




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonGetByInternalUsername]
 
    @InternalUsername  NVARCHAR(100) 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[Person].[PersonID]
        , [ORCID.].[Person].[InternalUsername]
        , [ORCID.].[Person].[PersonStatusTypeID]
        , [ORCID.].[Person].[CreateUnlessOptOut]
        , [ORCID.].[Person].[ORCID]
        , [ORCID.].[Person].[ORCIDRecorded]
        , [ORCID.].[Person].[FirstName]
        , [ORCID.].[Person].[LastName]
        , [ORCID.].[Person].[PublishedName]
        , [ORCID.].[Person].[EmailDecisionID]
        , [ORCID.].[Person].[EmailAddress]
        , [ORCID.].[Person].[AlternateEmailDecisionID]
        , [ORCID.].[Person].[AgreementAcknowledged]
        , [ORCID.].[Person].[Biography]
        , [ORCID.].[Person].[BiographyDecisionID]
    FROM
        [ORCID.].[Person]
    WHERE
        [ORCID.].[Person].[InternalUsername] = @InternalUsername




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonGetByORCID]
 
    @ORCID  VARCHAR(50) 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[Person].[PersonID]
        , [ORCID.].[Person].[InternalUsername]
        , [ORCID.].[Person].[PersonStatusTypeID]
        , [ORCID.].[Person].[CreateUnlessOptOut]
        , [ORCID.].[Person].[ORCID]
        , [ORCID.].[Person].[ORCIDRecorded]
        , [ORCID.].[Person].[FirstName]
        , [ORCID.].[Person].[LastName]
        , [ORCID.].[Person].[PublishedName]
        , [ORCID.].[Person].[EmailDecisionID]
        , [ORCID.].[Person].[EmailAddress]
        , [ORCID.].[Person].[AlternateEmailDecisionID]
        , [ORCID.].[Person].[AgreementAcknowledged]
        , [ORCID.].[Person].[Biography]
        , [ORCID.].[Person].[BiographyDecisionID]
    FROM
        [ORCID.].[Person]
    WHERE
        [ORCID.].[Person].[ORCID] = @ORCID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonGetByPersonStatusTypeID]
 
    @PersonStatusTypeID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[Person].[PersonID]
        , [ORCID.].[Person].[InternalUsername]
        , [ORCID.].[Person].[PersonStatusTypeID]
        , [ORCID.].[Person].[CreateUnlessOptOut]
        , [ORCID.].[Person].[ORCID]
        , [ORCID.].[Person].[ORCIDRecorded]
        , [ORCID.].[Person].[FirstName]
        , [ORCID.].[Person].[LastName]
        , [ORCID.].[Person].[PublishedName]
        , [ORCID.].[Person].[EmailDecisionID]
        , [ORCID.].[Person].[EmailAddress]
        , [ORCID.].[Person].[AlternateEmailDecisionID]
        , [ORCID.].[Person].[AgreementAcknowledged]
        , [ORCID.].[Person].[Biography]
        , [ORCID.].[Person].[BiographyDecisionID]
    FROM
        [ORCID.].[Person]
    WHERE
        [ORCID.].[Person].[PersonStatusTypeID] = @PersonStatusTypeID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonMessageAdd]

    @PersonMessageID  INT =NULL OUTPUT 
    , @PersonID  INT 
    , @XML_Sent  VARCHAR(MAX) =NULL
    , @XML_Response  VARCHAR(MAX) =NULL
    , @ErrorMessage  VARCHAR(1000) =NULL
    , @HttpResponseCode  VARCHAR(50) =NULL
    , @MessagePostSuccess  BIT =NULL
    , @RecordStatusID  INT =NULL
    , @PermissionID  INT =NULL
    , @RequestURL  VARCHAR(1000) =NULL
    , @HeaderPost  VARCHAR(1000) =NULL
    , @UserMessage  VARCHAR(2000) =NULL
    , @PostDate  SMALLDATETIME =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3575
 
  
        INSERT INTO [ORCID.].[PersonMessage]
        (
            [PersonID]
            , [XML_Sent]
            , [XML_Response]
            , [ErrorMessage]
            , [HttpResponseCode]
            , [MessagePostSuccess]
            , [RecordStatusID]
            , [PermissionID]
            , [RequestURL]
            , [HeaderPost]
            , [UserMessage]
            , [PostDate]
        )
        (
            SELECT
            @PersonID
            , @XML_Sent
            , @XML_Response
            , @ErrorMessage
            , @HttpResponseCode
            , @MessagePostSuccess
            , @RecordStatusID
            , @PermissionID
            , @RequestURL
            , @HeaderPost
            , @UserMessage
            , @PostDate
        )
   
        SET @intReturnVal = @@error
        SET @PersonMessageID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the PersonMessage record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonMessageDelete]
 
    @PersonMessageID  INT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[PersonMessage] WHERE         [ORCID.].[PersonMessage].[PersonMessageID] = @PersonMessageID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the PersonMessage record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonMessageEdit]

    @PersonMessageID  INT =NULL OUTPUT 
    , @PersonID  INT 
    , @XML_Sent  VARCHAR(MAX) =NULL
    , @XML_Response  VARCHAR(MAX) =NULL
    , @ErrorMessage  VARCHAR(1000) =NULL
    , @HttpResponseCode  VARCHAR(50) =NULL
    , @MessagePostSuccess  BIT =NULL
    , @RecordStatusID  INT =NULL
    , @PermissionID  INT =NULL
    , @RequestURL  VARCHAR(1000) =NULL
    , @HeaderPost  VARCHAR(1000) =NULL
    , @UserMessage  VARCHAR(2000) =NULL
    , @PostDate  SMALLDATETIME =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3575
 
  
        UPDATE [ORCID.].[PersonMessage]
        SET
            [PersonID] = @PersonID
            , [XML_Sent] = @XML_Sent
            , [XML_Response] = @XML_Response
            , [ErrorMessage] = @ErrorMessage
            , [HttpResponseCode] = @HttpResponseCode
            , [MessagePostSuccess] = @MessagePostSuccess
            , [RecordStatusID] = @RecordStatusID
            , [PermissionID] = @PermissionID
            , [RequestURL] = @RequestURL
            , [HeaderPost] = @HeaderPost
            , [UserMessage] = @UserMessage
            , [PostDate] = @PostDate
        FROM
            [ORCID.].[PersonMessage]
        WHERE
        [ORCID.].[PersonMessage].[PersonMessageID] = @PersonMessageID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the PersonMessage record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonMessageGet]
 
    @PersonMessageID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonMessage].[PersonMessageID]
        , [ORCID.].[PersonMessage].[PersonID]
        , [ORCID.].[PersonMessage].[XML_Sent]
        , [ORCID.].[PersonMessage].[XML_Response]
        , [ORCID.].[PersonMessage].[ErrorMessage]
        , [ORCID.].[PersonMessage].[HttpResponseCode]
        , [ORCID.].[PersonMessage].[MessagePostSuccess]
        , [ORCID.].[PersonMessage].[RecordStatusID]
        , [ORCID.].[PersonMessage].[PermissionID]
        , [ORCID.].[PersonMessage].[RequestURL]
        , [ORCID.].[PersonMessage].[HeaderPost]
        , [ORCID.].[PersonMessage].[UserMessage]
        , [ORCID.].[PersonMessage].[PostDate]
    FROM
        [ORCID.].[PersonMessage]
    WHERE
        [ORCID.].[PersonMessage].[PersonMessageID] = @PersonMessageID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonMessageGetByPersonID]
 
    @PersonID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonMessage].[PersonMessageID]
        , [ORCID.].[PersonMessage].[PersonID]
        , [ORCID.].[PersonMessage].[XML_Sent]
        , [ORCID.].[PersonMessage].[XML_Response]
        , [ORCID.].[PersonMessage].[ErrorMessage]
        , [ORCID.].[PersonMessage].[HttpResponseCode]
        , [ORCID.].[PersonMessage].[MessagePostSuccess]
        , [ORCID.].[PersonMessage].[RecordStatusID]
        , [ORCID.].[PersonMessage].[PermissionID]
        , [ORCID.].[PersonMessage].[RequestURL]
        , [ORCID.].[PersonMessage].[HeaderPost]
        , [ORCID.].[PersonMessage].[UserMessage]
        , [ORCID.].[PersonMessage].[PostDate]
    FROM
        [ORCID.].[PersonMessage]
    WHERE
        [ORCID.].[PersonMessage].[PersonID] = @PersonID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonMessageGetByPersonIDAndRecordStatusID]
 
    @PersonID  INT 
    , @RecordStatusID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonMessage].[PersonMessageID]
        , [ORCID.].[PersonMessage].[PersonID]
        , [ORCID.].[PersonMessage].[XML_Sent]
        , [ORCID.].[PersonMessage].[XML_Response]
        , [ORCID.].[PersonMessage].[ErrorMessage]
        , [ORCID.].[PersonMessage].[HttpResponseCode]
        , [ORCID.].[PersonMessage].[MessagePostSuccess]
        , [ORCID.].[PersonMessage].[RecordStatusID]
        , [ORCID.].[PersonMessage].[PermissionID]
        , [ORCID.].[PersonMessage].[RequestURL]
        , [ORCID.].[PersonMessage].[HeaderPost]
        , [ORCID.].[PersonMessage].[UserMessage]
        , [ORCID.].[PersonMessage].[PostDate]
    FROM
        [ORCID.].[PersonMessage]
    WHERE
        [ORCID.].[PersonMessage].[PersonID] = @PersonID
        AND [ORCID.].[PersonMessage].[RecordStatusID] = @RecordStatusID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonMessageGetByPersonIDAndRecordStatusIDAndPermissionID]
 
    @PersonID  INT 
    , @RecordStatusID  INT 
    , @PermissionID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonMessage].[PersonMessageID]
        , [ORCID.].[PersonMessage].[PersonID]
        , [ORCID.].[PersonMessage].[XML_Sent]
        , [ORCID.].[PersonMessage].[XML_Response]
        , [ORCID.].[PersonMessage].[ErrorMessage]
        , [ORCID.].[PersonMessage].[HttpResponseCode]
        , [ORCID.].[PersonMessage].[MessagePostSuccess]
        , [ORCID.].[PersonMessage].[RecordStatusID]
        , [ORCID.].[PersonMessage].[PermissionID]
        , [ORCID.].[PersonMessage].[RequestURL]
        , [ORCID.].[PersonMessage].[HeaderPost]
        , [ORCID.].[PersonMessage].[UserMessage]
        , [ORCID.].[PersonMessage].[PostDate]
    FROM
        [ORCID.].[PersonMessage]
    WHERE
        [ORCID.].[PersonMessage].[PersonID] = @PersonID
        AND [ORCID.].[PersonMessage].[RecordStatusID] = @RecordStatusID
        AND [ORCID.].[PersonMessage].[PermissionID] = @PermissionID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonMessagesGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonMessage].[PersonMessageID]
        , [ORCID.].[PersonMessage].[PersonID]
        , [ORCID.].[PersonMessage].[XML_Sent]
        , [ORCID.].[PersonMessage].[XML_Response]
        , [ORCID.].[PersonMessage].[ErrorMessage]
        , [ORCID.].[PersonMessage].[HttpResponseCode]
        , [ORCID.].[PersonMessage].[MessagePostSuccess]
        , [ORCID.].[PersonMessage].[RecordStatusID]
        , [ORCID.].[PersonMessage].[PermissionID]
        , [ORCID.].[PersonMessage].[RequestURL]
        , [ORCID.].[PersonMessage].[HeaderPost]
        , [ORCID.].[PersonMessage].[UserMessage]
        , [ORCID.].[PersonMessage].[PostDate]
    FROM
        [ORCID.].[PersonMessage]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonOthernameAdd]

    @PersonOthernameID  INT =NULL OUTPUT 
    , @PersonID  INT 
    , @OtherName  NVARCHAR(500) =NULL
    , @PersonMessageID  INT =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3733
 
  
        INSERT INTO [ORCID.].[PersonOthername]
        (
            [PersonID]
            , [OtherName]
            , [PersonMessageID]
        )
        (
            SELECT
            @PersonID
            , @OtherName
            , @PersonMessageID
        )
   
        SET @intReturnVal = @@error
        SET @PersonOthernameID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the PersonOthername record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonOthernameDelete]
 
    @PersonOthernameID  INT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[PersonOthername] WHERE         [ORCID.].[PersonOthername].[PersonOthernameID] = @PersonOthernameID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the PersonOthername record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonOthernameEdit]

    @PersonOthernameID  INT =NULL OUTPUT 
    , @PersonID  INT 
    , @OtherName  NVARCHAR(500) =NULL
    , @PersonMessageID  INT =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3733
 
  
        UPDATE [ORCID.].[PersonOthername]
        SET
            [PersonID] = @PersonID
            , [OtherName] = @OtherName
            , [PersonMessageID] = @PersonMessageID
        FROM
            [ORCID.].[PersonOthername]
        WHERE
        [ORCID.].[PersonOthername].[PersonOthernameID] = @PersonOthernameID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the PersonOthername record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonOthernameGet]
 
    @PersonOthernameID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonOthername].[PersonOthernameID]
        , [ORCID.].[PersonOthername].[PersonID]
        , [ORCID.].[PersonOthername].[OtherName]
        , [ORCID.].[PersonOthername].[PersonMessageID]
    FROM
        [ORCID.].[PersonOthername]
    WHERE
        [ORCID.].[PersonOthername].[PersonOthernameID] = @PersonOthernameID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonOthernamesGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonOthername].[PersonOthernameID]
        , [ORCID.].[PersonOthername].[PersonID]
        , [ORCID.].[PersonOthername].[OtherName]
        , [ORCID.].[PersonOthername].[PersonMessageID]
    FROM
        [ORCID.].[PersonOthername]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonsGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[Person].[PersonID]
        , [ORCID.].[Person].[InternalUsername]
        , [ORCID.].[Person].[PersonStatusTypeID]
        , [ORCID.].[Person].[CreateUnlessOptOut]
        , [ORCID.].[Person].[ORCID]
        , [ORCID.].[Person].[ORCIDRecorded]
        , [ORCID.].[Person].[FirstName]
        , [ORCID.].[Person].[LastName]
        , [ORCID.].[Person].[PublishedName]
        , [ORCID.].[Person].[EmailDecisionID]
        , [ORCID.].[Person].[EmailAddress]
        , [ORCID.].[Person].[AlternateEmailDecisionID]
        , [ORCID.].[Person].[AgreementAcknowledged]
        , [ORCID.].[Person].[Biography]
        , [ORCID.].[Person].[BiographyDecisionID]
    FROM
        [ORCID.].[Person]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonTokenAdd]

    @PersonTokenID  INT =NULL OUTPUT 
    , @PersonID  INT 
    , @PermissionID  INT 
    , @AccessToken  VARCHAR(50) 
    , @TokenExpiration  SMALLDATETIME 
    , @RefreshToken  VARCHAR(50) =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3595
 
  
        INSERT INTO [ORCID.].[PersonToken]
        (
            [PersonID]
            , [PermissionID]
            , [AccessToken]
            , [TokenExpiration]
            , [RefreshToken]
        )
        (
            SELECT
            @PersonID
            , @PermissionID
            , @AccessToken
            , @TokenExpiration
            , @RefreshToken
        )
   
        SET @intReturnVal = @@error
        SET @PersonTokenID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the PersonToken record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonTokenDelete]
 
    @PersonTokenID  INT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[PersonToken] WHERE         [ORCID.].[PersonToken].[PersonTokenID] = @PersonTokenID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the PersonToken record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonTokenEdit]

    @PersonTokenID  INT =NULL OUTPUT 
    , @PersonID  INT 
    , @PermissionID  INT 
    , @AccessToken  VARCHAR(50) 
    , @TokenExpiration  SMALLDATETIME 
    , @RefreshToken  VARCHAR(50) =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3595
 
  
        UPDATE [ORCID.].[PersonToken]
        SET
            [PersonID] = @PersonID
            , [PermissionID] = @PermissionID
            , [AccessToken] = @AccessToken
            , [TokenExpiration] = @TokenExpiration
            , [RefreshToken] = @RefreshToken
        FROM
            [ORCID.].[PersonToken]
        WHERE
        [ORCID.].[PersonToken].[PersonTokenID] = @PersonTokenID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the PersonToken record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonTokenGet]
 
    @PersonTokenID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonToken].[PersonTokenID]
        , [ORCID.].[PersonToken].[PersonID]
        , [ORCID.].[PersonToken].[PermissionID]
        , [ORCID.].[PersonToken].[AccessToken]
        , [ORCID.].[PersonToken].[TokenExpiration]
        , [ORCID.].[PersonToken].[RefreshToken]
    FROM
        [ORCID.].[PersonToken]
    WHERE
        [ORCID.].[PersonToken].[PersonTokenID] = @PersonTokenID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonTokenGetByPermissionID]
 
    @PermissionID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonToken].[PersonTokenID]
        , [ORCID.].[PersonToken].[PersonID]
        , [ORCID.].[PersonToken].[PermissionID]
        , [ORCID.].[PersonToken].[AccessToken]
        , [ORCID.].[PersonToken].[TokenExpiration]
        , [ORCID.].[PersonToken].[RefreshToken]
    FROM
        [ORCID.].[PersonToken]
    WHERE
        [ORCID.].[PersonToken].[PermissionID] = @PermissionID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonTokenGetByPersonID]
 
    @PersonID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonToken].[PersonTokenID]
        , [ORCID.].[PersonToken].[PersonID]
        , [ORCID.].[PersonToken].[PermissionID]
        , [ORCID.].[PersonToken].[AccessToken]
        , [ORCID.].[PersonToken].[TokenExpiration]
        , [ORCID.].[PersonToken].[RefreshToken]
    FROM
        [ORCID.].[PersonToken]
    WHERE
        [ORCID.].[PersonToken].[PersonID] = @PersonID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonTokenGetByPersonIDAndPermissionID]
 
    @PersonID  INT 
    , @PermissionID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonToken].[PersonTokenID]
        , [ORCID.].[PersonToken].[PersonID]
        , [ORCID.].[PersonToken].[PermissionID]
        , [ORCID.].[PersonToken].[AccessToken]
        , [ORCID.].[PersonToken].[TokenExpiration]
        , [ORCID.].[PersonToken].[RefreshToken]
    FROM
        [ORCID.].[PersonToken]
    WHERE
        [ORCID.].[PersonToken].[PersonID] = @PersonID
        AND [ORCID.].[PersonToken].[PermissionID] = @PermissionID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonTokensGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonToken].[PersonTokenID]
        , [ORCID.].[PersonToken].[PersonID]
        , [ORCID.].[PersonToken].[PermissionID]
        , [ORCID.].[PersonToken].[AccessToken]
        , [ORCID.].[PersonToken].[TokenExpiration]
        , [ORCID.].[PersonToken].[RefreshToken]
    FROM
        [ORCID.].[PersonToken]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonURLAdd]

    @PersonURLID  INT =NULL OUTPUT 
    , @PersonID  INT 
    , @PersonMessageID  INT =NULL
    , @URLName  VARCHAR(500) =NULL
    , @URL  VARCHAR(2000) 
    , @DecisionID  INT 

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3621
 
  
        INSERT INTO [ORCID.].[PersonURL]
        (
            [PersonID]
            , [PersonMessageID]
            , [URLName]
            , [URL]
            , [DecisionID]
        )
        (
            SELECT
            @PersonID
            , @PersonMessageID
            , @URLName
            , @URL
            , @DecisionID
        )
   
        SET @intReturnVal = @@error
        SET @PersonURLID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the PersonURL record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonURLDelete]
 
    @PersonURLID  INT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[PersonURL] WHERE         [ORCID.].[PersonURL].[PersonURLID] = @PersonURLID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the PersonURL record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonURLEdit]

    @PersonURLID  INT =NULL OUTPUT 
    , @PersonID  INT 
    , @PersonMessageID  INT =NULL
    , @URLName  VARCHAR(500) =NULL
    , @URL  VARCHAR(2000) 
    , @DecisionID  INT 

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3621
 
  
        UPDATE [ORCID.].[PersonURL]
        SET
            [PersonID] = @PersonID
            , [PersonMessageID] = @PersonMessageID
            , [URLName] = @URLName
            , [URL] = @URL
            , [DecisionID] = @DecisionID
        FROM
            [ORCID.].[PersonURL]
        WHERE
        [ORCID.].[PersonURL].[PersonURLID] = @PersonURLID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the PersonURL record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonURLGet]
 
    @PersonURLID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonURL].[PersonURLID]
        , [ORCID.].[PersonURL].[PersonID]
        , [ORCID.].[PersonURL].[PersonMessageID]
        , [ORCID.].[PersonURL].[URLName]
        , [ORCID.].[PersonURL].[URL]
        , [ORCID.].[PersonURL].[DecisionID]
    FROM
        [ORCID.].[PersonURL]
    WHERE
        [ORCID.].[PersonURL].[PersonURLID] = @PersonURLID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonURLGetByPersonID]
 
    @PersonID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonURL].[PersonURLID]
        , [ORCID.].[PersonURL].[PersonID]
        , [ORCID.].[PersonURL].[PersonMessageID]
        , [ORCID.].[PersonURL].[URLName]
        , [ORCID.].[PersonURL].[URL]
        , [ORCID.].[PersonURL].[DecisionID]
    FROM
        [ORCID.].[PersonURL]
    WHERE
        [ORCID.].[PersonURL].[PersonID] = @PersonID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonURLGetByPersonIDAndURL]
 
    @PersonID  INT 
    , @URL  VARCHAR(2000) 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonURL].[PersonURLID]
        , [ORCID.].[PersonURL].[PersonID]
        , [ORCID.].[PersonURL].[PersonMessageID]
        , [ORCID.].[PersonURL].[URLName]
        , [ORCID.].[PersonURL].[URL]
        , [ORCID.].[PersonURL].[DecisionID]
    FROM
        [ORCID.].[PersonURL]
    WHERE
        [ORCID.].[PersonURL].[PersonID] = @PersonID
        AND [ORCID.].[PersonURL].[URL] = @URL




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonURLGetByPersonMessageID]
 
    @PersonMessageID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonURL].[PersonURLID]
        , [ORCID.].[PersonURL].[PersonID]
        , [ORCID.].[PersonURL].[PersonMessageID]
        , [ORCID.].[PersonURL].[URLName]
        , [ORCID.].[PersonURL].[URL]
        , [ORCID.].[PersonURL].[DecisionID]
    FROM
        [ORCID.].[PersonURL]
    WHERE
        [ORCID.].[PersonURL].[PersonMessageID] = @PersonMessageID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonURLsGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonURL].[PersonURLID]
        , [ORCID.].[PersonURL].[PersonID]
        , [ORCID.].[PersonURL].[PersonMessageID]
        , [ORCID.].[PersonURL].[URLName]
        , [ORCID.].[PersonURL].[URL]
        , [ORCID.].[PersonURL].[DecisionID]
    FROM
        [ORCID.].[PersonURL]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonWorkAdd]

    @PersonWorkID  INT =NULL OUTPUT 
    , @PersonID  INT 
    , @PersonMessageID  INT =NULL
    , @DecisionID  INT 
    , @WorkTitle  VARCHAR(MAX) 
    , @ShortDescription  VARCHAR(MAX) =NULL
    , @WorkCitation  VARCHAR(MAX) =NULL
    , @WorkType  VARCHAR(500) =NULL
    , @URL  VARCHAR(1000) =NULL
    , @SubTitle  VARCHAR(MAX) =NULL
    , @WorkCitationType  VARCHAR(500) =NULL
    , @PubDate  SMALLDATETIME =NULL
    , @PublicationMediaType  VARCHAR(500) =NULL
    , @PubID  NVARCHAR(50) 

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3607
 
  
        INSERT INTO [ORCID.].[PersonWork]
        (
            [PersonID]
            , [PersonMessageID]
            , [DecisionID]
            , [WorkTitle]
            , [ShortDescription]
            , [WorkCitation]
            , [WorkType]
            , [URL]
            , [SubTitle]
            , [WorkCitationType]
            , [PubDate]
            , [PublicationMediaType]
            , [PubID]
        )
        (
            SELECT
            @PersonID
            , @PersonMessageID
            , @DecisionID
            , @WorkTitle
            , @ShortDescription
            , @WorkCitation
            , @WorkType
            , @URL
            , @SubTitle
            , @WorkCitationType
            , @PubDate
            , @PublicationMediaType
            , @PubID
        )
   
        SET @intReturnVal = @@error
        SET @PersonWorkID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the PersonWork record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonWorkDelete]
 
    @PersonWorkID  INT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[PersonWork] WHERE         [ORCID.].[PersonWork].[PersonWorkID] = @PersonWorkID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the PersonWork record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonWorkEdit]

    @PersonWorkID  INT =NULL OUTPUT 
    , @PersonID  INT 
    , @PersonMessageID  INT =NULL
    , @DecisionID  INT 
    , @WorkTitle  VARCHAR(MAX) 
    , @ShortDescription  VARCHAR(MAX) =NULL
    , @WorkCitation  VARCHAR(MAX) =NULL
    , @WorkType  VARCHAR(500) =NULL
    , @URL  VARCHAR(1000) =NULL
    , @SubTitle  VARCHAR(MAX) =NULL
    , @WorkCitationType  VARCHAR(500) =NULL
    , @PubDate  SMALLDATETIME =NULL
    , @PublicationMediaType  VARCHAR(500) =NULL
    , @PubID  NVARCHAR(50) 

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3607
 
  
        UPDATE [ORCID.].[PersonWork]
        SET
            [PersonID] = @PersonID
            , [PersonMessageID] = @PersonMessageID
            , [DecisionID] = @DecisionID
            , [WorkTitle] = @WorkTitle
            , [ShortDescription] = @ShortDescription
            , [WorkCitation] = @WorkCitation
            , [WorkType] = @WorkType
            , [URL] = @URL
            , [SubTitle] = @SubTitle
            , [WorkCitationType] = @WorkCitationType
            , [PubDate] = @PubDate
            , [PublicationMediaType] = @PublicationMediaType
            , [PubID] = @PubID
        FROM
            [ORCID.].[PersonWork]
        WHERE
        [ORCID.].[PersonWork].[PersonWorkID] = @PersonWorkID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the PersonWork record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonWorkGet]
 
    @PersonWorkID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonWork].[PersonWorkID]
        , [ORCID.].[PersonWork].[PersonID]
        , [ORCID.].[PersonWork].[PersonMessageID]
        , [ORCID.].[PersonWork].[DecisionID]
        , [ORCID.].[PersonWork].[WorkTitle]
        , [ORCID.].[PersonWork].[ShortDescription]
        , [ORCID.].[PersonWork].[WorkCitation]
        , [ORCID.].[PersonWork].[WorkType]
        , [ORCID.].[PersonWork].[URL]
        , [ORCID.].[PersonWork].[SubTitle]
        , [ORCID.].[PersonWork].[WorkCitationType]
        , [ORCID.].[PersonWork].[PubDate]
        , [ORCID.].[PersonWork].[PublicationMediaType]
        , [ORCID.].[PersonWork].[PubID]
    FROM
        [ORCID.].[PersonWork]
    WHERE
        [ORCID.].[PersonWork].[PersonWorkID] = @PersonWorkID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonWorkGetByDecisionID]
 
    @DecisionID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonWork].[PersonWorkID]
        , [ORCID.].[PersonWork].[PersonID]
        , [ORCID.].[PersonWork].[PersonMessageID]
        , [ORCID.].[PersonWork].[DecisionID]
        , [ORCID.].[PersonWork].[WorkTitle]
        , [ORCID.].[PersonWork].[ShortDescription]
        , [ORCID.].[PersonWork].[WorkCitation]
        , [ORCID.].[PersonWork].[WorkType]
        , [ORCID.].[PersonWork].[URL]
        , [ORCID.].[PersonWork].[SubTitle]
        , [ORCID.].[PersonWork].[WorkCitationType]
        , [ORCID.].[PersonWork].[PubDate]
        , [ORCID.].[PersonWork].[PublicationMediaType]
        , [ORCID.].[PersonWork].[PubID]
    FROM
        [ORCID.].[PersonWork]
    WHERE
        [ORCID.].[PersonWork].[DecisionID] = @DecisionID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonWorkGetByPersonID]
 
    @PersonID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonWork].[PersonWorkID]
        , [ORCID.].[PersonWork].[PersonID]
        , [ORCID.].[PersonWork].[PersonMessageID]
        , [ORCID.].[PersonWork].[DecisionID]
        , [ORCID.].[PersonWork].[WorkTitle]
        , [ORCID.].[PersonWork].[ShortDescription]
        , [ORCID.].[PersonWork].[WorkCitation]
        , [ORCID.].[PersonWork].[WorkType]
        , [ORCID.].[PersonWork].[URL]
        , [ORCID.].[PersonWork].[SubTitle]
        , [ORCID.].[PersonWork].[WorkCitationType]
        , [ORCID.].[PersonWork].[PubDate]
        , [ORCID.].[PersonWork].[PublicationMediaType]
        , [ORCID.].[PersonWork].[PubID]
    FROM
        [ORCID.].[PersonWork]
    WHERE
        [ORCID.].[PersonWork].[PersonID] = @PersonID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonWorkGetByPersonIDAndPubID]
 
    @PersonID  INT 
    , @PubID  NVARCHAR(50) 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonWork].[PersonWorkID]
        , [ORCID.].[PersonWork].[PersonID]
        , [ORCID.].[PersonWork].[PersonMessageID]
        , [ORCID.].[PersonWork].[DecisionID]
        , [ORCID.].[PersonWork].[WorkTitle]
        , [ORCID.].[PersonWork].[ShortDescription]
        , [ORCID.].[PersonWork].[WorkCitation]
        , [ORCID.].[PersonWork].[WorkType]
        , [ORCID.].[PersonWork].[URL]
        , [ORCID.].[PersonWork].[SubTitle]
        , [ORCID.].[PersonWork].[WorkCitationType]
        , [ORCID.].[PersonWork].[PubDate]
        , [ORCID.].[PersonWork].[PublicationMediaType]
        , [ORCID.].[PersonWork].[PubID]
    FROM
        [ORCID.].[PersonWork]
    WHERE
        [ORCID.].[PersonWork].[PersonID] = @PersonID
        AND [ORCID.].[PersonWork].[PubID] = @PubID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonWorkGetByPersonMessageID]
 
    @PersonMessageID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonWork].[PersonWorkID]
        , [ORCID.].[PersonWork].[PersonID]
        , [ORCID.].[PersonWork].[PersonMessageID]
        , [ORCID.].[PersonWork].[DecisionID]
        , [ORCID.].[PersonWork].[WorkTitle]
        , [ORCID.].[PersonWork].[ShortDescription]
        , [ORCID.].[PersonWork].[WorkCitation]
        , [ORCID.].[PersonWork].[WorkType]
        , [ORCID.].[PersonWork].[URL]
        , [ORCID.].[PersonWork].[SubTitle]
        , [ORCID.].[PersonWork].[WorkCitationType]
        , [ORCID.].[PersonWork].[PubDate]
        , [ORCID.].[PersonWork].[PublicationMediaType]
        , [ORCID.].[PersonWork].[PubID]
    FROM
        [ORCID.].[PersonWork]
    WHERE
        [ORCID.].[PersonWork].[PersonMessageID] = @PersonMessageID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonWorkIdentifierAdd]

    @PersonWorkIdentifierID  INT =NULL OUTPUT 
    , @PersonWorkID  INT 
    , @WorkExternalTypeID  INT 
    , @Identifier  VARCHAR(250) 

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3615
 
  
        INSERT INTO [ORCID.].[PersonWorkIdentifier]
        (
            [PersonWorkID]
            , [WorkExternalTypeID]
            , [Identifier]
        )
        (
            SELECT
            @PersonWorkID
            , @WorkExternalTypeID
            , @Identifier
        )
   
        SET @intReturnVal = @@error
        SET @PersonWorkIdentifierID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the PersonWorkIdentifier record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonWorkIdentifierDelete]
 
    @PersonWorkIdentifierID  INT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[PersonWorkIdentifier] WHERE         [ORCID.].[PersonWorkIdentifier].[PersonWorkIdentifierID] = @PersonWorkIdentifierID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the PersonWorkIdentifier record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_PersonWorkIdentifierEdit]

    @PersonWorkIdentifierID  INT =NULL OUTPUT 
    , @PersonWorkID  INT 
    , @WorkExternalTypeID  INT 
    , @Identifier  VARCHAR(250) 

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3615
 
  
        UPDATE [ORCID.].[PersonWorkIdentifier]
        SET
            [PersonWorkID] = @PersonWorkID
            , [WorkExternalTypeID] = @WorkExternalTypeID
            , [Identifier] = @Identifier
        FROM
            [ORCID.].[PersonWorkIdentifier]
        WHERE
        [ORCID.].[PersonWorkIdentifier].[PersonWorkIdentifierID] = @PersonWorkIdentifierID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the PersonWorkIdentifier record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonWorkIdentifierGet]
 
    @PersonWorkIdentifierID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonWorkIdentifier].[PersonWorkIdentifierID]
        , [ORCID.].[PersonWorkIdentifier].[PersonWorkID]
        , [ORCID.].[PersonWorkIdentifier].[WorkExternalTypeID]
        , [ORCID.].[PersonWorkIdentifier].[Identifier]
    FROM
        [ORCID.].[PersonWorkIdentifier]
    WHERE
        [ORCID.].[PersonWorkIdentifier].[PersonWorkIdentifierID] = @PersonWorkIdentifierID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonWorkIdentifierGetByPersonWorkID]
 
    @PersonWorkID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonWorkIdentifier].[PersonWorkIdentifierID]
        , [ORCID.].[PersonWorkIdentifier].[PersonWorkID]
        , [ORCID.].[PersonWorkIdentifier].[WorkExternalTypeID]
        , [ORCID.].[PersonWorkIdentifier].[Identifier]
    FROM
        [ORCID.].[PersonWorkIdentifier]
    WHERE
        [ORCID.].[PersonWorkIdentifier].[PersonWorkID] = @PersonWorkID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonWorkIdentifierGetByPersonWorkIDAndWorkExternalTypeIDAndIdentifier]
 
    @PersonWorkID  INT 
    , @WorkExternalTypeID  INT 
    , @Identifier  VARCHAR(250) 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonWorkIdentifier].[PersonWorkIdentifierID]
        , [ORCID.].[PersonWorkIdentifier].[PersonWorkID]
        , [ORCID.].[PersonWorkIdentifier].[WorkExternalTypeID]
        , [ORCID.].[PersonWorkIdentifier].[Identifier]
    FROM
        [ORCID.].[PersonWorkIdentifier]
    WHERE
        [ORCID.].[PersonWorkIdentifier].[PersonWorkID] = @PersonWorkID
        AND [ORCID.].[PersonWorkIdentifier].[WorkExternalTypeID] = @WorkExternalTypeID
        AND [ORCID.].[PersonWorkIdentifier].[Identifier] = @Identifier




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonWorkIdentifierGetByWorkExternalTypeID]
 
    @WorkExternalTypeID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonWorkIdentifier].[PersonWorkIdentifierID]
        , [ORCID.].[PersonWorkIdentifier].[PersonWorkID]
        , [ORCID.].[PersonWorkIdentifier].[WorkExternalTypeID]
        , [ORCID.].[PersonWorkIdentifier].[Identifier]
    FROM
        [ORCID.].[PersonWorkIdentifier]
    WHERE
        [ORCID.].[PersonWorkIdentifier].[WorkExternalTypeID] = @WorkExternalTypeID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonWorkIdentifiersGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonWorkIdentifier].[PersonWorkIdentifierID]
        , [ORCID.].[PersonWorkIdentifier].[PersonWorkID]
        , [ORCID.].[PersonWorkIdentifier].[WorkExternalTypeID]
        , [ORCID.].[PersonWorkIdentifier].[Identifier]
    FROM
        [ORCID.].[PersonWorkIdentifier]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_PersonWorksGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[PersonWork].[PersonWorkID]
        , [ORCID.].[PersonWork].[PersonID]
        , [ORCID.].[PersonWork].[PersonMessageID]
        , [ORCID.].[PersonWork].[DecisionID]
        , [ORCID.].[PersonWork].[WorkTitle]
        , [ORCID.].[PersonWork].[ShortDescription]
        , [ORCID.].[PersonWork].[WorkCitation]
        , [ORCID.].[PersonWork].[WorkType]
        , [ORCID.].[PersonWork].[URL]
        , [ORCID.].[PersonWork].[SubTitle]
        , [ORCID.].[PersonWork].[WorkCitationType]
        , [ORCID.].[PersonWork].[PubDate]
        , [ORCID.].[PersonWork].[PublicationMediaType]
        , [ORCID.].[PersonWork].[PubID]
    FROM
        [ORCID.].[PersonWork]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_RecordLevelAuditTrailAdd]

    @RecordLevelAuditTrailID  BIGINT =NULL OUTPUT 
    , @MetaTableID  INT 
    , @RowIdentifier  BIGINT 
    , @RecordLevelAuditTypeID  INT 
    , @CreatedDate  SMALLDATETIME 
    , @CreatedBy  VARCHAR(10) 

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
 
  
        INSERT INTO [ORCID.].[RecordLevelAuditTrail]
        (
            [MetaTableID]
            , [RowIdentifier]
            , [RecordLevelAuditTypeID]
            , [CreatedDate]
            , [CreatedBy]
        )
        (
            SELECT
            @MetaTableID
            , @RowIdentifier
            , @RecordLevelAuditTypeID
            , @CreatedDate
            , @CreatedBy
        )
   
        SET @intReturnVal = @@error
        SET @RecordLevelAuditTrailID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the RecordLevelAuditTrail record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_RecordLevelAuditTrailDelete]
 
    @RecordLevelAuditTrailID  BIGINT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[RecordLevelAuditTrail] WHERE         [ORCID.].[RecordLevelAuditTrail].[RecordLevelAuditTrailID] = @RecordLevelAuditTrailID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the RecordLevelAuditTrail record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_RecordLevelAuditTrailEdit]

    @RecordLevelAuditTrailID  BIGINT =NULL OUTPUT 
    , @MetaTableID  INT 
    , @RowIdentifier  BIGINT 
    , @RecordLevelAuditTypeID  INT 
    , @CreatedDate  SMALLDATETIME 
    , @CreatedBy  VARCHAR(10) 

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
 
  
        UPDATE [ORCID.].[RecordLevelAuditTrail]
        SET
            [MetaTableID] = @MetaTableID
            , [RowIdentifier] = @RowIdentifier
            , [RecordLevelAuditTypeID] = @RecordLevelAuditTypeID
            , [CreatedDate] = @CreatedDate
            , [CreatedBy] = @CreatedBy
        FROM
            [ORCID.].[RecordLevelAuditTrail]
        WHERE
        [ORCID.].[RecordLevelAuditTrail].[RecordLevelAuditTrailID] = @RecordLevelAuditTrailID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the RecordLevelAuditTrail record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_RecordLevelAuditTrailGet]
 
    @RecordLevelAuditTrailID  BIGINT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[RecordLevelAuditTrail].[RecordLevelAuditTrailID]
        , [ORCID.].[RecordLevelAuditTrail].[MetaTableID]
        , [ORCID.].[RecordLevelAuditTrail].[RowIdentifier]
        , [ORCID.].[RecordLevelAuditTrail].[RecordLevelAuditTypeID]
        , [ORCID.].[RecordLevelAuditTrail].[CreatedDate]
        , [ORCID.].[RecordLevelAuditTrail].[CreatedBy]
    FROM
        [ORCID.].[RecordLevelAuditTrail]
    WHERE
        [ORCID.].[RecordLevelAuditTrail].[RecordLevelAuditTrailID] = @RecordLevelAuditTrailID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_RecordLevelAuditTrailsGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[RecordLevelAuditTrail].[RecordLevelAuditTrailID]
        , [ORCID.].[RecordLevelAuditTrail].[MetaTableID]
        , [ORCID.].[RecordLevelAuditTrail].[RowIdentifier]
        , [ORCID.].[RecordLevelAuditTrail].[RecordLevelAuditTypeID]
        , [ORCID.].[RecordLevelAuditTrail].[CreatedDate]
        , [ORCID.].[RecordLevelAuditTrail].[CreatedBy]
    FROM
        [ORCID.].[RecordLevelAuditTrail]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_RecordLevelAuditTypeAdd]

    @RecordLevelAuditTypeID  INT =NULL OUTPUT 
    , @AuditType  VARCHAR(50) 

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3629
 
  
        INSERT INTO [ORCID.].[RecordLevelAuditType]
        (
            [AuditType]
        )
        (
            SELECT
            @AuditType
        )
   
        SET @intReturnVal = @@error
        SET @RecordLevelAuditTypeID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the RecordLevelAuditType record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_RecordLevelAuditTypeDelete]
 
    @RecordLevelAuditTypeID  INT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[RecordLevelAuditType] WHERE         [ORCID.].[RecordLevelAuditType].[RecordLevelAuditTypeID] = @RecordLevelAuditTypeID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the RecordLevelAuditType record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_RecordLevelAuditTypeEdit]

    @RecordLevelAuditTypeID  INT =NULL OUTPUT 
    , @AuditType  VARCHAR(50) 

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3629
 
  
        UPDATE [ORCID.].[RecordLevelAuditType]
        SET
            [AuditType] = @AuditType
        FROM
            [ORCID.].[RecordLevelAuditType]
        WHERE
        [ORCID.].[RecordLevelAuditType].[RecordLevelAuditTypeID] = @RecordLevelAuditTypeID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the RecordLevelAuditType record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_RecordLevelAuditTypeGet]
 
    @RecordLevelAuditTypeID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[RecordLevelAuditType].[RecordLevelAuditTypeID]
        , [ORCID.].[RecordLevelAuditType].[AuditType]
    FROM
        [ORCID.].[RecordLevelAuditType]
    WHERE
        [ORCID.].[RecordLevelAuditType].[RecordLevelAuditTypeID] = @RecordLevelAuditTypeID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_RecordLevelAuditTypesGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[RecordLevelAuditType].[RecordLevelAuditTypeID]
        , [ORCID.].[RecordLevelAuditType].[AuditType]
    FROM
        [ORCID.].[RecordLevelAuditType]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_REFDecisionAdd]

    @DecisionID  INT =NULL OUTPUT 
    , @DecisionDescription  VARCHAR(150) 
    , @DecisionDescriptionLong  VARCHAR(500) 

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3730
 
  
        INSERT INTO [ORCID.].[REF_Decision]
        (
            [DecisionDescription]
            , [DecisionDescriptionLong]
        )
        (
            SELECT
            @DecisionDescription
            , @DecisionDescriptionLong
        )
   
        SET @intReturnVal = @@error
        SET @DecisionID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the REF_Decision record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_REFDecisionDelete]
 
    @DecisionID  INT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[REF_Decision] WHERE         [ORCID.].[REF_Decision].[DecisionID] = @DecisionID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the REF_Decision record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_REFDecisionEdit]

    @DecisionID  INT =NULL OUTPUT 
    , @DecisionDescription  VARCHAR(150) 
    , @DecisionDescriptionLong  VARCHAR(500) 

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3730
 
  
        UPDATE [ORCID.].[REF_Decision]
        SET
            [DecisionDescription] = @DecisionDescription
            , [DecisionDescriptionLong] = @DecisionDescriptionLong
        FROM
            [ORCID.].[REF_Decision]
        WHERE
        [ORCID.].[REF_Decision].[DecisionID] = @DecisionID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the REF_Decision record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_REFDecisionGet]
 
    @DecisionID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[REF_Decision].[DecisionID]
        , [ORCID.].[REF_Decision].[DecisionDescription]
        , [ORCID.].[REF_Decision].[DecisionDescriptionLong]
    FROM
        [ORCID.].[REF_Decision]
    WHERE
        [ORCID.].[REF_Decision].[DecisionID] = @DecisionID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_REFDecisionsGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[REF_Decision].[DecisionID]
        , [ORCID.].[REF_Decision].[DecisionDescription]
        , [ORCID.].[REF_Decision].[DecisionDescriptionLong]
    FROM
        [ORCID.].[REF_Decision]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_REFPermissionAdd]

    @PermissionID  INT =NULL OUTPUT 
    , @PermissionScope  VARCHAR(100) 
    , @PermissionDescription  VARCHAR(500) 
    , @MethodAndRequest  VARCHAR(100) =NULL
    , @SuccessMessage  VARCHAR(1000) =NULL
    , @FailedMessage  VARCHAR(1000) =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3722
 
  
        INSERT INTO [ORCID.].[REF_Permission]
        (
            [PermissionScope]
            , [PermissionDescription]
            , [MethodAndRequest]
            , [SuccessMessage]
            , [FailedMessage]
        )
        (
            SELECT
            @PermissionScope
            , @PermissionDescription
            , @MethodAndRequest
            , @SuccessMessage
            , @FailedMessage
        )
   
        SET @intReturnVal = @@error
        SET @PermissionID = @@IDENTITY
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while adding the REF_Permission record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_REFPermissionDelete]
 
    @PermissionID  INT 

 
AS
 
    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
 
 
        DELETE FROM [ORCID.].[REF_Permission] WHERE         [ORCID.].[REF_Permission].[PermissionID] = @PermissionID

 
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while deleting the REF_Permission record.', 11, 11); 
            RETURN @intReturnVal 
        END
    RETURN @intReturnVal



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

 
CREATE PROCEDURE [ORCID.].[cg2_REFPermissionEdit]

    @PermissionID  INT =NULL OUTPUT 
    , @PermissionScope  VARCHAR(100) 
    , @PermissionDescription  VARCHAR(500) 
    , @MethodAndRequest  VARCHAR(100) =NULL
    , @SuccessMessage  VARCHAR(1000) =NULL
    , @FailedMessage  VARCHAR(1000) =NULL

AS


    DECLARE @intReturnVal INT 
    SET @intReturnVal = 0
    DECLARE @strReturn  Varchar(200) 
    SET @intReturnVal = 0
    DECLARE @intRecordLevelAuditTrailID INT 
    DECLARE @intFieldLevelAuditTrailID INT 
    DECLARE @intTableID INT 
    SET @intTableID = 3722
 
  
        UPDATE [ORCID.].[REF_Permission]
        SET
            [PermissionScope] = @PermissionScope
            , [PermissionDescription] = @PermissionDescription
            , [MethodAndRequest] = @MethodAndRequest
            , [SuccessMessage] = @SuccessMessage
            , [FailedMessage] = @FailedMessage
        FROM
            [ORCID.].[REF_Permission]
        WHERE
        [ORCID.].[REF_Permission].[PermissionID] = @PermissionID

        
        SET @intReturnVal = @@error
        IF @intReturnVal <> 0
        BEGIN
            RAISERROR (N'An error occurred while editing the REF_Permission record.', 11, 11); 
            RETURN @intReturnVal 
        END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_REFPermissionGet]
 
    @PermissionID  INT 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[REF_Permission].[PermissionID]
        , [ORCID.].[REF_Permission].[PermissionScope]
        , [ORCID.].[REF_Permission].[PermissionDescription]
        , [ORCID.].[REF_Permission].[MethodAndRequest]
        , [ORCID.].[REF_Permission].[SuccessMessage]
        , [ORCID.].[REF_Permission].[FailedMessage]
    FROM
        [ORCID.].[REF_Permission]
    WHERE
        [ORCID.].[REF_Permission].[PermissionID] = @PermissionID




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_REFPermissionGetByPermissionScope]
 
    @PermissionScope  VARCHAR(100) 

AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[REF_Permission].[PermissionID]
        , [ORCID.].[REF_Permission].[PermissionScope]
        , [ORCID.].[REF_Permission].[PermissionDescription]
        , [ORCID.].[REF_Permission].[MethodAndRequest]
        , [ORCID.].[REF_Permission].[SuccessMessage]
        , [ORCID.].[REF_Permission].[FailedMessage]
    FROM
        [ORCID.].[REF_Permission]
    WHERE
        [ORCID.].[REF_Permission].[PermissionScope] = @PermissionScope




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[cg2_REFPermissionsGet]
 
AS
 
    SELECT TOP 100 PERCENT
        [ORCID.].[REF_Permission].[PermissionID]
        , [ORCID.].[REF_Permission].[PermissionScope]
        , [ORCID.].[REF_Permission].[PermissionDescription]
        , [ORCID.].[REF_Permission].[MethodAndRequest]
        , [ORCID.].[REF_Permission].[SuccessMessage]
        , [ORCID.].[REF_Permission].[FailedMessage]
    FROM
        [ORCID.].[REF_Permission]



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
  Create PROCEDURE [ORCID.].[GetNarrative]
	@Subject BIGINT -- = 147559
AS
BEGIN

	SELECT TOP (200) 
		[ORCID.].[DefaultORCIDDecisionIDMapping].DefaultORCIDDecisionID, 
		ObjectValue AS Overview
	FROM            
		[RDF.].vwTripleValue LEFT JOIN [ORCID.].[DefaultORCIDDecisionIDMapping] ON [RDF.].vwTripleValue.ViewSecurityGroup = [ORCID.].[DefaultORCIDDecisionIDMapping].SecurityGroupID
	WHERE        
		(Subject = @Subject) 
		AND (PredicateValue = N'http://vivoweb.org/ontology/core#overview')

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
Create PROCEDURE [ORCID.].[GetPublications]
	@Subject BIGINT -- = 147559
AS
BEGIN

	DECLARE @AuthorInAuthorship BIGINT -- = 94
	SELECT @AuthorInAuthorship = [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#authorInAuthorship') 

	DECLARE @LinkedInformationResource BIGINT -- = 1535
	SELECT @LinkedInformationResource = [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#linkedInformationResource') 

	DECLARE @InformationResourceReference BIGINT -- = 381
	SELECT @InformationResourceReference = [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#informationResourceReference') 

	SELECT TOP (100) PERCENT 
		Triple_1.TripleID, 
		[RDF.].Triple.SortOrder, 
		[RDF.].Triple.ViewSecurityGroup, 
		[RDF.].Node.Value
	FROM            
		[RDF.].Triple 
		INNER JOIN [RDF.].Triple AS Triple_1 ON [RDF.].Triple.Object = Triple_1.Subject 
		INNER JOIN [RDF.].Triple AS Triple_2 ON Triple_1.Object = Triple_2.Subject 
		INNER JOIN [RDF.].Node ON Triple_2.Object = [RDF.].Node.NodeID
	WHERE        
		([RDF.].Triple.Subject = @Subject) 
		AND ([RDF.].Triple.Predicate = @AuthorInAuthorship) 
		AND (Triple_1.Predicate = @LinkedInformationResource) 
		AND  (Triple_2.Predicate = @InformationResourceReference)
	ORDER BY 
		[RDF.].Triple.SortOrder

END


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [ORCID.].[PeopleWithoutAnORCID]
 
AS
 
    SELECT TOP 100 PERCENT
        [Profile.Data].[Person].[PersonID]
        , [Profile.Data].[Person].[UserID]
        , [Profile.Data].[Person].[EmailAddr]
        , [Profile.Data].[Person].[FacultyRankID]
        , [Profile.Data].[Person].[InternalUsername]
		, [Profile.Data].[Person.FacultyRank].FacultyRank
		, [Profile.Data].[Person].LastName + ', ' + [Profile.Data].[Person].FirstName AS DisplayName
		, [Profile.Data].[Organization.Institution].InstitutionName
		, [Profile.Data].[Organization.Department].DepartmentName
		, [Profile.Data].[Organization.Division].DivisionName
		, OP.ORCID
    FROM
        [Profile.Data].[Person]
		LEFT JOIN [Profile.Data].[Person.FacultyRank] ON [Profile.Data].[Person].FacultyRankID = [Profile.Data].[Person.FacultyRank].FacultyRankID
		LEFT JOIN [ORCID.].Person OP ON [Profile.Data].[Person].InternalUsername = OP.InternalUsername
		INNER JOIN  [Profile.Data].[Person.Affiliation] 
			ON 
				[Profile.Data].[Person].PersonID = [Profile.Data].[Person.Affiliation].PersonID
				AND [Profile.Data].[Person.Affiliation].IsPrimary = 1
		LEFT JOIN   [Profile.Data].[Organization.Institution] ON [Profile.Data].[Person.Affiliation].InstitutionID = [Profile.Data].[Organization.Institution].InstitutionID
		LEFT JOIN   [Profile.Data].[Organization.Department] ON [Profile.Data].[Person.Affiliation].DepartmentID = [Profile.Data].[Organization.Department].DepartmentID
		LEFT JOIN   [Profile.Data].[Organization.Division] ON [Profile.Data].[Person.Affiliation].DivisionID = [Profile.Data].[Organization.Division].DivisionID
	WHERE 
		NOT ([Profile.Data].[Person].EmailAddr IS NULL)
		AND [Profile.Data].[Person].IsActive = 1
		AND [Profile.Data].[Person].Visible = 1
		AND OP.ORCID IS NULL
	ORDER BY
		[Profile.Data].[Organization.Institution].InstitutionName
		, [Profile.Data].[Organization.Department].DepartmentName
		, [Profile.Data].[Organization.Division].DivisionName
		, [Profile.Data].[Person].LastName 
		, [Profile.Data].[Person].FirstName


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [ORCID.].[PeopleWithoutAnORCIDByName]

	@PartialName VARCHAR(100)
 
AS
 
    SELECT TOP 100 PERCENT
        [Profile.Data].[Person].[PersonID]
        , [Profile.Data].[Person].[UserID]
        , [Profile.Data].[Person].[EmailAddr]
        , [Profile.Data].[Person].[FacultyRankID]
        , [Profile.Data].[Person].[InternalUsername]
		, [Profile.Data].[Person.FacultyRank].FacultyRank
		, [Profile.Data].[Person].LastName + ', ' + [Profile.Data].[Person].FirstName AS DisplayName
		, [Profile.Data].[Organization.Institution].InstitutionName
		, [Profile.Data].[Organization.Department].DepartmentName
		, [Profile.Data].[Organization.Division].DivisionName
		, OP.ORCID
    FROM
        [Profile.Data].[Person]
		LEFT JOIN [Profile.Data].[Person.FacultyRank] ON [Profile.Data].[Person].FacultyRankID = [Profile.Data].[Person.FacultyRank].FacultyRankID
		LEFT JOIN [ORCID.].Person OP ON [Profile.Data].[Person].InternalUsername = OP.InternalUsername
		INNER JOIN  [Profile.Data].[Person.Affiliation] 
			ON 
				[Profile.Data].[Person].PersonID = [Profile.Data].[Person.Affiliation].PersonID
				AND [Profile.Data].[Person.Affiliation].IsPrimary = 1
		LEFT JOIN   [Profile.Data].[Organization.Institution] ON [Profile.Data].[Person.Affiliation].InstitutionID = [Profile.Data].[Organization.Institution].InstitutionID
		LEFT JOIN   [Profile.Data].[Organization.Department] ON [Profile.Data].[Person.Affiliation].DepartmentID = [Profile.Data].[Organization.Department].DepartmentID
		LEFT JOIN   [Profile.Data].[Organization.Division] ON [Profile.Data].[Person.Affiliation].DivisionID = [Profile.Data].[Organization.Division].DivisionID
	WHERE 
		NOT ([Profile.Data].[Person].EmailAddr IS NULL)
		AND [Profile.Data].[Person].IsActive = 1
		AND [Profile.Data].[Person].Visible = 1
		AND OP.ORCID IS NULL
		AND 
			(
				[Profile.Data].[Person].LastName + ', ' + [Profile.Data].[Person].FirstName  like '%' + @PartialName + '%'
				OR [Profile.Data].[Person].FirstName + ' ' + [Profile.Data].[Person].LastName  like '%' + @PartialName + '%'
			)
	ORDER BY
		[Profile.Data].[Organization.Institution].InstitutionName
		, [Profile.Data].[Organization.Department].DepartmentName
		, [Profile.Data].[Organization.Division].DivisionName
		, [Profile.Data].[Person].LastName 
		, [Profile.Data].[Person].FirstName



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [RDF.SemWeb].[UpdateHash2Base64]
	@FullUpdate BIT = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	IF @FullUpdate = 1
		TRUNCATE TABLE [RDF.SemWeb].[Hash2Base64]
		
	DECLARE @StartNodeID BIGINT
	SELECT @StartNodeID = ISNULL((SELECT MAX(NodeID) FROM [RDF.SemWeb].[Hash2Base64]),-1)

	INSERT INTO [RDF.SemWeb].[Hash2Base64] (NodeID, SemWebHash)
		SELECT NodeID, [RDF.SemWeb].[fnHash2Base64](ValueHash) SemWebHash
			FROM [RDF.].Node
			WHERE NodeID > @StartNodeID

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[EagleI.UpdateEagleITables]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	select right(ProfilesURI,charindex('/',reverse(ProfilesURI))-1) NodeID, *
		into #e
		from (
			select
				r.x.value('profiles-uri[1]','varchar(1000)') ProfilesURI,
				r.x.value('eagle-i-uri[1]','varchar(1000)') EagleiURI,
				cast(r.x.query('html-fragment[1]/*') as nvarchar(max)) HTML
			from [Profile.Data].[EagleI.ImportXML] e cross apply e.x.nodes('//eagle-i-mappings/eagle-i-mapping') as r(x)
		) t


	select e.*, m.InternalID as PersonID
		into #EagleI
		from #e e
			inner join [RDF.Stage].[InternalNodeMap] m
			on e.NodeID = m.NodeID and m.Class = 'http://xmlns.com/foaf/0.1/Person' and m.InternalType = 'Person'
		where e.NodeID is not null and IsNumeric(e.NodeID) = 1

	truncate table [Profile.Data].[EagleI.HTML]

	insert into [Profile.Data].[EagleI.HTML] (NodeID, PersonID, EagleIURI, HTML)
		select NodeID, PersonID, EagleIURI, HTML from #EagleI

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Framework.].[Log.AddActivity]
	@userId int,
	@personId int = null,
	@subjectId bigint = null, 
	@methodName varchar(255),
	@property varchar(255),
	@propertyID bigint = null,
	@privacyCode int,
	@param1 varchar(255),
	@param2 varchar(255)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	IF (@personId is null)
	BEGIN
		select @personID = InternalID from [RDF.Stage].InternalNodeMap  where class = 'http://xmlns.com/foaf/0.1/Person' and nodeID = @subjectId
	END
	IF (@property is null)
	BEGIN
		select @property = value from [RDF.].Node where NodeID = @propertyID
	END
	INSERT INTO [Framework.].[Log.Activity] (userId, personId, methodName, property, privacyCode, param1, param2) 
		VALUES(@userId, @personId, @methodName, @property, @privacyCode, @param1, @param2)
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Funding.AddUpdateFunding]
	@FundingRoleID VARCHAR(50),
	@PersonID INT,
	@FundingID VARCHAR(50) = NULL,
	@FundingID2 VARCHAR(50) = NULL,
	@RoleLabel VARCHAR(100) = NULL,
	@RoleDescription VARCHAR(max) = NULL,
	@AgreementLabel VARCHAR(2000) = NULL,
	@GrantAwardedBy VARCHAR(1000) = NULL,
	@StartDate DATE = NULL,
	@EndDate DATE = NULL,
	@PrincipalInvestigatorName VARCHAR(100) = NULL,
	@Abstract VARCHAR(MAX) = NULL,
	@Source VARCHAR(20),
	@UserVerified BIT = 1 --Grants populated by disambiguation should use 0 for this. 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @FundingAgreementID VARCHAR(50)

	-- Cleanup input
	SELECT
		@FundingID = NULLIF(LTRIM(RTRIM(@FundingID)),''),
		@FundingID2 = NULLIF(LTRIM(RTRIM(@FundingID2)),''),
		@RoleLabel = NULLIF(LTRIM(RTRIM(@RoleLabel)),''),
		@RoleDescription = NULLIF(LTRIM(RTRIM(@RoleDescription)),''),
		@AgreementLabel = NULLIF(LTRIM(RTRIM(@AgreementLabel)),''),
		@GrantAwardedBy = NULLIF(LTRIM(RTRIM(@GrantAwardedBy)),''),
		@StartDate = NULLIF(@StartDate,'1/1/1900'),
		@EndDate = NULLIF(@EndDate,'1/1/1900'),
		@PrincipalInvestigatorName = NULLIF(LTRIM(RTRIM(@PrincipalInvestigatorName)),''),
		@Abstract = NULLIF(LTRIM(RTRIM(@Abstract)),''),
		@Source = ISNULL(NULLIF(LTRIM(RTRIM(@Source)),''),'Custom')

	SELECT @GrantAwardedBy = 'NIH'
		WHERE @GrantAwardedBy IS NULL AND @Source = 'NIH'

	--BEGIN TRY
	--BEGIN TRANSACTION
	
	IF EXISTS (SELECT * FROM [Profile.Data].[Funding.Role] WHERE FundingRoleID = @FundingRoleID)
	BEGIN
		-- Update existing funding

		SELECT @FundingAgreementID = FundingAgreementID 
			FROM [Profile.Data].[Funding.Role] 
			WHERE FundingRoleID = @FundingRoleID

		UPDATE [Profile.Data].[Funding.Role]
			SET	RoleLabel = @RoleLabel, 
				RoleDescription = @RoleDescription
			WHERE FundingRoleID = @FundingRoleID

		UPDATE [Profile.Data].[Funding.Agreement]
			SET	AgreementLabel = @AgreementLabel,
				FundingID = @FundingID,
				GrantAwardedBy = @GrantAwardedBy,
				StartDate = @StartDate,
				EndDate = @EndDate,
				PrincipalInvestigatorName = @PrincipalInvestigatorName,
				Abstract = @Abstract
			WHERE Source = 'Custom'
				AND FundingAgreementID = @FundingAgreementID
	END 
	ELSE
	BEGIN
		-- Add new funding

		-- Check if the agreement already exists (except for custom funding)
		SELECT @FundingAgreementID = FundingAgreementID
			FROM [Profile.Data].[Funding.Agreement]
			WHERE Source = @Source AND FundingID = @FundingID
				AND Source <> 'Custom'

		-- Create the agreement if it is new
		IF @FundingAgreementID IS NULL
		BEGIN
			SELECT @FundingAgreementID = NEWID() 

			INSERT INTO [Profile.Data].[Funding.Agreement] (FundingAgreementID, [Source], FundingID, FundingID2, AgreementLabel, GrantAwardedBy, StartDate, EndDate, PrincipalInvestigatorName, Abstract) 
				SELECT @FundingAgreementID, @Source, @FundingID, @FundingID2, @AgreementLabel, @GrantAwardedBy, @StartDate, @EndDate, @PrincipalInvestigatorName, @Abstract
		END

		-- Create the role if it does not already exist
		INSERT INTO [Profile.Data].[Funding.Role] (FundingRoleID, PersonID, FundingAgreementID, RoleLabel, RoleDescription)
			SELECT @FundingRoleID, @PersonID, @FundingAgreementID, @RoleLabel, @RoleDescription
			WHERE NOT EXISTS (SELECT * FROM [Profile.Data].[Funding.Role] WHERE PersonID = @PersonID AND FundingAgreementID = @FundingAgreementID)
	END

	-- Insert into the Funding.Add table if the user is manually editing funding
	IF (@UserVerified = 1)
		IF NOT EXISTS (SELECT * FROM [Profile.Data].[Funding.Add] WHERE FundingRoleID = @FundingRoleID)
			INSERT INTO [Profile.Data].[Funding.Add] (FundingRoleID, PersonID, FundingAgreementID)
				SELECT @FundingRoleID, @PersonID, @FundingAgreementID
				FROM [Profile.Data].[Funding.Role]
				WHERE FundingRoleID = @FundingRoleID

	--COMMIT TRANSACTION
	--END TRY
	--BEGIN CATCH
		--Check success
		/*IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=1
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)*/
	--END CATCH
END


GO
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Profile.Data].[Funding.DeleteFunding]
	@FundingRoleID varchar(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRY
	BEGIN TRANSACTION
		INSERT INTO [Profile.Data].[Funding.Delete] ([FundingRoleID], [PersonID], [FundingAgreementID], [Source], [FundingID], [FundingID2])
			SELECT @FundingRoleID, PersonID, r.FundingAgreementID, Source, FundingID, FundingID2
				FROM [Profile.Data].[Funding.Role] r 
					INNER JOIN [Profile.Data].[Funding.Agreement] a
						ON r.FundingAgreementID = a.FundingAgreementID
				WHERE r.FundingRoleID = @FundingRoleID
		DELETE 
			FROM [Profile.Data].[Funding.Add]
			WHERE FundingRoleID = @FundingRoleID
		DELETE 
			FROM [Profile.Data].[Funding.Role]
			WHERE FundingRoleID = @FundingRoleID
		DELETE a
			FROM [Profile.Data].[Funding.Delete] d 
				INNER JOIN [Profile.Data].[Funding.Agreement] a
					ON d.FundingAgreementID = a.FundingAgreementID
			WHERE d.FundingRoleID = @FundingRoleID
				AND NOT EXISTS (
					SELECT * 
					FROM [Profile.Data].[Funding.Role] r
					WHERE r.FundingAgreementID = a.FundingAgreementID
				)
	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		--Check success
		/*IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=1
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)*/
	END CATCH
END

GO
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Profile.Data].[Funding.Entity.UpdateEntityOnePerson]
	@PersonID INT,
	@FundingRoleID VARCHAR(50) = NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	CREATE TABLE #sql (
		i INT IDENTITY(0,1) PRIMARY KEY,
		s NVARCHAR(MAX)
	)
	INSERT INTO #sql (s)
		SELECT	'EXEC [RDF.Stage].ProcessDataMap '
					+'  @DataMapID = '+CAST(DataMapID AS VARCHAR(50))
					+', @InternalIdIn = '+InternalIdIn
					+', @TurnOffIndexing=0, @SaveLog=0; '
		FROM (
			SELECT *, '''SELECT CAST(FundingRoleID AS VARCHAR(50)) FROM [Profile.Data].[Funding.Role] WHERE PersonID = '+CAST(@PersonID AS VARCHAR(50))+'''' InternalIdIn
				FROM [Ontology.].DataMap
				WHERE class = 'http://vivoweb.org/ontology/core#ResearcherRole'
					AND NetworkProperty IS NULL
					AND Property IS NULL
			UNION ALL
			SELECT *, '''' + CAST(@PersonID AS VARCHAR(50)) + '''' InternalIdIn
				FROM [Ontology.].DataMap
				WHERE class = 'http://xmlns.com/foaf/0.1/Person' 
					AND property = 'http://vivoweb.org/ontology/core#hasResearcherRole'
					AND NetworkProperty IS NULL
		) t
		ORDER BY DataMapID

	DECLARE @s NVARCHAR(MAX)
	WHILE EXISTS (SELECT * FROM #sql)
	BEGIN
		SELECT @s = s
			FROM #sql
			WHERE i = (SELECT MIN(i) FROM #sql)
		print @s
		EXEC sp_executesql @s
		DELETE
			FROM #sql
			WHERE i = (SELECT MIN(i) FROM #sql)
	END

END
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Profile.Data].[Funding.GetFundingItem]
	@FundingRoleID VARCHAR(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT
		ISNULL(a.Abstract,'') Abstract,
		ISNULL(a.AgreementLabel,'') AgreementLabel,
		ISNULL(a.EndDate,'1/1/1900') EndDate,
		ISNULL(a.Source,'') Source,
		ISNULL(a.FundingID,'') FundingID,
		ISNULL(a.FundingID2,'') FundingID2,
		ISNULL(a.GrantAwardedBy,'') GrantAwardedBy,
		ISNULL(r.FundingRoleID,'') FundingRoleID,
		ISNULL(r.PersonID,'') PersonID,
		ISNULL(a.PrincipalInvestigatorName,'') PrincipalInvestigatorName,
		ISNULL(r.RoleDescription,'') RoleDescription,
		ISNULL(r.RoleLabel,'') RoleLabel,
		ISNULL(a.StartDate,'1/1/1900') StartDate,
		'' SponsorAwardID
	FROM [Profile.Data].[Funding.Role] r 
		INNER JOIN [Profile.Data].[Funding.Agreement] a
			ON r.FundingAgreementID = a.FundingAgreementID
				AND r.FundingRoleID = @FundingRoleID

END
GO
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Profile.Data].[Funding.GetPersonFunding]
	@PersonID INT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT
		ISNULL(a.Abstract,'') Abstract,
		ISNULL(a.AgreementLabel,'') AgreementLabel,
		ISNULL(a.EndDate,'1/1/1900') EndDate,
		ISNULL(a.Source,'') Source,
		ISNULL(a.FundingID,'') FundingID,
		ISNULL(a.FundingID2,'') FundingID2,
		ISNULL(a.GrantAwardedBy,'') GrantAwardedBy,
		ISNULL(r.FundingRoleID,'') FundingRoleID,
		ISNULL(r.PersonID,'') PersonID,
		ISNULL(a.PrincipalInvestigatorName,'') PrincipalInvestigatorName,
		ISNULL(r.RoleDescription,'') RoleDescription,
		ISNULL(r.RoleLabel,'') RoleLabel,
		ISNULL(a.StartDate,'1/1/1900') StartDate,
		'' SponsorAwardID
	FROM [Profile.Data].[Funding.Role] r 
		INNER JOIN [Profile.Data].[Funding.Agreement] a
			ON r.FundingAgreementID = a.FundingAgreementID
				AND r.PersonID = @PersonID
	ORDER BY StartDate desc, EndDate desc, FundingID

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Funding.GetPersonInfoForDisambiguation] 
	@startRow INT = 0,
	@nextRow INT OUTPUT
AS
BEGIN
SET nocount  ON;
 
 
	DECLARE  @search XML,
				@batchcount INT,
				@baseURI NVARCHAR(max),
				@orcidNodeID NVARCHAR(max),
				@rows INT,
				@batchSize INT

				
	SELECT @batchSize = 1000

	SELECT @baseURI = [Value] FROM [Framework.].[Parameter] WHERE [ParameterID] = 'baseURI'
	SELECT @orcidNodeID = NodeID from [RDF.].Node where Value = 'http://vivoweb.org/ontology/core#orcidId'
	
	SELECT personID, ROW_NUMBER() OVER (ORDER BY personID) AS rownum INTO #personIDs FROM [Profile.Data].Person p
	WHERE IsActive = 1 and not exists (select 1 from [Profile.Data].[Funding.DisambiguationSettings] s where s.PersonID = p.PersonID and enabled = 0)

	SELECT @rows = count(*) FROM #personIDs
	SELECT @nextRow = CASE WHEN @rows > @startRow + @batchSize THEN @startRow + @batchSize ELSE -1 END

	SELECT (
		select p2.personid as PersonID, 
		ISNULL(RTRIM(firstname),'')  "Name/First",
		ISNULL(RTRIM(middlename),'') "Name/Middle",
		ISNULL(RTRIM(p2.lastname),'') "Name/Last",
		ISNULL(RTRIM(suffix),'')     "Name/Suffix",
		d.cnt "LocalDuplicateNames",
		(SELECT DISTINCT ISNULL(LTRIM(ISNULL(emailaddress,p2.emailaddr)),'') Email
				FROM [Profile.Data].[Person.Affiliation] pa
				WHERE pa.personid = p2.personid
			FOR XML PATH(''),TYPE) AS "EmailList",
		(SELECT distinct Organization as Org FROM [Profile.Data].[Funding.DisambiguationOrganizationMapping] m
			JOIN [Profile.Data].[Person.Affiliation] pa
			on m.InstitutionID = pa.InstitutionID 
				or m.InstitutionID is null
			where pa.PersonID = p2.PersonID
			FOR XML PATH(''),ROOT('OrgList'),TYPE),
		(SELECT PMID
				FROM [Profile.Data].[Publication.Person.Add]
				WHERE personid =p2.personid
			FOR XML PATH(''),ROOT('PMIDAddList'),TYPE),
		(SELECT PMID
			FROM [Profile.Data].[Publication.Person.Include]
				WHERE personid =p2.personid
			FOR XML PATH(''),ROOT('PMIDIncludeList'),TYPE),
		(SELECT PMID
			FROM [Profile.Data].[Publication.Person.Exclude]
				WHERE personid =p2.personid
			FOR XML PATH(''),ROOT('PMIDExcludeList'),TYPE),
		(SELECT FundingID FROM [Profile.Data].[Funding.Add] ad
			join [Profile.Data].[Funding.Agreement] ag
				on ad.FundingAgreementID = ag.FundingAgreementID
				and ag.Source = 'NIH'
				WHERE ad.PersonID = p2.PersonID
			FOR XML PATH(''),ROOT('GrantsAddList'),TYPE),
		(SELECT FundingID FROM [Profile.Data].[Funding.Add] ad
			join [Profile.Data].[Funding.Agreement] ag
				on ad.FundingAgreementID = ag.FundingAgreementID
				and ag.Source = 'NIH'
				WHERE ad.PersonID = p2.PersonID
			FOR XML PATH(''),ROOT('GrantsAddList'),TYPE),
		(SELECT FundingID FROM [Profile.Data].[Funding.Delete]
				WHERE Source = 'NIH' and PersonID = p2.PersonID
			FOR XML PATH(''),ROOT('GrantsDeleteList'),TYPE),
		(SELECT @baseURI + CAST(i.NodeID AS VARCHAR) 
			FOR XML PATH(''),ROOT('URI'),TYPE),
				(select n.Value as '*' from [RDF.].Node n join
				[RDF.].Triple t  on n.NodeID = t.Object
				and t.Subject = i.NodeID
				and t.Predicate = @orcidNodeID
			FOR XML PATH(''),ROOT('ORCID'),TYPE)
	FROM [Profile.Data].Person p2 
	  LEFT JOIN ( SELECT [Utility.NLP].[fnNamePart1](firstname)F,
			lastname,
			COUNT(*)cnt
			FROM [Profile.Data].Person 
			GROUP BY [Utility.NLP].[fnNamePart1](firstname), 
				lastname
			)d ON d.f = [Utility.NLP].[fnNamePart1](p2.firstname)
				AND d.lastname = p2.lastname
				AND p2.IsActive = 1 
		LEFT JOIN [RDF.Stage].[InternalNodeMap] i
			ON [InternalType] = 'Person' AND [Class] = 'http://xmlns.com/foaf/0.1/Person' AND [InternalID] = CAST(p2.personid AS VARCHAR(50))
			JOIN #personIDs p3 on p2.personID = p3.personID AND p3.rownum > @startRow and (@nextRow = -1 OR p3.rownum <= @nextRow)
	  for xml path('Person'), root('FindFunding'), type) as X
END


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Funding.LoadDisambiguationResults]
AS
BEGIN
	--------------------------------------------------------------
	-- Get existing and deleted NIH grants
	--------------------------------------------------------------

	SELECT DISTINCT ISNULL(r.PersonID,0) PersonID, ISNULL(a.FundingID2,'') CORE_PROJECT_NUM
		INTO #ExistingRoles
		FROM [Profile.Data].[Funding.Role] r
			INNER JOIN [Profile.Data].[Funding.Agreement] a
				ON r.FundingAgreementID = a.FundingAgreementID
		WHERE a.Source = 'NIH' AND a.FundingID2 <> ''

	ALTER TABLE #ExistingRoles ADD PRIMARY KEY (PersonID, CORE_PROJECT_NUM)


	SELECT DISTINCT ISNULL(PersonID,0) PersonID, ISNULL(FundingID2,'') CORE_PROJECT_NUM
		INTO #DeletedRoles
		FROM [Profile.Data].[Funding.Delete]
		WHERE Source = 'NIH' AND FundingID2 <> ''

	ALTER TABLE #DeletedRoles ADD PRIMARY KEY (PersonID, CORE_PROJECT_NUM)

	--------------------------------------------------------------
	-- Get a list of agreements
	--------------------------------------------------------------

	SELECT 
			ISNULL(NEWID(),'00000000-0000-0000-0000-000000000000') FundingAgreementID,
			ISNULL(FundingID,'') FundingID,
			AgreementLabel,
			GrantAwardedBy,
			StartDate,
			EndDate,
			PrincipalInvestigatorName,
			NULLIF(Abstract,'') Abstract,
			Source,
			FundingID2
		INTO #Agreement
		FROM (
			SELECT *, ROW_NUMBER() OVER (PARTITION BY FundingID ORDER BY PersonID) k
			FROM [Profile.Data].[Funding.DisambiguationResults] e
			WHERE NOT EXISTS (
				SELECT * 
				FROM #DeletedRoles d 
				WHERE d.PersonID=e.PersonID AND d.CORE_PROJECT_NUM=e.FundingID2
			)
		) t
		WHERE k = 1

	ALTER TABLE #Agreement ADD PRIMARY KEY (FundingAgreementID)
	CREATE UNIQUE NONCLUSTERED INDEX idx_FundingID ON #Agreement(FundingID)

	-- Use the current FundingAgreementID if one exists
	UPDATE a
		SET a.FundingAgreementID = h.FundingAgreementID
		FROM #Agreement a
			INNER JOIN [Profile.Data].[Funding.Agreement] h
				ON a.FundingID = h.FundingID
					AND a.FundingID = h.FundingID2
					AND h.Source = 'NIH'

	--------------------------------------------------------------
	-- Get a list of new roles
	--------------------------------------------------------------

	SELECT ISNULL(NEWID(),'00000000-0000-0000-0000-000000000000') FundingRoleID, 
			e.PersonID, a.FundingAgreementID, e.RoleLabel RoleLabel, NULL RoleDescription
		INTO #Role
		FROM [Profile.Data].[Funding.DisambiguationResults] e
			INNER JOIN #Agreement a ON e.FundingID = a.FundingID
		WHERE NOT EXISTS (
			SELECT * 
			FROM #DeletedRoles d 
			WHERE d.PersonID=e.PersonID AND d.CORE_PROJECT_NUM=e.FundingID
		) AND NOT EXISTS (
			SELECT * 
			FROM #ExistingRoles a 
			WHERE a.PersonID=e.PersonID AND a.CORE_PROJECT_NUM=e.FundingID
		)

	ALTER TABLE #Role ADD PRIMARY KEY (FundingRoleID)
	CREATE UNIQUE NONCLUSTERED INDEX idx_PersonAgreement ON #Role(PersonID,FundingAgreementID)


	--------------------------------------------------------------
	-- Update actual tables
	--------------------------------------------------------------

	-- Update agreement information
	UPDATE h
		SET h.AgreementLabel = a.AgreementLabel,
			h.GrantAwardedBy = a.GrantAwardedBy,
			h.StartDate = a.StartDate,
			h.EndDate = a.EndDate,
			h.PrincipalInvestigatorName = a.PrincipalInvestigatorName,
			h.Abstract = a.Abstract
		FROM [Profile.Data].[Funding.Agreement] h
			INNER JOIN #Agreement a 
				ON h.FundingAgreementID = a.FundingAgreementID
		WHERE h.AgreementLabel <> a.AgreementLabel
			OR h.GrantAwardedBy <> a.GrantAwardedBy
			OR h.StartDate <> a.StartDate
			OR h.EndDate <> a.EndDate
			OR h.PrincipalInvestigatorName <> a.PrincipalInvestigatorName
			OR h.Abstract <> a.Abstract

	-- Insert new agreements
	INSERT INTO [Profile.Data].[Funding.Agreement]
		SELECT FundingAgreementID, FundingID, AgreementLabel, GrantAwardedBy, StartDate, EndDate, PrincipalInvestigatorName, Abstract, Source, FundingID2
		FROM #Agreement a
		WHERE FundingAgreementID NOT IN (SELECT FundingAgreementID FROM [Profile.Data].[Funding.Agreement])

	-- Insert new roles
	INSERT INTO [Profile.Data].[Funding.Role]
		SELECT FundingRoleID, PersonID, FundingAgreementID, RoleLabel, RoleDescription
		FROM #Role

	-- Update the Activity log	
	INSERT INTO [Framework.].[Log.Activity] (userId, personId, methodName, property, privacyCode, param1, param2) 
		SELECT 0, PersonID, '[Profile.Data].[Funding.LoadDisambiguationResults]', 'http://vivoweb.org/ontology/core#ResearcherRole', null, FundingRoleID, null 
		FROM #Role
	

	--******************************************************************
	--******************************************************************
	--*** Update RDF
	--******************************************************************
	--******************************************************************


	CREATE TABLE #DataMapID (DataMapID INT PRIMARY KEY)

	INSERT INTO #DataMapID (DataMapID)
		SELECT DataMapID
			FROM [Ontology.].[DataMap]
			WHERE Class IN ('http://vivoweb.org/ontology/core#Grant','http://vivoweb.org/ontology/core#ResearcherRole')
				AND Property IS NULL
				AND NetworkProperty IS NULL 
		UNION ALL
		SELECT DataMapID
			FROM [Ontology.].[DataMap]
			WHERE Class = 'http://vivoweb.org/ontology/core#Grant'
				AND Property IS NOT NULL
				AND NetworkProperty IS NULL 
		UNION ALL
		SELECT DataMapID
			FROM [Ontology.].[DataMap]
			WHERE Class = 'http://vivoweb.org/ontology/core#ResearcherRole'
				AND Property IS NOT NULL
				AND NetworkProperty IS NULL 
		UNION ALL
		SELECT DataMapID
			FROM [Ontology.].[DataMap]
			WHERE Class = 'http://xmlns.com/foaf/0.1/Person'
				AND Property = 'http://vivoweb.org/ontology/core#hasResearcherRole'
				AND NetworkProperty IS NULL 

	DECLARE @DataMapID INT

	WHILE EXISTS (SELECT * FROM #DataMapID)
	BEGIN
		SELECT @DataMapID = (SELECT TOP 1 DataMapID FROM #DataMapID ORDER BY DataMapID)

		EXEC [RDF.Stage].[ProcessDataMap] @DataMapID = @DataMapID, @TurnOffIndexing = 0

		DELETE FROM #DataMapID WHERE DataMapID = @DataMapID
	END
END
GO
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE  [Profile.Data].[Funding.AddDisambiguationLog] (@logID BIGINT, 
												@action VARCHAR(200),
												@actionText varchar(max) = null,
												@newLogID BIGINT OUTPUT )
AS
BEGIN
	IF @action='StartService'
		BEGIN
			DECLARE @logIDtable TABLE (logID BIGINT)
			INSERT INTO [Profile.Data].[Funding.DisambiguationAudit]  (ServiceCallStart)
			OUTPUT inserted.logID into @logIDtable
			VALUES (GETDATE())
			select @newLogID = logID from @logIDtable
		END
	IF @action='EndService'
		BEGIN
			UPDATE [Profile.Data].[Funding.DisambiguationAudit] 
			   SET ServiceCallEnd = GETDATE()
			 WHERE LogID=@LogID
			 select @newLogID = @logID
		END
	IF @action='Error'
		BEGIN
			UPDATE [Profile.Data].[Funding.DisambiguationAudit] 
			   SET ErrorText = @actionText,
				   ProcessEnd  = GETDATE(),
				   Success=0
			 WHERE LogID=@LogID
			 select @newLogID = @logID
		END
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Funding.ParseDisambiguationXML]
	@xml XMl,
	@truncate INT = null
AS
BEGIN
	IF @truncate = 1
	BEGIN
		Truncate table [Profile.Data].[Funding.DisambiguationResults]
	END

	Insert into [Profile.Data].[Funding.DisambiguationResults]
	(PersonID, FundingID, GrantAwardedBy, StartDate, EndDate, PrincipalInvestigatorName,
		AgreementLabel, Abstract, Source, FundingID2, RoleLabel)
	select nref.value('@PersonID','varchar(max)') PersonID,
	sref.value('FundingID[1]','varchar(max)') FundingID,
	sref.value('GrantAwardedBy[1]','varchar(max)') GrantAwardedBy,
	sref.value('StartDate[1]','varchar(max)') StartDate,
	sref.value('EndDate[1]','varchar(max)') EndDate,
	sref.value('PrincipalInvestigatorName[1]','varchar(max)') PrincipalInvestigatorName,
	sref.value('AgreementLabel[1]','varchar(max)') AgreementLabel,
	sref.value('Abstract[1]','varchar(max)') Abstract,
	sref.value('Source[1]','varchar(max)') Source,
	sref.value('FundingID2[1]','varchar(max)') FundingID2,
	sref.value('RoleLabel[1]','varchar(max)') RoleLabel
	from @xml.nodes('//PersonList[1]/Person') as R(nref)
	cross apply R.nref.nodes('Funding') as S(sref)
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Edit.Module].[CustomEditEducationalTraining.StoreItem]
@ExistingEducationalTrainingID BIGINT=NULL, @ExistingEducationalTrainingURI VARCHAR (400)=NULL, @educationalTrainingForID BIGINT=NULL, @educationalTrainingForURI BIGINT=NULL, 
@institution VARCHAR (MAX), @location VARCHAR (MAX),  @degree VARCHAR (MAX)=NULL,
@endDate VARCHAR (MAX)=NULL, @fieldOfStudy VARCHAR (MAX), @SessionID UNIQUEIDENTIFIER=NULL, @Error BIT=NULL OUTPUT, @NodeID BIGINT=NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	/*
	
	This stored procedure either creates or updates an
	AwardReceipt. In both cases a label is required.
	Nodes can be specified either by ID or URI.
	
	*/
	
	SELECT @Error = 0

	-------------------------------------------------
	-- Validate and prepare variables
	-------------------------------------------------
	
	-- Convert URIs to NodeIDs
 	IF (@ExistingEducationalTrainingID IS NULL) AND (@ExistingEducationalTrainingURI IS NOT NULL)
		SELECT @ExistingEducationalTrainingID = [RDF.].fnURI2NodeID(@ExistingEducationalTrainingURI)
 	IF (@educationalTrainingForID IS NULL) AND (@educationalTrainingForURI IS NOT NULL)
		SELECT @educationalTrainingForID = [RDF.].fnURI2NodeID(@educationalTrainingForURI)

	-- Check that some operation will be performed
	IF ((@ExistingEducationalTrainingID IS NULL) AND (@educationalTrainingForID IS NULL))
	BEGIN
		SELECT @Error = 1
		RETURN
	END

	-- Convert properties to NodeIDs
	DECLARE @institutionNodeID BIGINT
	DECLARE @locationNodeID BIGINT
	DECLARE @degreeNodeID BIGINT
	DECLARE @endDateNodeID BIGINT
	DECLARE @fieldOfStudyNodeID BIGINT
	
	SELECT @institutionNodeID = NULL, @locationNodeID = NULL, @degreeNodeID = NULL, @endDateNodeID = NULL, @fieldOfStudyNodeID = NULL
	
	IF IsNull(@institution,'')<>''
		EXEC [RDF.].GetStoreNode @Value = @institution, @Language = NULL, @DataType = NULL,
			@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @institutionNodeID OUTPUT
	IF IsNull(@location,'')<>''
		EXEC [RDF.].GetStoreNode @Value = @location, @Language = NULL, @DataType = NULL,
			@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @locationNodeID OUTPUT
	IF IsNull(@degree,'')<>''
		EXEC [RDF.].GetStoreNode @Value = @degree, @Language = NULL, @DataType = NULL,
			@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @degreeNodeID OUTPUT
	IF IsNull(@endDate,'')<>''
		EXEC [RDF.].GetStoreNode @Value = @endDate, @Language = NULL, @DataType = NULL,
			@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @endDateNodeID OUTPUT
	IF IsNull(@fieldOfStudy,'')<>''
		EXEC [RDF.].GetStoreNode @Value = @fieldOfStudy, @Language = NULL, @DataType = NULL,
			@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @fieldOfStudyNodeID OUTPUT


	DECLARE @label nvarchar(max)
	select @label = isnull(@institution, '') + ', ' + isnull(@fieldOfStudy, '')

	-------------------------------------------------
	-- Handle required nodes and properties
	-------------------------------------------------

	-- Get an EducationalTraining with just a label
	IF (@ExistingEducationalTrainingID IS NOT NULL)
	BEGIN
		-- The EducationalTraining NodeID is the ExistingEducationalTraining
		SELECT @NodeID = @ExistingEducationalTrainingID
		-- Delete any existing properties
		EXEC [RDF.].DeleteTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#trainingAtOrganization',
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		EXEC [RDF.].DeleteTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#trainingLocation',
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		EXEC [RDF.].DeleteTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://vivoweb.org/ontology/core#degreeEarned',
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		EXEC [RDF.].DeleteTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#endDate',
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		EXEC [RDF.].DeleteTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://vivoweb.org/ontology/core#majorField',
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		EXEC [RDF.].DeleteTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://www.w3.org/2000/01/rdf-schema#label',
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		-- Add the label
		DECLARE @labelNodeID BIGINT
		EXEC [RDF.].GetStoreNode	@Value = @label, 
									@Language = NULL,
									@DataType = NULL,
									@SessionID = @SessionID, 
									@Error = @Error OUTPUT, 
									@NodeID = @labelNodeID OUTPUT
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://www.w3.org/2000/01/rdf-schema#label',
									@ObjectID = @labelNodeID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
	END
	ELSE
	BEGIN
		-- Create a new EducationalTraining
		EXEC [RDF.].GetStoreNode	@EntityClassURI = 'http://vivoweb.org/ontology/core#EducationalTraining',
									@Label = @label,
									@ForceNewEntity = 1,
									@SessionID = @SessionID, 
									@Error = @Error OUTPUT, 
									@NodeID = @NodeID OUTPUT
		-- Link the EducationalTraining to the educationalTrainingOf
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://vivoweb.org/ontology/core#educationalTrainingOf',
									@ObjectID = @educationalTrainingForID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		-- Link the educationalTrainingFor to the EducationalTraining
		EXEC [RDF.].GetStoreTriple	@SubjectID = @educationalTrainingForID,
									@PredicateURI = 'http://vivoweb.org/ontology/core#educationalTraining',
									@ObjectID = @NodeID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
	END

	-------------------------------------------------
	-- Handle optional properties
	-------------------------------------------------

	-- Add optional properties to the AwardReceipt
	IF (@NodeID IS NOT NULL) AND (@Error = 0)
	BEGIN
		IF @institutionNodeID IS NOT NULL
			EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
										@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#trainingAtOrganization',
										@ObjectID = @institutionNodeID,
										@SessionID = @SessionID,
										@Error = @Error OUTPUT
		IF @locationNodeID IS NOT NULL
			EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
										@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#trainingLocation',
										@ObjectID = @locationNodeID,
										@SessionID = @SessionID,
										@Error = @Error OUTPUT
		IF @degreeNodeID IS NOT NULL
			EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
										@PredicateURI = 'http://vivoweb.org/ontology/core#degreeEarned',
										@ObjectID = @degreeNodeID,
										@SessionID = @SessionID,
										@Error = @Error OUTPUT
		IF @endDateNodeID IS NOT NULL
			EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
										@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#endDate',
										@ObjectID = @endDateNodeID,
										@SessionID = @SessionID,
										@Error = @Error OUTPUT
		IF @fieldOfStudyNodeID IS NOT NULL
			EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
										@PredicateURI = 'http://vivoweb.org/ontology/core#majorField',
										@ObjectID = @fieldOfStudyNodeID,
										@SessionID = @SessionID,
										@Error = @Error OUTPUT
	END

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Edit.Module].[CustomEditAssociatedInformationResource.GetList]
	@NodeID bigint = NULL,
	@SessionID uniqueidentifier = NULL
AS
BEGIN

	DECLARE @GroupID INT
 
	SELECT @GroupID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
 
	SELECT r.Reference, (CASE WHEN r.PMID IS NOT NULL THEN 1 ELSE 0 END) FromPubMed, i.PubID, r.PMID, r.MPID, NULL Category, r.URL, r.EntityDate PubDate, r.EntityID, r.Source, r.IsActive, i.GroupID
		FROM [Profile.Data].[Publication.Group.Include] i
			INNER JOIN [Profile.Data].[Publication.Entity.InformationResource] r
				ON i.PMID = r.PMID AND i.PMID IS NOT NULL
				AND i.GroupID = @GroupID
	UNION ALL
	SELECT r.Reference, (CASE WHEN r.PMID IS NOT NULL THEN 1 ELSE 0 END) FromPubMed, i.PubID, r.PMID, r.MPID, g.HmsPubCategory Category, r.URL, r.EntityDate PubDate, r.EntityID, r.Source, r.IsActive, i.GroupID
		FROM [Profile.Data].[Publication.Group.Include] i
			INNER JOIN [Profile.Data].[Publication.Entity.InformationResource] r
				ON i.MPID = r.MPID AND i.PMID IS NULL AND i.MPID IS NOT NULL
				AND i.GroupID = @GroupID
			INNER JOIN [Profile.Data].[Publication.Group.MyPub.General] g
				ON i.MPID = g.MPID
	ORDER BY EntityDate DESC, EntityID

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Group.AddPhoto]
	@GroupID INT=NULL,
	@GroupNodeID BIGINT=NULL,
	@Photo VARBINARY(MAX)=NULL,
	@PhotoLink NVARCHAR(MAX)=NULL
AS
BEGIN
	
	SET NOCOUNT ON;
	
	IF (@GroupID IS NULL) AND (@GroupNodeID IS NOT NULL)
	SELECT @GroupID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @GroupNodeID

	-- Only one custom photo per user, so replace any existing custom photos
	IF EXISTS (SELECT 1 FROM [Profile.Data].[Group.Photo] WHERE GroupID = @Groupid)
		BEGIN 
			UPDATE [Profile.Data].[Group.Photo] SET photo = @photo, PhotoLink = @PhotoLink WHERE GroupID = @Groupid 
		END
	ELSE 
		BEGIN 
			INSERT INTO [Profile.Data].[Group.Photo](GroupID ,Photo,PhotoLink) VALUES(@GroupID,@Photo,@PhotoLink)
		END 
	
	DECLARE @NodeID BIGINT
	DECLARE @URI VARCHAR(400)
	DECLARE @URINodeID BIGINT
	SELECT @NodeID = GroupNodeID, @URI = URI
		FROM [Profile.Data].[vwGroup.Photo]
		WHERE GroupID = @GroupID
	IF (@NodeID IS NOT NULL AND @URI IS NOT NULL)
		BEGIN
			EXEC [RDF.].[GetStoreNode] @Value = @URI, @NodeID = @URINodeID OUTPUT
			IF (@URINodeID IS NOT NULL)
				EXEC [RDF.].[GetStoreTriple]	@SubjectID = @NodeID,
												@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#mainImage',
												@ObjectID = @URINodeID
		END
 
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Group.UpdateSecurityMembership]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	------------------------------------------------------------
	-- Get the users who currently can edit a group
	------------------------------------------------------------

	SELECT s.UserID, ISNULL(m.NodeID,0) NodeID, g.GroupID
		INTO #OldSecurityMembership
		FROM [Profile.Data].[Group.General] g
			INNER JOIN [RDF.Stage].InternalNodeMap m
				ON m.Class = 'http://xmlns.com/foaf/0.1/Group' AND m.InternalType = 'Group' AND m.InternalID = CAST(g.GroupID AS VARCHAR(50))
			INNER JOIN [RDF.Security].[Member] s
				ON m.NodeID = s.SecurityGroupID
		WHERE m.NodeID IS NOT NULL

	ALTER TABLE #OldSecurityMembership ADD PRIMARY KEY (UserID,NodeID)

	------------------------------------------------------------
	-- Get the users who should be able to edit a group
	------------------------------------------------------------

	;WITH a AS (
		SELECT DISTINCT UserID, GroupID
		FROM (
				SELECT a.UserID, g.GroupID
					FROM [Profile.Data].[Group.Admin] a
						CROSS JOIN [Profile.Data].[Group.General] g
					WHERE g.ViewSecurityGroup <> 0
				UNION ALL
				SELECT a.UserID, g.GroupID
					FROM [Profile.Data].[Group.Manager] a
						CROSS JOIN [Profile.Data].[Group.General] g
					WHERE g.ViewSecurityGroup <> 0
			) t 
	)
	SELECT a.UserID, ISNULL(m.NodeID,0) NodeID, a.GroupID
		INTO #NewSecurityMembership
		FROM a INNER JOIN [RDF.Stage].InternalNodeMap m
			ON m.Class = 'http://xmlns.com/foaf/0.1/Group' AND m.InternalType = 'Group' AND m.InternalID = CAST(a.GroupID AS VARCHAR(50))
		WHERE m.NodeID IS NOT NULL

	ALTER TABLE #NewSecurityMembership ADD PRIMARY KEY (UserID,NodeID)

	------------------------------------------------------------
	-- Update the group security membership
	------------------------------------------------------------

	DELETE m
		FROM [RDF.Security].[Member] m
		WHERE EXISTS (SELECT * FROM #OldSecurityMembership o WHERE o.UserID=m.UserID AND o.NodeID=m.SecurityGroupID)
			AND NOT EXISTS (SELECT * FROM #NewSecurityMembership n WHERE n.UserID=m.UserID AND n.NodeID=m.SecurityGroupID)

	INSERT INTO [RDF.Security].[Member] (UserID, SecurityGroupID, IsVisible)
		SELECT UserID, NodeID, 0 IsVisible
		FROM #NewSecurityMembership n
		WHERE NOT EXISTS (SELECT * FROM [RDF.Security].[Member] m WHERE n.UserID=m.UserID AND n.NodeID=m.SecurityGroupID)

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Group.AddUpdateGroup]
	@ExistingGroupID INT=NULL, 
	@ExistingGroupNodeID BIGINT=NULL,
	@ExistingGroupURI VARCHAR(400)=NULL,
	@GroupName VARCHAR(MAX)=NULL,
	@EndDate DATETIME=NULL,
	@ViewSecurityGroup BIGINT=NULL,
	@SessionID UNIQUEIDENTIFIER=NULL, 
	@Error BIT=NULL OUTPUT, 
	@NodeID BIGINT=NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	/*
	
	This stored procedure either creates or updates a Group.
	Groups can be specified either by GroupID, NodeID or URI.
	
	*/
	
	SELECT @Error = 0

	-------------------------------------------------
	-- Validate and prepare variables
	-------------------------------------------------
	
	-- Convert URIs and NodeIDs to GroupID
 	IF (@ExistingGroupNodeID IS NULL) AND (@ExistingGroupURI IS NOT NULL)
		SELECT @ExistingGroupNodeID = [RDF.].fnURI2NodeID(@ExistingGroupURI)
 	IF (@ExistingGroupID IS NULL) AND (@ExistingGroupNodeID IS NOT NULL)
		SELECT @ExistingGroupID = CAST(m.InternalID AS INT)
			FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
			WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @ExistingGroupNodeID

	-------------------------------------------------
	-- Create a new group if needed
	-------------------------------------------------

	IF @ExistingGroupID IS NULL
	BEGIN
		-- Create the GroupID
		INSERT INTO [Profile.Data].[Group.General] (GroupName, ViewSecurityGroup, CreateDate, EndDate)
			SELECT ISNULL(NULLIF(@GroupName,''),'New Group'), ISNULL(@ViewSecurityGroup,0), GetDate(), ISNULL(@EndDate,DATEADD(yy,10,CAST(GetDate() AS DATE)))
		SELECT @ExistingGroupID = @@IDENTITY
		-- Create the NodeID (hidden by default)
		EXEC [RDF.].GetStoreNode @Class = 'http://xmlns.com/foaf/0.1/Group', @InternalType = 'Group', @InternalID = @ExistingGroupID,
			@ViewSecurityGroup = 0, @EditSecurityGroup = -40,
			@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @NodeID OUTPUT
		UPDATE [RDF.].[Node] SET EditSecurityGroup = @NodeID WHERE NodeID = @NodeID
		-- Add the class types
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
									@ObjectURI = 'http://xmlns.com/foaf/0.1/Agent',
									@ViewSecurityGroup = -1,
									@Weight = 1,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
									@ObjectURI = 'http://xmlns.com/foaf/0.1/Group',
									@ViewSecurityGroup = -1,
									@Weight = 1,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		/*
		-- Add a hasGroupSettings property
		DECLARE @BooleanTrueNodeID BIGINT
		EXEC [RDF.].GetStoreNode	@Value = 'true', 
									@Language = NULL,
									@DataType = 'http://www.w3.org/2001/XMLSchema#boolean',
									@SessionID = @SessionID, 
									@Error = @Error OUTPUT, 
									@NodeID = @BooleanTrueNodeID OUTPUT
		EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
									@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#hasGroupSettings',
									@ObjectID = @BooleanTrueNodeID,
									@ViewSecurityGroup = -1,
									@Weight = 1,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		*/
		-- Set the ViewSecurityGroup to the NodeID to make it private by default
		SELECT @ViewSecurityGroup = ISNULL(@ViewSecurityGroup,@NodeID)
		-- Make sure the group has a valid name
		SELECT @GroupName = ISNULL(NULLIF(@GroupName,''),'New Group '+CAST(@ExistingGroupID AS VARCHAR(50)))
		
		DECLARE @GroupSettings BIGINT
		SELECT @GroupSettings = _PropertyNode FROM [Ontology.].ClassProperty WHERE Class = 'http://xmlns.com/foaf/0.1/Group' and Property = 'http://profiles.catalyst.harvard.edu/ontology/prns#hasGroupSettings'
		INSERT INTO [RDF.Security].NodeProperty (NodeID, Property, ViewSecurityGroup)
		VALUES (@NodeID, @GroupSettings, @NodeID)
		
		-- Give all admins access to the group
		EXEC [Profile.Data].[Group.UpdateSecurityMembership]
	END

	-------------------------------------------------
	-- Update an existing group
	-------------------------------------------------

	-- Get the group's NodeID
	IF @NodeID IS NULL
		SELECT @NodeID = NodeID
			FROM [RDF.Stage].InternalNodeMap
			WHERE Class = 'http://xmlns.com/foaf/0.1/Group' AND InternalType = 'Group' AND InternalID = CAST(@ExistingGroupID AS VARCHAR(50))

	-- Update the ViewSecurityGroup
	IF @ViewSecurityGroup IS NOT NULL
	BEGIN
		UPDATE [Profile.Data].[Group.General] 
			SET ViewSecurityGroup = @ViewSecurityGroup 
			WHERE GroupID = @ExistingGroupID
		UPDATE [RDF.].[Node] 
			SET ViewSecurityGroup = @ViewSecurityGroup 
			WHERE NodeID = @NodeID

		DECLARE @contributingRole BIGINT
		SELECT @contributingRole = NodeID FROM [RDF.].Node 
			WHERE ValueHash = [RDF.].fnValueHash(null, null, 'http://vivoweb.org/ontology/core#contributingRole')

		UPDATE n 
			SET n.ViewSecurityGroup = @ViewSecurityGroup 
			FROM [RDF.].Node n 
			JOIN [RDF.].Triple t
			ON n.NodeID = t.Object AND t.Subject = @NodeID AND Predicate = @contributingRole
	END

	-- Update the EndDate
	IF @EndDate IS NOT NULL
	BEGIN
		UPDATE [Profile.Data].[Group.General] 
			SET EndDate = @EndDate 
			WHERE GroupID = @ExistingGroupID
	END

	-- Update the label
	IF NULLIF(@GroupName,'')<>''
	BEGIN
		-- Update the General table
		UPDATE [Profile.Data].[Group.General] 
			SET GroupName = @GroupName 
			WHERE GroupID = @ExistingGroupID
		-- Get the NodeID for the label
		DECLARE @labelNodeID BIGINT
		EXEC [RDF.].GetStoreNode	@Value = @GroupName, 
									@Language = NULL,
									@DataType = NULL,
									@SessionID = @SessionID, 
									@Error = @Error OUTPUT, 
									@NodeID = @labelNodeID OUTPUT
		-- Check if a label already exists
		DECLARE @ExistingTripleID BIGINT
		SELECT @ExistingTripleID = TripleID
			FROM [RDF.].[Triple]
			WHERE Subject = @NodeID AND Predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')
		IF @ExistingTripleID IS NOT NULL
		BEGIN
			-- Update an existing label
			UPDATE [RDF.].[Triple]
				SET Object = @labelNodeID
				WHERE TripleID = @ExistingTripleID
		END
		ELSE
		BEGIN
			-- Create a new label
			EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
										@PredicateURI = 'http://www.w3.org/2000/01/rdf-schema#label',
										@ObjectID = @labelNodeID,
										@SessionID = @SessionID,
										@Error = @Error OUTPUT
		END
	END

END


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Group.DeleteRestoreGroup]
	@GroupID INT=NULL, 
	@GroupNodeID BIGINT=NULL,
	@GroupURI VARCHAR(400)=NULL,
	@RestoreGroup BIT=0,
	@SessionID UNIQUEIDENTIFIER=NULL, 
	@Error BIT=NULL OUTPUT, 
	@NodeID BIGINT=NULL OUTPUT	
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	/*
	
	This stored procedure either deletes or restores a Group.
	Groups can be specified either by GroupID, NodeID or URI.
	
	*/
	
	SELECT @Error = 0

	-------------------------------------------------
	-- Validate and prepare variables
	-------------------------------------------------

	-- Check that the group is only specified in one way
	IF (CASE WHEN @GroupID IS NULL THEN 0 ELSE 1 END)+(CASE WHEN @GroupNodeID IS NULL THEN 0 ELSE 1 END)+(CASE WHEN @GroupURI IS NULL THEN 0 ELSE 1 END) <> 1
		RETURN;
	
	-- Convert URIs and NodeIDs to GroupID
 	IF (@GroupURI IS NOT NULL)
		SELECT @GroupNodeID = [RDF.].fnURI2NodeID(@GroupURI)
 	IF (@GroupNodeID IS NOT NULL)
		SELECT @GroupID = CAST(m.InternalID AS INT)
			FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
			WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @GroupNodeID
 
 	IF (@GroupNodeID IS NULL)
		select @GroupNodeID = NodeID from [RDF.Stage].[InternalNodeMap] where status=3 and class = 'http://xmlns.com/foaf/0.1/Group' and InternalID = @GroupID

	-- Make sure both a GroupID and GroupNodeID exist
	IF (@GroupID IS NULL) OR (@GroupNodeID IS NULL)
		RETURN;

	DECLARE @contributingRoleID BIGINT
	SELECT @contributingRoleID = [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#contributingRole')

	-------------------------------------------------
	-- Delete a group
	-------------------------------------------------

    IF @RestoreGroup = 0
	BEGIN
		-- Delete the group membership role nodes
		UPDATE n
			SET n.ViewSecurityGroup = 0
			FROM [RDF.].[Triple] t
				INNER JOIN [RDF.].[Node] n
					ON t.Object = n.NodeID
			WHERE Subject = @GroupNodeID AND Predicate = @contributingRoleID
		-- Delete the group node
		UPDATE [RDF.].[Node]
			SET ViewSecurityGroup = 0
			WHERE NodeID = @GroupNodeID
		-- Delete the group
		UPDATE [Profile.Data].[Group.General]
			SET ViewSecurityGroup = 0
			WHERE GroupID = @GroupID
		-- Remove access rights
		EXEC [Profile.Data].[Group.UpdateSecurityMembership]
	END

	-------------------------------------------------
	-- Restore a group, making it private
	-------------------------------------------------

    IF @RestoreGroup = 1
	BEGIN
		-- Restore the group
		UPDATE [Profile.Data].[Group.General]
			SET ViewSecurityGroup = @GroupNodeID,
			EndDate = CASE WHEN EndDate < GETDATE() THEN DATEADD(yy,10,CAST(GetDate() AS DATE)) ELSE EndDate END
			WHERE GroupID = @GroupID
		-- Restore the group node
		UPDATE [RDF.].[Node]
			SET ViewSecurityGroup = @GroupNodeID
			WHERE NodeID = @GroupNodeID
		-- Restore the group membership role nodes (where IsActive=1)
		UPDATE n
			SET n.ViewSecurityGroup = @GroupNodeID
			FROM [RDF.].[Triple] t
				INNER JOIN [RDF.].[Node] n
					ON t.Object = n.NodeID
			WHERE Subject = @GroupNodeID AND Predicate = @contributingRoleID
				AND n.NodeID IN (
					SELECT m.NodeID
					FROM [Profile.Data].[Group.Member] g
						INNER JOIN [RDF.Stage].InternalNodeMap m
							ON m.Class = 'http://vivoweb.org/ontology/core#MemberRole' AND m.InternalType = 'MemberRole' AND m.InternalID = g.MemberRoleID
					WHERE g.GroupID = @GroupID AND g.IsActive = 1
				)
		-- Restore access rights
		EXEC [RDF.].SetNodePropertySecurity @NodeID=@GroupNodeID,@PropertyURI='http://profiles.catalyst.harvard.edu/ontology/prns#hasGroupSettings',@ViewSecurityGroup=@GroupNodeID

		EXEC [Profile.Data].[Group.UpdateSecurityMembership]
	END

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Group.GetGroup]
	@GroupID INT=NULL, 
	@GroupNodeID BIGINT=NULL,
	@GroupURI VARCHAR(400)=NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Convert URIs and NodeIDs to GroupID
 	IF (@GroupNodeID IS NULL) AND (@GroupURI IS NOT NULL)
		SELECT @GroupNodeID = [RDF.].fnURI2NodeID(@GroupURI)
 	IF (@GroupID IS NULL) AND (@GroupNodeID IS NOT NULL)
		SELECT @GroupID = CAST(m.InternalID AS INT)
			FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
			WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @GroupNodeID

	SELECT * FROM [Profile.Data].[vwGroup.GeneralWithDeleted] where GroupID = @GroupID


END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Group.GetGroups]
	@SortBy VARCHAR(50)='GroupName',
	@SortDesc BIT=0,
	@ShowDeletedGroups BIT=0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @sql NVARCHAR(MAX)

	SELECT @sql = 'SELECT * FROM [Profile.Data].[vwGroup.GeneralWithDeleted] '
				+(CASE WHEN @ShowDeletedGroups = 0 THEN 'WHERE ViewSecurityGroup <> 0 '
					WHEN @ShowDeletedGroups = 1 THEN 'WHERE ViewSecurityGroup = 0 '
					ELSE '' END)
				+'ORDER BY '
				+(CASE WHEN @SortBy IN ('GroupID','CreateDate','ViewSecurityGroupName','GroupNodeID') 
					THEN @SortBy + (CASE WHEN @SortDesc=1 THEN ' DESC' ELSE '' END) + ', ' 
					ELSE '' END)
				+'GroupName'
				+(CASE WHEN @SortBy='GroupID' THEN '' ELSE ', GroupID' END)

	EXEC sp_executesql @sql

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Group.Manager.AddManager]
	-- Group
	@GroupID INT=NULL, 
	@GroupNodeID BIGINT=NULL,
	@GroupURI VARCHAR(400)=NULL,
	-- User
	@UserID INT=NULL,
	@UserNodeID BIGINT=NULL,
	@UserURI VARCHAR(400)=NULL,
	-- Other
	@SessionID UNIQUEIDENTIFIER=NULL, 
	@Error BIT=NULL OUTPUT 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	/*
	
	This stored procedure adds a Group Manager.
	Specify:
	1) A Group by either GroupID, NodeID or URI.
	2) A User by UserID, NodeID, or URI.
	
	*/
	
	SELECT @Error = 0

	-------------------------------------------------
	-- Validate and prepare variables
	-------------------------------------------------
	
	-- Convert URIs and NodeIDs to GroupID
 	IF (@GroupNodeID IS NULL) AND (@GroupURI IS NOT NULL)
		SELECT @GroupNodeID = [RDF.].fnURI2NodeID(@GroupURI)
 	IF (@GroupID IS NULL) AND (@GroupNodeID IS NOT NULL)
		SELECT @GroupID = CAST(m.InternalID AS INT)
			FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
			WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @GroupNodeID
	IF @GroupNodeID IS NULL
		SELECT @GroupNodeID = NodeID
			FROM [RDF.Stage].InternalNodeMap
			WHERE Class = 'http://xmlns.com/foaf/0.1/Group' AND InternalType = 'Group' AND InternalID = @GroupID

	-- Convert URIs and NodeIDs to UserID
 	IF (@UserNodeID IS NULL) AND (@UserURI IS NOT NULL)
		SELECT @UserNodeID = [RDF.].fnURI2NodeID(@UserURI)
 	IF (@UserID IS NULL) AND (@UserNodeID IS NOT NULL)
		SELECT @UserID = CAST(m.InternalID AS INT)
			FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
			WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @UserNodeID
	IF @UserNodeID IS NULL
		SELECT @UserNodeID = NodeID
			FROM [RDF.Stage].InternalNodeMap
			WHERE Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#User' AND InternalType = 'User' AND InternalID = @UserID

	-- Check that both a Group and a User exist
	IF (@GroupID IS NULL) OR (@UserID IS NULL) OR (@GroupNodeID IS NULL) OR (@UserNodeID IS NULL)
		RETURN;

	-------------------------------------------------
	-- Add the manager
	-------------------------------------------------

	INSERT INTO [Profile.Data].[Group.Manager] (GroupID, UserID)
		SELECT @GroupID, @UserID
		WHERE NOT EXISTS (SELECT * FROM [Profile.Data].[Group.Manager] WHERE GroupID=@GroupID AND UserID=@UserID)

	EXEC [RDF.].GetStoreTriple	@SubjectID = @GroupNodeID,
								@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#hasGroupManager',
								@ObjectID = @UserNodeID,
								@ViewSecurityGroup = -1,
								@Weight = 1,
								@SessionID = @SessionID,
								@Error = @Error OUTPUT

	EXEC [Profile.Data].[Group.UpdateSecurityMembership]

END




GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Group.Manager.DeleteManager]
	-- Group
	@GroupID INT=NULL, 
	@GroupNodeID BIGINT=NULL,
	@GroupURI VARCHAR(400)=NULL,
	-- User
	@UserID INT=NULL,
	@UserNodeID BIGINT=NULL,
	@UserURI VARCHAR(400)=NULL,
	-- Other
	@SessionID UNIQUEIDENTIFIER=NULL, 
	@Error BIT=NULL OUTPUT 
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	/*
	
	This stored procedure deletes a Group Manager.
	Specify:
	1) A Group by either GroupID, NodeID or URI.
	2) A User by UserID, NodeID, or URI.
	
	*/
	
	SELECT @Error = 0

	-------------------------------------------------
	-- Validate and prepare variables
	-------------------------------------------------
	
	-- Convert URIs and NodeIDs to GroupID
 	IF (@GroupNodeID IS NULL) AND (@GroupURI IS NOT NULL)
		SELECT @GroupNodeID = [RDF.].fnURI2NodeID(@GroupURI)
 	IF (@GroupID IS NULL) AND (@GroupNodeID IS NOT NULL)
		SELECT @GroupID = CAST(m.InternalID AS INT)
			FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
			WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @GroupNodeID
	IF @GroupNodeID IS NULL
		SELECT @GroupNodeID = NodeID
			FROM [RDF.Stage].InternalNodeMap
			WHERE Class = 'http://xmlns.com/foaf/0.1/Group' AND InternalType = 'Group' AND InternalID = @GroupID

	-- Convert URIs and NodeIDs to UserID
 	IF (@UserNodeID IS NULL) AND (@UserURI IS NOT NULL)
		SELECT @UserNodeID = [RDF.].fnURI2NodeID(@UserURI)
 	IF (@UserID IS NULL) AND (@UserNodeID IS NOT NULL)
		SELECT @UserID = CAST(m.InternalID AS INT)
			FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
			WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @UserNodeID
	IF @UserNodeID IS NULL
		SELECT @UserNodeID = NodeID
			FROM [RDF.Stage].InternalNodeMap
			WHERE Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#User' AND InternalType = 'User' AND InternalID = @UserID

	-- Check that both a GroupID and a UserID exist
	IF (@GroupID IS NULL) OR (@UserID IS NULL)
		RETURN;

	-------------------------------------------------
	-- Delete the manager
	-------------------------------------------------

	DELETE
		FROM [Profile.Data].[Group.Manager]
		WHERE GroupID=@GroupID AND UserID=@UserID

	DECLARE @hasGroupManagerNodeID BIGINT
	SELECT @hasGroupManagerNodeID = [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#hasGroupManager')

	IF (@GroupNodeID IS NOT NULL) AND (@UserNodeID IS NOT NULL)
		DELETE
			FROM [RDF.].[Triple]
			WHERE Subject = @GroupNodeID AND Predicate = @hasGroupManagerNodeID AND Object = @UserNodeID

	EXEC [Profile.Data].[Group.UpdateSecurityMembership]

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Group.Manager.GetManagers]
	@GroupID INT=NULL, 
	@GroupNodeID BIGINT=NULL,
	@GroupURI VARCHAR(400)=NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Convert URIs and NodeIDs to GroupID
 	IF (@GroupNodeID IS NULL) AND (@GroupURI IS NOT NULL)
		SELECT @GroupNodeID = [RDF.].fnURI2NodeID(@GroupURI)
 	IF (@GroupID IS NULL) AND (@GroupNodeID IS NOT NULL)
		SELECT @GroupID = CAST(m.InternalID AS INT)
			FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
			WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @GroupNodeID
	
	-- Validate GroupID
	IF (@GroupID IS NULL)
		RETURN;

	-- List the Managers
	SELECT m.GroupID, u.UserID, u.PersonID, u.FirstName, u.LastName, u.DisplayName, u.Institution, u.Department, u.Division, u.EmailAddr
		FROM [Profile.Data].[Group.Manager] m
			INNER JOIN [User.Account].[User] u
				ON m.UserID = u.UserID
		WHERE m.GroupID = @GroupID
		ORDER BY u.LastName, u.FirstName, u.DisplayName, u.UserID

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Publication.Entity.UpdateEntityOneGroup]
	@GroupID INT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

 
	-- *******************************************************************
	-- *******************************************************************
	-- Update InformationResource entities
	-- *******************************************************************
	-- *******************************************************************

	CREATE TABLE #tmpEntityIDs(EntityID int primary key)
	insert into #tmpEntityIDs
	select EntityID from [Profile.Data].[Publication.Entity.InformationResource]
		where PMID in (	SELECT PMID 
						FROM [Profile.Data].[Publication.Group.Include]
						WHERE PMID IS NOT NULL AND GroupID = @GroupID)
			and IsActive = 0

	update [Profile.Data].[Publication.Entity.InformationResource] set IsActive = 1 
		where EntityID in (select EntityID from #tmpEntityIDs)

 
	----------------------------------------------------------------------
	-- Get a list of current publications
	----------------------------------------------------------------------
 
	CREATE TABLE #Publications
	(
		PMID INT NULL ,
		MPID NVARCHAR(50) NULL ,
		PMCID NVARCHAR(55) NULL,
		doi [varchar](100) NULL,				  
		EntityDate DATETIME NULL ,
		Authors NVARCHAR(4000) NULL,					  
		Reference NVARCHAR(MAX) NULL ,
		Source VARCHAR(25) NULL ,
		URL VARCHAR(1000) NULL ,
		Title NVARCHAR(4000) NULL
				   
	)
 
	-- Add PMIDs to the publications temp table
	INSERT  INTO #Publications
            ( PMID ,
			  PMCID,
              EntityDate ,
			  Authors,
              Reference ,
              Source ,
              URL ,
              Title
            )
            SELECT -- Get Pub Med pubs
                    PG.PMID ,
					PG.PMCID,
                    EntityDate = PG.PubDate,
					authors = case when right(PG.Authors,5) = 'et al' then PG.Authors+'. '
								when PG.AuthorListCompleteYN = 'N' then PG.Authors+', et al. '
								when PG.Authors <> '' then PG.Authors+'. '
								else '' end,				  
                    Reference = REPLACE([Profile.Cache].[fnPublication.Pubmed.General2Reference](PG.PMID,
                                                              PG.ArticleDay,
                                                              PG.ArticleMonth,
                                                              PG.ArticleYear,
                                                              PG.ArticleTitle,
                                                              PG.Authors,
                                                              PG.AuthorListCompleteYN,
                                                              PG.Issue,
                                                              PG.JournalDay,
                                                              PG.JournalMonth,
                                                              PG.JournalYear,
                                                              PG.MedlineDate,
                                                              PG.MedlinePgn,
                                                              PG.MedlineTA,
                                                              PG.Volume, 0),
                                        CHAR(11), '') ,
                    Source = 'PubMed',
                    URL = 'http://www.ncbi.nlm.nih.gov/pubmed/' + CAST(ISNULL(PG.pmid, '') AS VARCHAR(20)),
                    Title = left((case when IsNull(PG.ArticleTitle,'') <> '' then PG.ArticleTitle else 'Untitled Publication' end),4000)
            FROM    [Profile.Data].[Publication.PubMed.General] PG
			WHERE	PG.PMID IN (
						SELECT PMID 
						FROM [Profile.Data].[Publication.Group.Include]
						WHERE PMID IS NOT NULL AND GroupID = @GroupID
					)
					AND PG.PMID NOT IN (
						SELECT PMID
						FROM [Profile.Data].[Publication.Entity.InformationResource]
						WHERE PMID IS NOT NULL
					)
 
	-- Add MPIDs to the publications temp table
	INSERT  INTO #Publications
            ( MPID ,
              EntityDate ,
			  Authors,
			  Reference ,
			  Source ,
              URL ,
              Title
            )
            SELECT  MPID ,
                    EntityDate ,
					Authors = REPLACE(authors, CHAR(11), '') ,
 
                    Reference = REPLACE( (CASE WHEN IsNull(article,'') <> '' THEN article + '. ' ELSE '' END)
										+ (CASE WHEN IsNull(pub,'') <> '' THEN pub + '. ' ELSE '' END)
										+ y
                                        + CASE WHEN y <> ''
                                                    AND vip <> '' THEN '; '
                                               ELSE ''
                                          END + vip
                                        + CASE WHEN y <> ''
                                                    OR vip <> '' THEN '.'
                                               ELSE ''
                                          END, CHAR(11), '') ,
                    Source = 'Custom' ,
                    URL = url,
                    Title = left((case when IsNull(article,'')<>'' then article when IsNull(pub,'')<>'' then pub else 'Untitled Publication' end),4000)
            FROM    ( SELECT    MPID ,
                                EntityDate ,
                                url ,
                                authors = CASE WHEN authors = '' THEN ''
                                               WHEN RIGHT(authors, 1) = '.'
                                               THEN LEFT(authors,
                                                         LEN(authors) - 1)
                                               ELSE authors
                                          END ,
                                article = CASE WHEN article = '' THEN ''
                                               WHEN RIGHT(article, 1) = '.'
                                               THEN LEFT(article,
                                                         LEN(article) - 1)
                                               ELSE article
                                          END ,
                                pub = CASE WHEN pub = '' THEN ''
                                           WHEN RIGHT(pub, 1) = '.'
                                           THEN LEFT(pub, LEN(pub) - 1)
                                           ELSE pub
                                      END ,
                                y ,
                                vip
                      FROM      ( SELECT    MPG.mpid ,
                                            EntityDate = MPG.publicationdt ,
                                            authors = CASE WHEN RTRIM(LTRIM(COALESCE(MPG.authors,
                                                              ''))) = ''
                                                           THEN ''
                                                           WHEN RIGHT(COALESCE(MPG.authors,
                                                              ''), 1) = '.'
                                                            THEN  COALESCE(MPG.authors,
                                                              '') + ' '
                                                           ELSE COALESCE(MPG.authors,
                                                              '') + '. '
                                                      END ,
                                            url = CASE WHEN COALESCE(MPG.url,
                                                              '') <> ''
                                                            AND LEFT(COALESCE(MPG.url,
                                                              ''), 4) = 'http'
                                                       THEN MPG.url
                                                       WHEN COALESCE(MPG.url,
                                                              '') <> ''
                                                       THEN 'http://' + MPG.url
                                                       ELSE ''
                                                  END ,
                                            article = LTRIM(RTRIM(COALESCE(MPG.articletitle,
                                                              ''))) ,
                                            pub = LTRIM(RTRIM(COALESCE(MPG.pubtitle,
                                                              ''))) ,
                                            y = CASE WHEN MPG.publicationdt > '1/1/1901'
                                                     THEN CONVERT(VARCHAR(50), YEAR(MPG.publicationdt))
                                                     ELSE ''
                                                END ,
                                            vip = COALESCE(MPG.volnum, '')
                                            + CASE WHEN COALESCE(MPG.issuepub,
                                                              '') <> ''
                                                   THEN '(' + MPG.issuepub
                                                        + ')'
                                                   ELSE ''
                                              END
                                            + CASE WHEN ( COALESCE(MPG.paginationpub,
                                                              '') <> '' )
                                                        AND ( COALESCE(MPG.volnum,
                                                              '')
                                                              + COALESCE(MPG.issuepub,
                                                              '') <> '' )
                                                   THEN ':'
                                                   ELSE ''
                                              END + COALESCE(MPG.paginationpub,
                                                             '')
                                  FROM      [Profile.Data].[Publication.Group.MyPub.General] MPG
                                  INNER JOIN [Profile.Data].[Publication.Group.Include] PL ON MPG.mpid = PL.mpid
                                                           AND PL.mpid NOT LIKE 'DASH%'
                                                           AND PL.mpid NOT LIKE 'ISI%'
                                                           AND PL.pmid IS NULL
                                                           AND PL.GroupID = @GroupID
																 
									WHERE MPG.MPID NOT IN (
										SELECT MPID
										FROM [Profile.Data].[Publication.Entity.InformationResource]
										WHERE (MPID IS NOT NULL)
									)
                                ) T0
                    ) T0
 
	CREATE NONCLUSTERED INDEX idx_pmid on #publications(pmid)
	CREATE NONCLUSTERED INDEX idx_mpid on #publications(mpid)

	declare @baseURI varchar(255)
	select @baseURI = Value From [Framework.].Parameter where ParameterID = 'baseURI'
	select a.PmPubsAuthorID, a.pmid, a2p.personID, isnull(Lastname + ' ' + Initials, CollectiveName) as Name, case when nodeID is not null then'<a href="' + @baseURI + cast(i.nodeID as varchar(55)) + '">'+ Lastname + ' ' + Initials + '</a>' else isnull(Lastname + ' ' + Initials, CollectiveName) END as link into #tmpAuthorLinks from [Profile.Data].[Publication.PubMed.Author] a 
		join #publications p on a.pmid = p.pmid
		left outer join [Profile.Data].[Publication.PubMed.Author2Person] a2p on a.PmPubsAuthorID = a2p.PmPubsAuthorID
		left outer join [RDF.Stage].InternalNodeMap i on a2p.PersonID = i.InternalID and i.class = 'http://xmlns.com/foaf/0.1/Person'

	select pmid, [Profile.Data].[fnPublication.Pubmed.ShortenAuthorLengthString](replace(replace(isnull(cast((
		select ', '+ link
		from #tmpAuthorLinks q
		where q.pmid = p.pmid
		order by PmPubsAuthorID
		for xml path(''), type
		) as nvarchar(max)),''), '&lt;' , '<'), '&gt;', '>')) s
		into #tmpPublicationLinks from #publications p where pmid is not null

	update g set g.Authors = t.s from #publications g
		join #tmpPublicationLinks t on g.PMID = t.PMID 							  
							  
	----------------------------------------------------------------------
	-- Update the Publication.Entity.InformationResource table
	----------------------------------------------------------------------

	DECLARE @maxEntityId AS INT
	select @maxEntityId = MAX(cast(InternalID as int)) from [RDF.Stage].InternalNodeMap where class = 'http://vivoweb.org/ontology/core#InformationResource'  AND InternalType = 'InformationResource'
  
	-- Insert new publications
	INSERT INTO [Profile.Data].[Publication.Entity.InformationResource] (
			PMID,
			PMCID,
			MPID,
			EntityName,
			EntityDate,
		    Authors,
			Reference,
			Source,
			URL,
			IsActive,
			PubYear,
			YearWeight		   
		)
		SELECT 	PMID,
				PMCID,
				MPID,
				Title,
				EntityDate,
				Authors,			
				Reference,
				Source,
				URL,
				1 IsActive,
				PubYear = year(EntityDate),
				YearWeight = (case when EntityDate is null then 0.5
								when year(EntityDate) <= 1901 then 0.5
								else power(cast(0.5 as float),cast(datediff(d,EntityDate,GetDate()) as float)/365.25/10)
								end)
		FROM #publications

	-- *******************************************************************
	-- *******************************************************************
	-- Update RDF
	-- *******************************************************************
	-- *******************************************************************
	--------------------------------------------------------------
	-- Version 3 : Create stub RDF
	--------------------------------------------------------------
	CREATE TABLE #sql (
		i INT IDENTITY(0,1) PRIMARY KEY,
		s NVARCHAR(MAX)
	)
	INSERT INTO #sql (s)
		SELECT	'EXEC [RDF.Stage].ProcessDataMap '
					+'  @DataMapID = '+CAST(DataMapID AS VARCHAR(50))
					+', @InternalIdIn = '+InternalIdIn
					+', @TurnOffIndexing=0, @SaveLog=0; '
		FROM (
		  	SELECT DataMapID, '''SELECT CAST (EntityID AS VARCHAR(50)) FROM [Profile.Data].[Publication.Entity.InformationResource] WHERE EntityID > ' + CAST(@maxEntityId AS VARCHAR(50)) + '''' InternalIdIn
				FROM [Ontology.].DataMap
				WHERE class = 'http://vivoweb.org/ontology/core#InformationResource' 
					AND property IS NULL
					AND NetworkProperty IS NULL
			UNION ALL
			SELECT (Select DataMapID FROM [Ontology.].DataMap WHERE class = 'http://vivoweb.org/ontology/core#InformationResource' AND property IS NULL	AND NetworkProperty IS NULL) DataMapID,
				'''SELECT CAST (EntityID AS VARCHAR(50)) FROM [Profile.Data].[Publication.Entity.InformationResource] WHERE EntityID = ' + CAST(EntityID AS VARCHAR(50)) + '''' InternalIdIn
				FROM #tmpEntityIDs
			UNION ALL
			SELECT DataMapID, '''' + CAST(@GroupID AS VARCHAR(50)) + '''' InternalIdIn
				FROM [Ontology.].DataMap
				WHERE class = 'http://xmlns.com/foaf/0.1/Group'
					AND property = 'http://profiles.catalyst.harvard.edu/ontology/prns#associatedInformationResource'
					AND NetworkProperty IS NULL
		) t
		ORDER BY DataMapID

	DECLARE @s NVARCHAR(MAX)
	WHILE EXISTS (SELECT * FROM #sql)
	BEGIN
		SELECT @s = s
			FROM #sql
			WHERE i = (SELECT MIN(i) FROM #sql)
		print @s
		EXEC sp_executesql @s
		DELETE
			FROM #sql
			WHERE i = (SELECT MIN(i) FROM #sql)
	END
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Group.Member.AddUpdateMember]
	-- Role
	@MemberRoleID VARCHAR(50)=NULL,
	@MemberRoleNodeID BIGINT=NULL,
	@MemberRoleURI VARCHAR(400)=NULL,
	-- Group
	@GroupID INT=NULL, 
	@GroupNodeID BIGINT=NULL,
	@GroupURI VARCHAR(400)=NULL,
	-- User
	@UserID INT=NULL,
	@UserNodeID BIGINT=NULL,
	@UserURI VARCHAR(400)=NULL,
	-- Other
	@IsApproved bit=NULL,
	@IsVisible bit=NULL,
	@Title nvarchar(255)=NULL,
	@SessionID UNIQUEIDENTIFIER=NULL, 
	@Error BIT=NULL OUTPUT, 
	@NodeID BIGINT=NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	/*
	
	This stored procedure either adds or updates a Group Member.
	Either specify:
	1) A MemberRole by either MemberRoleID, NodeID, or URI.
	2) A Group by either GroupID, NodeID or URI;
		and, a User by UserID, NodeID, or URI.
	
	*/
	
	SELECT @Error = 0

	-------------------------------------------------
	-- Validate and prepare variables
	-------------------------------------------------
	
	-- Convert MemberRoleID to GroupID and NodeID
 	IF (@MemberRoleNodeID IS NULL) AND (@MemberRoleURI IS NOT NULL)
		SELECT @MemberRoleNodeID = [RDF.].fnURI2NodeID(@MemberRoleURI)
 	IF (@MemberRoleID IS NULL) AND (@MemberRoleNodeID IS NOT NULL)
		SELECT @MemberRoleID = CAST(m.InternalID AS INT)
			FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
			WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @MemberRoleNodeID
	IF (@MemberRoleID IS NOT NULL)
		SELECT @GroupID = GroupID, @UserID = UserID
		FROM [Profile.Data].[Group.Member]
		WHERE MemberRoleID = @MemberRoleID

	-- Convert URIs and NodeIDs to GroupID
 	IF (@GroupNodeID IS NULL) AND (@GroupURI IS NOT NULL)
		SELECT @GroupNodeID = [RDF.].fnURI2NodeID(@GroupURI)
 	IF (@GroupID IS NULL) AND (@GroupNodeID IS NOT NULL)
		SELECT @GroupID = CAST(m.InternalID AS INT)
			FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
			WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @GroupNodeID
	IF @GroupNodeID IS NULL
		SELECT @GroupNodeID = NodeID
			FROM [RDF.Stage].InternalNodeMap
			WHERE Class = 'http://xmlns.com/foaf/0.1/Group' AND InternalType = 'Group' AND InternalID = @GroupID

	-- Convert URIs and NodeIDs to UserID
 	IF (@UserNodeID IS NULL) AND (@UserURI IS NOT NULL)
		SELECT @UserNodeID = [RDF.].fnURI2NodeID(@UserURI)
 	IF (@UserID IS NULL) AND (@UserNodeID IS NOT NULL)
		SELECT @UserID = CAST(m.InternalID AS INT)
			FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
			WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @UserNodeID
	IF @UserNodeID IS NULL
		SELECT @UserNodeID = NodeID
			FROM [RDF.Stage].InternalNodeMap
			WHERE Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#User' AND InternalType = 'User' AND InternalID = @UserID

	-- Convert the UserID to a PersonNodeID
	DECLARE @PersonNodeID BIGINT
	SELECT @PersonNodeID = m.NodeID
		FROM [User.Account].[User] u
			INNER JOIN [RDF.Stage].InternalNodeMap m
				ON m.Class = 'http://xmlns.com/foaf/0.1/Person' AND InternalType = 'Person' AND InternalID = u.PersonID
		WHERE u.UserID = @UserID AND u.PersonID IS NOT NULL

	IF @PersonNodeID IS NULL
		RETURN;

	-------------------------------------------------
	-- Create or update the membership
	-------------------------------------------------

	DECLARE @IsActive BIT
	SELECT @MemberRoleID = MemberRoleID, @IsActive = IsActive
		FROM [Profile.Data].[Group.Member] 
		WHERE GroupID=@GroupID AND UserID=@UserID

	DECLARE @labelNodeID BIGINT
	DECLARE @SecurityGroupID BIGINT


	-- Check if this is a new member
	IF @MemberRoleID IS NULL
	BEGIN
		-- Create a MemberRoleID
		SELECT @MemberRoleID = CAST(NEWID() AS VARCHAR(50))
		-- Validate the title
		SELECT @Title = ISNULL(NULLIF(@Title,''),'Member')
		-- Add the new member
		INSERT INTO [Profile.Data].[Group.Member] (MemberRoleID, GroupID, UserID, IsActive, IsApproved, IsVisible, Title)
			SELECT @MemberRoleID, @GroupID, @UserID, 1, ISNULL(@IsApproved,1), ISNULL(@IsVisible,1), @Title

		-- Order the members
		UPDATE x
		SET x.SortOrder = x.memberSort
			FROM (
                SELECT MemberRoleID, SortOrder, ROW_NUMBER () OVER ( ORDER BY lastname, firstname) AS memberSort FROM [Profile.Data].[Group.Member] m
				JOIN [User.Account].[User] u ON m.UserID = u.UserID				
				AND GroupID = @GroupID
			) x

		DECLARE @SortOrder BIGINT
		SELECT @SortOrder = SortOrder FROM [Profile.Data].[Group.Member] where MemberRoleID = @MemberRoleID

		----------------------------------
		-- Create the MemberRole RDF
		----------------------------------
		-- Get the Group's ViewSecurityGroup
		SELECT @SecurityGroupID = ViewSecurityGroup
			FROM [Profile.Data].[Group.General]
			WHERE GroupID = @GroupID
		-- Create the NodeID (hidden by default)
		EXEC [RDF.].GetStoreNode @Class = 'http://vivoweb.org/ontology/core#MemberRole', @InternalType = 'MemberRole', @InternalID = @MemberRoleID,
			@ViewSecurityGroup = @SecurityGroupID, @EditSecurityGroup = -40,
			@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @MemberRoleNodeID OUTPUT
		-- Add the class types
		EXEC [RDF.].GetStoreTriple	@SubjectID = @MemberRoleNodeID,
									@PredicateURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
									@ObjectURI = 'http://vivoweb.org/ontology/core#MemberRole',
									@ViewSecurityGroup = -1,
									@Weight = 1,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		EXEC [RDF.].GetStoreTriple	@SubjectID = @MemberRoleNodeID,
									@PredicateURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
									@ObjectURI = 'http://vivoweb.org/ontology/core#Role',
									@ViewSecurityGroup = -1,
									@Weight = 1,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		-- Add the title (label)
		EXEC [RDF.].GetStoreNode	@Value = @Title, 
									@Language = NULL,
									@DataType = NULL,
									@SessionID = @SessionID, 
									@Error = @Error OUTPUT, 
									@NodeID = @labelNodeID OUTPUT
		EXEC [RDF.].GetStoreTriple	@SubjectID = @MemberRoleNodeID,
									@PredicateURI = 'http://www.w3.org/2000/01/rdf-schema#label',
									@ObjectID = @labelNodeID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		-- Link the MemberRole to the Group and the Person
		EXEC [RDF.].GetStoreTriple	@SubjectID = @MemberRoleNodeID,
									@PredicateURI = 'http://vivoweb.org/ontology/core#roleContributesTo',
									@ObjectID = @GroupNodeID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		EXEC [RDF.].GetStoreTriple	@SubjectID = @MemberRoleNodeID,
									@PredicateURI = 'http://vivoweb.org/ontology/core#memberRoleOf',
									@ObjectID = @PersonNodeID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
		-- Link the Group and the Person to the MemberRole
		EXEC [RDF.].GetStoreTriple	@SubjectID = @GroupNodeID,
									@PredicateURI = 'http://vivoweb.org/ontology/core#contributingRole',
									@ObjectID = @MemberRoleNodeID,
									@SessionID = @SessionID,
									@SortOrder = @SortOrder,
									@Error = @Error OUTPUT
		EXEC [RDF.].GetStoreTriple	@SubjectID = @PersonNodeID,
									@PredicateURI = 'http://vivoweb.org/ontology/core#hasMemberRole',
									@ObjectID = @MemberRoleNodeID,
									@SessionID = @SessionID,
									@Error = @Error OUTPUT
	END
	ELSE
	BEGIN
		-- Update an existing member
		SELECT @MemberRoleNodeID = NodeID
			FROM [RDF.Stage].InternalNodeMap
			WHERE Class = 'http://vivoweb.org/ontology/core#MemberRole' AND InternalType = 'MemberRole' AND InternalID = @MemberRoleID
		-- Confirm the MemberRole NodeID exists
		IF @MemberRoleNodeID IS NULL
			RETURN;
		-- Activate an inactive member
		IF @IsActive = 0
		BEGIN
			UPDATE [Profile.Data].[Group.Member] 
				SET IsActive = 1
				WHERE MemberRoleID = @MemberRoleID
			SELECT @SecurityGroupID = ViewSecurityGroup
				FROM [Profile.Data].[Group.General]
				WHERE GroupID = @GroupID
			UPDATE [RDF.].[Node]
				SET ViewSecurityGroup = @SecurityGroupID
				WHERE NodeID = @MemberRoleNodeID
		END
		-- Update the title
		IF (ISNULL(@Title,'')<>'')
		BEGIN
			-- Update the General table
			UPDATE [Profile.Data].[Group.Member] 
				SET Title = @Title
				WHERE MemberRoleID = @MemberRoleID
			-- Get the NodeID for the label
			EXEC [RDF.].GetStoreNode	@Value = @Title, 
										@Language = NULL,
										@DataType = NULL,
										@SessionID = @SessionID, 
										@Error = @Error OUTPUT, 
										@NodeID = @labelNodeID OUTPUT
			-- Check if a label already exists
			DECLARE @ExistingTripleID BIGINT
			SELECT @ExistingTripleID = TripleID
				FROM [RDF.].[Triple]
				WHERE Subject = @MemberRoleNodeID AND Predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')
			IF @ExistingTripleID IS NOT NULL
			BEGIN
				-- Update an existing label
				UPDATE [RDF.].[Triple]
					SET Object = @labelNodeID
					WHERE TripleID = @ExistingTripleID
			END
			ELSE
			BEGIN
				-- Create a new label
				EXEC [RDF.].GetStoreTriple	@SubjectID = @MemberRoleNodeID,
											@PredicateURI = 'http://www.w3.org/2000/01/rdf-schema#label',
											@ObjectID = @labelNodeID,
											@SessionID = @SessionID,
											@Error = @Error OUTPUT
			END

		END
	END
	
	EXEC [Profile.Data].[Publication.Entity.UpdateEntityOneGroup] @GroupID=@GroupID

	SELECT @NodeID = @MemberRoleNodeID

END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Group.Member.DeleteMember]
	-- Role
	@MemberRoleID VARCHAR(50)=NULL,
	@MemberRoleNodeID BIGINT=NULL,
	@MemberRoleURI VARCHAR(400)=NULL,
	-- Group
	@GroupID INT=NULL, 
	@GroupNodeID BIGINT=NULL,
	@GroupURI VARCHAR(400)=NULL,
	-- User
	@UserID INT=NULL,
	@UserNodeID BIGINT=NULL,
	@UserURI VARCHAR(400)=NULL,
	-- Other
	@SessionID UNIQUEIDENTIFIER=NULL, 
	@Error BIT=NULL OUTPUT, 
	@NodeID BIGINT=NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	/*
	
	This stored procedure deletes a Group Member.
	Either specify:
	1) A MemberRole by either MemberRoleID, NodeID, or URI.
	2) A Group by either GroupID, NodeID or URI;
		and, a User by UserID, NodeID, or URI.
	
	*/
	
	SELECT @Error = 0

	-------------------------------------------------
	-- Validate and prepare variables
	-------------------------------------------------
	
	-- Convert IDs and URIs to MemberRoleID

 	IF (@MemberRoleNodeID IS NULL) AND (@MemberRoleURI IS NOT NULL)
		SELECT @MemberRoleNodeID = [RDF.].fnURI2NodeID(@MemberRoleURI)
 	IF (@MemberRoleID IS NULL) AND (@MemberRoleNodeID IS NOT NULL)
		SELECT @MemberRoleID = CAST(m.InternalID AS INT)
			FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
			WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @MemberRoleNodeID

	IF (@MemberRoleID IS NULL)
	BEGIN
		-- Convert URIs and NodeIDs to GroupID
 		IF (@GroupNodeID IS NULL) AND (@GroupURI IS NOT NULL)
			SELECT @GroupNodeID = [RDF.].fnURI2NodeID(@GroupURI)
 		IF (@GroupID IS NULL) AND (@GroupNodeID IS NOT NULL)
			SELECT @GroupID = CAST(m.InternalID AS INT)
				FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
				WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @GroupNodeID

		-- Convert URIs and NodeIDs to UserID
 		IF (@UserNodeID IS NULL) AND (@UserURI IS NOT NULL)
			SELECT @UserNodeID = [RDF.].fnURI2NodeID(@UserURI)
 		IF (@UserID IS NULL) AND (@UserNodeID IS NOT NULL)
			SELECT @UserID = CAST(m.InternalID AS INT)
				FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
				WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @UserNodeID

		-- Lookup the MemberRoleID
		IF (@GroupID IS NOT NULL) AND (@UserID IS NOT NULL)
			SELECT @MemberRoleID = MemberRoleID
			FROM [Profile.Data].[Group.Member]
			WHERE GroupID = @GroupID AND UserID = @UserID
	END

	IF (@MemberRoleID IS NULL)
		RETURN;

	-------------------------------------------------
	-- Delete the MemberRole
	-------------------------------------------------

	SELECT @MemberRoleNodeID = NodeID
		FROM [RDF.Stage].InternalNodeMap
		WHERE Class = 'http://vivoweb.org/ontology/core#MemberRole' AND InternalType = 'MemberRole' AND InternalID = @MemberRoleID

	UPDATE [Profile.Data].[Group.Member]
		SET IsActive = 0
		WHERE MemberRoleID = @MemberRoleID

	IF (@MemberRoleNodeID IS NOT NULL)
		UPDATE [RDF.].[Node]
			SET ViewSecurityGroup = 0
			WHERE NodeID = @MemberRoleNodeID

	EXEC [Profile.Data].[Publication.Entity.UpdateEntityOneGroup] @GroupID=@GroupID

	SELECT @NodeID = @MemberRoleNodeID

END



GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Group.Member.GetMembers]
	@GroupID INT=NULL, 
	@GroupNodeID BIGINT=NULL,
	@GroupURI VARCHAR(400)=NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	-- Convert URIs and NodeIDs to GroupID
 	IF (@GroupNodeID IS NULL) AND (@GroupURI IS NOT NULL)
		SELECT @GroupNodeID = [RDF.].fnURI2NodeID(@GroupURI)
 	IF (@GroupID IS NULL) AND (@GroupNodeID IS NOT NULL)
		SELECT @GroupID = CAST(m.InternalID AS INT)
			FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
			WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @GroupNodeID
	
	-- Validate GroupID
	IF (@GroupID IS NULL)
		RETURN;

	-- Get the BaseURI
	DECLARE @baseURI NVARCHAR(400)
	SELECT @baseURI = value FROM [Framework.].Parameter WHERE ParameterID = 'baseURI'

	-- List the Members
	SELECT m.GroupID, u.UserID, u.PersonID, @baseURI+CAST(i.NodeID AS VARCHAR(50)) PersonURI, m.IsApproved, m.IsVisible, m.Title,
			p.FirstName, p.LastName, p.DisplayName, p.InstitutionName, p.DepartmentName, p.DivisionFullName, p.FacultyRank, p.FacultyRankSort
		FROM [Profile.Data].[Group.Member] m
			INNER JOIN [User.Account].[User] u
				ON m.UserID = u.UserID
			INNER JOIN [Profile.Cache].[Person] p
				ON u.PersonID = p.PersonID
			INNER JOIN [RDF.Stage].InternalNodeMap i
				ON i.Class = 'http://xmlns.com/foaf/0.1/Person' AND i.InternalType = 'Person' AND i.InternalID = u.PersonID
		WHERE m.GroupID = @GroupID AND m.IsActive = 1 AND m.IsApproved = 1 AND m.IsVisible = 1
		ORDER BY p.LastName, p.FirstName, p.DisplayName, p.UserID

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Group.Member.Search]
	@LastName nvarchar(100) = NULL,
	@FirstName nvarchar(100) = NULL,
	@Institution nvarchar(500) = NULL,
	@Department nvarchar(500) = NULL,
	@Division nvarchar(500) = NULL,
	@includeUsers bit = 1,
	@offset INT = 0,
	@limit INT = 20
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET nocount  ON;

	SELECT @offset = IsNull(@offset,0), @limit = IsNull(@limit,1000)
	SELECT @limit = 1000 WHERE @limit > 1000
	
	SELECT	@LastName = (CASE WHEN @LastName = '' THEN NULL ELSE @LastName END),
			@FirstName = (CASE WHEN @FirstName = '' THEN NULL ELSE @FirstName END),
			@Institution = (CASE WHEN @Institution = '' THEN NULL ELSE @Institution END),
			@Department = (CASE WHEN @Department = '' THEN NULL ELSE @Department END),
			@Division = (CASE WHEN @Division = '' THEN NULL ELSE @Division END)

	DECLARE @sql NVARCHAR(MAX)
	
	SELECT @sql = '
		SELECT UserID, PersonID, DisplayName, Institution, Department, EmailAddr
			FROM (
				SELECT UserID, isnull(PersonID, 0) as PersonID, DisplayName, Institution, Department, EmailAddr, 
					row_number() over (order by LastName, FirstName, UserID) k
				FROM [User.Account].[User]
				WHERE IsActive = 1
					AND CanBeProxy = 1
					' + IsNull('AND FirstName LIKE '''+replace(@FirstName,'''','''''')+'%''','') + '
					' + IsNull('AND LastName LIKE '''+replace(@LastName,'''','''''')+'%''','') + '
					' + IsNull('AND Institution = '''+replace(@Institution,'''','''''')+'''','') + '
					' + IsNull('AND Department = '''+replace(@Department,'''','''''')+'''','') + '
					' + IsNull('AND Division = '''+replace(@Division,'''','''''')+'''','') + '
					' + CASE WHEN @includeUsers = 0 THEN 'AND isnull(PersonID, 0) > 0' ELSE '' END + '
			) t
			WHERE (k >= ' + cast(@offset+1 as varchar(50)) + ') AND (k < ' + cast(@offset+@limit+1 as varchar(50)) + ')
			ORDER BY k
		'

	EXEC sp_executesql @sql

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Publication.GetGroupMemberPublications]
	@GroupID INT=NULL,
	@StartDate DateTime='01/01/1753',
	@EndDate DateTime='01/01/2500',
	@PersonIDs XML=NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	
	CREATE TABLE #pubs (
		PMID int null,
		MPID nvarchar(50) null
	)

	IF @PersonIDs is null
	BEGIN
		insert into #pubs
		  select distinct pmid, mpid from [Profile.Data].[Publication.Person.Include] a
			  join [Profile.Data].Person p on a.PersonID = p.PersonID
			  join [Profile.Data].[Group.Member] g on p.UserID = g.UserID and p.IsActive = 1 and g.IsActive = 1
			  and g.GroupID = @GroupID
			  where (pmid is null or pmid not in (select pmid from [Profile.Data].[Publication.Group.Include] where GroupID = @GroupID and PMID is not null))
			  and (mpid is null or mpid not in (select copiedMPID from [Profile.Data].[Publication.Group.MyPub.General] where GroupID = @GroupID and copiedMPID is not null))
	END 
	ELSE
	BEGIN
		;with People as (
			select nref.value('.','varchar(max)') as PersonID from @PersonIDs.nodes('//PersonIDs/PersonID') as R(nref)
		)
		insert into #pubs
			select distinct pmid, mpid from [Profile.Data].[Publication.Person.Include] a
				join People p on a.PersonID = p.PersonID
				where (pmid is null or pmid not in (select pmid from [Profile.Data].[Publication.Group.Include] where GroupID = @GroupID and PMID is not null))
				and (mpid is null or mpid not in (select copiedMPID from [Profile.Data].[Publication.Group.MyPub.General] where GroupID = @GroupID and copiedMPID is not null))
	END

  select top 100 '' as rownum, reference, case when e.PMID is not null then 'true' else 'false' end as FromPubMed, 0 as PubID, e.pmid, e.mpid, e.url, e.EntityDate as pubdate, '' as category from [Profile.Data].[vwPublication.Entity.InformationResource] e
	  join #pubs a on (a.PMID = e.PMID and e.MPID is null) OR (a.MPID = e.MPID and e.PMID is null)
	  where @StartDate <= isnull(EntityDate,'01/01/1900') and @EndDate >= isnull(EntityDate,'01/01/1900')
	  order by EntityDate desc
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.Group.Pubmed.AddPublication] 
	@GroupNodeID BIGINT=null,
	@pmid int
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @GroupID INT

	SELECT @GroupID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @GroupNodeID

	if exists (select * from [Profile.Data].[Publication.PubMed.AllXML] where pmid = @pmid)
	begin
 
		declare @ParseDate datetime
		set @ParseDate = (select coalesce(ParseDT,'1/1/1900') from [Profile.Data].[Publication.PubMed.AllXML] where pmid = @pmid)
		if (@ParseDate < '1/1/2000')
		begin
			exec [Profile.Data].[Publication.Pubmed.ParsePubMedXML] 
			 @pmid
		end
 BEGIN TRY 
		BEGIN TRANSACTION
 
			if not exists (select * from [Profile.Data].[Publication.Group.Include] where GroupID = @GroupID and pmid = @pmid)
			begin
 
				declare @pubid uniqueidentifier
				declare @mpid varchar(50)

				set @pubid = (select newid())
				set @mpid = null
 

				insert into [Profile.Data].[Publication.Group.Include](pubid,GroupID,pmid,mpid)
					values (@pubid,@GroupID,@pmid,@mpid)
 
			end
 
		COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
 
		-- Raise an error with the details of the exception
		SELECT @ErrMsg =  ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()
 
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
			 
	END CATCH		
 
	END
 
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[CustomViewAuthorInAuthorship.GetGroupList]
	@NodeID bigint = NULL,
	@SessionID uniqueidentifier = NULL
AS
BEGIN

	DECLARE @SecurityGroupID BIGINT, @HasSpecialViewAccess BIT
	EXEC [RDF.Security].GetSessionSecurityGroup @SessionID, @SecurityGroupID OUTPUT, @HasSpecialViewAccess OUTPUT
	CREATE TABLE #SecurityGroupNodes (SecurityGroupNode BIGINT PRIMARY KEY)
	INSERT INTO #SecurityGroupNodes (SecurityGroupNode) EXEC [RDF.Security].GetSessionSecurityGroupNodes @SessionID, @NodeID


	declare @AssociatedInformationResource bigint
	select @AssociatedInformationResource = [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#associatedInformationResource') 


	select i.NodeID, p.EntityID, i.Value rdf_about, p.EntityName rdfs_label, 
		isnull(p.authors, '') + p.Reference prns_informationResourceReference, p.EntityDate prns_publicationDate,
		year(p.EntityDate) prns_year, p.pmid bibo_pmid, p.pmcid vivo_pmcid, p.doi bibo_doi, p.mpid prns_mpid, p.URL vivo_webpage,
		isnull(b.PMCCitations, -1) as PMCCitations, isnull(Fields, '') as Fields, isnull(TranslationHumans , 0) as TranslationHumans, isnull(TranslationAnimals , 0) as TranslationAnimals, 
		isnull(TranslationCells , 0) as TranslationCells, isnull(TranslationPublicHealth , 0) as TranslationPublicHealth, isnull(TranslationClinicalTrial , 0) as TranslationClinicalTrial
	from [RDF.].[Triple] t
		inner join [RDF.].[Node] a
			on t.subject = @NodeID and t.predicate = @AssociatedInformationResource
				and t.object = a.NodeID
				and ((t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
				and ((a.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (a.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (a.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
		inner join [RDF.].[Node] i
			on t.object = i.NodeID
				and ((i.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (i.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (i.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
		inner join [RDF.Stage].[InternalNodeMap] m
			on i.NodeID = m.NodeID
		inner join [Profile.Data].[Publication.Entity.InformationResource] p
			on m.InternalID = p.EntityID
		left join [Profile.Data].[Publication.Pubmed.Bibliometrics] b on p.PMID = b.PMID
	order by p.EntityDate desc
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[NetworkAuthorshipTimeline.Group.GetData]
	@NodeID BIGINT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @GroupID BIGINT
	SELECT @GroupID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID

    -- Insert statements for procedure here
	declare @gc varchar(max)

	declare @y table (
		y int,
		A int,
		B int
	)

	insert into @y (y,A,B)
		select n.n y, coalesce(t.A,0) A, coalesce(t.B,0) B
		from [Utility.Math].[N] left outer join (
			select (case when y < 1970 then 1970 else y end) y,
				sum(A) A,
				sum(B) B
			from (
				select pmid, pubyear y, 1 A, 0 B
				from (
					SELECT pmid, pubyear
					  FROM [Profile.Data].[vwGroup.Publication.Entity.AssociatedInformationResource] a
					  join [Profile.Data].[vwPublication.Entity.InformationResource] b on a.EntityID = b.EntityID
					  and a.GroupID = @GroupID
				) t
			) t
			group by y
		) t on n.n = t.y
		where n.n between year(getdate())-30 and year(getdate())

	declare @x int

	select @x = max(A+B)
		from @y

	if coalesce(@x,0) > 0
	begin
		declare @v varchar(1000)
		declare @z int
		declare @k int
		declare @i int

		set @z = power(10,floor(log(@x)/log(10)))
		set @k = floor(@x/@z)
		if @x > @z*@k
			select @k = @k + 1
		if @k > 5
			select @k = floor(@k/2.0+0.5), @z = @z*2

		set @v = ''
		set @i = 0
		while @i <= @k
		begin
			set @v = @v + '|' + cast(@z*@i as varchar(50))
			set @i = @i + 1
		end
		set @v = '|0|'+cast(@x as varchar(50))
		--set @v = '|0|50|100'

		declare @h varchar(1000)
		set @h = ''
		select @h = @h + '|' + (case when y % 2 = 1 then '' else ''''+right(cast(y as varchar(50)),2) end)
			from @y
			order by y 

		declare @w float
		--set @w = @k*@z
		set @w = @x

		declare @d varchar(max)
		set @d = ''
		select @d = @d + cast(floor(0.5 + 100*A/@w) as varchar(50)) + ','
			from @y
			order by y
		set @d = left(@d,len(@d)-1) + '|'
		select @d = @d + cast(floor(0.5 + 100*B/@w) as varchar(50)) + ','
			from @y
			order by y
		set @d = left(@d,len(@d)-1)

		declare @c varchar(50)
		set @c = 'FB8072,80B1D3'
		--set @c = 'FB8072,B3DE69,80B1D3'
		--set @c = 'F96452,a8dc4f,68a4cc'
		--set @c = 'fea643,76cbbd,b56cb5'

		--select @v, @h, @d

		--set @gc = '//chart.googleapis.com/chart?chs=595x100&chf=bg,s,ffffff|c,s,ffffff&chxt=x,y&chxl=0:' + @h + '|1:' + @v + '&cht=bvs&chd=t:' + @d + '&chdl=First+Author|Middle or Unkown|Last+Author&chco='+@c+'&chbh=10'
		--set @gc = '//chart.googleapis.com/chart?chs=595x100&chf=bg,s,ffffff|c,s,ffffff&chxt=x,y&chxl=0:' + @h + '|1:' + @v + '&cht=bvs&chd=t:' + @d + '&chdl=Major+Topic|Minor+Topic&chco='+@c+'&chbh=10'
		set @gc = '//chart.googleapis.com/chart?chs=595x100&chf=bg,s,ffffff|c,s,ffffff&chxt=x,y&chxl=0:' + @h + '|1:' + @v + '&cht=bvs&chd=t:' + @d + '&chco='+@c+'&chbh=10'


		declare @asText varchar(max)
		set @asText = '<table style="width:592px"><tr><th>Year</th><th>Count</th></tr>'
		select @asText = @asText + '<tr><td style="text-align:center;">' + cast(y as varchar(50)) + '</td><td style="text-align:center;">' + cast(A + B as varchar(50)) + '</td></tr>'
			from @y
			where A + B > 0
			order by y 
		select @asText = @asText + '</table>'

		declare @alt varchar(max)
		select @alt = 'Bar chart showing ' + cast(sum(A + B) as varchar(50))+ ' publications over ' + cast(count(*) as varchar(50)) + ' distinct years, with a maximum of ' + cast(@x as varchar(50)) + ' publications in ' from @y where A + B > 0
		select @alt = @alt + cast(y as varchar(50)) + ' and '
			from @y
			where A + B = @x
			order by y 
		select @alt = left(@alt, len(@alt) - 4)

		select @gc gc, @alt alt, @asText asText --, @w w

		--select * from @y order by y

	end

END


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Module].[NetworkRadial.Group.GetCoAuthors]
	@NodeID BIGINT,
	@SessionID UNIQUEIDENTIFIER=NULL,
	@OutputFormat VARCHAR(50)='JSON'
AS
BEGIN
	SET NOCOUNT ON;	
	
	DECLARE @GroupID INT
	SELECT @GroupID = CAST(m.InternalID AS INT)
		FROM [RDF.Stage].[InternalNodeMap] m, [RDF.].Node n
		WHERE m.Status = 3 AND m.ValueHash = n.ValueHash AND n.NodeID = @NodeID
 
	SELECT TOP 120
					personid,
					distance,
					numberofpaths,
					weight,
					w2,
					lastname,
					firstname,
					p,
					k,
					cast(-1 as bigint) nodeid,
					cast('' as varchar(400)) uri,
					0 nodeindex
		INTO #network 
		FROM ( 
						SELECT p.personid, 
										1 as distance, 
										0 as numberofpaths, 
										0 as weight, 
										0.5 as w2, 
										p.lastname, 
										p.firstname, 
										p.numpublications p, 
										ROW_NUMBER() OVER (ORDER BY p.PersonID DESC) k 
							FROM [Profile.Cache].Person p
							JOIN [Profile.Data].[vwGroup.Member] g
							on p.PersonID = g.PersonID
							  AND p.IsActive = 1
							  and g.GroupID = @GroupID
					) t 
		--WHERE k <= 80 
	ORDER BY distance, k

	--UPDATE #network set distance = 0 where k = 1
	
	UPDATE n
		SET n.NodeID = m.NodeID, n.URI = p.Value + cast(m.NodeID as varchar(50))
		FROM #network n, [RDF.Stage].InternalNodeMap m, [Framework.].Parameter p
		WHERE p.ParameterID = 'baseURI' AND m.InternalHash = [RDF.].fnValueHash(null,null,'http://xmlns.com/foaf/0.1/Person^^Person^^'+cast(n.PersonID as varchar(50)))
 
	DELETE FROM #network WHERE IsNull(URI,'') = ''	
	
	UPDATE a
		SET a.nodeindex = b.ni
		FROM #network a, (
			SELECT *, row_number() over (order by distance desc, k desc)-1 ni
			FROM #network
		) b
		WHERE a.personid = b.personid

	SELECT c.personid1 id1, c.personid2	id2, c.n, CAST(c.w AS VARCHAR) w, 
			(CASE WHEN YEAR(firstpubdate)<1980 THEN 1980 ELSE YEAR(firstpubdate) END) y1, 
			(CASE WHEN YEAR(lastpubdate)<1980 THEN 1980 ELSE YEAR(lastpubdate) END) y2,
			0 k,
			a.nodeid n1, b.nodeid n2, a.uri u1, b.uri u2, a.nodeindex ni1, b.nodeindex ni2
		into #network2
		from #network a
			JOIN #network b on a.personid < b.personid  
			JOIN [Profile.Cache].[SNA.Coauthor] c ON a.personid = c.personid1 and b.personid = c.personid2  
 
	;with a as (
		select id1, id2, w, k from #network2
		union all
		select id2, id1, w, k from #network2
	), b as (
		select a.*, row_number() over (partition by a.id1 order by a.w desc, a.id2) s
		from a, 
			(select id1 from a group by id1 having max(k) = 0) b,
			(select id1 from a group by id1 having max(k) > 0) c
		where a.id1 = b.id1 and a.id2 = c.id1
	)
	update n
		set n.k = 2
		from #network2 n, b
		where (n.id1 = b.id1 and n.id2 = b.id2 and b.s = 1) or (n.id1 = b.id2 and n.id2 = b.id1 and b.s = 1)
 
	update n
		set n.k = 3
		from #network2 n, (
			select *, row_number() over (order by k desc, w desc) r 
			from #network2 
		) r
		where n.id1=r.id1 and n.id2=r.id2 and n.k=0 and r.r<=360
 
	IF @OutputFormat = 'XML'
	BEGIN
		SELECT (
			SELECT (
				SELECT personid "@id", nodeid "@nodeid", uri "@uri", distance "@d", p "@pubs", firstname "@fn", lastname "@ln", cast(w2 as varchar(50)) "@w2"
				FROM #network
				FOR XML PATH('NetworkPerson'),ROOT('NetworkPeople'),TYPE
			), (
				SELECT id1 "@id1", id2 "@id2", n "@n", cast(w as varchar(50)) "@w", y1 "@y1", y2 "@y2",
					n1 "@nodeid1", n2 "@nodeid2", u1 "@uri1", u2 "@uri2"
				FROM #network2
				WHERE k > 0
				FOR XML PATH('NetworkCoAuthor'),ROOT('NetworkCoAuthors'),TYPE
			)
			FOR XML PATH('LocalNetwork'), TYPE) [XML]
	END

	IF @OutputFormat = 'JSON'
	BEGIN
		SELECT
			'{'+CHAR(10)
			+'"NetworkPeople":['+CHAR(10)
			+SUBSTRING(ISNULL(CAST((
				SELECT	',{'
						+'"id":'+cast(personid as varchar(50))+','
						+'"nodeid":'+cast(nodeid as varchar(50))+','
						+'"uri":"'+uri+'",'
						+'"d":'+cast(distance as varchar(50))+',' 
						+'"pubs":'+cast(p as varchar(50))+',' 
						+'"fn":"'+firstname+'",' 
						+'"ln":"'+lastname+'",'
						+'"w2":'+cast(w2 as varchar(50))
						+'}'+CHAR(10)
				FROM #network
				ORDER BY nodeindex
				FOR XML PATH(''),TYPE
			) as VARCHAR(MAX)),''),2,9999999)
			+'],'+CHAR(10)
			+'"NetworkCoAuthors":['+CHAR(10)
			+SUBSTRING(ISNULL(CAST((
				SELECT	',{'
						+'"source":'+cast(ni2 as varchar(50))+','
						+'"target":'+cast(ni1 as varchar(50))+','
						+'"n":'+cast(n as varchar(50))+','
						+'"w":'+cast(w as varchar(50))+',' 
						+'"id1":'+cast(id1 as varchar(50))+','
						+'"id2":'+cast(id2 as varchar(50))+','
						+'"y1":'+cast(y1 as varchar(50))+',' 
						+'"y2":'+cast(y2 as varchar(50))+',' 
						+'"nodeid1":'+cast(n1 as varchar(50))+','
						+'"nodeid2":'+cast(n2 as varchar(50))+','
						+'"uri1":"'+u1+'",'
						+'"uri2":"'+u2+'"'
						+'}'+CHAR(10)
				FROM #network2
				ORDER BY ni2, ni1
				FOR XML PATH(''),TYPE
			) as VARCHAR(MAX)),''),2,9999999)
			+']'+CHAR(10)
			+'}' JSON
	END  
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Module].[NetworkMap.GetGroup]
	@NodeID BIGINT=NULL,
	@which INT=0,
	@SessionID UNIQUEIDENTIFIER=NULL
AS
BEGIN

	DECLARE @GroupID INT
	SELECT @GroupID = GroupID FROM [Profile.Data].[vwGroup.General] WHERE GroupNodeID = @NodeID

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET nocount  ON;
 
	DECLARE  @f  TABLE(
		PersonID INT,
		display_name NVARCHAR(255),
		latitude FLOAT,
		longitude FLOAT,
		address1 NVARCHAR(1000),
		address2 NVARCHAR(1000),
		URI VARCHAR(400)
	)
 
	INSERT INTO @f (	PersonID,
						display_name,
						latitude,
						longitude,
						address1,
						address2
					)
		SELECT	p.PersonID,
				p.displayname,
				l.latitude,
				l.longitude,
				CASE WHEN p.addressstring like '%,%' THEN LEFT(p.addressstring,CHARINDEX(',',p.addressstring) - 1)ELSE P.addressstring END address1,
				CASE WHEN p.addressstring like '%,%' THEN REPLACE(SUBSTRING(p.addressstring,CHARINDEX(',',p.addressstring) + 1,LEN(p.addressstring)),', USA','') ELSE p.addressstring END address2
		FROM [Profile.Data].vwperson p,
				(SELECT PersonID
					FROM [Profile.Data].[vwGroup.Member]
					WHERE GroupID = @GroupID
					and IsActive = 1
				) t,
				[Profile.Data].vwperson l
		 WHERE p.PersonID = t.PersonID
			 AND p.PersonID = l.PersonID
			 AND l.latitude IS NOT NULL
			 AND l.longitude IS NOT NULL
		 ORDER BY p.lastname, p.firstname
 
	UPDATE @f
		SET URI = p.Value + cast(m.NodeID as varchar(50))
		FROM @f, [RDF.Stage].InternalNodeMap m, [Framework.].Parameter p
		WHERE p.ParameterID = 'baseURI' AND m.InternalHash = [RDF.].fnValueHash(null,null,'http://xmlns.com/foaf/0.1/Person^^Person^^'+cast(PersonID as varchar(50)))
 
	DELETE FROM @f WHERE URI IS NULL
 
 
	IF @which = 0
	BEGIN
		SELECT PersonID, 
			display_name,
			latitude,
			longitude,
			address1,
			address2,
			URI
		FROM @f
		ORDER BY address1,
			address2,
			display_name
	END
	ELSE
	BEGIN
		SELECT DISTINCT	a.latitude	x1,
						a.longitude	y1,
						d.latitude	x2,
						d.longitude	y2,
						a.PersonID	a,
						d.PersonID	b,
						0 is_person,
						a.URI u1,
						d.URI u2
			FROM @f a,
					 [Profile.Data].[Publication.Person.Include] b,
					 [Profile.Data].[Publication.Person.Include] c,
					 @f d
		 WHERE a.PersonID = b.PersonID
			 AND b.pmid = c.pmid
			 AND b.PersonID < c.PersonID
			 AND c.PersonID = d.PersonID
	END
		
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.Group.DeleteAllPublications]
	@GroupID INT,
	@deletePMID BIT = 0,
	@deleteMPID BIT = 0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	BEGIN TRY 
	BEGIN TRANSACTION
			delete from [Profile.Data].[Publication.Group.Include] 
				where GroupID = @GroupID AND (
						( (@deletePMID = 1) AND (@deleteMPID = 0) AND (pmid is not null) )
					or	( (@deletePMID = 0) AND (@deleteMPID = 1) AND (pmid is null) AND (mpid is not null) )
					or	( (@deletePMID = 1) AND (@deleteMPID = 1) )
				)

	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
 
		-- Raise an error with the details of the exception
		SELECT @ErrMsg =  ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()
 
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
			 
	END CATCH		

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.Group.DeleteOnePublication]
	@GroupID INT,
	@PubID varchar(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
BEGIN TRY 	 
	BEGIN TRANSACTION

		delete from [Profile.Data].[Publication.Group.Include]  where pubid = @PubID and GroupID = @GroupID

	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
 
		-- Raise an error with the details of the exception
		SELECT @ErrMsg =  ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()
 
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
			 
	END CATCH		

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.Group.MyPub.AddPublication]
	@GroupID INT,
	@HMS_PUB_CATEGORY nvarchar(60) = '',
	@PUB_TITLE nvarchar(2000) = '',
	@ARTICLE_TITLE nvarchar(2000) = '',
	@CONF_EDITORS nvarchar(2000) = '',
	@CONF_LOC nvarchar(2000) = '',
	@EDITION nvarchar(30) = '',
	@PLACE_OF_PUB nvarchar(60) = '',
	@VOL_NUM nvarchar(30) = '',
	@PART_VOL_PUB nvarchar(15) = '',
	@ISSUE_PUB nvarchar(30) = '',
	@PAGINATION_PUB nvarchar(30) = '',
	@ADDITIONAL_INFO nvarchar(2000) = '',
	@PUBLISHER nvarchar(255) = '',
	@CONF_NM nvarchar(2000) = '',
	@CONF_DTS nvarchar(60) = '',
	@REPT_NUMBER nvarchar(35) = '',
	@CONTRACT_NUM nvarchar(35) = '',
	@DISS_UNIV_NM nvarchar(2000) = '',
	@NEWSPAPER_COL nvarchar(15) = '',
	@NEWSPAPER_SECT nvarchar(15) = '',
	@PUBLICATION_DT smalldatetime = '',
	@ABSTRACT varchar(max) = '',
	@AUTHORS varchar(max) = '',
	@URL varchar(1000) = '',
	@created_by varchar(50) = ''
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	 
	DECLARE @mpid nvarchar(50)
	SET @mpid = cast(NewID() as nvarchar(50))

	DECLARE @pubid nvarchar(50)
	SET @pubid = cast(NewID() as nvarchar(50))
	BEGIN TRY
	BEGIN TRANSACTION

		INSERT INTO [Profile.Data].[Publication.Group.MyPub.General]
		        (
			mpid,
			GroupID,
			HmsPubCategory,
			PubTitle,
			ArticleTitle,
			ConfEditors,
			ConfLoc,
			EDITION,
			PlaceOfPub,
			VolNum,
			PartVolPub,
			IssuePub,
			PaginationPub,
			AdditionalInfo,
			Publisher,
			ConfNm,
			ConfDts,
			ReptNumber,
			ContractNum,
			DissUnivNM,
			NewspaperCol,
			NewspaperSect,
			PublicationDT,
			ABSTRACT,
			AUTHORS,
			URL,
			CreatedBy,
			CreatedDT,
			UpdatedBy,
			UpdatedDT
		) VALUES (
			@mpid,
			@GroupID,
			@HMS_PUB_CATEGORY,
			@PUB_TITLE,
			@ARTICLE_TITLE,
			@CONF_EDITORS,
			@CONF_LOC,
			@EDITION,
			@PLACE_OF_PUB,
			@VOL_NUM,
			@PART_VOL_PUB,
			@ISSUE_PUB,
			@PAGINATION_PUB,
			@ADDITIONAL_INFO,
			@PUBLISHER,
			@CONF_NM,
			@CONF_DTS,
			@REPT_NUMBER,
			@CONTRACT_NUM,
			@DISS_UNIV_NM,
	@NEWSPAPER_COL,
			@NEWSPAPER_SECT,
			@PUBLICATION_DT,
			@ABSTRACT,
			@AUTHORS,
			@URL,
			@created_by,
			GetDate(),
			@created_by,
			GetDate()
		)

		INSERT INTO [Profile.Data].[Publication.Group.Include]
		        ( PubID, GroupID,   MPID )
			VALUES (@pubid, @GroupID, @mpid)


	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=1
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.Group.MyPub.CopyExistingPublication]
	@GroupID INT,
	@MPID nvarchar(50)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	
	 
	DECLARE @newmpid nvarchar(50)
	SET @newmpid = cast(NewID() as nvarchar(50))

	DECLARE @pubid nvarchar(50)
	SET @pubid = cast(NewID() as nvarchar(50))
	BEGIN TRY
	BEGIN TRANSACTION

		INSERT INTO [Profile.Data].[Publication.Group.MyPub.General]
		        (
			mpid,
			GroupID,
			HmsPubCategory,
			PubTitle,
			ArticleTitle,
			ConfEditors,
			ConfLoc,
			EDITION,
			PlaceOfPub,
			VolNum,
			PartVolPub,
			IssuePub,
			PaginationPub,
			AdditionalInfo,
			Publisher,
			ConfNm,
			ConfDts,
			ReptNumber,
			ContractNum,
			DissUnivNM,
			NewspaperCol,
			NewspaperSect,
			PublicationDT,
			ABSTRACT,
			AUTHORS,
			URL,
			CreatedBy,
			CreatedDT,
			UpdatedBy,
			UpdatedDT,
			CopiedMPID
		) select
			@newmpid,
			@GroupID,
			HmsPubCategory,
			PubTitle,
			ArticleTitle,
			ConfEditors,
			ConfLoc,
			EDITION,
			PlaceOfPub,
			VolNum,
			PartVolPub,
			IssuePub,
			PaginationPub,
			AdditionalInfo,
			Publisher,
			ConfNm,
			ConfDts,
			ReptNumber,
			ContractNum,
			DissUnivNM,
			NewspaperCol,
			NewspaperSect,
			PublicationDT,
			ABSTRACT,
			AUTHORS,
			URL,
			CreatedBy,
			CreatedDT,
			UpdatedBy,
			UpdatedDT,
			@MPID
			from [Profile.Data].[Publication.MyPub.General]
			where MPID = @MPID

		INSERT INTO [Profile.Data].[Publication.Group.Include]
		        ( PubID, GroupID,   MPID )
			VALUES (@pubid, @GroupID, @newmpid)


	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=1
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Direct.].[UpdateLogOutgoing]
	@FSID uniqueidentifier,
	@ResponseState int,
	@ResponseStatus int = NULL,
	@ResultText varchar(4000) = NULL,
	@ResultCount varchar(10) = NULL,
	@ResultDetailsURL varchar(1000) = NULL
AS
BEGIN
	UPDATE [Direct.].LogOutgoing SET ResponseTime = datediff(ms,SentDate,GetDate()),
	ResponseState = @ResponseState,
	ResponseStatus = ISNULL(@ResponseStatus, ResponseStatus),
	ResultText = ISNULL(@ResultText, ResultText),
	ResultCount = ISNULL(@ResultCount, ResultCount),
	ResultDetailsURL = ISNULL(@ResultDetailsURL, ResultDetailsURL)
	WHERE FSID = @FSID
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Direct.].[AddLogOutgoing]
	@FSID uniqueidentifier,
	@SiteID int,
	@Details bit
AS
BEGIN
	INSERT INTO [Direct.].LogOutgoing(FSID, SiteID, Details, SentDate)
	values (@FSID, @SiteID, @Details, GETDATE())
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Direct.].[AddLogIncoming]
	@Details bit,
	@RequestIP varchar(16),
	@QueryString varchar(1000)
AS
BEGIN
	INSERT INTO [Direct.].LogIncoming(Details,ReceivedDate,RequestIP,QueryString)
	values (@Details, GETDATE(), @RequestIP, @QueryString)
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Publication.GetGroupOption]
	@GroupID INT=NULL
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT top 1 [IncludeMemberPublications] FROM [Profile.Data].[Publication.Group.Option] WHERE GroupID = @GroupID AND [IncludeMemberPublications] = 1
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Publication.SetGroupOption]
	@GroupID INT=NULL,
	@IncludeMemberPublications INT=0
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DELETE FROM [Profile.Data].[Publication.Group.Option] WHERE GroupID = @GroupID
	INSERT INTO [Profile.Data].[Publication.Group.Option] (GroupID, IncludeMemberPublications) VALUES (@GroupID, @IncludeMemberPublications)
	
	EXEC [Profile.Data].[Publication.Entity.UpdateEntityOneGroup] @GroupID=@GroupID
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Edit.Module].[CustomEditWebsite.AddEditWebsite]
	@ExistingURLID [varchar](50)=NULL
	, @NodeID bigint=NULL
	, @URL [varchar](max)=NULL
	, @WebPageTitle [varchar](max)=NULL
	, @PublicationDate [varchar](max)=NULL
	, @SortOrder int=NULL
	, @Delete bit=0
	, @Predicate [varchar](100)=NULL
AS
BEGIN
	DECLARE @InternalID INT, @InternalType NVARCHAR(300)
	DECLARE @DataMapID INT

	IF @ExistingURLID IS NOT NULL
	BEGIN
		DECLARE @ExistingOrder int

		IF EXISTS (SELECT 1 FROM [Profile.Data].[Person.Websites] WHERE UrlID = @ExistingURLID)
		BEGIN
			SELECT @InternalID = PersonID FROM [Profile.Data].[Person.Websites] WHERE UrlID = @ExistingURLID

			IF @DELETE=1 SELECT @SortOrder = MAX(SortOrder) FROM  [Profile.Data].[Person.Websites] WHERE PersonID = @InternalID

			IF @SortOrder IS NOT NULL
			BEGIN
				SELECT @SortOrder = CASE WHEN @SortOrder < 1 THEN 1 
						WHEN @SortOrder > (SELECT MAX(SortOrder) FROM  [Profile.Data].[Person.Websites] WHERE PersonID = @InternalID) THEN (SELECT MAX(SortOrder) FROM  [Profile.Data].[Person.Websites] WHERE PersonID = @InternalID)
						ELSE @SortOrder END
				
				SELECT @ExistingOrder = SortOrder FROM [Profile.Data].[Person.Websites] WHERE UrlID = @ExistingURLID

				IF @SortOrder < @ExistingOrder UPDATE [Profile.Data].[Person.Websites] SET SortOrder = SortOrder + 1 WHERE PersonID = @InternalID AND SortOrder >= @SortOrder AND SortOrder < @ExistingOrder
				ELSE IF @SortOrder > @ExistingOrder UPDATE [Profile.Data].[Person.Websites] SET SortOrder = SortOrder - 1 WHERE PersonID = @InternalID AND SortOrder <= @SortOrder AND SortOrder > @ExistingOrder			
				UPDATE [Profile.Data].[Person.Websites] SET SortOrder = @SortOrder WHERE UrlID = @ExistingURLID
			END

			IF @DELETE=1 DELETE FROM [Profile.Data].[Person.Websites] WHERE UrlID = @ExistingURLID
			ELSE UPDATE [Profile.Data].[Person.Websites] SET URL = ISNULL(@URL, URL), WebPageTitle = ISNULL(@WebPageTitle, WebPageTitle) WHERE UrlID = @ExistingURLID

			SELECT @DataMapID = DataMapID FROM [Ontology.].DataMap WHERE MapTable = '[Profile.Data].[Person.Websites]'
		END

		IF EXISTS (SELECT 1 FROM [Profile.Data].[Person.MediaLinks] WHERE UrlID = @ExistingURLID)
		BEGIN
			SELECT @InternalID = PersonID FROM [Profile.Data].[Person.MediaLinks] WHERE UrlID = @ExistingURLID

			IF @DELETE=1 SELECT @SortOrder = MAX(SortOrder) FROM  [Profile.Data].[Person.MediaLinks] WHERE PersonID = @InternalID

			IF @SortOrder IS NOT NULL
			BEGIN
				SELECT @SortOrder = CASE WHEN @SortOrder < 1 THEN 1 
						WHEN @SortOrder > (SELECT MAX(SortOrder) FROM  [Profile.Data].[Person.MediaLinks] WHERE PersonID = @InternalID) THEN (SELECT MAX(SortOrder) FROM  [Profile.Data].[Person.MediaLinks] WHERE PersonID = @InternalID)
						ELSE @SortOrder END
				SELECT @ExistingOrder = SortOrder FROM [Profile.Data].[Person.MediaLinks] WHERE UrlID = @ExistingURLID

				IF @SortOrder < @ExistingOrder UPDATE [Profile.Data].[Person.MediaLinks] SET SortOrder = SortOrder + 1 WHERE PersonID = @InternalID AND SortOrder >= @SortOrder AND SortOrder < @ExistingOrder
				ELSE IF @SortOrder > @ExistingOrder UPDATE [Profile.Data].[Person.MediaLinks] SET SortOrder = SortOrder - 1 WHERE PersonID = @InternalID AND SortOrder <= @SortOrder AND SortOrder > @ExistingOrder			
				UPDATE [Profile.Data].[Person.MediaLinks] SET SortOrder = @SortOrder WHERE UrlID = @ExistingURLID
			END

			IF @DELETE=1 DELETE FROM [Profile.Data].[Person.MediaLinks] WHERE UrlID = @ExistingURLID
			ELSE UPDATE [Profile.Data].[Person.MediaLinks] SET URL = ISNULL(@URL, URL), WebPageTitle = ISNULL(@WebPageTitle, WebPageTitle), PublicationDate = ISNULL(@PublicationDate, PublicationDate) WHERE UrlID = @ExistingURLID

			SELECT @DataMapID = DataMapID FROM [Ontology.].DataMap WHERE MapTable = '[Profile.Data].[Person.MediaLinks]'
		END

		IF EXISTS (SELECT 1 FROM [Profile.Data].[Group.Websites] WHERE UrlID = @ExistingURLID)
		BEGIN
			SELECT @InternalID = GroupID FROM [Profile.Data].[Group.Websites] WHERE UrlID = @ExistingURLID

			IF @DELETE=1 SELECT @SortOrder = MAX(SortOrder) FROM  [Profile.Data].[Group.Websites] WHERE GroupID = @InternalID

			IF @SortOrder IS NOT NULL
			BEGIN
				SELECT @SortOrder = CASE WHEN @SortOrder < 1 THEN 1 
						WHEN @SortOrder > (SELECT MAX(SortOrder) FROM  [Profile.Data].[Group.Websites] WHERE GroupID = @InternalID) THEN (SELECT MAX(SortOrder) FROM  [Profile.Data].[Group.Websites] WHERE GroupID = @InternalID)
						ELSE @SortOrder END
				
				SELECT @ExistingOrder = SortOrder FROM [Profile.Data].[Group.Websites] WHERE UrlID = @ExistingURLID

				IF @SortOrder < @ExistingOrder UPDATE [Profile.Data].[Group.Websites] SET SortOrder = SortOrder + 1 WHERE GroupID = @InternalID AND SortOrder >= @SortOrder AND SortOrder < @ExistingOrder
				ELSE IF @SortOrder > @ExistingOrder UPDATE [Profile.Data].[Group.Websites] SET SortOrder = SortOrder - 1 WHERE GroupID = @InternalID AND SortOrder <= @SortOrder AND SortOrder > @ExistingOrder			
				UPDATE [Profile.Data].[Group.Websites] SET SortOrder = @SortOrder WHERE UrlID = @ExistingURLID
			END

			IF @DELETE=1 DELETE FROM [Profile.Data].[Group.Websites] WHERE UrlID = @ExistingURLID
			ELSE UPDATE [Profile.Data].[Group.Websites] SET URL = ISNULL(@URL, URL), WebPageTitle = ISNULL(@WebPageTitle, WebPageTitle) WHERE UrlID = @ExistingURLID

			SELECT @DataMapID = DataMapID FROM [Ontology.].DataMap WHERE MapTable = '[Profile.Data].[Group.Websites]'
		END

		IF EXISTS (SELECT 1 FROM [Profile.Data].[Group.MediaLinks] WHERE UrlID = @ExistingURLID)
		BEGIN
			SELECT @InternalID = GroupID FROM [Profile.Data].[Group.MediaLinks] WHERE UrlID = @ExistingURLID

			IF @DELETE=1 SELECT @SortOrder = MAX(SortOrder) FROM  [Profile.Data].[Group.MediaLinks] WHERE GroupID = @InternalID

			IF @SortOrder IS NOT NULL
			BEGIN
				SELECT @SortOrder = CASE WHEN @SortOrder < 1 THEN 1 
						WHEN @SortOrder > (SELECT MAX(SortOrder) FROM  [Profile.Data].[Group.MediaLinks] WHERE GroupID = @InternalID) THEN (SELECT MAX(SortOrder) FROM  [Profile.Data].[Group.MediaLinks] WHERE GroupID = @InternalID)
						ELSE @SortOrder END
				SELECT @ExistingOrder = SortOrder FROM [Profile.Data].[Group.MediaLinks] WHERE UrlID = @ExistingURLID

				IF @SortOrder < @ExistingOrder UPDATE [Profile.Data].[Group.MediaLinks] SET SortOrder = SortOrder + 1 WHERE GroupID = @InternalID AND SortOrder >= @SortOrder AND SortOrder < @ExistingOrder
				ELSE IF @SortOrder > @ExistingOrder UPDATE [Profile.Data].[Group.MediaLinks] SET SortOrder = SortOrder - 1 WHERE GroupID = @InternalID AND SortOrder <= @SortOrder AND SortOrder > @ExistingOrder			
				UPDATE [Profile.Data].[Group.MediaLinks] SET SortOrder = @SortOrder WHERE UrlID = @ExistingURLID
			END

			IF @DELETE=1 DELETE FROM [Profile.Data].[Group.MediaLinks] WHERE UrlID = @ExistingURLID
			ELSE UPDATE [Profile.Data].[Group.MediaLinks] SET URL = ISNULL(@URL, URL), WebPageTitle = ISNULL(@WebPageTitle, WebPageTitle), PublicationDate = ISNULL(@PublicationDate, PublicationDate) WHERE UrlID = @ExistingURLID

			SELECT @DataMapID = DataMapID FROM [Ontology.].DataMap WHERE MapTable = '[Profile.Data].[Group.MediaLinks]'
		END
	END



	IF @NodeID IS NOT NULL AND @ExistingURLID IS NULL
	BEGIN 
		SELECT @InternalID = CAST(m.InternalID AS INT),
			@InternalType = InternalType
 			FROM [RDF.Stage].[InternalNodeMap] m
			WHERE m.Status = 3 AND m.NodeID = @NodeID

		SELECT @ExistingURLID = NEWID()
		
		IF @InternalType = 'Person' AND @Predicate = 'http://vivoweb.org/ontology/core#webpage'
		BEGIN
			INSERT INTO [Profile.Data].[Person.Websites] (UrlID, PersonID, URL, WebPageTitle, SortOrder) 
			VALUES(@ExistingURLID, @InternalID, @URL, @WebPageTitle, ISNULL((SELECT MAX(SortOrder) + 1 FROM  [Profile.Data].[Person.Websites] WHERE PersonID = @InternalID), 1))

			SELECT @DataMapID = DataMapID FROM [Ontology.].DataMap WHERE MapTable = '[Profile.Data].[Person.Websites]'
		END

		IF @InternalType = 'Person' AND @Predicate = 'http://profiles.catalyst.harvard.edu/ontology/prns#mediaLinks'
		BEGIN
			INSERT INTO [Profile.Data].[Person.MediaLinks] (UrlID, PersonID, URL, WebPageTitle, PublicationDate, SortOrder) 
			VALUES(@ExistingURLID, @InternalID, @URL, @WebPageTitle, @PublicationDate, ISNULL((SELECT MAX(SortOrder) + 1 FROM  [Profile.Data].[Person.MediaLinks] WHERE PersonID = @InternalID), 1))

			SELECT @DataMapID = DataMapID FROM [Ontology.].DataMap WHERE MapTable = '[Profile.Data].[Person.MediaLinks]'
		END

		IF @InternalType = 'Group' AND @Predicate = 'http://vivoweb.org/ontology/core#webpage'
		BEGIN
			INSERT INTO [Profile.Data].[Group.Websites] (UrlID, GroupID, URL, WebPageTitle, SortOrder) 
			VALUES(@ExistingURLID, @InternalID, @URL, @WebPageTitle, ISNULL((SELECT MAX(SortOrder) + 1 FROM  [Profile.Data].[Group.Websites] WHERE GroupID = @InternalID), 1))

			SELECT @DataMapID = DataMapID FROM [Ontology.].DataMap WHERE MapTable = '[Profile.Data].[Group.Websites]'
		END

		IF @InternalType = 'Group' AND @Predicate = 'http://profiles.catalyst.harvard.edu/ontology/prns#mediaLinks'
		BEGIN
			INSERT INTO [Profile.Data].[Group.MediaLinks] (UrlID, GroupID, URL, WebPageTitle, PublicationDate, SortOrder) 
			VALUES(@ExistingURLID, @InternalID, @URL, @WebPageTitle, @PublicationDate, ISNULL((SELECT MAX(SortOrder) + 1 FROM  [Profile.Data].[Group.MediaLinks] WHERE GroupID = @InternalID), 1))

			SELECT @DataMapID = DataMapID FROM [Ontology.].DataMap WHERE MapTable = '[Profile.Data].[Group.MediaLinks]'
		END
	END


	-- *******************************************************************
	-- *******************************************************************
	-- Update RDF
	-- *******************************************************************
	-- *******************************************************************

	CREATE TABLE #sql (
		i INT IDENTITY(0,1) PRIMARY KEY,
		s NVARCHAR(MAX)
	)
		INSERT INTO #sql (s)
		SELECT	'EXEC [RDF.Stage].ProcessDataMap '
					+'  @DataMapID = '+CAST(DataMapID AS VARCHAR(50))
					+', @InternalIdIn = '''''''+@ExistingURLID
					+''''''', @TurnOffIndexing=0, @SaveLog=0; '
		FROM [Ontology.].DataMap WHERE MapTable = '[Profile.Data].[vwURL]' ORDER BY DataMapID


		INSERT INTO #sql (s)
		SELECT	'EXEC [RDF.Stage].ProcessDataMap '
					+'  @DataMapID = '+CAST(@DataMapID AS VARCHAR(50))
					+', @InternalIdIn = '+CAST(@InternalID AS VARCHAR(50))
					+', @TurnOffIndexing=0, @SaveLog=0; '


	DECLARE @s NVARCHAR(MAX)
	WHILE EXISTS (SELECT * FROM #sql)
	BEGIN
		SELECT @s = s
			FROM #sql
			WHERE i = (SELECT MIN(i) FROM #sql)
		print @s
		EXEC sp_executesql @s
		DELETE
			FROM #sql
			WHERE i = (SELECT MIN(i) FROM #sql)
	END
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Edit.Module].[CustomEditWebsite.GetData]
	@NodeID bigint=NULL
	, @Predicate [varchar](100)=NULL
AS
BEGIN

	DECLARE @InternalID INT, @InternalType NVARCHAR(300)

	SELECT @InternalID = CAST(m.InternalID AS INT),
		@InternalType = InternalType
 		FROM [RDF.Stage].[InternalNodeMap] m
		WHERE m.Status = 3 AND m.NodeID = @NodeID

	IF @InternalType = 'Person' AND @Predicate = 'http://vivoweb.org/ontology/core#webpage'
	BEGIN
		SELECT *, null as PublicationDate FROM [Profile.Data].[Person.Websites] WHERE PersonID = @InternalID ORDER BY SortOrder
	END
	ELSE IF @InternalType = 'Person' AND @Predicate = 'http://profiles.catalyst.harvard.edu/ontology/prns#mediaLinks'
	BEGIN
		SELECT * FROM [Profile.Data].[Person.MediaLinks] WHERE PersonID = @InternalID ORDER BY SortOrder
	END
	ELSE IF @InternalType = 'Group' AND @Predicate = 'http://vivoweb.org/ontology/core#webpage'
	BEGIN
		SELECT *, null as PublicationDate FROM [Profile.Data].[Group.Websites] WHERE GroupID = @InternalID ORDER BY SortOrder
	END
	ELSE IF @InternalType = 'Group' AND @Predicate = 'http://profiles.catalyst.harvard.edu/ontology/prns#mediaLinks'
	BEGIN
		SELECT * FROM [Profile.Data].[Group.MediaLinks] WHERE GroupID = @InternalID ORDER BY SortOrder
	END
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Publication.Pubmed.GetPMIDsforBibliometrics]
	@Job varchar(55) = 'Bibliometrics',
	@BatchID varchar(100)
AS
BEGIN
	SET NOCOUNT ON;	

	CREATE TABLE #tmp (LogID INT, BatchID VARCHAR(100), RowID INT, HttpMethod VARCHAR(10), URL VARCHAR(500), PostData VARCHAR(MAX)) 

	Create table #tmp2(pmid int primary key)
	insert into #tmp2
	SELECT pmid
		FROM [Profile.Data].[Publication.PubMed.Disambiguation]
		WHERE pmid IS NOT NULL 
		UNION   
	SELECT pmid
		FROM [Profile.Data].[Publication.Person.Include]
		WHERE pmid IS NOT NULL 

	declare @c int,	@BatchSize int, @rowsCount int, @URL varchar(500), @logLevel int
	select @c = count(1) from #tmp2
	--select @batchID = NEWID()
	select @URL = URL, @BatchSize = batchSize, @logLevel = logLevel from [Profile.Import].[PRNSWebservice.Options] where job = @Job
	insert into #tmp(LogID, BatchID, RowID, HttpMethod, URL, PostData)
	select -1, @batchID batchID, n, 'POST', @URL, (
	select pmid "PMID" FROM #tmp2 order by pmid offset n * @BatchSize ROWS FETCH NEXT @BatchSize ROWS ONLY FOR XML path(''), ELEMENTS, ROOT('PMIDS')) x
	from [Utility.Math].N where n <= @c / @BatchSize

	select @rowsCount = @@ROWCOUNT

	Update [Profile.Import].[PRNSWebservice.Log.Summary]  set RecordsCount = @c, RowsCount = @rowsCount where BatchID = @BatchID

	DECLARE @LogIDTable TABLE (LogID int, RowID int)
	IF @logLevel = 1
	BEGIN
		INSERT INTO [Profile.Import].[PRNSWebservice.Log] (Job, BatchID, RowID, HttpMethod, URL)
		OUTPUT inserted.LogID, Inserted.RowID into @LogIDTable
		SELECT 'bibliometrics', BatchID, RowID, HttpMethod, URL FROM #tmp
		UPDATE t SET t.LogID = l.LogID FROM #tmp t JOIN @LogIDTable l ON t.RowID = l.RowID
	END
	ELSE IF @logLevel = 2
	BEGIN
		INSERT INTO [Profile.Import].[PRNSWebservice.Log] (Job, BatchID, RowID, HttpMethod, URL, PostData)
		OUTPUT inserted.LogID, Inserted.RowID into @LogIDTable
		SELECT 'bibliometrics', BatchID, RowID, HttpMethod, URL, PostData FROM #tmp
		UPDATE t SET t.LogID = l.LogID FROM #tmp t JOIN @LogIDTable l ON t.RowID = l.RowID
	END

	SELECT * FROM #tmp
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Publication.Pubmed.ParseBibliometricResults]
	@Job varchar(55) = '',
	@BatchID varchar(100) = '',
	@RowID int = -1,
	@LogID int = -1,
	@URL varchar (500) = '',
	@Data varchar(max)
AS
BEGIN
	create table #tmp(
		pmid int primary key,
		PMCCitations int,
		MedlineTA varchar(255),
		TranslationAnimals int,
		TranslationCells int,
		TranslationHumans int,
		TranslationPublicHealth int,
		TranslationClinicalTrial int
	)

	CREATE TABLE #tmpJournalHeading(
		[MedlineTA] [varchar](255) NOT NULL,
		[BroadJournalHeading] [varchar](100) NOT NULL,
		[Weight] [float] NULL,
		[DisplayName] [varchar](100) NULL,
		[Abbreviation] [varchar](50) NULL,
		[Color] [varchar](6) NULL,
		[Angle] [float] NULL,
		[Arc] [float] NULL,
	PRIMARY KEY CLUSTERED 
	(
		[MedlineTA] ASC,
		[BroadJournalHeading] ASC
	)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
	)

	declare @x xml
	select @x = cast(@Data as xml)

	insert into #tmp
	select t.x.value('PMID[1]', 'int') as PMID,
	t.x.value('PMCCitations[1]', 'int') as PMCCitations,
	t.x.value('MedlineTA[1]', 'varchar(255)') as MedlineTA,
	t.x.value('TranslationAnimals[1]', 'int') as TranslationAnimals,
	t.x.value('TranslationCells[1]', 'int') as TranslationCells,
	t.x.value('TranslationHumans[1]', 'int') as TranslationHumans,
	t.x.value('TranslationPublicHealth[1]', 'int') as TranslationPublicHealth,
	t.x.value('TranslationClinicalTrial[1]', 'int') as TranslationClinicalTrial
	from @x.nodes('/Bibliometrics/ArticleSummary') t(x)

	insert into #tmpJournalHeading (MedlineTA, BroadJournalHeading, DisplayName, Abbreviation, Color, Angle, Arc)
		select 
		t.x.value('MedlineTA[1]', 'varchar(255)') as MedlineTA,
		t.x.value('BroadJournalHeading[1]', 'varchar(100)') as BroadJournalHeading,
	--	t.x.value('Weight[1]', 'float') as Weight,
		t.x.value('DisplayName[1]', 'varchar(100)') as DisplayName,
		t.x.value('Abbreviation[1]', 'varchar(50)') as Abbreviation,
		t.x.value('Color[1]', 'varchar(6)') as Color,
		t.x.value('Angle[1]', 'float') as Angle,
		t.x.value('Arc[1]', 'float') as Arc
		from @x.nodes('/Bibliometrics/JournalHeading') t(x)

	;with counts as (
		select MedlineTA, count(*) c from #tmpJournalHeading
		Group by MedlineTA
	)
	update a set a.weight = 1.0 / c from #tmpJournalHeading a join counts b on a.MedlineTA = b.MedlineTA

	delete from [Profile.Data].[Publication.Pubmed.JournalHeading] where MedlineTA in (select MedlineTA from #tmpJournalHeading)
	insert into [Profile.Data].[Publication.Pubmed.JournalHeading] select * from #tmpJournalHeading

	delete from [Profile.Data].[Publication.Pubmed.Bibliometrics] where PMID in (select pmid from #tmp)

	;
	with abbs as (
		SELECT t2.MedlineTA, weight, STUFF((SELECT '|' + CAST([Abbreviation] AS varchar) + ',' + CAST([Color] as varchar) +  ',' + CAST(DisplayName as varchar)  FROM [Profile.Data].[Publication.Pubmed.JournalHeading] t1  where t1.MedlineTA =t2.MedlineTA FOR XML PATH('')), 1 ,1, '') AS ValueList
		FROM #tmpJournalHeading t2
		GROUP BY t2.MedlineTA, t2.Weight
	)
	insert into [Profile.Data].[Publication.Pubmed.Bibliometrics] 
		(PMID, PMCCitations, MedlineTA, Fields, TranslationHumans, TranslationAnimals, TranslationCells, TranslationPublicHealth, TranslationClinicalTrial)
	select PMID, PMCCitations, a.MedlineTA, ValueList , TranslationHumans, TranslationAnimals, TranslationCells, TranslationPublicHealth, TranslationClinicalTrial
		from #tmp a left join abbs b on a.MedlineTA = b.MedlineTA

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Profile.Import].[GoogleWebservice.GetGeocodeAPIData]	 
AS
BEGIN
	SET NOCOUNT ON;	

	CREATE TABLE #tmp (LogID INT, BatchID VARCHAR(100), RowID INT IDENTITY, HttpMethod VARCHAR(10), URL VARCHAR(500), PostData VARCHAR(MAX)) 

	INSERT INTO #tmp(URL) 
	SELECT DISTINCT addressstring
	  FROM [Profile.Data].Person
	 WHERE (ISNULL(latitude ,0)=0
 			OR geoscore = 0)
	and addressstring<>''
	and IsActive = 1

	DECLARE @bid AS VARCHAR(100)
	SET @bid = NEWID()
	UPDATE t SET
		t.LogID = -1,
		t.BatchID = @bid, 
		t.HttpMethod = 'GET',
		t.URL = o.url + REPLACE(REPLACE(t.URL, '#', '' ), ' ', '+') + '&sensor=false' + isnull('&key=' + apikey, '') 
			FROM #tmp t
			JOIN [Profile.Import].[PRNSWebservice.Options] o ON o.job = 'geocode'

	IF EXISTS (SELECT 1 FROM [Profile.Import].[PRNSWebservice.Options] WHERE job = 'geocode' AND logLevel > 0)
	BEGIN
		DECLARE @LogIDTable TABLE (LogID int, RowID int)
		INSERT INTO [Profile.Import].[PRNSWebservice.Log] (Job, BatchID, RowID, HttpMethod, URL)
		OUTPUT inserted.LogID, Inserted.RowID into @LogIDTable
		SELECT 'Geocode', BatchID, RowID, HttpMethod, URL FROM #tmp

		UPDATE t SET t.LogID = l.LogID FROM #tmp t JOIN @LogIDTable l ON t.RowID = l.RowID
	END

	SELECT * FROM #tmp
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Profile.Import].[GoogleWebservice.ParseGeocodeResults]
	@BatchID varchar(100) = '',
	@RowID int = -1,
	@LogID int = -1,
	@URL varchar (500) = '',
	@Data varchar(max)
AS
BEGIN
	SET NOCOUNT ON;	
	declare @x xml, @status varchar(100), @errorText varchar(max), @lat varchar(20), @lng varchar(20), @location_type varchar(100)

	begin try
		set @x = cast(@data	as xml)
	end try
	begin catch
		set @status = 'XML Parsing Error'
		set @errorText = ERROR_MESSAGE()
	end catch

	if @x is not null
	BEGIN
		select @status = nref.value('status[1]','varchar(100)'),
		@errorText = nref.value('error_message[1]','varchar(max)'),
		@lat = nref.value('result[1]/geometry[1]/location[1]/lat[1]','varchar(20)'),
		@lng = nref.value('result[1]/geometry[1]/location[1]/lng[1]','varchar(20)'),
		@location_type = nref.value('result[1]/geometry[1]/location_type[1]','varchar(100)')
		from @x.nodes('//GeocodeResponse[1]') as R(nref)
	END

	IF @status = 'OK' 
	BEGIN
		UPDATE t SET t.Latitude = @lat, t.Longitude = @lng, t.GeoScore = case when @location_type = 'ROOFTOP' then 9 when @location_type = 'RANGE_INTERPOLATED' then 6 when @location_type = 'GEOMETRIC_CENTER' then 4 else 3 end
			FROM [Profile.Data].Person t
			JOIN [Profile.Import].[PRNSWebservice.Options] o ON o.job = 'geocode'
			AND @URL = o.url + REPLACE(REPLACE(t.AddressString, '#', '' ), ' ', '+') + '&sensor=false' + isnull('&key=' + options, '') 
			AND isnull(t.GeoScore, 0) < 10
		update [Profile.Import].[PRNSWebservice.Log] set ResultCount = @@ROWCOUNT where LogID = @LogID
	END
	ELSE 
	BEGIN
		if @LogID > 0
		begin
			select @LogID = isnull(@LogID, -1) from [Profile.Import].[PRNSWebservice.Log] where BatchID = @BatchID and RowID = @RowID
		end

		if @LogID > 0
			update [Profile.Import].[PRNSWebservice.Log] set Success = 0, HttpResponse = @Data, ErrorText = isnull(@status, '') + ' : ' + isnull(@errorText, '') where LogID = @LogID
		else
			insert into [Profile.Import].[PRNSWebservice.Log] (Job, BatchID, RowID, URL, HttpResponse, Success, ErrorText) Values ('Geocode', @BatchID, @RowID, @URL, @Data, 0, isnull(@status, '') + ' : ' + isnull(@errorText, ''))
	END
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Profile.Import].[PRNSWebservice.CheckForErrors]
	@BatchID varchar(100)
AS
BEGIN
	DECLARE @ErrorCount int
	select @ErrorCount = count(*) from  [Profile.Import].[PRNSWebservice.Log] WHERE BatchID = @BatchID AND Success = 0
	UPDATE [Profile.Import].[PRNSWebservice.Log.Summary] set JobEnd = GETDATE(), ErrorCount = @ErrorCount WHERE BatchID = @BatchID
	IF @ErrorCount > 0
		RAISERROR('%i Errors recorded in [Profile.Import].[PRNSWebservice.Log] for BatchID %s',16,1, @ErrorCount, @BatchID);
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Import].[PRNSWebservice.GetPostData]
	@Job varchar(55)
AS
BEGIN
	DECLARE @batchID UNIQUEIDENTIFIER, @logLevel int, @proc varchar(100)

	select @batchID = NEWID()
	select @proc = GetPostDataProc, @logLevel = logLevel from [Profile.Import].[PRNSWebservice.Options] where job = @job

  	IF @logLevel >= 0
	BEGIN
		INSERT INTO [Profile.Import].[PRNSWebservice.Log.Summary]  (Job, BatchID, JobStart)
		SELECT @Job, @BatchID, getdate()
	END

	if @proc is null
	BEGIN
		RAISERROR('Job doesn''t exist', 16, -1)
		return
	END

	exec @proc @Job=@Job, @BatchID=@BatchID
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Import].[PRNSWebservice.ImportData]
	@Job varchar(55),
	@BatchID varchar(100) = '',
	@RowID int = -1,
	@HttpResponseCode int = -1,
	@LogID int = -1,
	@URL varchar (500) = '',
	@Data varchar(max)
AS
BEGIN
	if EXISTS (SELECT 1 FROM [Profile.Import].[PRNSWebservice.Options] WHERE job = @Job AND logLevel = 2) OR @HttpResponseCode <> 200
	begin
		if @LogID > 0
		begin
			select @LogID = isnull(@LogID, -1) from [Profile.Import].[PRNSWebservice.Log] where BatchID = @BatchID and RowID = @RowID
		end

		if @LogID > 0
			update [Profile.Import].[PRNSWebservice.Log] set HttpResponseCode = @HttpResponseCode, 
															 HttpResponse = @Data, 
															 Success = Case when @HttpResponseCode = 200 then null else 0 end 
				where LogID = @LogID
		else
			insert into [Profile.Import].[PRNSWebservice.Log] (Job, BatchID, RowID, URL, HttpResponseCode, HttpResponse, Success) Values (@Job, @BatchID, @RowID, @URL, @HttpResponseCode, @Data, Case when @HttpResponseCode = 200 then null else 0 end)
	end


	if @HttpResponseCode = 200
	begin
		declare @proc varchar(100), @sql nvarchar(2000)
		select @proc = ImportDataProc from [Profile.Import].[PRNSWebservice.Options] where job = @job
		if @proc is null
		BEGIN
			RAISERROR('Job doesn''t exist', 16, -1)
			return
		END

		exec @proc @data=@data, @URL=@URL, @BatchID=@BatchID, @RowID=@RowID, @LogID=@LogID, @Job=@Job
	END
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Import].[PRNSWebservice.AddLog]
	@logID BIGINT = -1,
	@batchID varchar(100) = null,
	@rowID int = -1,
	@Job varchar(55),
	@action VARCHAR(200),
	@actionText varchar(max) = null,
	@newLogID BIGINT OUTPUT
AS
BEGIN
	DECLARE @LogLevel INT
	SELECT @LogLevel = LogLevel FROM [Profile.Import].[PRNSWebservice.Options] WHERE Job=@Job

	IF @LogLevel > 0 OR @action = 'Error'
	BEGIN 
		IF @logID < 0
		BEGIN
			SELECT @logID = ISNULL(LogID, -1) FROM [Profile.Import].[PRNSWebservice.Log] WHERE BatchID = @batchID AND RowID = @rowID

			if @logID < 0
			BEGIN
				DECLARE @LogIDTable TABLE (logID BIGINT)
				INSERT INTO [Profile.Import].[PRNSWebservice.Log] (Job, BatchID, RowID)
				OUTPUT Inserted.LogID INTO @LogIDTable
				VALUES (@job, @batchID, @rowID)
				SELECT @logID = LogID from @LogIDTable
			END
		END

		IF @action='StartService'
			BEGIN
				UPDATE [Profile.Import].[PRNSWebservice.Log]
				   SET ServiceCallStart = GETDATE()
				 WHERE LogID = @logID
			END
		IF @action='EndService'
			BEGIN
				UPDATE [Profile.Import].[PRNSWebservice.Log]
				   SET ServiceCallEnd = GETDATE()
				 WHERE LogID = @logID
			END
		IF @action='RowComplete'
			BEGIN
				UPDATE [Profile.Import].[PRNSWebservice.Log]
				   SET ProcessEnd  =GETDATE(),
					   Success= isnull(Success, 1)
				 WHERE LogID = @logID
			END
		IF @action='Error'
			BEGIN
				UPDATE [Profile.Import].[PRNSWebservice.Log]
				   SET ErrorText = isnull(ErrorText + ' ', '') + @actionText,
					   ProcessEnd  =GETDATE(),
					   Success=0
				 WHERE LogID = @logID
			END
	END
	Select @newLogID = @logID
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[CustomViewAuthorInAuthorship.GetJournalHeadings]
	@NodeID bigint = NULL,
	@SessionID uniqueidentifier = NULL
AS
BEGIN
	DECLARE @SecurityGroupID BIGINT, @HasSpecialViewAccess BIT
	EXEC [RDF.Security].GetSessionSecurityGroup @SessionID, @SecurityGroupID OUTPUT, @HasSpecialViewAccess OUTPUT
	CREATE TABLE #SecurityGroupNodes (SecurityGroupNode BIGINT PRIMARY KEY)
	INSERT INTO #SecurityGroupNodes (SecurityGroupNode) EXEC [RDF.Security].GetSessionSecurityGroupNodes @SessionID, @NodeID

	declare @class nvarchar(400)
	select @class = class from [RDF.Stage].InternalNodeMap where nodeid=@NodeID 

	create table #tmp(
		[Order] int,
		BroadJournalHeading varchar(100),
		[Weight] float,
		[Count] int,
		Color varchar(6)
	)

	if @class = 'http://xmlns.com/foaf/0.1/Person'
	BEGIN
		declare @AuthorInAuthorship bigint
		select @AuthorInAuthorship = [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#authorInAuthorship') 
		declare @LinkedInformationResource bigint
		select @LinkedInformationResource = [RDF.].fnURI2NodeID('http://vivoweb.org/ontology/core#linkedInformationResource') 

		insert into #tmp
		select /*top 10*/ ROW_NUMBER() OVER (ORDER BY CASE isnull(h.BroadJournalHeading, 'Unknown') WHEN 'Unknown' THEN 1 ELSE 0 END, SUM(isnull(h.Weight, 1)) desc, count(*) desc) as [Order],
		 isnull(h.DisplayName, 'Unknown') BroadJournalHeading, SUM(isnull(h.Weight, 1)) as [Weight], count(*) as [Count], Color--, count(*) * 100.0 / sum (count(*)) over() as Percentage, Sum(isnull(h.Weight, 1))over() as Total
		from [RDF.].[Triple] t
			inner join [RDF.].[Node] a
				on t.subject = @NodeID and t.predicate = @AuthorInAuthorship
					and t.object = a.NodeID
					and ((t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
					and ((a.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (a.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (a.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
			inner join [RDF.].[Node] i
				on t.object = i.NodeID
					and ((i.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (i.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (i.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
			inner join [RDF.Stage].[InternalNodeMap] m
				on i.NodeID = m.NodeID
			inner join [Profile.Data].[Publication.Entity.Authorship] e
				on m.InternalID = e.EntityID
			inner join [Profile.Data].[Publication.Entity.InformationResource] p
				on e.InformationResourceID = p.EntityID
			left join [Profile.Data].[Publication.Pubmed.Bibliometrics] b on p.PMID = b.PMID
			left join [Profile.Data].[Publication.Pubmed.JournalHeading] h on b.MedlineTA = H.MedlineTA
		--order by p.EntityDate desc
		GROUP BY isnull(h.BroadJournalHeading, 'Unknown'), DisplayName, Color
		ORDER BY CASE isnull(h.BroadJournalHeading, 'Unknown') WHEN 'Unknown' THEN 1 ELSE 0 END, SUM(isnull(h.Weight, 1)) desc, count(*) desc
	END
	ELSE if @class = 'http://xmlns.com/foaf/0.1/Group'
	BEGIN

		declare @AssociatedInformationResource bigint
		select @AssociatedInformationResource = [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#associatedInformationResource') 

		insert into #tmp
		select /*top 10*/ ROW_NUMBER() OVER (ORDER BY CASE isnull(h.BroadJournalHeading, 'Unknown') WHEN 'Unknown' THEN 1 ELSE 0 END, SUM(isnull(h.Weight, 1)) desc, count(*) desc) as [Order],
		 isnull(h.DisplayName, 'Unknown') BroadJournalHeading, SUM(isnull(h.Weight, 1)) as [Weight], count(*) as [Count], Color--, count(*) * 100.0 / sum (count(*)) over() as Percentage, Sum(isnull(h.Weight, 1))over() as Total
		from [RDF.].[Triple] t
			inner join [RDF.].[Node] a
				on t.subject = @NodeID and t.predicate = @AssociatedInformationResource
					and t.object = a.NodeID
					and ((t.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (t.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (t.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
					and ((a.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (a.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (a.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
			inner join [RDF.].[Node] i
				on t.object = i.NodeID
					and ((i.ViewSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (i.ViewSecurityGroup > 0 AND @HasSpecialViewAccess = 1) OR (i.ViewSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)))
			inner join [RDF.Stage].[InternalNodeMap] m
				on i.NodeID = m.NodeID
			inner join [Profile.Data].[Publication.Entity.InformationResource] p
				on m.InternalID = p.EntityID
			left join [Profile.Data].[Publication.Pubmed.Bibliometrics] b on p.PMID = b.PMID
			left join [Profile.Data].[Publication.Pubmed.JournalHeading] h on b.MedlineTA = H.MedlineTA
		--order by p.EntityDate desc
		GROUP BY isnull(h.BroadJournalHeading, 'Unknown'), DisplayName, Color
		ORDER BY CASE isnull(h.BroadJournalHeading, 'Unknown') WHEN 'Unknown' THEN 1 ELSE 0 END, SUM(isnull(h.Weight, 1)) desc, count(*) desc
	END
	--select * from #tmp ORDER BY [Weight] desc, [count]desc
	
	DECLARE @totalWeight float
	DECLARE @totalCount int
	SELECT @totalWeight = SUM(Weight), @totalCount = SUM(Count) from #tmp

	DELETE FROM #tmp WHERE BroadJournalHeading = 'Unknown' OR [Order] > 9

	INSERT INTO #tmp ([Order], BroadJournalHeading, [Weight], [Count], Color) 
	SELECT top 1 10, 'Other' as BroadJournalHeading, @totalWeight - (Select top 1 sum ([Weight]) over () from #tmp) AS [Weight], @totalCount - (Select top 1 sum ([Count]) over () from #tmp) AS [Count], 'BAB0AC' from #tmp

	UPDATE #tmp set color = '4E79A7' where [Order] = 1
	UPDATE #tmp set color = 'F28E2B' where [Order] = 2
	UPDATE #tmp set color = 'E15759' where [Order] = 3
	UPDATE #tmp set color = '76B7B2' where [Order] = 4
	UPDATE #tmp set color = '59A14F' where [Order] = 5
	UPDATE #tmp set color = 'EDC948' where [Order] = 6
	UPDATE #tmp set color = 'B07AA1' where [Order] = 7
	UPDATE #tmp set color = 'FF9DA7' where [Order] = 8
	UPDATE #tmp set color = '9C755F' where [Order] = 9
	UPDATE #tmp SET [Weight] = [Weight] / @totalWeight;

	select BroadJournalHeading, [Count], Weight, Color from #tmp
	ORDER BY [Order]
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Profile.Module].[GenericRDF.AddPluginToProfile]
@SubjectID BIGINT=NULL, @SubjectURI nvarchar(255)=NULL, @PluginName varchar(55), @SessionID UNIQUEIDENTIFIER=NULL, @Error BIT=NULL OUTPUT, @NodeID BIGINT=NULL OUTPUT
AS
BEGIN
	DECLARE @InternalType nvarchar(100)
	DECLARE @InternalID nvarchar(100)
	DECLARE @Label nvarchar(255)
	DECLARE @LabelID BIGINT
	DECLARE @PredicateURI nvarchar(100)
	DECLARE @SearchableData nvarchar(max)
	DECLARE @SearchableDataID BIGINT
	
	IF (@SubjectID IS NULL)
		SET @SubjectID = [RDF.].fnURI2NodeID(@SubjectURI)

	SELECT @InternalType = [Object] FROM [Ontology.Import].[Triple] 
		WHERE [Subject] = 'http://profiles.catalyst.harvard.edu/ontology/prns#PluginInstance' AND [Predicate] = 'http://www.w3.org/2000/01/rdf-schema#label'

	SELECT @InternalID = InternalID + '-' + @pluginName FROM [RDF.Stage].[InternalNodeMap]
		WHERE [NodeID] = @SubjectID AND Class = 'http://xmlns.com/foaf/0.1/Person'

	IF (@InternalID is null)
	BEGIN
		SELECT @InternalID = InternalID + '-GROUP-' + @pluginName FROM [RDF.Stage].[InternalNodeMap]
			WHERE [NodeID] = @SubjectID AND Class = 'http://xmlns.com/foaf/0.1/Group'
	END

	SELECT @SearchableData = SearchableData from [Profile.Module].[GenericRDF.Data] WHERE Name = @PluginName and NodeID = @SubjectID
	

	EXEC [RDF.].GetStoreNode	@Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#PluginInstance',
								@InternalType = @InternalType,
								@InternalID = @InternalID,
								@SessionID = @SessionID, 
								@Error = @Error OUTPUT, 
								@NodeID = @NodeID OUTPUT

	select @PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/plugins#' + @PluginName

	-- for some reason, this Status in [RDF.Stage].InternalNodeMap is set to 0, not 3.  This causes issues so
	-- we fix
	UPDATE [RDF.Stage].[InternalNodeMap] SET [Status] = 3 WHERE NodeID = @NodeID			

	SELECT @Label = @InternalType + '^^' + @InternalID
		
	EXEC [RDF.].GetStoreNode @Value = @Label, @Language = NULL, @DataType = NULL,
		@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @LabelID OUTPUT	

	EXEC [RDF.].GetStoreNode @Value = @SearchableData, @Language = NULL, @DataType = NULL,
		@SessionID = @SessionID, @Error = @Error OUTPUT, @NodeID = @SearchableDataID OUTPUT	


	-- Add the Type
	EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
								@PredicateURI = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
								@ObjectURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#PluginInstance',
								--@SessionID = @SessionID,
								@Error = @Error OUTPUT
	-- Add the Label
	EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
								@PredicateURI = 'http://www.w3.org/2000/01/rdf-schema#label',
								@ObjectID = @LabelID,
								--@SessionID = @SessionID,
								@Error = @Error OUTPUT
	-- Add Searchable Data
	EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
								@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#pluginSearchableData',
								@ObjectID = @SearchableDataID,
								--@SessionID = @SessionID,
								@Error = @Error OUTPUT
	-- Link the ApplicationInstance to the person
	EXEC [RDF.].GetStoreTriple	@SubjectID = @NodeID,
								@PredicateURI = 'http://profiles.catalyst.harvard.edu/ontology/prns#pluginInstanceFor',
								@ObjectID = @SubjectID,
								--@SessionID = @SessionID,
								@Error = @Error OUTPUT								
	-- Link the person to the ApplicationInstance

	EXEC [RDF.].GetStoreTriple	@SubjectID = @SubjectID,
								@PredicateURI = @PredicateURI,
								@ObjectID = @NodeID,
								--@SessionID = @SessionID,
								@Error = @Error OUTPUT

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Profile.Module].[GenericRDF.RemovePluginFromProfile]
@SubjectID BIGINT=NULL, @SubjectURI NVARCHAR(255)=NULL, @PluginName varchar(55), @DeleteType tinyint = 1, @SessionID UNIQUEIDENTIFIER=NULL, @Error BIT=NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	DECLARE @ApplicationInstanceNodeID  BIGINT
	DECLARE @TripleID BIGINT
	DECLARE @PersonID INT
	DECLARE @InternalID nvarchar(100)	
	DECLARE @InternalType nvarchar(300)
	DECLARE @PERSON_FILTER_ID INT
	DECLARE @InternalUserName NVARCHAR(50)
	DECLARE @PersonFilter NVARCHAR(50)

	IF (@SubjectID IS NULL)
		SET @SubjectID = [RDF.].fnURI2NodeID(@SubjectURI)
	
	-- Lookup the PersonID
	SELECT @InternalID = InternalID, @InternalType = InternalType
		FROM [RDF.Stage].[InternalNodeMap]
		WHERE NodeID = @SubjectID
	
	IF @InternalType = 'Person'
	BEGIN
		-- Lookup the App Instance's NodeID
		SELECT @ApplicationInstanceNodeID  = NodeID
			FROM [RDF.Stage].[InternalNodeMap]
			WHERE Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#PluginInstance'
				AND InternalID = @InternalID + '-' + @pluginName
	END
	ELSE IF @InternalType = 'Group'
	BEGIN
		-- Lookup the App Instance's NodeID
		SELECT @ApplicationInstanceNodeID  = NodeID
			FROM [RDF.Stage].[InternalNodeMap]
			WHERE Class = 'http://profiles.catalyst.harvard.edu/ontology/prns#PluginInstance' 
				AND InternalID = @InternalID + '-GROUP-' + @pluginName
	END
		
	-- there is only ONE link from the person to the application object, so grab it	
	SELECT @TripleID = [TripleID] FROM [RDF.].Triple 
		WHERE [Subject] = @SubjectID
		AND [Object] = @ApplicationInstanceNodeID

	-- now delete it
	BEGIN TRAN

		EXEC [RDF.].DeleteTriple @TripleID = @TripleID, 
								 @SessionID = @SessionID, 
								 @Error = @Error

		IF (@DeleteType = 0) -- true delete, remove the now orphaned application instance
		BEGIN
			EXEC [RDF.].DeleteNode @NodeID = @ApplicationInstanceNodeID, 
							   @DeleteType = @DeleteType,
							   @SessionID = @SessionID, 
							   @Error = @Error OUTPUT
		END							   
	COMMIT
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[GenericRDF.AddEditPluginData]
	@Name varchar(55),
	@NodeID bigint,
	@Data varchar(max),
	@SearchableData varchar(max)
AS
BEGIN
	DECLARE @Error bit, @PluginInstanceID BIGINT
	IF ISNULL(@Data, '') <> ''
	BEGIN
		IF EXISTS (SELECT 1 FROM [Profile.Module].[GenericRDF.Data] WHERE Name = @Name and NodeID = @NodeID)
		BEGIN
			UPDATE [Profile.Module].[GenericRDF.Data] SET Data = @Data, SearchableData = @SearchableData WHERE Name = @Name and NodeID = @NodeID
		END
		ELSE
		BEGIN		
			INSERT INTO [Profile.Module].[GenericRDF.Data] (Name, NodeID, Data, SearchableData) VALUES(@Name, @NodeID, @Data, @SearchableData)
		END
		EXEC [Profile.Module].[GenericRDF.AddPluginToProfile] @SubjectID=@NodeID, @PluginName=@Name, @Error=@Error OUTPUT, @NodeID=@PluginInstanceID OUTPUT
	END
	ELSE
	BEGIN
		EXEC [Profile.Module].[GenericRDF.RemovePluginFromProfile] @SubjectID=@NodeID, @PluginName=@Name
		DELETE FROM [Profile.Module].[GenericRDF.Data] WHERE Name = @Name and NodeID = @NodeID
	END
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

CREATE PROCEDURE [Profile.Module].[GenericRDF.AddUpdateOntology]
	@PluginName varchar(55)
AS
BEGIN 
	IF EXISTS (SELECT 1 WHERE @PluginName LIKE '%[^a-zA-Z0-9]%')
	BEGIN
		SELECT '@PluginName must contain only AlphaNumeric charactors. Spaces are not allowed.'
		RETURN
	END
/*
	IF NOT EXISTS (SELECT 1 FROM [Plugin.].Plugins WHERE Name = @PluginName)
	BEGIN
		SELECT '@PluginName does not exist in [Plugin.].Plugins'
		RETURN
	END
*/

	DECLARE @PropertyGroupURI varchar(400),
		@CustomDisplayModuleXML xml,
		@CustomEditModuleXML xml,
		@label varchar(55),
		@InternalType nvarchar(100),
		@PropertyURI nvarchar(400),
		@Error BIT,
		@NodeID BIGINT,
		@LabelNodeID BIGINT

	SET @PropertyURI = 'http://profiles.catalyst.harvard.edu/ontology/plugins#' + @PluginName

	SELECT @InternalType = n.value FROM [rdf.].[Triple] t JOIN [rdf.].Node n ON t.[Object] = n.NodeID 
		WHERE t.[Subject] = [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#Plugin')
		and t.Predicate = [RDF.].fnURI2NodeID('http://www.w3.org/2000/01/rdf-schema#label')



	IF EXISTS (SELECT 1 FROM [Profile.Module].[GenericRDF.Plugins] WHERE Name = @PluginName AND EnabledForPerson = 1)
	BEGIN
		SELECT @PropertyGroupURI=ISNULL(PropertyGroupURI, 'http://profiles.catalyst.harvard.edu/ontology/prns#PropertyGroupOverview'),
			@CustomDisplayModuleXML=ISNULL(CustomDisplayModuleXML, '<Module ID="' + CustomDisplayModule + '" />'),
			@CustomEditModuleXML=ISNULL(CustomEditModuleXML, '<Module ID="' + CustomEditModule + '" />'),
			@label = label
			FROM [Profile.Module].[GenericRDF.Plugins] WHERE Name = @PluginName AND EnabledForPerson = 1

		EXEC [Ontology.].[AddProperty]	@OWL = 'PLUGINS_1.0', 
									@PropertyURI = @PropertyURI,
									@PropertyName = @label,
									@ObjectType = 0,
									@PropertyGroupURI = @PropertyGroupURI, 
									@ClassURI = 'http://xmlns.com/foaf/0.1/Person',
									@IsDetail = 0,
									@IncludeDescription = 0

		UPDATE [Ontology.].[ClassProperty] set EditExistingSecurityGroup = -20, ViewSecurityGroup = -1,
			IsDetail = 0, IncludeDescription = 1, SearchWeight = 1,
			CustomEdit = 1, CustomEditModule = @CustomEditModuleXML,
			CustomDisplay = 1, CustomDisplayModule = @CustomDisplayModuleXML,
			EditSecurityGroup = -20, EditPermissionsSecurityGroup = -20, -- was -20's
			EditAddNewSecurityGroup = -20, EditAddExistingSecurityGroup = -20, EditDeleteSecurityGroup = -20 
		WHERE class = 'http://xmlns.com/foaf/0.1/Person'
			AND property = @PropertyURI
	END
	ELSE
	BEGIN
		UPDATE [Ontology.].[ClassProperty] set EditExistingSecurityGroup = -50, ViewSecurityGroup = -50,
			EditSecurityGroup = -50, EditPermissionsSecurityGroup = -50, -- was -20's
			EditAddNewSecurityGroup = -50, EditAddExistingSecurityGroup = -50, EditDeleteSecurityGroup = -50 
		WHERE class = 'http://xmlns.com/foaf/0.1/Person'
			AND property = @PropertyURI
	END


	IF EXISTS (SELECT 1 FROM [Profile.Module].[GenericRDF.Plugins] WHERE Name = @PluginName AND EnabledForGroup = 1)
	BEGIN

		SELECT @PropertyGroupURI=ISNULL(PropertyGroupURI, 'http://profiles.catalyst.harvard.edu/ontology/prns#PropertyGroupOverview'),
			@CustomDisplayModuleXML=ISNULL(CustomDisplayModuleXML, '<Module ID="' + CustomDisplayModule + '" />'),
			@CustomEditModuleXML=ISNULL(CustomEditModuleXML, '<Module ID="' + CustomEditModule + '" />'),
			@label = label
			FROM[Profile.Module].[GenericRDF.Plugins] WHERE Name = @PluginName AND EnabledForGroup = 1

		EXEC [Ontology.].[AddProperty]	@OWL = 'PLUGINS_1.0', 
									@PropertyURI = @PropertyURI,
									@PropertyName = @label,
									@ObjectType = 0,
									@PropertyGroupURI = @PropertyGroupURI, 
									@ClassURI = 'http://xmlns.com/foaf/0.1/Group',
									@IsDetail = 0,
									@IncludeDescription = 0


		UPDATE [Ontology.].[ClassProperty] set EditExistingSecurityGroup = -20, ViewSecurityGroup = -1,
			IsDetail = 0, IncludeDescription = 1, SearchWeight = 1,
			CustomEdit = 1, CustomEditModule = @CustomEditModuleXML,
			CustomDisplay = 1, CustomDisplayModule = @CustomDisplayModuleXML,
			EditSecurityGroup = -20, EditPermissionsSecurityGroup = -20, -- was -20's
			EditAddNewSecurityGroup = -20, EditAddExistingSecurityGroup = -20, EditDeleteSecurityGroup = -20 
		WHERE class = 'http://xmlns.com/foaf/0.1/Group'
			AND property = @PropertyURI
	END
	ELSE
	BEGIN
		UPDATE [Ontology.].[ClassProperty] set EditExistingSecurityGroup = -50, ViewSecurityGroup = -50,
			EditSecurityGroup = -50, EditPermissionsSecurityGroup = -50, -- was -20's
			EditAddNewSecurityGroup = -50, EditAddExistingSecurityGroup = -50, EditDeleteSecurityGroup = -50 
		WHERE class = 'http://xmlns.com/foaf/0.1/Group'
			AND property = @PropertyURI
	END
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Module].[GenericRDF.GetPluginData]
	@Name varchar(55),
	@NodeID bigint
AS
BEGIN
	SELECT data FROM [Profile.Module].[GenericRDF.Data] WHERE name = @name AND NodeID = @NodeID
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[List.AddRemove.Filter]
	@UserID INT,
	@Institution VARCHAR(1000)=NULL,
	@FacultyRank VARCHAR(100)=NULL,
	@Remove BIT=0,
	@Size INT=NULL OUTPUT
AS
BEGIN

	SELECT @FacultyRank = CASE WHEN @FacultyRank = '--' THEN '' ELSE @FacultyRank END

	-- Get existing list info
	SELECT @Size = Size
		FROM [Profile.Data].[List.General]
		WHERE UserID = @UserID

	-- Get the list of people
	CREATE TABLE #p (PersonID INT PRIMARY KEY)
	INSERT INTO #p
		SELECT l.PersonID
			FROM [Profile.Data].[List.Member] l
				LEFT OUTER JOIN [Profile.Cache].[Person] p
					ON l.PersonID=p.PersonID
			WHERE l.UserID=@UserID AND
				(CASE WHEN @Institution IS NULL THEN 1
					WHEN @Institution = p.InstitutionName THEN 1
					ELSE 0 END)
				+(CASE WHEN @FacultyRank IS NULL THEN 1
					WHEN @FacultyRank = p.FacultyRank THEN 1
					ELSE 0 END)
				=2

	BEGIN TRANSACTION
		-- Remove
		IF (@Remove=1)
		BEGIN
			DELETE FROM [Profile.Data].[List.Member]
				WHERE UserID=@UserID AND PersonID IN (SELECT PersonID FROM #p)
		END
		-- Update list size
		UPDATE [Profile.Data].[List.General]
			SET Size = (SELECT COUNT(*) FROM [Profile.Data].[List.Member] WHERE UserID=@UserID)
			WHERE UserID = @UserID
		SELECT @Size = Size
			FROM [Profile.Data].[List.General]
			WHERE UserID=@UserID
	COMMIT TRANSACTION

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[List.AddRemove.Person]
	@UserID INT,
	@PersonID INT,
	@Remove BIT=0,
	@Size INT=NULL OUTPUT
AS
BEGIN

	-- Get existing list info
	SELECT @Size = Size
		FROM [Profile.Data].[List.General]
		WHERE UserID = @UserID

	-- Determine if the person is in the list
	DECLARE @PersonInList BIT
	SELECT @PersonInList = 0
	SELECT @PersonInList = 1
		FROM [Profile.Data].[List.Member] 
		WHERE UserID=@UserID AND PersonID=@PersonID

	BEGIN TRANSACTION

	-- Add the person if needed
	IF (@Remove=0 AND @PersonInList=0)
	BEGIN
		INSERT INTO [Profile.Data].[List.Member] (UserID, PersonID)
			SELECT @UserID, @PersonID
		UPDATE [Profile.Data].[List.General]
			SET Size = Size+1
			WHERE UserID = @UserID
		SELECT @Size = @Size+1
	END

	-- Remove the person if needed
	IF (@Remove=1 AND @PersonInList=1)
	BEGIN
		DELETE FROM [Profile.Data].[List.Member]
			WHERE UserID=@UserID AND PersonID=@PersonID
		UPDATE [Profile.Data].[List.General]
			SET Size = Size-1
			WHERE UserID = @UserID
		SELECT @Size = @Size-1
	END

	COMMIT TRANSACTION

END


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[List.AddRemove.SelectedPeople]
	@UserID INT,
	@SelectedPeople VARCHAR(MAX),
	@Remove BIT=0,
	@Size INT=NULL OUTPUT
AS
BEGIN

	-- Get existing list info
	SELECT @Size = Size
		FROM [Profile.Data].[List.General]
		WHERE UserID = @UserID

	-- Get the list of people
	CREATE TABLE #p (PersonID INT PRIMARY KEY)
	DECLARE @x XML
	SELECT @x = CAST('<x>'+REPLACE(@SelectedPeople,',','</x><x>')+'</x>' AS XML)
	INSERT INTO #p
		SELECT DISTINCT r.p.value('.','INT')
		FROM (SELECT @x x) t
			CROSS APPLY t.x.nodes('x') AS r(p)

	BEGIN TRANSACTION
		-- Remove
		IF (@Remove=1)
		BEGIN
			DELETE FROM [Profile.Data].[List.Member]
				WHERE UserID=@UserID AND PersonID IN (SELECT PersonID FROM #p)
		END
		-- Update list size
		UPDATE [Profile.Data].[List.General]
			SET Size = (SELECT COUNT(*) FROM [Profile.Data].[List.Member] WHERE UserID=@UserID)
			WHERE UserID = @UserID
		SELECT @Size = Size
			FROM [Profile.Data].[List.General]
			WHERE UserID=@UserID
	COMMIT TRANSACTION

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[List.AddRemove.Search]
	@UserID INT,
	@SearchXML XML,
	@SessionID UNIQUEIDENTIFIER,
	@Remove BIT=0,
	@Size INT=NULL OUTPUT
AS
BEGIN

	-- Get existing list info
	SELECT @Size = Size
		FROM [Profile.Data].[List.General]
		WHERE UserID = @UserID

	-- Construct a search XML
	DECLARE @MatchOptions VARCHAR(MAX)
	DECLARE @SearchOptions XML
	SELECT @MatchOptions = CAST(t.p.query('.') AS VARCHAR(MAX))
		FROM @SearchXML.nodes('/SearchOptions/MatchOptions') AS t(p)
	SELECT @SearchOptions = 
		'<SearchOptions>' + 
			@MatchOptions +
			'<OutputOptions>
				<Offset>0</Offset>
				<Limit>100000</Limit>
			</OutputOptions>	
		</SearchOptions>'

	-- Get the list of matching people
	CREATE TABLE #Node (
		SortOrder bigint primary key,
		NodeID bigint,
		Paths bigint,
		Weight float,
		PersonID int
	)
	INSERT INTO #Node (SortOrder, NodeID, Paths, Weight) 
		EXEC [Search.].[GetNodes] @SearchOptions=@SearchOptions, @NoRDF=1, @SessionID=@SessionID
	UPDATE n SET PersonID = m.InternalID 
		FROM #Node n
			INNER JOIN [RDF.Stage].InternalNodeMap m 
				ON Class = 'http://xmlns.com/foaf/0.1/Person' AND InternalType = 'Person' AND n.NodeID = m.NodeID

	-- Add or Remove
	BEGIN TRANSACTION
		-- Add
		IF (@Remove=0)
			INSERT INTO [Profile.Data].[List.Member] (UserID, PersonID)
				SELECT @UserID, PersonID
					FROM #Node n
					WHERE NOT EXISTS (
						SELECT *
						FROM [Profile.Data].[List.Member] l
						WHERE l.UserID=@UserID AND n.PersonID=l.PersonID
					)
		-- Remove
		IF (@Remove=1)
			DELETE l
				FROM [Profile.Data].[List.Member] l
					INNER JOIN #Node n
						ON l.UserID=@UserID AND l.PersonID=n.PersonID
		-- Update list size
		UPDATE [Profile.Data].[List.General]
			SET Size = (SELECT COUNT(*) FROM [Profile.Data].[List.Member] WHERE UserID=@UserID)
			WHERE UserID = @UserID
		SELECT @Size = Size
			FROM [Profile.Data].[List.General]
			WHERE UserID=@UserID
	COMMIT TRANSACTION

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[List.ExportCoAuthorConnections] 
	@UserID int
AS
BEGIN

	SELECT Data 
	FROM (
		SELECT 0 x, 0 PersonID1, 0 PersonID2, '"PersonID 1","PersonID 2","First Name 1","Last Name 1","Display Name 1","First Name 2","Last Name 2","Display Name 2"'
				+',"CoAuthored Publications","First CoAuthored Publication","Last CoAuthored Publication"' AS Data
		UNION
		SELECT 1 x, m1.PersonID, m2.PersonID,
				CAST(m1.PersonID AS VARCHAR(50))
				+ ',' + CAST(m2.PersonID as varchar(MAX))
				+ ',"' + REPLACE(p1.FirstName,'"','""') + '"'
				+ ',"' + REPLACE(p1.LastName,'"','""') + '"'
				+ ',"' + REPLACE(p1.DisplayName,'"','""') + '"'
				+ ',"' + REPLACE(p2.FirstName,'"','""') + '"'
				+ ',"' + REPLACE(p2.LastName,'"','""') + '"'
				+ ',"' + REPLACE(p2.DisplayName,'"','""') + '"'
				+ ',' + CAST(n AS VARCHAR(50))
				+ ',"' + CONVERT(VARCHAR(50), FirstPubDate, 101) + '"'
				+ ',"' + CONVERT(VARCHAR(50), LastPubDate, 101) + '"'
			FROM [Profile.Cache].[SNA.Coauthor] c 
				INNER JOIN [Profile.Data].[List.Member] m1 ON c.PersonID1 = m1.PersonID  AND m1.UserID = @UserID
				INNER JOIN [Profile.Data].[List.Member] m2 ON c.PersonID2 = m2.PersonID AND m2.UserID = @UserID
				INNER JOIN [Profile.Cache].[Person] p1 ON PersonID1 = p1.PersonID
				INNER JOIN [Profile.Cache].[Person] p2 ON PersonID2 = p2.PersonID
			WHERE c.PersonID1 < c.PersonID2
	) t
	ORDER BY x, PersonID1, PersonID2

END


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[List.ExportPersonList] 
	@UserID INT
AS
BEGIN

	DECLARE @IsAdmin INT
	SELECT @IsAdmin=1
		FROM [Profile.Data].[List.Admin] a
		WHERE @UserID IS NOT NULL
			AND a.UserID=@UserID

	DECLARE @basePath nvarchar(max)
	SELECT @basePath = Value from [Framework.].Parameter where ParameterID = 'basePath'

	SELECT Data 
	FROM (
		SELECT -1 PersonID, 
				'"PersonID","First Name","Last Name","Display Name"'
				+',"Address Line 1","Address Line 2","Address Line 3","Address Line 4","Address","Latitude","Longitude"'
				+',"Phone","Fax","Institution","Department","Division","Faculty Rank"'
				+',"Publications","CoAuthors"'
				+(CASE WHEN @IsAdmin=1 THEN ',"Email"' ELSE '' END)
				+',"Profiles URL"'
				Data
		UNION ALL
		SELECT m.PersonID, 
				CAST(m.PersonID AS VARCHAR(50)) 
				+ ',"' + REPLACE(FirstName,'"','""') + '"'
				+ ',"' + REPLACE(LastName,'"','""') + '"'
				+ ',"' + REPLACE(DisplayName,'"','""') + '"'
				+ ',' + (CASE WHEN ShowAddress = 'Y' THEN 
								'"' + REPLACE(ISNULL(AddressLine1,''),'"','""') + '"'
								+ ',"' + REPLACE(ISNULL(AddressLine2,''),'"','""') + '"'
								+ ',"' + REPLACE(ISNULL(AddressLine3,''),'"','""') + '"'
								+ ',"' + REPLACE(ISNULL(AddressLine4,''),'"','""') + '"'
								+ ',"' + REPLACE(ISNULL(AddressString,''),'"','""') + '"'
								+ ',' + ISNULL(CAST(Latitude AS VARCHAR(50)), '')
								+ ',' + ISNULL(CAST(Longitude AS VARCHAR(50)), '') 
							ELSE ',,,,,,' END)
				+ ',' + (CASE WHEN ShowPhone = 'Y' THEN '"'+REPLACE(REPLACE(Phone,',','-'),'"','""')+'"' ELSE '' END)
				+ ',' + (CASE WHEN ShowFax = 'Y' THEN '"'+REPLACE(REPLACE(Fax,',','-'),'"','""')+'"' ELSE '' END)
				+ ',"' + REPLACE(ISNULL(InstitutionName,''),'"','""') + '"'
				+ ',"' + REPLACE(ISNULL(DepartmentName,''),'"','""') + '"'
				+ ',"' + REPLACE(ISNULL(DivisionFullName,''),'"','""') + '"'
				+ ',"' + REPLACE(ISNULL(FacultyRank,''),'"','""') + '"'
				+ ',' + (CASE WHEN ShowPublications='Y' THEN 
								CAST(ISNULL(NumPublications,0) AS VARCHAR(50)) 
								+ ',' + CAST(ISNULL(Reach1,0) AS VARCHAR(50))
							ELSE ',' END)
				+ (CASE WHEN @IsAdmin=1 THEN ',' + (CASE WHEN ShowEmail='Y' AND x.UserID IS NOT NULL THEN '"'+REPLACE(EmailAddr,'"','""')+'"' ELSE '""' END) ELSE '' END)
				+ ',"' + @basePath + isnull('/Display/' + a2.AliasType + '/' + AliasID, '/Profile/' + cast(i.NodeID as nvarchar(max))) + '"'
			FROM [Profile.Data].[List.Member] m 
				INNER JOIN [Profile.Cache].[Person] p 
					ON m.PersonID = p.PersonID AND m.UserID = @UserID
				JOIN [RDF.Stage].InternalNodeMap i ON i.class = 'http://xmlns.com/foaf/0.1/Person' AND m.PersonID = i.InternalID
				LEFT JOIN [RDF.].Alias a2 on i.NodeID = a2.NodeID and a2.Preferred = 1
				OUTER APPLY (
					SELECT MAX(UserID) UserID
					FROM [Profile.Data].[List.Admin] a
					WHERE @UserID IS NOT NULL
						AND a.UserID=@UserID
						AND (CASE WHEN a.AdminForInstitution IS NULL THEN 1 WHEN a.AdminForInstitution=p.InstitutionName THEN 1 ELSE 0 END)=1
						AND (CASE WHEN a.AdminForDepartment IS NULL THEN 1 WHEN a.AdminForDepartment=p.DepartmentName THEN 1 ELSE 0 END)=1
						AND (CASE WHEN a.AdminForDivision IS NULL THEN 1 WHEN a.AdminForDivision=p.DivisionFullName THEN 1 ELSE 0 END)=1
				) x
	) t
	ORDER BY PersonID

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[List.ExportPersonPublicationsList] 
	@UserID int
AS
BEGIN

	SELECT Data 
	FROM (
		SELECT -1 PersonID, '"PersonID","First Name","Last Name","Display Name","PubMed ID","Publication Date","Source (Journal)","Item (Article)","Reference","URL"' Data
		UNION ALL
		SELECT l.PersonID, Data
			FROM [Profile.Data].[List.Member] l
				INNER JOIN [Profile.Cache].[List.Export.Publications] p
					ON l.UserID=@UserID AND l.PersonID=p.PersonID
	) t
	ORDER BY PersonID

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[List.GetList]
	@SessionID UNIQUEIDENTIFIER,
	@ListID INT=NULL OUTPUT,
	@Size INT=NULL OUTPUT
AS
BEGIN

	-- Convert SessionID to UserID
	DECLARE @UserID INT
	SELECT @UserID = UserID
		FROM [User.Session].[Session]
		WHERE SessionID = @SessionID

	-- Exit if there is no user account
	IF @UserID IS NULL
		RETURN;

	-- Get existing list info
	SELECT @ListID = UserID, @Size = Size
		FROM [Profile.Data].[List.General]
		WHERE UserID = @UserID

	-- Create a new list if needed
	IF @ListID IS NULL
	BEGIN
		INSERT INTO [Profile.Data].[List.General] (UserID, Size, CreateDate)
			SELECT @UserID, 0, GetDate()
		SELECT @ListID = @UserID, @Size = 0
	END

END


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[List.GetPeople]
	@UserID INT=NULL,
	@Institution VARCHAR(1000)=NULL,
	@FacultyRank VARCHAR(100)=NULL,
	@ReturnInstitutions BIT=0,
	@ReturnFacultyRanks BIT=0,
	@Offset INT=0,
	@Limit INT=100000,
	@NumPeople INT=NULL OUTPUT
AS
BEGIN

	-- Create a temp table to store the list
	CREATE TABLE #p (
		SortOrder INT IDENTITY(0,1) PRIMARY KEY,
		PersonID INT NOT NULL,
		FirstName VARCHAR(100),
		LastName VARCHAR(100),
		DisplayName VARCHAR(510),
		InstitutionName VARCHAR(1000),
		FacultyRank VARCHAR(100),
		FacultyRankSort TINYINT,
		DepartmentName VARCHAR(1000)
	)

	SELECT @FacultyRank = CASE WHEN @FacultyRank = '--' THEN '' ELSE @FacultyRank END

	-- Get the list of people
	INSERT INTO #p (PersonID, FirstName, LastName, DisplayName, InstitutionName, FacultyRank, FacultyRankSort, DepartmentName)
		SELECT m.PersonID, p.FirstName, p.LastName, p.DisplayName, p.InstitutionName, p.FacultyRank, p.FacultyRankSort, p.DepartmentName
		FROM [Profile.Data].[List.Member] m 
			INNER JOIN [Profile.Cache].[Person] p
				ON m.UserID = @UserID AND m.PersonID = p.PersonID
		WHERE
			(CASE WHEN @Institution IS NULL THEN 1
				WHEN @Institution = p.InstitutionName THEN 1
				ELSE 0 END)
			+(CASE WHEN @FacultyRank IS NULL THEN 1
				WHEN @FacultyRank = p.FacultyRank THEN 1
				ELSE 0 END)
			=2
		ORDER BY LastName, FirstName, DisplayName, PersonID

	-- Determine the number of people
	SELECT @NumPeople=(SELECT COUNT(*) FROM #p)

	-- Return the institutions
	IF (@ReturnInstitutions=1)
		SELECT InstitutionName, COUNT(*) n
		FROM #p
		--FROM [Profile.Data].[List.Member] m 
		--	INNER JOIN [Profile.Cache].[Person] p
		--		ON ListID = @ListID AND m.PersonID = p.PersonID
		GROUP BY InstitutionName
		ORDER BY InstitutionName

	-- Return the faculty ranks
	IF (@ReturnFacultyRanks=1)
		SELECT FacultyRank, n
		FROM (
			SELECT FacultyRank, FacultyRankSort, COUNT(*) n
			FROM #p
			--FROM [Profile.Data].[List.Member] m 
			--	INNER JOIN [Profile.Cache].[Person] p
			--		ON ListID = @ListID AND m.PersonID = p.PersonID
			GROUP BY FacultyRank, FacultyRankSort
		) t
		ORDER BY FacultyRankSort

	-- Return the people
	SELECT PersonID, DisplayName, FirstName, LastName, InstitutionName, FacultyRank, DepartmentName
		FROM #p
		WHERE SortOrder>=@Offset AND SortOrder<@Offset+@Limit
		ORDER BY SortOrder

END


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[List.GetSummary] 
	@UserID int
AS
BEGIN

	--declare @ListID int 
	--set @listid=5

	;WITH a AS (
		SELECT p.*
		FROM [Profile.Data].[List.Member] m 
			INNER JOIN [Profile.Cache].[Person] p 
				ON m.PersonID = p.PersonID AND m.UserID = @UserID 
	), b AS (
		SELECT 'Institution' Variable, InstitutionName Value, COUNT(*) n
			FROM a
			GROUP BY InstitutionName
		UNION ALL
		SELECT 'Department' Variable, DepartmentName Value, COUNT(*) n
			FROM a
			GROUP BY DepartmentName
		UNION ALL
		SELECT 'FacultyRank' Variable, FacultyRank Value, COUNT(*) n
			FROM a
			GROUP BY FacultyRank
	), c AS (
		SELECT Variable, ISNULL(NULLIF(Value,''),'Unknown') Value, n
		FROM b
	), d AS (
		SELECT Variable, Value, n,
			ROW_NUMBER() OVER (PARTITION BY Variable ORDER BY (CASE WHEN Value='Other' then 1 else 0 end), n desc, Value) k,
			COUNT(*) OVER (PARTITION BY Variable) m
		FROM c
	), e AS (
		SELECT Variable, (CASE WHEN k>10 THEN 'Other' WHEN k=10 AND m>10 THEN 'Other' ELSE Value END) Value, n
			FROM d
	)
	SELECT Variable, Value, sum(n) n
		FROM e
		GROUP BY Variable, Value
		ORDER BY (CASE Variable WHEN 'Institution' THEN 0 WHEN 'Department' THEN 1 ELSE 2 END),
			(CASE WHEN Value='Other' then 1 else 0 end), n desc

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[List.UpdateAllLists]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	SELECT UserID, PersonID
		INTO #p
		FROM [Profile.Data].[List.Member]
		WHERE PersonID NOT IN (SELECT PersonID FROM [Profile.Cache].[Person])

	ALTER TABLE #p ADD PRIMARY KEY (ListID, PersonID)

	BEGIN TRANSACTION

		DELETE m
			FROM [Profile.Data].[List.Member] m
				INNER JOIN #p p ON m.UserID=p.UserID AND m.PersonID=p.PersonID

		SELECT UserID, COUNT(*) n
			INTO #l
			FROM [Profile.Data].[List.Member]
			GROUP BY UserID

		ALTER TABLE #l ADD PRIMARY KEY (UserID)

		UPDATE g
			SET g.Size=l.n
			FROM [Profile.Data].[List.General] g
				INNER JOIN #l l ON g.UserID=l.UserID AND g.Size<>l.n

		UPDATE [Profile.Data].[List.General]
			SET Size=0
			WHERE UserID NOT IN (SELECT UserID FROM #l)

	COMMIT TRANSACTION

END


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Module].[NetworkMap.GetList]
	@UserID BIGINT=NULL,
	@which INT=0,
	@SessionID UNIQUEIDENTIFIER=NULL
AS
BEGIN

	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET nocount  ON;
 
	DECLARE  @f  TABLE(
		PersonID INT,
		display_name NVARCHAR(255),
		latitude FLOAT,
		longitude FLOAT,
		address1 NVARCHAR(1000),
		address2 NVARCHAR(1000),
		URI VARCHAR(400)
	)
 
	INSERT INTO @f (PersonID, display_name, latitude, longitude, address1, address2, URI)
		SELECT t.PersonID, t.DisplayName, t.latitude, t.longitude, b.Addr, 
			'('+(CASE WHEN t.n=1 THEN '1 Person' 
					WHEN t.n>5 THEN '5 of '+CAST(n AS VARCHAR(10))+' People Shown' 
					ELSE CAST(n AS VARCHAR(10))+' People' 
					END)+')', 
			f.Value + cast(m.NodeID as varchar(50)) URI
		FROM (
			SELECT *, DENSE_RANK() OVER (ORDER BY n DESC, r DESC, p) k
			FROM (
				SELECT *, COUNT(*) OVER (PARTITION BY i) n, SUM(Reach1) OVER (PARTITION BY i) r, MIN(PersonID) OVER (PARTITION BY i) p
				FROM (
					SELECT	p.PersonID,
							p.displayname,
							p.latitude,
							p.longitude,
							p.AddressLine1,
							p.AddressLine2,
							p.AddressLine3,
							p.AddressLine4,
							p.AddressString,
							p.Reach1,
							p.NumPublications,
							DENSE_RANK() OVER (ORDER BY p.latitude, p.longitude) i,
							ROW_NUMBER() OVER (PARTITION BY p.latitude, p.longitude ORDER BY p.Reach1 DESC, p.NumPublications DESC, p.PersonID) j
					FROM [Profile.Cache].[Person] p
						INNER JOIN [Profile.Data].[List.Member] m
							ON p.PersonID = m.PersonID
					WHERE m.UserID = @UserID
						AND ISNULL(p.latitude,0)<>0
						AND ISNULL(p.longitude,0)<>0
				) t
			) t
		) t 
		INNER JOIN [RDF.Stage].[InternalNodeMap] m
			ON t.PersonID=m.InternalID AND m.class='http://xmlns.com/foaf/0.1/Person' AND m.InternalType='Person'
		CROSS JOIN [Framework.].[Parameter] f
		CROSS APPLY (
			SELECT LTRIM(RTRIM(ISNULL(AddressLine1,''))) a1, LTRIM(RTRIM(ISNULL(AddressLine2,''))) a2, LTRIM(RTRIM(ISNULL(AddressLine3,''))) a3, LTRIM(RTRIM(ISNULL(AddressLine4,''))) a4
		) a
		OUTER APPLY (
			SELECT TOP 1 addr
			FROM (
				SELECT 0 x, a3 + ', ' + a4 addr
					WHERE a3<>'' AND a4<>''
				UNION ALL SELECT 1 x, a1 + ', ' + a4
					WHERE a1<>'' AND a3='' AND a4<>'' AND (a2='' OR a2 LIKE 'Ste %' OR a2 LIKE 'Suite %')
				UNION ALL SELECT 2 x, a2 + ', ' + a4
					WHERE a3='' AND a4<>'' AND a2 LIKE '[0-9]%'
				UNION ALL SELECT 3 x, LTRIM(RTRIM(REPLACE(REPLACE(REPLACE(AddressString,'  ',' '),'  ',' '),'  ',' ')))
			) t
			ORDER BY x
		) b
		WHERE t.k<=20 AND t.j<=5 AND f.ParameterID = 'baseURI'


	IF @which = 0
	BEGIN
		SELECT PersonID, 
			display_name,
			latitude,
			longitude,
			address1,
			address2,
			URI
		FROM @f
		ORDER BY address1,
			address2,
			display_name
	END
	ELSE
	BEGIN
		SELECT DISTINCT	a.latitude	x1,
						a.longitude	y1,
						d.latitude	x2,
						d.longitude	y2,
						a.PersonID	a,
						d.PersonID	b,
						0 is_person,
						a.URI u1,
						d.URI u2
			FROM @f a,
					 [Profile.Data].[Publication.Person.Include] b,
					 [Profile.Data].[Publication.Person.Include] c,
					 @f d
		 WHERE a.PersonID = b.PersonID
			 AND b.pmid = c.pmid
			 AND b.PersonID < c.PersonID
			 AND c.PersonID = d.PersonID
			 --AND 1=0
	END
		
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Module].[NetworkRadial.List.GetCoAuthors]
	@UserID BIGINT,
	@SessionID UNIQUEIDENTIFIER=NULL,
	@OutputFormat VARCHAR(50)='JSON'
AS
BEGIN
	SET NOCOUNT ON;	

	--declare @ListID bigint
	--select @ListID=12
 
	SELECT TOP 120
					personid,
					distance,
					numberofpaths,
					weight,
					w2,
					lastname,
					firstname,
					p,
					k,
					cast(-1 as bigint) nodeid,
					cast('' as varchar(400)) uri,
					0 nodeindex
		INTO #network 
		FROM ( 
						SELECT p.personid, 
										1 as distance, 
										0 as numberofpaths, 
										0 as weight, 
										0.5 as w2, 
										p.lastname, 
										p.firstname, 
										p.numpublications p, 
										ROW_NUMBER() OVER (ORDER BY p.numpublications DESC) k 
							FROM [Profile.Cache].Person p
							JOIN [Profile.Data].[List.Member] g
							on p.PersonID = g.PersonID
							  AND p.IsActive = 1
							  and g.UserID = @UserID
					) t 
		--WHERE k <= 80 
	ORDER BY distance, k

	--UPDATE #network set distance = 0 where k = 1
	
	UPDATE n
		SET n.NodeID = m.NodeID, n.URI = p.Value + cast(m.NodeID as varchar(50))
		FROM #network n, [RDF.Stage].InternalNodeMap m, [Framework.].Parameter p
		WHERE p.ParameterID = 'baseURI' AND m.InternalHash = [RDF.].fnValueHash(null,null,'http://xmlns.com/foaf/0.1/Person^^Person^^'+cast(n.PersonID as varchar(50)))
 
	DELETE FROM #network WHERE IsNull(URI,'') = ''	


	UPDATE a
		SET a.nodeindex = b.ni
		FROM #network a, (
			SELECT *, row_number() over (order by distance desc, k desc)-1 ni
			FROM #network
		) b
		WHERE a.personid = b.personid

/*
	SELECT c.personid1 id1, c.personid2	id2, c.n, CAST(c.w AS VARCHAR) w, 
			(CASE WHEN YEAR(firstpubdate)<1980 THEN 1980 ELSE YEAR(firstpubdate) END) y1, 
			(CASE WHEN YEAR(lastpubdate)<1980 THEN 1980 ELSE YEAR(lastpubdate) END) y2,
			0 k,
			a.nodeid n1, b.nodeid n2, a.uri u1, b.uri u2, a.nodeindex ni1, b.nodeindex ni2
		into #network2
		from #network a
			JOIN #network b on a.personid < b.personid  
			JOIN [Profile.Cache].[SNA.Coauthor] c ON a.personid = c.personid1 and b.personid = c.personid2  
 
	;with a as (
		select id1, id2, w, k from #network2
		union all
		select id2, id1, w, k from #network2
	), b as (
		select a.*, row_number() over (partition by a.id1 order by a.w desc, a.id2) s
		from a, 
			(select id1 from a group by id1 having max(k) = 0) b,
			(select id1 from a group by id1 having max(k) > 0) c
		where a.id1 = b.id1 and a.id2 = c.id1
	)
	update n
		set n.k = 2
		from #network2 n, b
		where (n.id1 = b.id1 and n.id2 = b.id2 and b.s = 1) or (n.id1 = b.id2 and n.id2 = b.id1 and b.s = 1)
 
	update n
		set n.k = 3
		from #network2 n, (
			select *, row_number() over (order by k desc, w desc) r 
			from #network2 
		) r
		where n.id1=r.id1 and n.id2=r.id2 and n.k=0 and r.r<=360
 */


 	SELECT top 360 c.personid1 id1, c.personid2	id2, c.n, CAST(c.w AS VARCHAR) w, 
			(CASE WHEN YEAR(firstpubdate)<1980 THEN 1980 ELSE YEAR(firstpubdate) END) y1, 
			(CASE WHEN YEAR(lastpubdate)<1980 THEN 1980 ELSE YEAR(lastpubdate) END) y2,
			1 k,
			a.nodeid n1, b.nodeid n2, a.uri u1, b.uri u2, a.nodeindex ni1, b.nodeindex ni2
		into #network2
		from #network a
			JOIN #network b on a.personid < b.personid  
			JOIN [Profile.Cache].[SNA.Coauthor] c ON a.personid = c.personid1 and b.personid = c.personid2  
		order by c.w desc

	IF @OutputFormat = 'XML'
	BEGIN
		SELECT (
			SELECT (
				SELECT personid "@id", nodeid "@nodeid", uri "@uri", distance "@d", p "@pubs", firstname "@fn", lastname "@ln", cast(w2 as varchar(50)) "@w2"
				FROM #network
				FOR XML PATH('NetworkPerson'),ROOT('NetworkPeople'),TYPE
			), (
				SELECT id1 "@id1", id2 "@id2", n "@n", cast(w as varchar(50)) "@w", y1 "@y1", y2 "@y2",
					n1 "@nodeid1", n2 "@nodeid2", u1 "@uri1", u2 "@uri2"
				FROM #network2
				--WHERE k > 0
				FOR XML PATH('NetworkCoAuthor'),ROOT('NetworkCoAuthors'),TYPE
			)
			FOR XML PATH('LocalNetwork'), TYPE) [XML]
	END

	IF @OutputFormat = 'JSON'
	BEGIN
		SELECT
			'{'+CHAR(10)
			+'"NetworkPeople":['+CHAR(10)
			+SUBSTRING(ISNULL(CAST((
				SELECT	',{'
						+'"id":'+cast(personid as varchar(50))+','
						+'"nodeid":'+cast(nodeid as varchar(50))+','
						+'"uri":"'+uri+'",'
						+'"d":'+cast(distance as varchar(50))+',' 
						+'"pubs":'+cast(p as varchar(50))+',' 
						+'"fn":"'+firstname+'",' 
						+'"ln":"'+lastname+'",'
						+'"w2":'+cast(w2 as varchar(50))
						+'}'+CHAR(10)
				FROM #network
				ORDER BY nodeindex
				FOR XML PATH(''),TYPE
			) as VARCHAR(MAX)),''),2,9999999)
			+'],'+CHAR(10)
			+'"NetworkCoAuthors":['+CHAR(10)
			+SUBSTRING(ISNULL(CAST((
				SELECT	',{'
						+'"source":'+cast(ni2 as varchar(50))+','
						+'"target":'+cast(ni1 as varchar(50))+','
						+'"n":'+cast(n as varchar(50))+','
						+'"w":'+cast(w as varchar(50))+',' 
						+'"id1":'+cast(id1 as varchar(50))+','
						+'"id2":'+cast(id2 as varchar(50))+','
						+'"y1":'+cast(y1 as varchar(50))+',' 
						+'"y2":'+cast(y2 as varchar(50))+',' 
						+'"nodeid1":'+cast(n1 as varchar(50))+','
						+'"nodeid2":'+cast(n2 as varchar(50))+','
						+'"uri1":"'+u1+'",'
						+'"uri2":"'+u2+'"'
						+'}'+CHAR(10)
				FROM #network2
				ORDER BY ni2, ni1
				FOR XML PATH(''),TYPE
			) as VARCHAR(MAX)),''),2,9999999)
			+']'+CHAR(10)
			+'}' JSON
	END  
END


GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Cache].[List.Export.UpdatePublications]
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;


	SELECT *, ROW_NUMBER() OVER (PARTITION BY PersonID, EntityID ORDER BY PMID) k
		INTO #t
		FROM (
			SELECT p.PersonID, i.EntityID, FirstName, LastName, DisplayName, i.PMID, i.EntityDate, g.MedlineTA Source, i.EntityName Item, i.Reference, i.URL
				FROM [Profile.Cache].[Person] p 
					INNER JOIN [Profile.Data].[Publication.Entity.Authorship] a on p.PersonID = a.PersonID and a.IsActive = 1
					INNER JOIN [Profile.Data].[Publication.Entity.InformationResource] i on a.InformationResourceID = i.EntityID
					INNER JOIN [Profile.Data].[Publication.PubMed.General] g on i.PMID=g.PMID
				WHERE i.PMID IS NOT NULL
			UNION ALL
			SELECT p.PersonID, i.EntityID, FirstName, LastName, DisplayName, i.PMID, i.EntityDate, g.PubTitle Source, i.EntityName Item, i.Reference, i.URL
				FROM [Profile.Cache].[Person] p 
					INNER JOIN [Profile.Data].[Publication.Entity.Authorship] a on p.PersonID = a.PersonID and a.IsActive = 1
					INNER JOIN [Profile.Data].[Publication.Entity.InformationResource] i on a.InformationResourceID = i.EntityID
					INNER JOIN [Profile.Data].[Publication.MyPub.General] g on i.MPID=g.MPID
				WHERE i.PMID IS NULL AND i.MPID IS NOT NULL
		) t


	SELECT ISNULL(PersonID,-1) PersonID,
			ISNULL(ROW_NUMBER() OVER (PARTITION BY PersonID ORDER BY EntityDate, PMID, EntityID),-1) SortOrder,
			CAST(PersonID AS VARCHAR(50)) 
			+ ',"' + REPLACE(FirstName,'"','""') + '"'
			+ ',"' + REPLACE(LastName,'"','""') + '"'
			+ ',"' + REPLACE(DisplayName,'"','""') + '"'
			+ ',' + CAST(PMID AS VARCHAR(50))
			+ ',"' + CONVERT(VARCHAR(50), EntityDate, 101) + '"'
			+ ',"' + REPLACE(Source,'"','""') + '"'
			+ ',"' + REPLACE(Item,'"','""') + '"'
			+ ',"' + REPLACE(Reference,'"','""') + '"'
			+ ',"' + REPLACE(URL,'"','""') + '"'
			s
		INTO #p
		FROM #t
		WHERE k=1

	ALTER TABLE #p ADD PRIMARY KEY (PersonID, SortOrder)


	;WITH a AS (
		SELECT DISTINCT PersonID
		FROM #p
	)
	SELECT PersonID, SUBSTRING(Data,2,LEN(Data)) Data
		INTO #x
		FROM (
			SELECT PersonID, CAST((
					SELECT CHAR(10)+s
					FROM #p b
					WHERE b.PersonID=a.PersonID
					FOR XML PATH(''), TYPE
				) AS NVARCHAR(MAX)) Data
			FROM a
		) t

	
	TRUNCATE TABLE [Profile.Cache].[List.Export.Publications]

	INSERT INTO [Profile.Cache].[List.Export.Publications]
		SELECT * FROM #x

END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE Procedure [Profile.Data].[Publication.Pubmed.UpdateDisambiguationSettings](
	@PersonID int,
	@Enabled bit = 1
	)
AS 
BEGIN
	if exists (select 1 from [Profile.Data].[Publication.Pubmed.DisambiguationSettings] where PersonID = @PersonID)
	BEGIN
		update [Profile.Data].[Publication.Pubmed.DisambiguationSettings] set Enabled = @Enabled where PersonID = @PersonID
	END
	ELSE 
	BEGIN
		insert into [Profile.Data].[Publication.Pubmed.DisambiguationSettings] (PersonID, Enabled) values (@PersonID, @Enabled)
	END
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE Procedure [Profile.Data].[Publication.Pubmed.GetDisambiguationSettings](
	@PersonID int
	)
AS 
BEGIN
	select * from [Profile.Data].[Publication.Pubmed.DisambiguationSettings] where PersonID = @PersonID
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE Procedure [Profile.Data].[Funding.UpdateDisambiguationSettings](
	@PersonID int,
	@Enabled bit = 1
	)
AS 
BEGIN
	if exists (select 1 from [Profile.Data].[Funding.DisambiguationSettings] where PersonID = @PersonID)
	BEGIN
		update [Profile.Data].[Funding.DisambiguationSettings] set Enabled = @Enabled where PersonID = @PersonID
	END
	ELSE 
	BEGIN
		insert into [Profile.Data].[Funding.DisambiguationSettings] (PersonID, Enabled) values (@PersonID, @Enabled)
	END
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE Procedure [Profile.Data].[Funding.GetDisambiguationSettings](
	@PersonID int
	)
AS 
BEGIN
	select * from [Profile.Data].[Funding.DisambiguationSettings] where PersonID = @PersonID
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Data].[Publication.Group.MyPub.GetPublication](	@mpid NVARCHAR(50))
AS
BEGIN
	SET NOCOUNT ON;

	SELECT	HmsPubCategory, 
					AdditionalInfo, 
					authors, 
					PlaceOfPub, 
					NewspaperCol, 
					ConfDTS, 
					ConfEditors, 
					ConfNM, 
					ContractNum, 
					PublicationDT, 
					edition, 
					IssuePub, 
					ConfLoc, 
					publisher, 
					url, 
					PaginationPub, 
					ReptNumber, 
					NewspaperSect, 
					PubTitle, 
					ArticleTitle, 
					DissUnivNM, 
					VolNum, 
					abstract 
    FROM	[Profile.Data].[Publication.Group.MyPub.General] 
   WHERE	mpid =@mpid

END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE  procedure [Profile.Data].[Publication.Group.MyPub.UpdatePublication]
	@mpid nvarchar(50),
	@HMS_PUB_CATEGORY nvarchar(60) = '',
	@PUB_TITLE nvarchar(2000) = '',
	@ARTICLE_TITLE nvarchar(2000) = '',
	@CONF_EDITORS nvarchar(2000) = '',
	@CONF_LOC nvarchar(2000) = '',
	@EDITION nvarchar(30) = '',
	@PLACE_OF_PUB nvarchar(60) = '',
	@VOL_NUM nvarchar(30) = '',
	@PART_VOL_PUB nvarchar(15) = '',
	@ISSUE_PUB nvarchar(30) = '',
	@PAGINATION_PUB nvarchar(30) = '',
	@ADDITIONAL_INFO nvarchar(2000) = '',
	@PUBLISHER nvarchar(255) = '',
	@CONF_NM nvarchar(2000) = '',
	@CONF_DTS nvarchar(60) = '',
	@REPT_NUMBER nvarchar(35) = '',
	@CONTRACT_NUM nvarchar(35) = '',
	@DISS_UNIV_NM nvarchar(2000) = '',
	@NEWSPAPER_COL nvarchar(15) = '',
	@NEWSPAPER_SECT nvarchar(15) = '',
	@PUBLICATION_DT smalldatetime = '',
	@ABSTRACT varchar(max) = '',
	@AUTHORS varchar(max) = '',
	@URL varchar(1000) = '',
	@updated_by varchar(50) = ''
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	---------------------------------------------------
	-- Update the MyPub General information
	---------------------------------------------------
 
	UPDATE [Profile.Data].[Publication.Group.MyPub.General] SET
		HmsPubCategory = @HMS_PUB_CATEGORY,
		PubTitle = @PUB_TITLE,
		ArticleTitle = @ARTICLE_TITLE,
		ConfEditors = @CONF_EDITORS,
		ConfLoc = @CONF_LOC,
		EDITION = @EDITION,
		PlaceOfPub = @PLACE_OF_PUB,
		VolNum = @VOL_NUM,
		PartVolPub = @PART_VOL_PUB,
		IssuePub = @ISSUE_PUB,
		PaginationPub = @PAGINATION_PUB,
		AdditionalInfo = @ADDITIONAL_INFO,
		PUBLISHER = @PUBLISHER,
		ConfNm = @CONF_NM,
		ConfDTs = @CONF_DTS,
		ReptNumber = @REPT_NUMBER,
		ContractNum = @CONTRACT_NUM,
		DissUnivNm = @DISS_UNIV_NM,
		NewspaperCol = @NEWSPAPER_COL,
		NewspaperSect = @NEWSPAPER_SECT,
		PublicationDT = @PUBLICATION_DT,
		ABSTRACT = @ABSTRACT,
		AUTHORS = @AUTHORS,
		URL = @URL,
		UpdatedBy = @updated_by,
		UpdatedDT = GetDate()
	WHERE mpid = @mpid
		and mpid not in (select mpid from [Profile.Data].[Publication.DSpace.MPID])
		and mpid not in (select mpid from [Profile.Data].[Publication.ISI.MPID])


	IF @@ROWCOUNT > 0
	BEGIN

		DECLARE @SQL NVARCHAR(MAX)

		---------------------------------------------------
		-- Update the InformationResource Entity
		---------------------------------------------------
	
		-- Get publication information
	
		CREATE TABLE #Publications
		(
			PMID INT NULL ,
			MPID NVARCHAR(50) NULL ,
			EntityDate DATETIME NULL ,
			Reference VARCHAR(MAX) NULL ,
			Source VARCHAR(25) NULL ,
			URL VARCHAR(1000) NULL ,
			Title VARCHAR(4000) NULL
		)

		INSERT  INTO #Publications
				( MPID ,
				  EntityDate ,
				  Reference ,
				  Source ,
				  URL ,
				  Title
				)
				SELECT  MPID ,
						EntityDate ,
						Reference = REPLACE(--authors
											 (CASE WHEN IsNull(article,'') <> '' THEN article + '. ' ELSE '' END)
											+ (CASE WHEN IsNull(pub,'') <> '' THEN pub + '. ' ELSE '' END)
											+ y
											+ CASE WHEN y <> ''
														AND vip <> '' THEN '; '
												   ELSE ''
											  END + vip
											+ CASE WHEN y <> ''
														OR vip <> '' THEN '.'
												   ELSE ''
											  END, CHAR(11), '') ,
						Source = 'Custom' ,
						URL = url,
						Title = left((case when IsNull(article,'')<>'' then article when IsNull(pub,'')<>'' then pub else 'Untitled Publication' end),4000)
				FROM    ( SELECT    MPID ,
									EntityDate ,
									url ,
									authors = CASE WHEN authors = '' THEN ''
												   WHEN RIGHT(authors, 1) = '.'
												   THEN LEFT(authors,
															 LEN(authors) - 1)
												   ELSE authors
											  END ,
									article = CASE WHEN article = '' THEN ''
												   WHEN RIGHT(article, 1) = '.'
												   THEN LEFT(article,
															 LEN(article) - 1)
												   ELSE article
											  END ,
									pub = CASE WHEN pub = '' THEN ''
											   WHEN RIGHT(pub, 1) = '.'
											   THEN LEFT(pub, LEN(pub) - 1)
											   ELSE pub
										  END ,
									y ,
									vip
						  FROM      ( SELECT    MPG.mpid ,
												EntityDate = MPG.publicationdt ,
												authors = CASE WHEN RTRIM(LTRIM(COALESCE(MPG.authors,
																  ''))) = ''
															   THEN ''
															   WHEN RIGHT(COALESCE(MPG.authors,
																  ''), 1) = '.'
																THEN  COALESCE(MPG.authors,
																  '') + ' '
															   ELSE COALESCE(MPG.authors,
																  '') + '. '
														  END ,
												url = CASE WHEN COALESCE(MPG.url,
																  '') <> ''
																AND LEFT(COALESCE(MPG.url,
																  ''), 4) = 'http'
														   THEN MPG.url
														   WHEN COALESCE(MPG.url,
																  '') <> ''
														   THEN 'http://' + MPG.url
														   ELSE ''
													  END ,
												article = LTRIM(RTRIM(COALESCE(MPG.articletitle,
																  ''))) ,
												pub = LTRIM(RTRIM(COALESCE(MPG.pubtitle,
																  ''))) ,
												y = CASE WHEN MPG.publicationdt > '1/1/1901'
														 THEN CONVERT(VARCHAR(50), YEAR(MPG.publicationdt))
														 ELSE ''
													END ,
												vip = COALESCE(MPG.volnum, '')
												+ CASE WHEN COALESCE(MPG.issuepub,
																  '') <> ''
													   THEN '(' + MPG.issuepub
															+ ')'
													   ELSE ''
												  END
												+ CASE WHEN ( COALESCE(MPG.paginationpub,
																  '') <> '' )
															AND ( COALESCE(MPG.volnum,
																  '')
																  + COALESCE(MPG.issuepub,
																  '') <> '' )
													   THEN ':'
													   ELSE ''
												  END + COALESCE(MPG.paginationpub,
																 '')
									  FROM      [Profile.Data].[Publication.Group.MyPub.General] MPG
									  WHERE MPID = @mpid
									) T0
						) T0

		-- Update the entity record
		DECLARE @EntityID INT		
		UPDATE e
			SET e.EntityDate = p.EntityDate,
				e.Reference = p.Reference,
				e.Source = p.Source,
				e.URL = p.URL,
				@EntityID = e.EntityID
			FROM #publications p, [Profile.Data].[Publication.Entity.InformationResource] e
			WHERE p.MPID = e.MPID

	END
 
END

GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.Pubmed.ParsePubmedBookArticle]
	@pmid int,
	@mpid varchar(50)
AS
BEGIN
	SET NOCOUNT ON;
	update [Profile.Data].[Publication.PubMed.AllXML] set ParseDT = GETDATE() where pmid = @pmid

	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	

	if not exists (select 1 from [Profile.Data].[vwPublication.PubMed.AllXML.PubmedBookArticle] where pmid = @pmid)
	begin
		set @ErrMsg =  'Error in [Profile.Data].[Publication.Pubmed.ParsePubmedBookArticle] pmid ' + cast(@pmid as varchar(50)) + ' does not exist'
		RAISERROR(@ErrMsg, 16, 1)
	end

	create table #authors (
		ValidYN varchar(1),
		LastName varchar(100),
		FirstName varchar(100),
		ForeName varchar(100),
		Suffix varchar(20),
		Initials varchar(20),
		Affiliation varchar(max))
			
	insert into #authors
	select
		nref.value('@ValidYN','varchar(1)') ValidYN, 
		nref.value('LastName[1]','varchar(100)') LastName, 
		nref.value('FirstName[1]','varchar(100)') FirstName,
		nref.value('ForeName[1]','varchar(100)') ForeName,
		nref.value('Suffix[1]','varchar(20)') Suffix,
		nref.value('Initials[1]','varchar(20)') Initials,
		COALESCE(nref.value('AffiliationInfo[1]/Affiliation[1]','varchar(1000)'),
			nref.value('Affiliation[1]','varchar(max)')) Affiliation
	from [Profile.Data].[Publication.PubMed.AllXML] cross apply x.nodes('//AuthorList[@Type="authors"]/Author') as R(nref) 
	where pmid = @pmid

	declare @authors varchar(max)
	select @authors = isnull(cast((
		select ', '+lastname+' '+initials
		from #authors q
		--order by PmPubsAuthorID
		for xml path(''), type
	) as nvarchar(max)),'') 

	if len(@authors) > 2
	select @authors = SUBSTRING(@authors, 3, len(@authors) - 2)
	
	BEGIN TRY
	BEGIN TRANSACTION
		if exists (select 1 from [Profile.Data].[Publication.MyPub.General] where pmid=@pmid)
		begin
			update a set 
				HmsPubCategory = b.HmsPubCategory,
				a.PubTitle = b.PubTitle,
				a.ArticleTitle = b.ArticleTitle,
				a.PlaceOfPub = b.PlaceOfPub,
				a.Publisher = b.Publisher,
				a.PublicationDT = b.PublicationDT,
				a.Authors = isnull(@authors, ''),
				URL = 'https://www.ncbi.nlm.nih.gov/pubmed/' + cast(@pmid as varchar(50))
			from [Profile.Data].[Publication.MyPub.General] a
			join [Profile.Data].[vwPublication.PubMed.AllXML.PubmedBookArticle] b
			on a.PMID = @pmid and b.PMID = @pmid
		end 
		else 
		begin
			insert into [Profile.Data].[Publication.MyPub.General] (MPID, PMID, HmsPubCategory, PubTitle, ArticleTitle, PlaceOfPub, Publisher, PublicationDT, Authors, URL)
			select @mpid, PMID, HmsPubCategory, PubTitle, ArticleTitle, PlaceOfPub, Publisher, PublicationDT, isnull(@authors, ''), 'https://www.ncbi.nlm.nih.gov/pubmed/' + cast(@pmid as varchar(50)) from [Profile.Data].[vwPublication.PubMed.AllXML.PubmedBookArticle] where pmid = @pmid
		end

	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=1
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE procedure [Profile.Data].[Publication.Pubmed.AddPubmedBookArticle]
	@pmid int,
	@personID int
AS
BEGIN
	DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int,@proc VARCHAR(200),@date DATETIME,@auditid UNIQUEIDENTIFIER 
	SELECT @proc = OBJECT_NAME(@@PROCID),@date=GETDATE() 	

	declare @mpid varchar(50)
	if exists (select 1 from [Profile.Data].[Publication.MyPub.General] where pmid=@pmid)
	begin
		select @mpid = mpid from [Profile.Data].[Publication.MyPub.General] where pmid=@pmid
	end
	else
	begin
		SET @mpid = cast(NewID() as nvarchar(50))
		exec [Profile.Data].[Publication.Pubmed.ParsePubmedBookArticle] @pmid=@pmid, @mpid=@mpid
	end

	DECLARE @pubid nvarchar(50)
	SET @pubid = cast(NewID() as nvarchar(50))


	BEGIN TRY
	BEGIN TRANSACTION
		INSERT INTO [Profile.Data].[Publication.Person.Include]
				( PubID, PersonID,   MPID )
	 
			VALUES (@pubid, @PersonID, @mpid)

		INSERT INTO [Profile.Data].[Publication.Person.Add]
				( PubID, PersonID,   MPID )
			VALUES (@pubid, @PersonID, @mpid)
	COMMIT TRANSACTION
	END TRY
	BEGIN CATCH
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK
		SELECT @date=GETDATE()
		EXEC [Profile.Cache].[Process.AddAuditUpdate] @auditid=@auditid OUTPUT,@ProcessName =@proc,@ProcessEndDate=@date,@error = 1,@insert_new_record=1
		--Raise an error with the details of the exception
		SELECT @ErrMsg = ERROR_MESSAGE(), @ErrSeverity = ERROR_SEVERITY()
		RAISERROR(@ErrMsg, @ErrSeverity, 1)
	END CATCH


END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [RDF.Security].[CanEditNode] (
	@NodeID	bigint,
	@SessionID UNIQUEIDENTIFIER=NULL
) 
AS
BEGIN
	DECLARE @SecurityGroupID BIGINT, @HasSpecialViewAccess BIT, @HasSpecialEditAccess BIT
	EXEC [RDF.Security].GetSessionSecurityGroup @SessionID, @SecurityGroupID OUTPUT, @HasSpecialViewAccess OUTPUT, @HasSpecialEditAccess OUTPUT
	CREATE TABLE #SecurityGroupNodes (SecurityGroupNode BIGINT PRIMARY KEY)
	INSERT INTO #SecurityGroupNodes (SecurityGroupNode) EXEC [RDF.Security].GetSessionSecurityGroupNodes @SessionID, @NodeID
	DECLARE @CanEdit BIT
	SELECT @CanEdit = 0
	SELECT @CanEdit = 1
		FROM [RDF.].Node
		WHERE NodeID = @NodeID
			AND ( (EditSecurityGroup BETWEEN @SecurityGroupID AND -1) OR (EditSecurityGroup > 0 AND @HasSpecialEditAccess = 1) OR (EditSecurityGroup IN (SELECT * FROM #SecurityGroupNodes)) )

	select @CanEdit as CanEdit
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Import].[PRNSWebservice.PubMed.GetPersonInfoForDisambiguation] 
	@Job varchar(55) = 'PubMedDisambiguation_GetPubs',
	@BatchID varchar(100)
AS
BEGIN
SET nocount  ON;
 
 
DECLARE  @search XML,
            @batchcount INT,
            @threshold FLOAT,
            @baseURI NVARCHAR(max),
			@orcidNodeID NVARCHAR(max),
			@BatchSize int,
			@URL varchar(500),
			@logLevel int

select @URL = URL, @BatchSize = batchSize, @logLevel = logLevel from [Profile.Import].[PRNSWebservice.Options] where job = @Job

--SET Custom Threshold based on internal Institutional Logic, default is .98
SELECT @threshold = .98

--SELECT @batchID=NEWID()

SELECT @baseURI = [Value] FROM [Framework.].[Parameter] WHERE [ParameterID] = 'baseURI'
SELECT @orcidNodeID = NodeID from [RDF.].Node where Value = 'http://vivoweb.org/ontology/core#orcidId'

CREATE TABLE #tmp (LogID INT, RowID INT not null primary key, PostData XML) 

insert into #tmp (LogID, RowID, PostData)
SELECT -1, personid, 
                   (SELECT ISNULL(RTRIM(firstname),'')  "Name/First",
                                          ISNULL(RTRIM(middlename),'') "Name/Middle",
                                          ISNULL(RTRIM(p.lastname),'') "Name/Last",
                                          ISNULL(RTRIM(suffix),'')     "Name/Suffix",
                                          CASE 
                                                 WHEN a.n IS NOT NULL OR b.n IS NOT NULL 
                                                          /*  Below is example of a custom piece of logic to alter the disambiguation by telling the disambiguation service
                                                            to Require First Name usage in the algorithm for faculty who are lower in rank */
                                                      OR facultyranksort > 4 
                                                      THEN 'true'
                                                ELSE 'false'
                                          END "RequireFirstName",
                                          d.cnt                                                                              "LocalDuplicateNames",
                                          @threshold                                                                   "MatchThreshold",
                                          (SELECT DISTINCT ISNULL(LTRIM(ISNULL(emailaddress,p.emailaddr)),'') Email
                                                      FROM [Profile.Data].[Person.Affiliation] pa
                                                WHERE pa.personid = p.personid
                                                FOR XML PATH(''),TYPE) AS "EmailList",
                                          (SELECT Affiliation
                                                      FROM [Profile.Data].[Publication.PubMed.DisambiguationAffiliation]
                                                FOR XML PATH(''),TYPE) AS "AffiliationList",
                                          (SELECT PMID
                                             FROM [Profile.Data].[Publication.Person.Add]
                                            WHERE personid =p2.personid
                                        FOR XML PATH(''),ROOT('PMIDAddList'),TYPE),
                                          (SELECT PMID
                                             FROM [Profile.Data].[Publication.Person.Exclude]
                                            WHERE personid =p2.personid
                                        FOR XML PATH(''),ROOT('PMIDExcludeList'),TYPE),
                                          (SELECT @baseURI + CAST(i.NodeID AS VARCHAR) 
                                        FOR XML PATH(''),ROOT('URI'),TYPE),
										  (select n.Value as '*' from [RDF.].Node n join
											[RDF.].Triple t  on n.NodeID = t.Object
											and t.Subject = i.NodeID
											and t.Predicate = @orcidNodeID
										FOR XML PATH(''),ROOT('ORCID'),TYPE)
                              FROM [Profile.Data].Person p
                                       LEFT JOIN ( 
                                                
                                                         --case 1
                                                            SELECT LEFT(firstname,1)  f,
                                                                              LEFT(middlename,1) m,
                                                                              lastname,
                                                                              COUNT(* )          n
                                                              FROM [Profile.Data].Person
                                                            GROUP BY LEFT(firstname,1),
                                                                              LEFT(middlename,1),
                                                                              lastname
                                                            HAVING COUNT(* ) > 1
                                                      )A ON a.lastname = p.lastname
                                                        AND a.f=LEFT(firstname,1)
                                                        AND a.m = LEFT(middlename,1)
                              LEFT JOIN (               
 
                                                      --case 2
                                                      SELECT LEFT(firstname,1) f,
                                                                        lastname,
                                                                        COUNT(* )         n
                                                        FROM [Profile.Data].Person
                                                      GROUP BY LEFT(firstname,1),
                                                                        lastname
                                                      HAVING COUNT(* ) > 1
                                                                        AND SUM(CASE 
                                                                                                       WHEN middlename = '' THEN 1
                                                                                                      ELSE 0
                                                                                                END) > 0
                                                                                                
                                                )B ON b.f = LEFT(firstname,1)
                                                  AND b.lastname = p.lastname
                              LEFT JOIN ( SELECT [Utility.NLP].[fnNamePart1](firstname)F,
                                                                                          lastname,
                                                                                          COUNT(*)cnt
                                                                              FROM [Profile.Data].Person 
                                                                         GROUP BY [Utility.NLP].[fnNamePart1](firstname), 
                                                                                          lastname
                                                                  )d ON d.f = [Utility.NLP].[fnNamePart1](p2.firstname)
                                                                        AND d.lastname = p2.lastname

                              LEFT JOIN [RDF.Stage].[InternalNodeMap] i
								 ON [InternalType] = 'Person' AND [Class] = 'http://xmlns.com/foaf/0.1/Person' AND [InternalID] = CAST(p2.personid AS VARCHAR(50))                             
                         WHERE p.personid = p2.personid
                        
                        FOR XML PATH(''),ROOT('FindPMIDs')) XML--as xml)
  --INTO #batch
  FROM [Profile.Data].vwperson  p2 where PersonID not in (select PersonID from [Profile.Data].[Publication.Pubmed.DisambiguationSettings] where Enabled = 0)

  select @BatchSize = @@ROWCOUNT

	Update [Profile.Import].[PRNSWebservice.Log.Summary]  set RecordsCount = @BatchSize, RowsCount = @BatchSize  where BatchID = @BatchID

	DECLARE @LogIDTable TABLE (LogID int, RowID int)
	IF @logLevel = 1
	BEGIN
		INSERT INTO [Profile.Import].[PRNSWebservice.Log] (Job, BatchID, RowID, HttpMethod, URL)
		OUTPUT inserted.LogID, Inserted.RowID into @LogIDTable
		SELECT @Job, @BatchID, RowID, 'POST', @URL FROM #tmp
		UPDATE t SET t.LogID = l.LogID FROM #tmp t JOIN @LogIDTable l ON t.RowID = l.RowID
	END
	ELSE IF @logLevel = 2
	BEGIN
		INSERT INTO [Profile.Import].[PRNSWebservice.Log] (Job, BatchID, RowID, HttpMethod, URL, PostData)
		OUTPUT inserted.LogID, Inserted.RowID into @LogIDTable
		SELECT @Job, @BatchID, RowID, 'POST', @URL, cast(PostData as varchar(max)) FROM #tmp
		UPDATE t SET t.LogID = l.LogID FROM #tmp t JOIN @LogIDTable l ON t.RowID = l.RowID
	END

	select LogID, cast(@batchID as varchar(100)) as BatchID, RowID, 'POST' as HttpMethod, @URL as URL, cast(PostData as varchar(max)) from #tmp
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Import].[PRNSWebservice.PubMed.ImportDisambiguationResults] 
	@Job varchar(55) = '',
	@BatchID varchar(100) = '',
	@RowID int = -1,
	@LogID int = -1,
	@URL varchar (500) = '',
	@Data varchar(max)
AS
BEGIN
	SET NOCOUNT ON;	
	
	declare @x xml
	select @x = cast(@Data as xml)


	BEGIN TRY
		BEGIN TRAN		 
			  declare @rowsCount int
			  --delete from [Profile.Data].[Publication.PubMed.Disambiguation] where personid = @RowID				 
			  -- Add publications_include records
			  INSERT INTO [Profile.Data].[Publication.PubMed.Disambiguation] (personid,pmid)
			  SELECT @RowID,
					 D.element.value('.','INT') pmid		 
				FROM @x.nodes('//PMID') AS D(element)
			   WHERE NOT EXISTS(SELECT TOP 1 * FROM [Profile.Data].[Publication.PubMed.Disambiguation]	 dp WHERE personid = @RowID and dp.pmid = D.element.value('.','INT'))	
			   select @rowsCount = @@ROWCOUNT
			   if @logID > 0
			       update [Profile.Import].[PRNSWebservice.Log] set ResultCount = @rowsCount where LogID = @logID

		
		COMMIT
	END TRY
	BEGIN CATCH
		DECLARE @ErrMsg nvarchar(4000), @ErrSeverity int
		--Check success
		IF @@TRANCOUNT > 0  ROLLBACK

		-- Raise an error with the details of the exception
		SELECT @ErrMsg = '[Profile.Import].[PRNSWebservice.PubMed.ImportDisambiguationResults]' + ERROR_MESSAGE(),
					 @ErrSeverity = ERROR_SEVERITY()

		RAISERROR(@ErrMsg, @ErrSeverity, 1)
			 
	END CATCH				
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Import].[PRNSWebservice.PubMed.GetAllPMIDs]
	@Job varchar(55),
	@BatchID varchar(100)
AS
BEGIN
	SET NOCOUNT ON;	

	DECLARE  @baseURI NVARCHAR(max),
			@URL varchar(500),
			@logLevel int, 
			@rowsCount int

select @URL = URL, @logLevel = logLevel from [Profile.Import].[PRNSWebservice.Options] where job = @Job


	DECLARE @GetOnlyNewXML BIT
	select @GetOnlyNewXML = case when options = 'GetOnlyNewXML=True' then 1 else 0 end from [Profile.Import].[PRNSWebservice.Options] where job = @Job

	CREATE TABLE #tmp (LogID INT, BatchID VARCHAR(100), RowID INT, HttpMethod VARCHAR(10), URL VARCHAR(500), PostData VARCHAR(MAX)) 

	
	IF @GetOnlyNewXML = 1 
	-- ONLY GET XML FOR NEW Publications
		BEGIN
			INSERT INTO #tmp(RowID) 
			SELECT distinct pmid
				FROM [Profile.Data].[Publication.PubMed.Disambiguation]
				WHERE pmid NOT IN(SELECT PMID FROM [Profile.Data].[Publication.PubMed.General])
				AND pmid IS NOT NULL AND pmid not in (select pmid from [Profile.Data].[Publication.PubMed.DisambiguationExclude])
		END
	ELSE 
	-- FULL REFRESH
		BEGIN
			INSERT INTO #tmp(RowID) 
			SELECT distinct pmid
				FROM [Profile.Data].[Publication.PubMed.Disambiguation]
				WHERE pmid IS NOT NULL AND pmid not in (select pmid from [Profile.Data].[Publication.PubMed.DisambiguationExclude]) 
				UNION   
			SELECT distinct pmid
				FROM [Profile.Data].[Publication.Person.Include]
				WHERE pmid IS NOT NULL AND pmid not in (select pmid from [Profile.Data].[Publication.PubMed.DisambiguationExclude]) 
		END 


	UPDATE t SET
		t.LogID = -1,
		t.BatchID = @BatchID, 
		t.HttpMethod = 'POST',
		t.URL = o.url,
		t.PostData = '<PMID>' + cast(RowID as varchar(100)) + '</PMID>'
			FROM #tmp t
			JOIN [Profile.Import].[PRNSWebservice.Options] o ON o.job = 'GetPubMedXML'
	select @rowsCount = @@ROWCOUNT

	Update [Profile.Import].[PRNSWebservice.Log.Summary]  set RecordsCount = @rowsCount, RowsCount = @rowsCount where BatchID = @BatchID

	DECLARE @LogIDTable TABLE (LogID int, RowID int)
	IF @logLevel = 1
	BEGIN
		INSERT INTO [Profile.Import].[PRNSWebservice.Log] (Job, BatchID, RowID, HttpMethod, URL)
		OUTPUT inserted.LogID, Inserted.RowID into @LogIDTable
		SELECT @Job, @BatchID, RowID, 'POST', @URL FROM #tmp
		UPDATE t SET t.LogID = l.LogID FROM #tmp t JOIN @LogIDTable l ON t.RowID = l.RowID
	END
	ELSE IF @logLevel = 2
	BEGIN
		INSERT INTO [Profile.Import].[PRNSWebservice.Log] (Job, BatchID, RowID, HttpMethod, URL, PostData)
		OUTPUT inserted.LogID, Inserted.RowID into @LogIDTable
		SELECT @Job, @BatchID, RowID, 'POST', @URL, cast(PostData as varchar(max)) FROM #tmp
		UPDATE t SET t.LogID = l.LogID FROM #tmp t JOIN @LogIDTable l ON t.RowID = l.RowID
	END

	SELECT * FROM #tmp
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Import].[PRNSWebservice.Pubmed.AddPubMedXML]
	@Job varchar(55) = '',
	@BatchID varchar(100) = '',
	@RowID int = -1,
	@LogID int = -1,
	@URL varchar (500) = '',
	@Data varchar(max)
AS
BEGIN
	SET NOCOUNT ON;	

	BEGIN TRY 	 
		IF ISNULL(@Data,'')='' 
		BEGIN
			DELETE FROM [Profile.Data].[Publication.PubMed.Disambiguation] WHERE pmid = @RowID AND NOT EXISTS (SELECT 1 FROM [Profile.Data].[Publication.Person.Add]  pa WHERE pa.pmid = @RowID)
			RETURN
		END
 
		-- Remove existing pmid record
		DELETE FROM [Profile.Data].[Publication.PubMed.AllXML] WHERE pmid = @RowID
		
		-- Add Pub Med XML	
		INSERT INTO [Profile.Data].[Publication.PubMed.AllXML](pmid,X) VALUES(@RowID,CAST(@Data AS XML))		
		RETURN
	END TRY
	BEGIN CATCH
		declare @errorMessage varchar(max)
		select @errorMessage = Error_Message()

		if @LogID < 0
		begin
			select @LogID = isnull(LogID, -1) from [Profile.Import].[PRNSWebservice.Log] where BatchID = @BatchID and RowID = @RowID
		end
		select @logid
		if @LogID > 0
			update [Profile.Import].[PRNSWebservice.Log] set Success = 0, HttpResponse = @Data, ErrorText = @errorMessage where LogID = @LogID
		else
			insert into [Profile.Import].[PRNSWebservice.Log] (Job, BatchID, RowID, URL, HttpResponse, Success, ErrorText) Values (@Job, @BatchID, @RowID, @URL, @Data, 0, @errorMessage)
	END CATCH	
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Import].[PRNSWebservice.Funding.ParseDisambiguationXML]
	@Job varchar(55) = '',
	@BatchID varchar(100) = '',
	@RowID int = -1,
	@LogID int = -1,
	@URL varchar (500) = '',
	@Data varchar(max)
AS
BEGIN
	SET NOCOUNT ON;	

	BEGIN TRY 
		declare @rowsCount int
		declare @xml xml
		set @xml = cast(@Data as xml)

		Insert into [Profile.Data].[Funding.DisambiguationResults]
		(PersonID, FundingID, GrantAwardedBy, StartDate, EndDate, PrincipalInvestigatorName,
			AgreementLabel, Abstract, Source, FundingID2, RoleLabel)
		select nref.value('@PersonID','varchar(max)') PersonID,
		sref.value('FundingID[1]','varchar(max)') FundingID,
		sref.value('GrantAwardedBy[1]','varchar(max)') GrantAwardedBy,
		sref.value('StartDate[1]','varchar(max)') StartDate,
		sref.value('EndDate[1]','varchar(max)') EndDate,
		sref.value('PrincipalInvestigatorName[1]','varchar(max)') PrincipalInvestigatorName,
		sref.value('AgreementLabel[1]','varchar(max)') AgreementLabel,
		sref.value('Abstract[1]','varchar(max)') Abstract,
		sref.value('Source[1]','varchar(max)') Source,
		sref.value('FundingID2[1]','varchar(max)') FundingID2,
		sref.value('RoleLabel[1]','varchar(max)') RoleLabel
		from @xml.nodes('//PersonList[1]/Person') as R(nref)
		cross apply R.nref.nodes('Funding') as S(sref)
		
		select @rowsCount = @@ROWCOUNT
		if @logID > 0
			update [Profile.Import].[PRNSWebservice.Log] set ResultCount = @rowsCount where LogID = @logID
	END TRY
	BEGIN CATCH
		declare @errorMessage varchar(max)
		select @errorMessage = Error_Message()

		if @LogID < 0
		begin
			select @LogID = isnull(LogID, -1) from [Profile.Import].[PRNSWebservice.Log] where BatchID = @BatchID and RowID = @RowID
		end
		select @logid
		if @LogID > 0
			update [Profile.Import].[PRNSWebservice.Log] set Success = 0, HttpResponse = @Data, ErrorText = @errorMessage where LogID = @LogID
		else
			insert into [Profile.Import].[PRNSWebservice.Log] (Job, BatchID, RowID, URL, HttpResponse, Success, ErrorText) Values (@Job, @BatchID, @RowID, @URL, @Data, 0, @errorMessage)
	END CATCH	
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [Profile.Import].[PRNSWebservice.Funding.GetPersonInfoForDisambiguation] 
	@Job varchar(55),
	@BatchID varchar(100)
AS
BEGIN
	SET NOCOUNT ON;
	CREATE TABLE #tmp (LogID INT, BatchID VARCHAR(100), RowID INT, HttpMethod VARCHAR(10), URL VARCHAR(500), PostData xml) 

	DECLARE  --@search XML,
				@batchcount INT,
				--@threshold FLOAT,
				@baseURI NVARCHAR(max),
				@orcidNodeID NVARCHAR(max),
				@BatchSize int,
				@URL varchar(500),
				@logLevel int,
				@rows int,
				@rowsCount int

	select @URL = URL, @BatchSize = batchSize, @logLevel = logLevel from [Profile.Import].[PRNSWebservice.Options] where job = @Job

	SELECT @baseURI = [Value] FROM [Framework.].[Parameter] WHERE [ParameterID] = 'baseURI'
	SELECT @orcidNodeID = NodeID from [RDF.].Node where Value = 'http://vivoweb.org/ontology/core#orcidId'
	
	SELECT personID, ROW_NUMBER() OVER (ORDER BY personID) AS rownum INTO #personIDs FROM [Profile.Data].Person p
	WHERE IsActive = 1 and not exists (select 1 from [Profile.Data].[Funding.DisambiguationSettings] s where s.PersonID = p.PersonID and enabled = 0)

	SELECT @rows = count(*) FROM #personIDs

	insert into #tmp(LogID, BatchID, RowID, HttpMethod, URL, PostData)
	select -1, @batchID batchID, n, 'POST', @URL, (
		SELECT (
			select p2.personid as PersonID, 
			ISNULL(RTRIM(firstname),'')  "Name/First",
			ISNULL(RTRIM(middlename),'') "Name/Middle",
			ISNULL(RTRIM(p2.lastname),'') "Name/Last",
			ISNULL(RTRIM(suffix),'')     "Name/Suffix",
			d.cnt "LocalDuplicateNames",
			(SELECT DISTINCT ISNULL(LTRIM(ISNULL(emailaddress,p2.emailaddr)),'') Email
					FROM [Profile.Data].[Person.Affiliation] pa
					WHERE pa.personid = p2.personid
				FOR XML PATH(''),TYPE) AS "EmailList",
			(SELECT distinct Organization as Org FROM [Profile.Data].[Funding.DisambiguationOrganizationMapping] m
				JOIN [Profile.Data].[Person.Affiliation] pa
				on m.InstitutionID = pa.InstitutionID 
					or m.InstitutionID is null
				where pa.PersonID = p2.PersonID
				FOR XML PATH(''),ROOT('OrgList'),TYPE),
			(SELECT PMID
					FROM [Profile.Data].[Publication.Person.Add]
					WHERE personid =p2.personid
				FOR XML PATH(''),ROOT('PMIDAddList'),TYPE),
			(SELECT PMID
				FROM [Profile.Data].[Publication.Person.Include]
					WHERE personid =p2.personid
				FOR XML PATH(''),ROOT('PMIDIncludeList'),TYPE),
			(SELECT PMID
				FROM [Profile.Data].[Publication.Person.Exclude]
					WHERE personid =p2.personid
				FOR XML PATH(''),ROOT('PMIDExcludeList'),TYPE),
			(SELECT FundingID FROM [Profile.Data].[Funding.Add] ad
				join [Profile.Data].[Funding.Agreement] ag
					on ad.FundingAgreementID = ag.FundingAgreementID
					and ag.Source = 'NIH'
					WHERE ad.PersonID = p2.PersonID
				FOR XML PATH(''),ROOT('GrantsAddList'),TYPE),
			(SELECT FundingID FROM [Profile.Data].[Funding.Add] ad
				join [Profile.Data].[Funding.Agreement] ag
					on ad.FundingAgreementID = ag.FundingAgreementID
					and ag.Source = 'NIH'
					WHERE ad.PersonID = p2.PersonID
				FOR XML PATH(''),ROOT('GrantsAddList'),TYPE),
			(SELECT FundingID FROM [Profile.Data].[Funding.Delete]
					WHERE Source = 'NIH' and PersonID = p2.PersonID
				FOR XML PATH(''),ROOT('GrantsDeleteList'),TYPE),
			(SELECT @baseURI + CAST(i.NodeID AS VARCHAR) 
				FOR XML PATH(''),ROOT('URI'),TYPE),
			(select n.Value as '*' from [RDF.].Node n join
					[RDF.].Triple t  on n.NodeID = t.Object
					and t.Subject = i.NodeID
					and t.Predicate = @orcidNodeID
				FOR XML PATH(''),ROOT('ORCID'),TYPE)
		FROM [Profile.Data].Person p2 
		  LEFT JOIN ( SELECT [Utility.NLP].[fnNamePart1](firstname)F,
				lastname,
				COUNT(*)cnt
				FROM [Profile.Data].Person 
				GROUP BY [Utility.NLP].[fnNamePart1](firstname), 
					lastname
				)d ON d.f = [Utility.NLP].[fnNamePart1](p2.firstname)
					AND d.lastname = p2.lastname
					AND p2.IsActive = 1 
			LEFT JOIN [RDF.Stage].[InternalNodeMap] i
			ON [InternalType] = 'Person' AND [Class] = 'http://xmlns.com/foaf/0.1/Person' AND [InternalID] = CAST(p2.personid AS VARCHAR(50))
				JOIN #personIDs p3 on p2.personID = p3.personID
		  order by p3.PersonID offset n * @BatchSize ROWS FETCH NEXT @BatchSize ROWS ONLY for xml path('Person'), root('FindFunding'), type) as X
	  ) x
	from [Utility.Math].N where n <= @rows / @BatchSize

	select @rowsCount = @@ROWCOUNT

	Update [Profile.Import].[PRNSWebservice.Log.Summary]  set RecordsCount = @rows, RowsCount = @rowsCount where BatchID = @BatchID

	DECLARE @LogIDTable TABLE (LogID int, RowID int)
	IF @logLevel = 1
	BEGIN
		INSERT INTO [Profile.Import].[PRNSWebservice.Log] (Job, BatchID, RowID, HttpMethod, URL)
		OUTPUT inserted.LogID, Inserted.RowID into @LogIDTable
		SELECT @job, BatchID, RowID, HttpMethod, URL FROM #tmp
		UPDATE t SET t.LogID = l.LogID FROM #tmp t JOIN @LogIDTable l ON t.RowID = l.RowID
	END
	ELSE IF @logLevel = 2
	BEGIN
		INSERT INTO [Profile.Import].[PRNSWebservice.Log] (Job, BatchID, RowID, HttpMethod, URL, PostData)
		OUTPUT inserted.LogID, Inserted.RowID into @LogIDTable
		SELECT @job, BatchID, RowID, HttpMethod, URL, convert(varchar(max), PostData) FROM #tmp
		UPDATE t SET t.LogID = l.LogID FROM #tmp t JOIN @LogIDTable l ON t.RowID = l.RowID
	END

	Truncate table [Profile.Data].[Funding.DisambiguationResults]
	SELECT LogID, BatchID, RowID, HttpMethod, URL, convert(varchar(max), PostData) FROM #tmp
END
GO
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO
CREATE PROCEDURE [RDF.].[GetPresentationXMLByType]
@subjectType varchar(max)=NULL, @predicate BIGINT=NULL, @objectType varchar(max)=NULL, @PresentationXML XML=NULL OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

	declare @typeID bigint
	select @typeID = [RDF.].fnURI2NodeID('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')

	select @subjectType = null where @subjectType = '0'
	select @predicate = null where @predicate = 0
	select @objectType = null where @objectType = '0'

	create table #subjectTypes ( st bigint)
	create table #objectTypes (ot bigint)

	insert into #subjectTypes
		SELECT Split.a.value('.', 'VARCHAR(100)')
		FROM ( select CAST('<c>' + REPLACE(@subjectType, ',', '</c><c>') + '</c>' as XML) as A) AS A CROSS APPLY A.nodes ('/c') AS Split(a); 

	if @objectType is not null
		insert into #objectTypes
			SELECT Split.a.value('.', 'VARCHAR(100)')
			FROM ( select CAST('<c>' + REPLACE(@objectType, ',', '</c><c>') + '</c>' as XML) as A) AS A CROSS APPLY A.nodes ('/c') AS Split(a); 

	/* --This is cleaner for SQL Server 2016 and above

	insert into #subjectTypes SELECT cast(value as bigint) from string_split(@subjectType, ',')
	if @objectType is not null
		insert into #objectTypes SELECT cast(value as bigint) from string_split(@objectType, ',')
	*/

	declare @SecurityGroupListXML xml
	select @SecurityGroupListXML = NULL

	declare @NetworkNode bigint
	declare @ConnectionNode bigint
	select	@NetworkNode = [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#Network'),
			@ConnectionNode = [RDF.].fnURI2NodeID('http://profiles.catalyst.harvard.edu/ontology/prns#Connection')


	-------------------------------------------------------------------------------
	-- Determine the PresentationType (P = profile, N = network, C = connection)
	-------------------------------------------------------------------------------

	declare @PresentationType char(1)
	select @PresentationType = (case when @objectType is not null AND @predicate is not null AND @subjectType is not null then 'C'
									when @predicate is not null AND @subjectType is not null then 'N'
									when @subjectType is not null then 'P'
									else NULL end)


	-------------------------------------------------------------------------------
	-- Get the PresentationID based on type
	-------------------------------------------------------------------------------

	declare @PresentationID int
	select @PresentationID = (
			select top 1 PresentationID
				from [Ontology.Presentation].[XML]
				where type = IsNull(@PresentationType,'P')
					AND	(_SubjectNode IS NULL
							OR _SubjectNode in (select * from #subjectTypes)
						)
					AND	(_PredicateNode IS NULL
							OR _PredicateNode = @predicate
						)
					AND	(_ObjectNode IS NULL
							OR _ObjectNode in (select * from #objectTypes)
						)
				order by	(case when _ObjectNode is null then 1 else 0 end),
							(case when _PredicateNode is null then 1 else 0 end),
							(case when _SubjectNode is null then 1 else 0 end),
							PresentationID
		)

	-------------------------------------------------------------------------------
	-- Get the PropertyListXML based on type
	-------------------------------------------------------------------------------

	declare @PropertyListXML xml

	-- View properties
	select @PropertyListXML = (
		select PropertyGroupURI "@URI", _PropertyGroupLabel "@Label", SortOrder "@SortOrder", x.query('.')
		from (
			select PropertyGroupURI, _PropertyGroupLabel, SortOrder,
			(
				select	a.URI "@URI", 
						a.TagName "@TagName", 
						a.Label "@Label", 
						p.SortOrder "@SortOrder",
						(case when a.CustomDisplay = 1 then 'true' else 'false' end) "@CustomDisplay",
						cast(a.CustomDisplayModule as xml)
				from [ontology.].PropertyGroupProperty p, (
					select NodeID,
						max(URI) URI, 
						max(TagName) TagName, 
						max(Label) Label,
						max(CustomDisplay) CustomDisplay,
						max(CustomDisplayModule) CustomDisplayModule
					from (
							select
								c._PropertyNode NodeID,
								c.Property URI,
								c._TagName TagName,
								c._PropertyLabel Label,
								cast(c.CustomDisplay as tinyint) CustomDisplay,
								IsNull(cast(c.CustomDisplayModule as nvarchar(max)),cast(p.CustomDisplayModule as nvarchar(max))) CustomDisplayModule
							from [Ontology.].ClassProperty c
								left outer join [Ontology.].PropertyGroupProperty p
								on c.Property = p.PropertyURI
							where c._ClassNode in (
								select * from #subjectTypes where @predicate is null and @objectType is null
								union all
								select @NetworkNode
									where @subjectType is not null and @predicate is not null and @objectType is null
								union all
								select @ConnectionNode
									where @subjectType is not null and @predicate is not null and @objectType is not null
							)
							and 1 = (case	when c._NetworkPropertyNode is null and @predicate is null then 1
											when c._NetworkPropertyNode is null and @predicate is not null and @objectType is null and c._ClassNode = @NetworkNode then 1
											when c._NetworkPropertyNode is null and @predicate is not null and @objectType is not null and c._ClassNode = @ConnectionNode then 1
											when c._NetworkPropertyNode = @predicate and @objectType is not null then 1
											else 0 end)
							and (c.CustomDisplay = 0 OR (c.CustomDisplay = 1 and c.CustomDisplayModule is not null))
						) t
					group by NodeID
				) a
				where p._PropertyNode = a.NodeID and p._PropertyGroupNode = g._PropertyGroupNode
				order by p.SortOrder
				for xml path('Property'), type
			) x
			from [ontology.].PropertyGroup g
		) t
		where x is not null
		order by SortOrder
		for xml path('PropertyGroup'), type
	)

	-------------------------------------------------------------------------------
	-- Combine the PresentationXML with property information
	-------------------------------------------------------------------------------

	select @PresentationXML = (
		select
			PresentationXML.value('Presentation[1]/@PresentationClass[1]','varchar(max)') "@PresentationClass",
			PresentationXML.value('Presentation[1]/PageOptions[1]/@Columns[1]','varchar(max)') "PageOptions/@Columns",
			PresentationXML.query('Presentation[1]/WindowName[1]'),
			PresentationXML.query('Presentation[1]/PageColumns[1]'),
			PresentationXML.query('Presentation[1]/PageTitle[1]'),
			PresentationXML.query('Presentation[1]/PageBackLinkName[1]'),
			PresentationXML.query('Presentation[1]/PageBackLinkURL[1]'),
			PresentationXML.query('Presentation[1]/PageSubTitle[1]'),
			PresentationXML.query('Presentation[1]/PageDescription[1]'),
			PresentationXML.query('Presentation[1]/PanelTabType[1]'),
			PresentationXML.query('Presentation[1]/PanelList[1]'),
			PresentationXML.query('Presentation[1]/ExpandRDFList[1]'),
			@PropertyListXML "PropertyList",
			@SecurityGroupListXML "SecurityGroupList"
		from [Ontology.Presentation].[XML]
		where presentationid = @PresentationID
		for xml path('Presentation'), type
	)
	
	select @PresentationXML PresentationXML

END
GO
